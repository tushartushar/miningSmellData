Implementation smell,Namespace,Class,File,Method,Description
Long Method,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The method has 470 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The method has 344 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The method has 243 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The method has 169 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The method has 228 lines of code.
Complex Method,engine.net,ResourceApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,applymap,Cyclomatic complexity of the method is 13
Complex Method,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,Cyclomatic complexity of the method is 27
Complex Method,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,Cyclomatic complexity of the method is 126
Complex Method,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,Cyclomatic complexity of the method is 126
Complex Method,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,Cyclomatic complexity of the method is 22
Complex Method,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,Cyclomatic complexity of the method is 111
Complex Method,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 29
Complex Method,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Long Parameter List,engine.net,Form1,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Form1.cs,Form1,The method has 5 parameters.
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,InfCodes,The method has 7 parameters.
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,InfCodes,The method has 5 parameters.
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The method has 8 parameters.
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The method has 11 parameters.
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters.
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters.
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters.
Long Statement,engine.net,ResourceApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,mapval,The length of the statement  "	Logger.getLogger ().dbg ("map " + m.ToString () + " val " + data.Length.ToString () + " bytes ofs=0x" + os [0].ToString ("X")); " is 127.
Long Statement,engine.net,Logger,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Logger.cs,setOptions,The length of the statement  "		wr = new StreamWriter (new FileStream (Path.Combine (Path.GetDirectoryName (Application.ExecutablePath)' "install.log")' FileMode.Create)' Encoding.ASCII); " is 155.
Empty Catch Block,engine.net,BrowserController,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\BrowserController.cs,startBrowser,The method has an empty catch block.
Empty Catch Block,engine.net,Logger,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Logger.cs,dbg,The method has an empty catch block.
Empty Catch Block,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The method has an empty catch block.
Empty Catch Block,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The method has an empty catch block.
Empty Catch Block,ComponentAce.Compression.Libs.zlib,ZOutputStream,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\ZOutputStream.cs,finish,The method has an empty catch block.
Empty Catch Block,ComponentAce.Compression.Libs.zlib,ZOutputStream,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,retOK,The following statement contains a magic number: for (int i = 0; i < prms.Length / 2; i++)  	s += "' " + prms [i * 2] + ":" + prms [i * 2 + 1] + "";  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,retOK,The following statement contains a magic number: for (int i = 0; i < prms.Length / 2; i++)  	s += "' " + prms [i * 2] + ":" + prms [i * 2 + 1] + "";  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,retOK,The following statement contains a magic number: for (int i = 0; i < prms.Length / 2; i++)  	s += "' " + prms [i * 2] + ":" + prms [i * 2 + 1] + "";  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,retOK,The following statement contains a magic number: s += "' " + prms [i * 2] + ":" + prms [i * 2 + 1] + "";  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,retOK,The following statement contains a magic number: s += "' " + prms [i * 2] + ":" + prms [i * 2 + 1] + "";  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,str2byte,The following statement contains a magic number: if (str.Length % 2 != 0)  	throw new BadParamException ("bytes"' str);  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,str2byte,The following statement contains a magic number: for (int i = 0; i < str.Length / 2; i++) {  	try {  		byte b = byte.Parse ("" + str [i * 2] + str [i * 2 + 1]' System.Globalization.NumberStyles.AllowHexSpecifier);  		bts.Add (b);  	}  	catch (Exception) {  		throw new BadParamException ("bytes"' str);  	}  }  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,str2byte,The following statement contains a magic number: for (int i = 0; i < str.Length / 2; i++) {  	try {  		byte b = byte.Parse ("" + str [i * 2] + str [i * 2 + 1]' System.Globalization.NumberStyles.AllowHexSpecifier);  		bts.Add (b);  	}  	catch (Exception) {  		throw new BadParamException ("bytes"' str);  	}  }  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,str2byte,The following statement contains a magic number: for (int i = 0; i < str.Length / 2; i++) {  	try {  		byte b = byte.Parse ("" + str [i * 2] + str [i * 2 + 1]' System.Globalization.NumberStyles.AllowHexSpecifier);  		bts.Add (b);  	}  	catch (Exception) {  		throw new BadParamException ("bytes"' str);  	}  }  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,str2byte,The following statement contains a magic number: try {  	byte b = byte.Parse ("" + str [i * 2] + str [i * 2 + 1]' System.Globalization.NumberStyles.AllowHexSpecifier);  	bts.Add (b);  }  catch (Exception) {  	throw new BadParamException ("bytes"' str);  }  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,str2byte,The following statement contains a magic number: try {  	byte b = byte.Parse ("" + str [i * 2] + str [i * 2 + 1]' System.Globalization.NumberStyles.AllowHexSpecifier);  	bts.Add (b);  }  catch (Exception) {  	throw new BadParamException ("bytes"' str);  }  
Magic Number,engine.net,ApiPart,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,rotateBytes,The following statement contains a magic number: for (int i = 0; i < data.Length / 2; i++) {  	int j = data.Length - i - 1;  	data [i] ^= data [j];  	data [j] ^= data [i];  	data [i] ^= data [j];  }  
Magic Number,engine.net,InstApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,urldecode,The following statement contains a magic number: while (i < data.Length) {  	if (data [i] == 0x25) {  		char h1 = (char)data [i + 1];  		char h2 = (char)data [i + 2];  		i += 2;  		res.Add (byte.Parse ("" + h1 + h2' System.Globalization.NumberStyles.AllowHexSpecifier));  	}  	else  		res.Add (data [i]);  	i++;  }  
Magic Number,engine.net,InstApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,urldecode,The following statement contains a magic number: while (i < data.Length) {  	if (data [i] == 0x25) {  		char h1 = (char)data [i + 1];  		char h2 = (char)data [i + 2];  		i += 2;  		res.Add (byte.Parse ("" + h1 + h2' System.Globalization.NumberStyles.AllowHexSpecifier));  	}  	else  		res.Add (data [i]);  	i++;  }  
Magic Number,engine.net,InstApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,urldecode,The following statement contains a magic number: if (data [i] == 0x25) {  	char h1 = (char)data [i + 1];  	char h2 = (char)data [i + 2];  	i += 2;  	res.Add (byte.Parse ("" + h1 + h2' System.Globalization.NumberStyles.AllowHexSpecifier));  }  else  	res.Add (data [i]);  
Magic Number,engine.net,InstApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,urldecode,The following statement contains a magic number: if (data [i] == 0x25) {  	char h1 = (char)data [i + 1];  	char h2 = (char)data [i + 2];  	i += 2;  	res.Add (byte.Parse ("" + h1 + h2' System.Globalization.NumberStyles.AllowHexSpecifier));  }  else  	res.Add (data [i]);  
Magic Number,engine.net,InstApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,urldecode,The following statement contains a magic number: i += 2;  
Magic Number,engine.net,InstApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,process,The following statement contains a magic number: if (loc.Contains ("?")) {  	string[] prt = loc.Split (new char[] {  		'?'  	}' 2);  	foreach (string s in prt [0].Split ('/'))  		path.Add (s);  	prt = prt [1].Split ('&');  	foreach (string s in prt) {  		string[] p = s.Split (new char[] {  			'='  		}' 2);  		prms.Add (urldecode (p [0])' urldecode (p [1]));  	}  }  else  	foreach (string s in loc.Split ('/'))  		path.Add (s);  
Magic Number,engine.net,InstApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,process,The following statement contains a magic number: if (loc.Contains ("?")) {  	string[] prt = loc.Split (new char[] {  		'?'  	}' 2);  	foreach (string s in prt [0].Split ('/'))  		path.Add (s);  	prt = prt [1].Split ('&');  	foreach (string s in prt) {  		string[] p = s.Split (new char[] {  			'='  		}' 2);  		prms.Add (urldecode (p [0])' urldecode (p [1]));  	}  }  else  	foreach (string s in loc.Split ('/'))  		path.Add (s);  
Magic Number,engine.net,InstApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,process,The following statement contains a magic number: foreach (string s in prt) {  	string[] p = s.Split (new char[] {  		'='  	}' 2);  	prms.Add (urldecode (p [0])' urldecode (p [1]));  }  
Magic Number,engine.net,VarsApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,getvar,The following statement contains a magic number: if (!vars.ContainsKey (v))  	throw new ErrException (2' "No variable " + v);  
Magic Number,engine.net,VarsApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,getvar,The following statement contains a magic number: throw new ErrException (2' "No variable " + v);  
Magic Number,engine.net,FileApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,flush,The following statement contains a magic number: if (xfiles [id].name == "")  	throw new ErrException (8' "Cant flush resource");  
Magic Number,engine.net,FileApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,flush,The following statement contains a magic number: throw new ErrException (8' "Cant flush resource");  
Magic Number,engine.net,FileApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,seek,The following statement contains a magic number: if (ofs == 2)  	ps = xfiles [id].ms.Length - pos;  
Magic Number,engine.net,ResourceApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,StreamCopy,The following statement contains a magic number: while (true) {  	rd = from.Read (buf' 0' (sz - total > 8192 ? 8192 : (sz - total)));  	to.Write (buf' 0' rd);  	total += rd;  	if (total == sz)  		break;  }  
Magic Number,engine.net,ResourceApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,StreamCopy,The following statement contains a magic number: while (true) {  	rd = from.Read (buf' 0' (sz - total > 8192 ? 8192 : (sz - total)));  	to.Write (buf' 0' rd);  	total += rd;  	if (total == sz)  		break;  }  
Magic Number,engine.net,ResourceApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,StreamCopy,The following statement contains a magic number: rd = from.Read (buf' 0' (sz - total > 8192 ? 8192 : (sz - total)));  
Magic Number,engine.net,ResourceApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,StreamCopy,The following statement contains a magic number: rd = from.Read (buf' 0' (sz - total > 8192 ? 8192 : (sz - total)));  
Magic Number,engine.net,Program,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Program.cs,Main,The following statement contains a magic number: try {  	ResourceLocator.locateReader ();  	XmlDocument doc = ResourceLocator.readXmlResource ("install.cfg"' "icfg");  	XmlNode root = doc.DocumentElement;  	nm = root.Attributes ["nm"].Value;  	window = (root.Attributes ["w"] != null);  	if (window) {  		string ws = root.Attributes ["w"].Value;  		if (ws == "mx")  			mx = true;  		else {  			w = int.Parse (ws);  			h = int.Parse (root.Attributes ["h"].Value);  		}  		sz = (root.Attributes ["sz"] != null);  	}  	if (root.Attributes ["l"] != null) {  		int lgs = int.Parse (root.Attributes ["l"].Value);  		dbg = (lgs & 1) != 0;  		con = (lgs & 2) != 0;  		log = (lgs & 4) != 0;  	}  	Logger.getLogger ().setOptions (log' con' dbg);  }  catch (Exception ex) {  	MessageBox.Show ("ERROR:" + ex.GetType ().Name + "\r\n" + ex.Message);  	return;  }  
Magic Number,engine.net,Program,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Program.cs,Main,The following statement contains a magic number: try {  	ResourceLocator.locateReader ();  	XmlDocument doc = ResourceLocator.readXmlResource ("install.cfg"' "icfg");  	XmlNode root = doc.DocumentElement;  	nm = root.Attributes ["nm"].Value;  	window = (root.Attributes ["w"] != null);  	if (window) {  		string ws = root.Attributes ["w"].Value;  		if (ws == "mx")  			mx = true;  		else {  			w = int.Parse (ws);  			h = int.Parse (root.Attributes ["h"].Value);  		}  		sz = (root.Attributes ["sz"] != null);  	}  	if (root.Attributes ["l"] != null) {  		int lgs = int.Parse (root.Attributes ["l"].Value);  		dbg = (lgs & 1) != 0;  		con = (lgs & 2) != 0;  		log = (lgs & 4) != 0;  	}  	Logger.getLogger ().setOptions (log' con' dbg);  }  catch (Exception ex) {  	MessageBox.Show ("ERROR:" + ex.GetType ().Name + "\r\n" + ex.Message);  	return;  }  
Magic Number,engine.net,Program,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Program.cs,Main,The following statement contains a magic number: if (root.Attributes ["l"] != null) {  	int lgs = int.Parse (root.Attributes ["l"].Value);  	dbg = (lgs & 1) != 0;  	con = (lgs & 2) != 0;  	log = (lgs & 4) != 0;  }  
Magic Number,engine.net,Program,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Program.cs,Main,The following statement contains a magic number: if (root.Attributes ["l"] != null) {  	int lgs = int.Parse (root.Attributes ["l"].Value);  	dbg = (lgs & 1) != 0;  	con = (lgs & 2) != 0;  	log = (lgs & 4) != 0;  }  
Magic Number,engine.net,Program,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Program.cs,Main,The following statement contains a magic number: con = (lgs & 2) != 0;  
Magic Number,engine.net,Program,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Program.cs,Main,The following statement contains a magic number: log = (lgs & 4) != 0;  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,process,The following statement contains a magic number: while (!m_stop) {  	svr.BeginGetContext (new AsyncCallback (OnRequests)' svr).AsyncWaitHandle.WaitOne (3000' true);  	double sec = (DateTime.Now - lastcon).TotalSeconds;  	if (sec > 5) {  		lastcon = DateTime.Now;  		if (canstop) {  			Logger.getLogger ().dbg ("Webbrowser timeout. Stopping engine");  			InstApi.getApi ().process ("close");  		}  		else {  			Logger.getLogger ().dbg ("Webbrowser timeout. Restarting browser");  			if (BrowserController.obj != null) {  				BrowserController.obj.restartBrowser ();  			}  			#if !NO_EXPLORER  			else if (Form1.obj == null) {  				Logger.getLogger ().dbg ("No browser controller object. Stopping server");  				InstApi.getApi ().process ("close");  			}  			#endif  		}  	}  }  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,process,The following statement contains a magic number: while (!m_stop) {  	svr.BeginGetContext (new AsyncCallback (OnRequests)' svr).AsyncWaitHandle.WaitOne (3000' true);  	double sec = (DateTime.Now - lastcon).TotalSeconds;  	if (sec > 5) {  		lastcon = DateTime.Now;  		if (canstop) {  			Logger.getLogger ().dbg ("Webbrowser timeout. Stopping engine");  			InstApi.getApi ().process ("close");  		}  		else {  			Logger.getLogger ().dbg ("Webbrowser timeout. Restarting browser");  			if (BrowserController.obj != null) {  				BrowserController.obj.restartBrowser ();  			}  			#if !NO_EXPLORER  			else if (Form1.obj == null) {  				Logger.getLogger ().dbg ("No browser controller object. Stopping server");  				InstApi.getApi ().process ("close");  			}  			#endif  		}  	}  }  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,process,The following statement contains a magic number: svr.BeginGetContext (new AsyncCallback (OnRequests)' svr).AsyncWaitHandle.WaitOne (3000' true);  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,process,The following statement contains a magic number: if (sec > 5) {  	lastcon = DateTime.Now;  	if (canstop) {  		Logger.getLogger ().dbg ("Webbrowser timeout. Stopping engine");  		InstApi.getApi ().process ("close");  	}  	else {  		Logger.getLogger ().dbg ("Webbrowser timeout. Restarting browser");  		if (BrowserController.obj != null) {  			BrowserController.obj.restartBrowser ();  		}  		#if !NO_EXPLORER  		else if (Form1.obj == null) {  			Logger.getLogger ().dbg ("No browser controller object. Stopping server");  			InstApi.getApi ().process ("close");  		}  		#endif  	}  }  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The following statement contains a magic number: if (what.StartsWith ("/api/")) {  	tp = "application/json; encoding=UTF-8";  	what = what.Remove (0' 5);  	if (what != "hb") {  		buffer = InstApi.getApi ().process (what);  	}  	else  		buffer = Encoding.UTF8.GetBytes ("{r:0}");  	con.Response.AddHeader ("Expires"' "Mon' 26 Jul 1997 05:00:00 GMT");  	con.Response.AddHeader ("Cache-Control"' "no-store' no-cache' must-revalidate");  	//con.Response.AddHeader("Expires"' "-1");  	con.Response.AddHeader ("Pragma"' "no-cache");  }  else {  	what = what.Split ('?') [0].Remove (0' 1);  	Logger.getLogger ().dbg ("request " + what);  	try {  		buffer = ResourceLocator.getResources ().getResource (what);  	}  	catch (Exception) {  		try {  			con.Response.StatusCode = 404;  			con.Response.Close ();  		}  		catch (Exception) {  		}  		return;  	}  	string ext = Path.GetExtension (what).Remove (0' 1);  	switch (ext) {  	case "html":  	case "xml":  	case "css":  		tp = "text/" + ext + "; charset=UTF-8";  		break;  	case "jpg":  		tp = "image/jpeg";  		break;  	case "bmp":  	case "png":  		tp = "image/" + ext;  		break;  	case "js":  		tp = "application/javascript; charset=UTF-8";  		break;  	case "mid":  		tp = "audio/midi";  		break;  	case "wav":  		tp = "audio/x-wav";  		break;  	}  }  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The following statement contains a magic number: if (what.StartsWith ("/api/")) {  	tp = "application/json; encoding=UTF-8";  	what = what.Remove (0' 5);  	if (what != "hb") {  		buffer = InstApi.getApi ().process (what);  	}  	else  		buffer = Encoding.UTF8.GetBytes ("{r:0}");  	con.Response.AddHeader ("Expires"' "Mon' 26 Jul 1997 05:00:00 GMT");  	con.Response.AddHeader ("Cache-Control"' "no-store' no-cache' must-revalidate");  	//con.Response.AddHeader("Expires"' "-1");  	con.Response.AddHeader ("Pragma"' "no-cache");  }  else {  	what = what.Split ('?') [0].Remove (0' 1);  	Logger.getLogger ().dbg ("request " + what);  	try {  		buffer = ResourceLocator.getResources ().getResource (what);  	}  	catch (Exception) {  		try {  			con.Response.StatusCode = 404;  			con.Response.Close ();  		}  		catch (Exception) {  		}  		return;  	}  	string ext = Path.GetExtension (what).Remove (0' 1);  	switch (ext) {  	case "html":  	case "xml":  	case "css":  		tp = "text/" + ext + "; charset=UTF-8";  		break;  	case "jpg":  		tp = "image/jpeg";  		break;  	case "bmp":  	case "png":  		tp = "image/" + ext;  		break;  	case "js":  		tp = "application/javascript; charset=UTF-8";  		break;  	case "mid":  		tp = "audio/midi";  		break;  	case "wav":  		tp = "audio/x-wav";  		break;  	}  }  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The following statement contains a magic number: what = what.Remove (0' 5);  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The following statement contains a magic number: try {  	buffer = ResourceLocator.getResources ().getResource (what);  }  catch (Exception) {  	try {  		con.Response.StatusCode = 404;  		con.Response.Close ();  	}  	catch (Exception) {  	}  	return;  }  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The following statement contains a magic number: try {  	con.Response.StatusCode = 404;  	con.Response.Close ();  }  catch (Exception) {  }  
Magic Number,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The following statement contains a magic number: con.Response.StatusCode = 404;  
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += (buf [index++] & 0xff);  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += (buf [index++] & 0xff);  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (k >= 16) {  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	k -= 16;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (k >= 16) {  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	k -= 16;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The following statement contains a magic number: k -= 16;  
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				int[] bl = new int[1];  				int[] bd = new int[1];  				int[][] tl = new int[1][];  				int[][] td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[] tl = new int[1];  			int[] td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[] tl = new int[1];  		int[] td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = (int)(b & 7);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = k & 7;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (32)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (32)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  	mode = BAD;  	z.msg = "invalid stored block lengths";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (14)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (14)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = BAD;  	z.msg = "too many length or distance symbols";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = BAD;  	z.msg = "too many length or distance symbols";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = BAD;  	z.msg = "too many length or distance symbols";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (14));  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (14);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: blens [border [index++]] = b & 7;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 19) {  	blens [border [index++]] = 0;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: bb [0] = 7;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (t)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (t + i)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = BAD;  	z.msg = "invalid bit length repeat";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = BAD;  	z.msg = "invalid bit length repeat";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = BAD;  	z.msg = "invalid bit length repeat";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: c = c == 16 ? blens [i - 1] : 0;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: bl [0] = 9;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: bd [0] = 6;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (m >= 258 && n >= 10) {  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  	p = z.next_in_index;  	n = z.avail_in;  	b = s.bitb;  	k = s.bitk;  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (r != Z_OK) {  		mode = r == Z_STREAM_END ? WASH : BADCODE;  		break;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (m >= 258 && n >= 10) {  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  	p = z.next_in_index;  	n = z.avail_in;  	b = s.bitb;  	k = s.bitk;  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (r != Z_OK) {  		mode = r == Z_STREAM_END ? WASH : BADCODE;  		break;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (k < (j)) {  	if (n != 0)  		r = Z_OK;  	else {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: tindex = (tree_index + (b & inflate_mask [j])) * 3;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (e == 0) {  	// literal  	lit = tree [tindex + 2];  	mode = LIT;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: lit = tree [tindex + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	get_Renamed = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	get_Renamed = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	get_Renamed = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: get_Renamed = e & 15;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: len = tree [tindex + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 32) != 0) {  	// end of block  	mode = WASH;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (k < (j)) {  	if (n != 0)  		r = Z_OK;  	else {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (k < (j)) {  	if (n != 0)  		r = Z_OK;  	else {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: tindex = (tree_index + (b & inflate_mask [j])) * 3;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// distance  	get_Renamed = e & 15;  	dist = tree [tindex + 2];  	mode = DISTEXT;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// distance  	get_Renamed = e & 15;  	dist = tree [tindex + 2];  	mode = DISTEXT;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// distance  	get_Renamed = e & 15;  	dist = tree [tindex + 2];  	mode = DISTEXT;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: get_Renamed = e & 15;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: dist = tree [tindex + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (k < (j)) {  	if (n != 0)  		r = Z_OK;  	else {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (k > 7) {  	// return unused byte' if any  	k -= 8;  	n++;  	p--;  	// can always return one  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (k > 7) {  	// return unused byte' if any  	k -= 8;  	n++;  	p--;  	// can always return one  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The following statement contains a magic number: k -= 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (20)) {  	// max bits for literal/length code  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (20)) {  	// max bits for literal/length code  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (15)) {  	// max bits for distance code  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (15)) {  	// max bits for distance code  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e = tp [(tp_index + t) * 3];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (e)) {  	// get extra bits (up to 13)  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: Array.Copy (s.window' r' s.window' q' 2);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: q += 2;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: r += 2;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c -= 2;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp [(tp_index + t) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp [(tp_index + t) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e = tp [(tp_index + t) * 3];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp [(tp_index + t) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp [(tp_index + t) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15) {  	inflateEnd (z);  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15) {  	inflateEnd (z);  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  	z.istate.mode = BAD;  	z.msg = "unknown compression method";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.marker = 5;  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  	z.istate.mode = BAD;  	z.msg = "invalid window size";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  	z.istate.mode = BAD;  	z.msg = "invalid window size";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  	z.istate.mode = BAD;  	z.msg = "invalid window size";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.marker = 5;  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((((z.istate.method << 8) + b) % 31) != 0) {  	z.istate.mode = BAD;  	z.msg = "incorrect header check";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((((z.istate.method << 8) + b) % 31) != 0) {  	z.istate.mode = BAD;  	z.msg = "incorrect header check";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((((z.istate.method << 8) + b) % 31) != 0) {  	z.istate.mode = BAD;  	z.msg = "incorrect header check";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.marker = 5;  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  	z.istate.mode = BAD;  	z.msg = "incorrect data check";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.marker = 5;  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4) {  	if (z.next_in [p] == mark [m]) {  		m++;  	}  	else if (z.next_in [p] != 0) {  		m = 0;  	}  	else {  		m = 4 - m;  	}  	p++;  	n--;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4) {  	if (z.next_in [p] == mark [m]) {  		m++;  	}  	else if (z.next_in [p] != 0) {  		m = 0;  	}  	else {  		m = 4 - m;  	}  	p++;  	n--;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (z.next_in [p] == mark [m]) {  	m++;  }  else if (z.next_in [p] != 0) {  	m = 0;  }  else {  	m = 4 - m;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (z.next_in [p] != 0) {  	m = 0;  }  else {  	m = 4 - m;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: m = 4 - m;  
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (m != 4) {  	return Z_DATA_ERROR;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY)  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  	// overflow of MANY  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (byte)j;  		// bits in this table  		r [1] = (byte)l;  		// bits to dump before this table  		j = SupportClass.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY)  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  	// overflow of MANY  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (byte)j;  		// bits in this table  		r [1] = (byte)l;  		// bits to dump before this table  		j = SupportClass.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY)  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  	// overflow of MANY  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (byte)j;  		// bits in this table  		r [1] = (byte)l;  		// bits to dump before this table  		j = SupportClass.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (byte)j;  	// bits in this table  	r [1] = (byte)l;  	// bits to dump before this table  	j = SupportClass.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (byte)j;  	// bits in this table  	r [1] = (byte)l;  	// bits to dump before this table  	j = SupportClass.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (byte)j;  	// bits in this table  	r [1] = (byte)l;  	// bits to dump before this table  	j = SupportClass.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = (int)(q - u [h - 1] - j);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = 128 + 64;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = 128 + 64;  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = v [p++];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(e [v [p] - s] + 16 + 64);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(e [v [p] - s] + 16 + 64);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = d [v [p++] - s];  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (j = SupportClass.URShift (i' w); j < z; j += f) {  	Array.Copy (r' 0' hp' (q + j) * 3' 3);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (j = SupportClass.URShift (i' w); j < z; j += f) {  	Array.Copy (r' 0' hp' (q + j) * 3' 3);  }  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (q + j) * 3' 3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (q + j) * 3' 3);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build (c' 0' 19' 19' null' null' tb' bb' hp' hn' v);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build (c' 0' 19' 19' null' null' tb' bb' hp' hn' v);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build (c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);  
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (r != Z_OK || (bd [0] == 0 && nl > 257)) {  	if (r == Z_DATA_ERROR) {  		z.msg = "oversubscribed distance tree";  	}  	else if (r == Z_BUF_ERROR) {  		z.msg = "incomplete distance tree";  		r = Z_DATA_ERROR;  	}  	else if (r != Z_MEM_ERROR) {  		z.msg = "empty distance tree with lengths";  		r = Z_DATA_ERROR;  	}  	return r;  }  
Magic Number,ComponentAce.Compression.Libs.zlib,SupportClass,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\SupportClass.cs,URShift,The following statement contains a magic number: if (number >= 0)  	return number >> bits;  else  	return (number >> bits) + (2 << ~bits);  
Magic Number,ComponentAce.Compression.Libs.zlib,SupportClass,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\SupportClass.cs,URShift,The following statement contains a magic number: return (number >> bits) + (2 << ~bits);  
Duplicate Code,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 31)' (14' 33)' (16' 35)' (18' 37)' (20' 39)' (22' 41)' (24' 43))
Duplicate Code,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 40)' (14' 42))
Duplicate Code,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 31)' (16' 35)' (18' 37)' (20' 39)' (22' 41)' (24' 43))
Duplicate Code,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfCodes.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((225' 249)' (260' 284))
Missing Default,engine.net,ResourceApi,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\InstApi.cs,applymap,The following switch statement is missing a default case: switch (c.cmd) {  case MapCmd.Cmd.INSERT_RES:  	byte[] data = ResourceLocator.getResources ().getResource (c.sdata);  	fout.Write (data' 0' data.Length);  	break;  case MapCmd.Cmd.INSERT_VALUE:  	fout.Write (c.bdata' 0' c.bdata.Length);  	break;  case MapCmd.Cmd.INSERT_FILE:  	FileStream fs = new FileStream (c.sdata' FileMode.Open);  	StreamCopy (fs' fout' (int)fs.Length);  	fs.Close ();  	break;  }  
Missing Default,engine.net,Server,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\Server.cs,OnRequests,The following switch statement is missing a default case: switch (ext) {  case "html":  case "xml":  case "css":  	tp = "text/" + ext + "; charset=UTF-8";  	break;  case "jpg":  	tp = "image/jpeg";  	break;  case "bmp":  case "png":  	tp = "image/" + ext;  	break;  case "js":  	tp = "application/javascript; charset=UTF-8";  	break;  case "mid":  	tp = "audio/midi";  	break;  case "wav":  	tp = "audio/x-wav";  	break;  }  
Missing Default,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\old-games_game-utilities\Beneath a Steel Sky\installer\engine.net\zlib\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
