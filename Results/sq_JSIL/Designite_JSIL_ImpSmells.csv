Implementation smell,Namespace,Class,File,Method,Description
Long Method,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The method has 115 lines of code.
Long Method,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,BeginEmitTypeDefinition,The method has 110 lines of code.
Long Method,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitCachedValues,The method has 121 lines of code.
Long Method,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The method has 124 lines of code.
Long Method,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The method has 170 lines of code.
Long Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp_Pointer,The method has 106 lines of code.
Long Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The method has 103 lines of code.
Long Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,The method has 113 lines of code.
Long Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_CompoundAssignment,The method has 126 lines of code.
Long Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,The method has 103 lines of code.
Long Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,The method has 121 lines of code.
Long Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateField,The method has 100 lines of code.
Long Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The method has 232 lines of code.
Long Method,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,TypesAreEqual,The method has 108 lines of code.
Long Method,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,TypeReferenceInternal,The method has 105 lines of code.
Long Method,JSIL.Internal,TypeInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,The method has 206 lines of code.
Long Method,JSIL.Internal,Util,C:\repos\sq_JSIL\JSIL\Util.cs,EscapeIdentifier,The method has 146 lines of code.
Long Method,JSIL.Transforms,ExpandCastExpressions,C:\repos\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,The method has 195 lines of code.
Long Method,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The method has 241 lines of code.
Long Method,JSIL.Transforms,SimplifyLoops,C:\repos\sq_JSIL\JSIL\Transforms\SimplifyLoops.cs,VisitNode,The method has 119 lines of code.
Long Method,JSIL.Transforms,FunctionAnalysis2ndPass,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FunctionAnalysis2ndPass,The method has 220 lines of code.
Long Method,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The method has 116 lines of code.
Long Method,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The method has 163 lines of code.
Complex Method,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitInterfaceDefinition,Cyclomatic complexity of the method is 13
Complex Method,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitCustomAttributes,Cyclomatic complexity of the method is 8
Complex Method,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitPInvokeInfo,Cyclomatic complexity of the method is 10
Complex Method,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitCachedValues,Cyclomatic complexity of the method is 12
Complex Method,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,Cyclomatic complexity of the method is 8
Complex Method,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,Cyclomatic complexity of the method is 12
Complex Method,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,Cyclomatic complexity of the method is 9
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,ILBlockTranslator,Cyclomatic complexity of the method is 9
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate,Cyclomatic complexity of the method is 8
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp_Pointer,Cyclomatic complexity of the method is 10
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp,Cyclomatic complexity of the method is 12
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,HandleJSReplacement,Cyclomatic complexity of the method is 9
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_PropertyCall,Cyclomatic complexity of the method is 9
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,Cyclomatic complexity of the method is 10
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,Cyclomatic complexity of the method is 12
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_CompoundAssignment,Cyclomatic complexity of the method is 10
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Stloc,Cyclomatic complexity of the method is 8
Complex Method,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Conv,Cyclomatic complexity of the method is 8
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,LoadAssembly,Cyclomatic complexity of the method is 12
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,Cyclomatic complexity of the method is 13
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,DoProxyDiagnostics,Cyclomatic complexity of the method is 15
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,DeclareType,Cyclomatic complexity of the method is 13
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,EmitTypeMethodExpressions,Cyclomatic complexity of the method is 12
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeDefinition,Cyclomatic complexity of the method is 8
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,Cyclomatic complexity of the method is 13
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,Cyclomatic complexity of the method is 21
Complex Method,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,ShouldTranslateMethodBody,Cyclomatic complexity of the method is 9
Complex Method,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,IsStruct,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,IsOpenType,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,TypesAreEqual,Cyclomatic complexity of the method is 28
Complex Method,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,TypesAreAssignable,Cyclomatic complexity of the method is 11
Complex Method,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,ExpandPositionalGenericParameters,Cyclomatic complexity of the method is 10
Complex Method,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,EnqueueType,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,ConstructTypeInformation,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,GetProxies,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Ast.Enumerators,JSNodeChildEnumerator,C:\repos\sq_JSIL\JSIL\AST\Enumerators.cs,MoveNext,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Ast,JSAstVisitor,C:\repos\sq_JSIL\JSIL\AST\JSAstVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Ast,JSReferenceExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,TryDereference,Cyclomatic complexity of the method is 14
Complex Method,JSIL.Ast,JSReferenceExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,TryMaterialize,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Ast,JSCastExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,NewInternal,Cyclomatic complexity of the method is 13
Complex Method,JSIL.Ast,JSPointerExpressionUtil,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,OffsetFromBytesToElements,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Ast,JSNode,C:\repos\sq_JSIL\JSIL\AST\JSNodeTypes.cs,EnsureTypeIdsAreAssigned,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Ast,JSNodeTraversalData,C:\repos\sq_JSIL\JSIL\AST\Traversal.cs,JSNodeTraversalData,Cyclomatic complexity of the method is 13
Complex Method,JSIL.Ast.Traversal,JSNodeTraversalData,C:\repos\sq_JSIL\JSIL\AST\Traversal.cs,JSNodeTraversalData,Cyclomatic complexity of the method is 13
Complex Method,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,TypeReferenceInternal,Cyclomatic complexity of the method is 13
Complex Method,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,TypeReference,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Internal,MemberIdentifier,C:\repos\sq_JSIL\JSIL\MemberIdentifier.cs,GetParameterTypes,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Internal,MemberIdentifier,C:\repos\sq_JSIL\JSIL\MemberIdentifier.cs,TypesAreEqual,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Internal,MethodSignature,C:\repos\sq_JSIL\JSIL\MethodSignature.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Internal,SourceMapBuilder,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Internal,ProxyInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,ProxyInfo,Cyclomatic complexity of the method is 13
Complex Method,JSIL.Internal,ProxyInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,IsMatch,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Internal,TypeInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,Cyclomatic complexity of the method is 51
Complex Method,JSIL.Internal,MemberInfo<T>,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,MemberInfo,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Translator,Configuration,C:\repos\sq_JSIL\JSIL\Configuration.cs,MergeInto,Cyclomatic complexity of the method is 18
Complex Method,JSIL.Translator,CodeGeneratorConfiguration,C:\repos\sq_JSIL\JSIL\Configuration.cs,MergeInto,Cyclomatic complexity of the method is 29
Complex Method,JSIL.Transforms,GenericTypesRewriter,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,ResolveTypeReference,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Transforms,IntroduceCharCasts,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,DeoptimizeSwitchStatements,C:\repos\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Transforms,DeoptimizeSwitchStatements,C:\repos\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Transforms,SimplifyLoops,C:\repos\sq_JSIL\JSIL\Transforms\SimplifyLoops.cs,VisitNode,Cyclomatic complexity of the method is 15
Complex Method,JSIL.Transforms,OptimizeArrayEnumerators,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Transforms,StaticAnalyzer,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Transforms,FunctionAnalysis2ndPass,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FunctionAnalysis2ndPass,Cyclomatic complexity of the method is 23
Complex Method,JSIL.Transforms,FunctionAnalysis2ndPass,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,Cyclomatic complexity of the method is 27
Complex Method,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,Cyclomatic complexity of the method is 47
Complex Method,JSIL.Transforms,SimplifyOperators,C:\repos\sq_JSIL\JSIL\Transforms\SimplifyOperators.cs,VisitNode,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,IntroduceVariableReferences,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,GetConstructedReference,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,Cyclomatic complexity of the method is 16
Complex Method,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,PostOptimizeAssignment,Cyclomatic complexity of the method is 9
Long Parameter List,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The method has 5 parameters. Parameters: formatter' typeReference' context' replaceMode' useStandartSubstitution
Long Parameter List,JSIL,DefinitelyTypedBaseEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitCustomAttributes,The method has 5 parameters. Parameters: context' declaringType' member' astEmitter' standalone
Long Parameter List,JSIL,DefinitelyTypedBaseEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitMethodDefinition,The method has 7 parameters. Parameters: context' methodRef' method' astEmitter' stubbed' dollar' methodInfo
Long Parameter List,JSIL,DefinitelyTypedBaseEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitField,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' defaultValue
Long Parameter List,JSIL,DefinitelyTypedBaseEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitConstant,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' value
Long Parameter List,JSIL,DefinitelyTypedEmptyAstEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,DefinitelyTypedEmptyAstEmitter,The method has 5 parameters. Parameters: output' jsil' typeSystem' typeInfo' configuration
Long Parameter List,JSIL,FunctionCache,C:\repos\sq_JSIL\JSIL\FunctionCache.cs,Create,The method has 7 parameters. Parameters: info' methodDef' method' identifier' translator' parameters' body
Long Parameter List,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitCustomAttributes,The method has 5 parameters. Parameters: context' declaringType' member' astEmitter' standalone
Long Parameter List,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitMethodDefinition,The method has 7 parameters. Parameters: context' methodRef' method' astEmitter' stubbed' dollar' methodInfo
Long Parameter List,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitOverrides,The method has 5 parameters. Parameters: context' typeInfo' method' methodInfo' astEmitter
Long Parameter List,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitMarshalInfo,The method has 5 parameters. Parameters: methodRef' method' attributes' mi' astEmitter
Long Parameter List,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitFieldOrConstant,The method has 6 parameters. Parameters: context' astEmitter' field' dollar' defaultValue' isConstant
Long Parameter List,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitField,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' defaultValue
Long Parameter List,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitConstant,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' value
Long Parameter List,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,JavascriptAstEmitter,The method has 5 parameters. Parameters: output' jsil' typeSystem' typeInfo' configuration
Long Parameter List,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,ILBlockTranslator,The method has 9 parameters. Parameters: translator' context' methodReference' methodDefinition' methodSymbols' ilb' parameters' allVariables' referenceReplacer
Long Parameter List,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,HandleJSReplacement,The method has 6 parameters. Parameters: method' methodInfo' thisExpression' arguments' resultType' explicitThis
Long Parameter List,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoMethodReplacement,The method has 7 parameters. Parameters: method' thisExpression' arguments' virtual' static' explicitThis' suppressThisClone
Long Parameter List,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The method has 5 parameters. Parameters: typeName' methodName' method' genericArguments' arguments
Long Parameter List,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_PropertyCall,The method has 5 parameters. Parameters: thisExpression' method' arguments' virtual' static
Long Parameter List,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoPropertyReplacement,The method has 6 parameters. Parameters: thisExpression' thisType' method' arguments' virtual' static
Long Parameter List,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateSwitchCase,The method has 5 parameters. Parameters: block' conditionType' exitLabelName' needExitLabel' epilogue
Long Parameter List,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,NeedsExplicitThis,The method has 6 parameters. Parameters: declaringType' declaringTypeDef' declaringTypeInfo' isSelf' thisReferenceType' methodInfo
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,AssemblyTranslator,The method has 7 parameters. Parameters: configuration' typeInfoProvider' manifest' assemblyDataResolver' onProxyAssemblyLoaded' analyzers' emitterGroupFactories
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,AssemblyLoadErrorWrapper,The method has 5 parameters. Parameters: loader' assemblyName' readerParameters' useSymbols' mainAssemblyPath
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The method has 5 parameters. Parameters: assemblyEmitter' context' assembly' outputStream' sourceMapBuilder
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateModule,The method has 6 parameters. Parameters: context' assemblyEmitter' module' sealedTypes' declaredTypes' stubbed
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,DeclareType,The method has 7 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' declaredTypes' stubbed' isImported
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,DeclareNestedTypes,The method has 7 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' declaredTypes' stubbed' skipped
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,EmitTypeMethodExpressions,The method has 7 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' stubbed' dollar' nextDisambiguatedId
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeDefinition,The method has 7 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' stubbed' dollar' cachers
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,GetAllVariablesForMethod,The method has 5 parameters. Parameters: context' parameters' methodBody' ignoredVariables' enableUnsafeCode
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateField,The method has 5 parameters. Parameters: field' defaultValues' cctorContext' dollar' fieldSelfIdentifier
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The method has 8 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' cctor' stubbed' dollar' cachers
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,CreateMethodInformation,The method has 5 parameters. Parameters: methodInfo' stubbed' isExternal' isJSReplaced' methodIsProxied
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,ShouldTranslateMethodBody,The method has 6 parameters. Parameters: method' methodInfo' stubbed' isExternal' isJSReplaced' methodIsProxied
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,EmitAndDefineMethod,The method has 11 parameters. Parameters: context' methodRef' method' astEmitter' assemblyEmitter' stubbed' dollar' cachers' nextDisambiguatedId' methodInfo' bodyTransformer
Long Parameter List,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,EmitMethodBody,The method has 10 parameters. Parameters: context' methodRef' method' astEmitter' assemblyEmitter' stubbed' cachers' nextDisambiguatedId' methodInfo' bodyTransformer
Long Parameter List,JSIL,JSILIdentifier,C:\repos\sq_JSIL\JSIL\SpecialIdentifiers.cs,CreateNamedFunction,The method has 5 parameters. Parameters: resultType' name' argumentNames' body' closure
Long Parameter List,JSIL,TranslationResult,C:\repos\sq_JSIL\JSIL\TranslationResult.cs,AddFile,The method has 6 parameters. Parameters: type' filename' bytes' position' properties' sourceMapBuilder
Long Parameter List,JSIL.Ast,JSFunctionExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSFunctionExpression,The method has 5 parameters. Parameters: method' allVariables' parameters' body' methodTypes
Long Parameter List,JSIL.Ast,JSMethodPointerInfoExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSMethodPointerInfoExpression,The method has 5 parameters. Parameters: reference' method' methodTypes' isVirtual' genericArguments
Long Parameter List,JSIL.Ast,JSPropertyAccess,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSPropertyAccess,The method has 7 parameters. Parameters: thisReference' property' isWrite' typeQualified' originalType' originalMethod' isVirtualCall
Long Parameter List,JSIL.Ast,JSInvocationExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSInvocationExpression,The method has 7 parameters. Parameters: type' method' thisReference' arguments' explicitThis' constantIfArgumentsAre' suppressThisClone
Long Parameter List,JSIL.Ast,JSInvocationExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,InvokeMethod,The method has 6 parameters. Parameters: type' method' thisReference' arguments' constantIfArgumentsAre' suppressThisClone
Long Parameter List,JSIL.Ast,JSInvocationExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,InvokeMethod,The method has 6 parameters. Parameters: type' method' thisReference' arguments' constantIfArgumentsAre' suppressThisClone
Long Parameter List,JSIL.Ast,JSInvocationExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,InvokeBaseMethod,The method has 5 parameters. Parameters: type' method' thisReference' arguments' constantIfArgumentsAre
Long Parameter List,JSIL.Ast,JSInvocationExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,InvokeBaseMethod,The method has 5 parameters. Parameters: type' method' thisReference' arguments' constantIfArgumentsAre
Long Parameter List,JSIL.Ast,JSMemberDescriptor,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSMemberDescriptor,The method has 5 parameters. Parameters: isPublic' isStatic' isVirtual' isReadonly' offset
Long Parameter List,JSIL.Ast,JSBinaryOperatorExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSBinaryOperatorExpression,The method has 5 parameters. Parameters: op' lhs' rhs' actualType' canSimplify
Long Parameter List,JSIL.Ast,JSBinaryOperatorExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSBinaryOperatorExpression,The method has 5 parameters. Parameters: op' lhs' rhs' actualType' extraValues
Long Parameter List,JSIL.Ast,JSCastExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,New,The method has 5 parameters. Parameters: inner' newType' typeSystem' force' isCoercion
Long Parameter List,JSIL.Ast,JSCastExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,NewInternal,The method has 5 parameters. Parameters: inner' newType' typeSystem' force' make
Long Parameter List,JSIL.Ast,JSFieldDeclaration,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSFieldDeclaration,The method has 5 parameters. Parameters: fieldInfo' descriptor' name' fieldType' defaultValue
Long Parameter List,JSIL.Ast,JSConstantDeclaration,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSConstantDeclaration,The method has 5 parameters. Parameters: fieldInfo' descriptor' name' fieldType' value
Long Parameter List,JSIL.Ast,JSCachedMethod,C:\repos\sq_JSIL\JSIL\AST\JSIdentifierTypes.cs,JSCachedMethod,The method has 5 parameters. Parameters: reference' method' methodTypes' genericArguments' index
Long Parameter List,JSIL.Ast,JSFakeMethod,C:\repos\sq_JSIL\JSIL\AST\JSIdentifierTypes.cs,JSFakeMethod,The method has 6 parameters. Parameters: name' returnType' parameterTypes' methodTypes' genericArguments' escape
Long Parameter List,JSIL.Ast,JSVerbatimLiteral,C:\repos\sq_JSIL\JSIL\AST\JSLiteralTypes.cs,JSVerbatimLiteral,The method has 5 parameters. Parameters: description' expression' variables' type' isConstantIfArgumentsAre
Long Parameter List,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,JavascriptFormatter,The method has 7 parameters. Parameters: output' sourceMapBuilder' typeInfo' manifest' assembly' configuration' stubbed
Long Parameter List,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,MemberDescriptor,The method has 5 parameters. Parameters: isPublic' isStatic' isVirtual' isReadonly' offset
Long Parameter List,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The method has 6 parameters. Parameters: method' signature' context' forConstructor' allowCache' alwaysUseIdentifiers
Long Parameter List,JSIL.Internal,MemberIdentifier,C:\repos\sq_JSIL\JSIL\MemberIdentifier.cs,MemberIdentifier,The method has 6 parameters. Parameters: isStatic' type' name' returnType' parameterTypes' genericArgumentCount
Long Parameter List,JSIL.Internal,PackedArrayUtil,C:\repos\sq_JSIL\JSIL\PackedStructArray.cs,FilterInvocationResult,The method has 5 parameters. Parameters: methodReference' method' result' typeInfo' typeSystem
Long Parameter List,JSIL.Internal,PackedArrayUtil,C:\repos\sq_JSIL\JSIL\PackedStructArray.cs,GetItem,The method has 6 parameters. Parameters: targetType' targetTypeInfo' target' index' methodTypes' proxy
Long Parameter List,JSIL.Internal,Mapping,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,Mapping,The method has 6 parameters. Parameters: generatedLine' generatedColumn' originalLine' originalColumn' source' name
Long Parameter List,JSIL.Internal,TypeInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,The method has 6 parameters. Parameters: source' module' type' declaringType' baseClass' identifier
Long Parameter List,JSIL.Internal,MemberInfo<T>,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,MemberInfo,The method has 7 parameters. Parameters: parent' identifier' member' proxies' isIgnored' isExternal' sourceProxy
Long Parameter List,JSIL.Internal,FieldInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,FieldInfo,The method has 5 parameters. Parameters: parent' identifier' field' proxies' sourceProxy
Long Parameter List,JSIL.Internal,PropertyInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,PropertyInfo,The method has 5 parameters. Parameters: parent' identifier' property' proxies' sourceProxy
Long Parameter List,JSIL.Internal,EventInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,EventInfo,The method has 5 parameters. Parameters: parent' identifier' evt' proxies' sourceProxy
Long Parameter List,JSIL.Internal,MethodInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,MethodInfo,The method has 5 parameters. Parameters: parent' identifier' method' proxies' sourceProxy
Long Parameter List,JSIL.Internal,MethodInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,MethodInfo,The method has 6 parameters. Parameters: parent' identifier' method' proxies' property' sourceProxy
Long Parameter List,JSIL.Internal,MethodInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,MethodInfo,The method has 6 parameters. Parameters: parent' identifier' method' proxies' evt' sourceProxy
Long Parameter List,JSIL.Compiler.Extensibility,IAssemblyEmitter,C:\repos\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitCustomAttributes,The method has 5 parameters. Parameters: context' declaringType' member' astEmitter' standalone
Long Parameter List,JSIL.Compiler.Extensibility,IAssemblyEmitter,C:\repos\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitMethodDefinition,The method has 7 parameters. Parameters: context' methodRef' method' astEmitter' stubbed' dollar' methodInfo
Long Parameter List,JSIL.Compiler.Extensibility,IAssemblyEmitter,C:\repos\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitField,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' defaultValue
Long Parameter List,JSIL.Compiler.Extensibility,IAssemblyEmitter,C:\repos\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitConstant,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' value
Long Parameter List,JSIL.Compiler.Extensibility,IFunctionTransformer,C:\repos\sq_JSIL\JSIL\Extensibility\IAnalyzer.cs,MaybeReplaceMethodCall,The method has 7 parameters. Parameters: caller' method' methodInfo' thisExpression' arguments' resultType' explicitThis
Long Parameter List,JSIL.Transforms,SignatureCacher,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,SignatureCacher,The method has 5 parameters. Parameters: typeInfo' localCachingEnabled' preferLocalCacheForGenericMethodSignatures' preferLocalCacheForGenericInterfaceMethodSignatures' useMethodSignaturePerMethod
Long Parameter List,JSIL.Transforms,SignatureCacher,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,WriteSignatureToOutput,The method has 6 parameters. Parameters: output' enclosingFunction' methodReference' methodSignature' referenceContext' forConstructor
Long Parameter List,JSIL.Transforms,SignatureCacher,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,WriteInterfaceMemberToOutput,The method has 6 parameters. Parameters: output' astEmitter' enclosingFunction' jsMethod' method' referenceContext
Long Parameter List,JSIL.Transforms,HoistAllocations,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,CreateHoistedVariable,The method has 5 parameters. Parameters: update' type' array' index' defaultValue
Long Parameter List,JSIL.Transforms,ExpandCastExpressions,C:\repos\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,ExpandCastExpressions,The method has 6 parameters. Parameters: typeSystem' js' jsil' typeInfo' methodTypeFactory' emulateInt64
Long Parameter List,JSIL.Transforms,IntroduceEnumCasts,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceEnumCasts.cs,IntroduceEnumCasts,The method has 5 parameters. Parameters: typeSystem' js' typeInfo' methodTypes' functionSource
Long Parameter List,JSIL.Transforms,OptimizeArrayEnumerators,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,ReplaceWhileLoop,The method has 6 parameters. Parameters: wl' enumerator' enumeratorType' arrayMember' indexMember' lengthMember
Long Parameter List,JSIL.Transforms,OptimizeArrayEnumerators,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,ReplaceWhileLoopAndEnumerator,The method has 6 parameters. Parameters: wl' backingStore' enumerator' enumeratorType' arrayMember' lengthMember
Long Parameter List,JSIL.Transforms,Access,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Access,The method has 5 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' source' isControlFlow
Long Parameter List,JSIL.Transforms,Assignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Assignment,The method has 8 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' target' newValue' operator' targetType' sourceType
Long Parameter List,JSIL.Transforms,SideEffect,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,SideEffect,The method has 5 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' variable' type
Long Parameter List,JSIL.Transforms,FieldAccess,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FieldAccess,The method has 5 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' field' isRead
Long Parameter List,JSIL.Transforms,Invocation,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Invocation,The method has 7 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' type' method' nonJSMethod' variables
Long Parameter List,JSIL.Transforms,Invocation,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Invocation,The method has 7 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' thisVariable' method' nonJSMethod' variables
Long Parameter List,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,EliminateSingleUseTemporaries,The method has 5 parameters. Parameters: member' functionSource' typeSystem' variables' typeInfo
Long Parameter List,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,EmulateStructAssignment,The method has 7 parameters. Parameters: member' functionSource' typeSystem' typeInfo' clr' methodTypes' optimizeCopies
Long Identifier,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitAssemblyReferences,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericMethodSignatureWithoutResultType,The length of the parameter additionalArgsForNameCalculation is 32.
Long Identifier,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericArgumentsIfNeed,The length of the parameter additionalArgsForNameCalculation is 32.
Long Identifier,JSIL,DefinitelyTypedBaseEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitAssemblyReferences,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitAssemblyReferences,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The length of the parameter wrapAssemblyInImmediatelyInvokedFunctionExpression is 50.
Long Identifier,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,DeclareAssembly,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL.Internal,TypeInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,,The length of the parameter DeferredMethodSignatureSetUpdates is 33.
Long Identifier,JSIL.Internal,TypeInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,,The length of the parameter DeferredStaticMethodSignatureSetUpdates is 39.
Long Identifier,JSIL.Translator,Configuration,C:\repos\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter GenerateSkeletonsForStubbedAssemblies is 37.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,C:\repos\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter DisableGenericSignaturesLocalCache is 34.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,C:\repos\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter PreferLocalCacheForGenericMethodSignatures is 42.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,C:\repos\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter PreferLocalCacheForGenericInterfaceMethodSignatures is 51.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,C:\repos\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter CacheOneMethodSignaturePerMethod is 32.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,C:\repos\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter EliminatePointlessFinallyBlocks is 31.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,C:\repos\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter AutoGenerateEventAccessorsInSkeletons is 37.
Long Identifier,JSIL.Compiler.Extensibility,IAssemblyEmitter,C:\repos\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitAssemblyReferences,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL.Transforms,SignatureCacher,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,SignatureCacher,The length of the parameter preferLocalCacheForGenericMethodSignatures is 42.
Long Identifier,JSIL.Transforms,SignatureCacher,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,SignatureCacher,The length of the parameter preferLocalCacheForGenericInterfaceMethodSignatures is 51.
Long Identifier,JSIL.Transforms,SignatureCacher,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,,The length of the parameter PreferLocalCacheForGenericMethodSignatures is 42.
Long Identifier,JSIL.Transforms,SignatureCacher,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,,The length of the parameter PreferLocalCacheForGenericInterfaceMethodSignatures is 51.
Long Identifier,JSIL.Transforms,CachedSignatureRecord,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,CachedSignatureRecord,The length of the parameter rewritenGenericParametersCount is 30.
Long Identifier,JSIL.Transforms,CachedSignatureRecord,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,,The length of the parameter RewritenGenericParametersCount is 30.
Long Identifier,JSIL.Transforms,CachedInterfaceMemberRecord,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,CachedInterfaceMemberRecord,The length of the parameter rewritenGenericParametersCount is 30.
Long Identifier,JSIL.Transforms,CachedInterfaceMemberRecord,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,,The length of the parameter RewritenGenericParametersCount is 30.
Long Identifier,JSIL.Transforms,EliminatePointlessRetargeting,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminatePointlessRetargeting.cs,IsCachedValueValidForGivenCacheKey,The length of the parameter cachedValueLastInitializationNodeIndex is 38.
Long Identifier,JSIL.Transforms,LabelGroupLabelData,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,,The length of the parameter TimesUsedAsRecursiveExitTarget is 30.
Long Identifier,JSIL.Transforms,OptimizeArrayEnumerators,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The length of the parameter enumeratorAssignmentBeforeLoop is 30.
Long Identifier,JSIL.Transforms,FunctionAnalysis2ndPass,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,,The length of the parameter ViolatesThisReferenceImmutability is 33.
Long Identifier,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,,The length of the parameter VariablesExemptedFromEffectivelyConstantStatus is 46.
Long Identifier,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,The length of the parameter allowImmutabilityOptimizations is 30.
Long Identifier,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the parameter thisReferenceNeedsCopyAndReassignment is 37.
Long Identifier,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the parameter rightVarIsEffectivelyConstantHere is 33.
Long Identifier,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the parameter rightVarIsEffectivelyConstantHere is 33.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitHeader,The length of the statement  "            Formatter.WriteRaw("import {$private as $asmJsilCore' StaticType as $StaticType' Type as $Type' NullArg as $Null} from \"./JSIL.Core\""); " is 137.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitAssemblyReferences,The length of the statement  "                        Formatter.WriteRaw(string.Format("import {{$private as {0}}} from \"./{1}\""' referenceOverride.Key.IDString' referenceOverride.Value)); " is 136.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInstance,The length of the statement  "                var instanceFields = typedef.Fields.Where(it => it.IsPublic && !it.IsStatic && !Translator.ShouldSkipMember(it)).OrderBy(md => md.Name); " is 136.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInstance,The length of the statement  "                     || (it.SetMethod != null && it.SetMethod.IsPublic && !it.SetMethod.IsStatic && !Translator.ShouldSkipMember(it.SetMethod)))) " is 124.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInstance,The length of the statement  "                var instanceMethods = typedef.Methods.Where(it => it.IsPublic && !it.IsStatic && !it.IsConstructor && !Translator.ShouldSkipMember(it)).OrderBy(md => md.Name); " is 159.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInOutType,The length of the statement  "            var interfaces = typedef.Interfaces.Where(it => DefinitelyTypedUtilities.IsTypePublic(it) && !Translator.ShouldSkipMember(it)); " is 127.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "            var staticFields = typedef.Fields.Where(it => it.IsPublic && it.IsStatic && !Translator.ShouldSkipMember(it)).OrderBy(md => md.Name); " is 133.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "                     || (it.SetMethod != null && it.SetMethod.IsPublic && it.SetMethod.IsStatic && !Translator.ShouldSkipMember(it.SetMethod)))) " is 123.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "            var constructors = typedef.Methods.Where(it => it.IsPublic && !it.IsStatic && it.IsConstructor && !Translator.ShouldSkipMember(it)); " is 132.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "            var staticMethods = typedef.Methods.Where(it => it.IsPublic && it.IsStatic && !it.IsConstructor && !Translator.ShouldSkipMember(it)).OrderBy(it => it.Name); " is 156.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "                var instanceMethods = typedef.Methods.Where(it => it.IsPublic && !Translator.ShouldSkipMember(it)).GroupBy(method => method.Name).OrderBy(group => group.Key); " is 158.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitMethod,The length of the statement  "                    Formatter.WriteGenericMethodSignatureWithoutResultType(method.GenericParameters' method.DeclaringType.GenericParameters); " is 121.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitInterfaceMethod,The length of the statement  "                Formatter.CommaSeparatedList(DefinitelyTypedUtilities.BuildGenericParemetersMap(method.GenericParameters' method.DeclaringType.GenericParameters)' pair => { " is 156.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitInterfaceMethod,The length of the statement  "                    Formatter.WriteGenericArgumentsIfNeed(new[] { DefinitelyTypedUtilities.GetGenericParameterInstanceParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterInParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterOutParameterName(pair.Value) }); " is 274.
Long Statement,JSIL,DefinitelyTypedExportEmitter,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitHeader,The length of the statement  "            Formatter.WriteRaw(string.Format("import {{$private as $this}} from \"./internals/{0}\""' Formatter.Assembly.FullName)); " is 120.
Long Statement,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The length of the statement  "                    map = DefinitelyTypedUtilities.BuildGenericParemetersMap(((MethodDefinition) gp.Owner).GenericParameters' ((MethodDefinition) gp.Owner).DeclaringType.GenericParameters); " is 169.
Long Statement,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The length of the statement  "            } else if (typeReference is PointerType || typeReference is OptionalModifierType || typeReference is RequiredModifierType || typeReference is PinnedType || typeReference is SentinelType || typeReference is FunctionPointerType " is 225.
Long Statement,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericMethodSignatureWithoutResultType,The length of the statement  "            formatter.CommaSeparatedList(DefinitelyTypedUtilities.BuildGenericParemetersMap(args' additionalArgsForNameCalculation)' pair => { " is 130.
Long Statement,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericMethodSignatureWithoutResultType,The length of the statement  "                formatter.WriteGenericArgumentsIfNeed(new[] { DefinitelyTypedUtilities.GetGenericParameterInstanceParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterInParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterOutParameterName(pair.Value)}); " is 273.
Long Statement,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericArgumentsIfNeed,The length of the statement  "                    .SelectMany(pair => new[] { DefinitelyTypedUtilities.GetGenericParameterInstanceParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterInParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterOutParameterName(pair.Value)})); " is 256.
Long Statement,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,TranslateAttributeConstructorArgument,The length of the statement  "                    throw new NotImplementedException(String.Format("Attribute arguments of type '{0}' are not implemented."' ca.Type.FullName)); " is 125.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "            var offsetInElements = JSPointerExpressionUtil.OffsetFromBytesToElements(delta' TypeUtil.GetElementType(pae.Pointer.GetActualType(TypeSystem)' true)); " is 150.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "            var regex = new Regex(@"(\$\$|\$(?'name'((etypeof|typeof|assemblyof|explicitThis|declaringType)\([a-zA-Z0-9_]([a-zA-Z0-9_]*)\))|([a-zA-Z0-9_]([a-zA-Z0-9_]*)))|(?'text'[^\$]*)|)"' RegexOptions.ExplicitCapture); " is 209.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "            foreach (var line in verbatim.Expression.Split(new string[] { Environment.NewLine }' StringSplitOptions.RemoveEmptyEntries)) { " is 126.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "                // Like with packed array elements' if we're passing the result of a pointer dereference directly to a function' pass a proxy instead. " is 134.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "                // If the pointer has been hoisted the proxy will be reused' which reduces GC pressure and allows unpacking to happen on demand. " is 128.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,AddSourceMapInfo,The length of the statement  "                //Output.Comment(string.Join("; "' node.SymbolInfo.SequencePoints.Select(item => item.StartLine + ":" + item.StartColumn))); " is 124.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,AddSourceMapInfo,The length of the statement  "                Output.SourceMapBuilder.AddInfo(Output.OutputWithPositionInfo.Line' Output.OutputWithPositionInfo.Column' node.SymbolInfo.SequencePoints); " is 138.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,AddSourceMapInfoEnd,The length of the statement  "                Output.SourceMapBuilder.AddInfoEnd(Output.OutputWithPositionInfo.Line' Output.OutputWithPositionInfo.Column' node.SymbolInfo.SequencePoints); " is 141.
Long Statement,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,AddSourceMapInfoEnd,The length of the statement  "                //Output.Comment("--" + string.Join("; "' node.SymbolInfo.SequencePoints.Select(item => item.EndLine + ":" + item.EndColumn))); " is 127.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,HandleJSReplacement,The length of the statement  "                        foreach (var kvp in methodInfo.GenericParameterNames.Zip(genericMethod.GenericArguments' (n' p) => new { Name = n' Value = p })) { " is 130.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,HandleJSReplacement,The length of the statement  "                        argsDict["etypeof(" + kvp.Name + ")"] = Translate_TypeOf(typeSpecification != null ? typeSpecification.ElementType : type.GetElementType()); " is 140.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoMethodReplacement,The length of the statement  "                    result = JSInvocationExpression.InvokeMethod(method.Reference.DeclaringType' method' thisExpression' arguments' suppressThisClone: suppressThisClone); " is 150.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The length of the statement  "                                var temporaryAssignment = new JSBinaryOperatorExpression(JSOperator.Assignment' temporaryVariable' argumentsExpression' argumentsExpressionType); " is 145.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoNonJSILMethodReplacement,The length of the statement  "                case "System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle'System.RuntimeTypeHandle)": " is 139.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoNonJSILMethodReplacement,The length of the statement  "                case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)": " is 135.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,AddSymbolInfo,The length of the statement  "                                .Where(item => !(item.SequencePoint.StartLine == item.SequencePoint.EndLine && item.SequencePoint.StartColumn == item.SequencePoint.EndColumn)) " is 143.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateSwitchCase,The length of the statement  "                var switchBreaks = (from be in jsBlock.AllChildrenRecursive.OfType<JSBreakExpression>() where be.TargetLoop == null select be); " is 127.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_CompoundAssignment_MultidimensionalArray,The length of the statement  "            Func<JSExpression[]' JSExpression' JSInvocationExpressionBase> makeSetter = (_indices' _value) => JSInvocationExpression.InvokeMethod( " is 134.
Long Statement,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Ldlen,The length of the statement  "                return new JSUntranslatableExpression(String.Format("Retrieving the length of a type with no length property: {0}"' argType.FullName)); " is 135.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,Translate,The length of the statement  "                    Console.Error.WriteLine("// WARNING: Bug checks have been suppressed. You may be running JSIL on a broken/unsupported .NET runtime."); " is 134.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,The length of the statement  "            var results = EmitterGroupFactories.Select(item => new {EmitterGroup = item' TranslationResult = new TranslationResult(this.Configuration' assemblyPath' Manifest)}).ToList(); " is 174.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,The length of the statement  "                                    var formatter = new JavascriptFormatter(tw' sourceMapBuilder' this.TypeInfoProvider' Manifest' assembly' Configuration' stubbed); " is 129.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,AnalyzeFunctions,The length of the statement  "                    throw new InvalidDataException("Method collection mutated during analysis. Try setting UseThreads=false (and report an issue!)"); " is 129.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,GetMethodsToAnalyze,The length of the statement  "                                    typeList.AddRange(TypeInfoProvider.FindTypeProxy(new TypeIdentifier(info.Definition)).ProxiedTypes.Select(item => item.Resolve())); " is 131.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The length of the statement  "                assemblyDeclarationReplacement = (string) metadata.GetAttributeParameters("JSIL.Meta.JSRepaceAssemblyDeclaration")[0].Value; " is 124.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The length of the statement  "            var wrapAssemblyInImmediatelyInvokedFunctionExpression = Configuration.InlineAssemblyReferences.GetValueOrDefault(false); " is 121.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,DeclareType,The length of the statement  "                    DeclareType(context' declaringType' astEmitter' assemblyEmitter' declaredTypes' IsStubbed(declaringType.Module.Assembly)); " is 122.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,The length of the statement  "                    allVariables = GetAllVariablesForMethod(context' decompiler.Parameters' ilb' ignoredVariables' Configuration.CodeGenerator.EnableUnsafeCode.GetValueOrDefault(false)); " is 166.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,The length of the statement  "                    var freezeInvocation = translator.SpecialIdentifiers.JSIL.FreezeImmutableObject(new JSIndirectVariable(translator.Variables' "this"' method)); " is 142.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The length of the statement  "                    context' astBuilder.Parameters' block' ignoreReasons' Configuration.CodeGenerator.EnableUnsafeCode.GetValueOrDefault(false) " is 123.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The length of the statement  "                        this' ctx' realCctor' realCctor' ReadMethodSymbolsIfSourceMapEnabled(realCctor)' block' astBuilder.Parameters' variables " is 120.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The length of the statement  "                            // If the field's value is of an ignored type then we ignore the initialization since it probably won't translate anyway. " is 121.
Long Statement,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The length of the statement  "                                // TODO: Expand this to include 'new X' expressions that are effectively constant' by using static analysis to ensure that " is 122.
Long Statement,JSIL,JavascriptEmitterGroupFactory,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,GenerateManifest,The length of the statement  "                result.AddFile("Manifest"' Path.GetFileName(assemblyPath) + ".manifest.js"' new ArraySegment<byte>(ms.GetBuffer()' 0' (int) ms.Length)' 0); " is 139.
Long Statement,JSIL,JSILIdentifier,C:\repos\sq_JSIL\JSIL\SpecialIdentifiers.cs,NewElementReference,The length of the statement  "                throw new ArgumentException("Cannot create a reference to an element of a value of type '" + arrayType.FullName + "'"' target.ToString()); " is 138.
Long Statement,JSIL,JSILIdentifier,C:\repos\sq_JSIL\JSIL\SpecialIdentifiers.cs,CreateNamedFunction,The length of the statement  "            // FIXME: We should do a cast of the result to ensure it's actually the requested result type instead of just a raw JS function " is 127.
Long Statement,JSIL.Ast,JSAstVisitor,C:\repos\sq_JSIL\JSIL\AST\JSAstVisitor.cs,GetEnclosingNodes,The length of the statement  "            // https://connect.microsoft.com/VisualStudio/feedback/details/781746/c-compiler-produces-incorrect-code-for-use-of-enumerator-structs-inside-enumerator-functions " is 162.
Long Statement,JSIL.Ast,JSResultReferenceExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,ReplaceChild,The length of the statement  "                    throw new InvalidOperationException("Replacing an invocation expression inside a result reference with a non invocation expression"); " is 133.
Long Statement,JSIL.Ast,JSInvocationExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetActualType,The length of the statement  "                return _ActualType = SubstituteTypeArgs(targetMethod.Method.Source' targetMethod.Reference.ReturnType' targetMethod.Reference); " is 127.
Long Statement,JSIL.Ast,JSArrayExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,UnpackArrayInitializer,The length of the statement  "                        return new JSUntranslatableExpression(String.Format("Array initializers with element type '{0}' not implemented"' elementType.FullName)); " is 137.
Long Statement,JSIL.Ast,JSCastExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,NewInternal,The length of the statement  "                    return new JSUntranslatableExpression("Cannot cast reference of type '" + currentDerefed.FullName + "' to type '" + newDerefed.FullName + "'"); " is 143.
Long Statement,JSIL.Ast,JSMethod,C:\repos\sq_JSIL\JSIL\AST\JSIdentifierTypes.cs,GetNameForInstanceReference,The length of the statement  "            // For methods that implement a method of a closed generic interface' we need to ensure we fully-qualify their name when necessary. " is 131.
Long Statement,JSIL.Ast,JSVerbatimLiteral,C:\repos\sq_JSIL\JSIL\AST\JSLiteralTypes.cs,ToString,The length of the statement  "                variablesText = String.Join("' "' (from kvp in Variables select String.Format("{0}={1}"' kvp.Key' kvp.Value)).ToArray()); " is 121.
Long Statement,JSIL.Ast,JSNode,C:\repos\sq_JSIL\JSIL\AST\JSNodeTypes.cs,GetTypeId,The length of the statement  "                throw new InvalidOperationException(string.Format("Node type '{0}' was loaded after JSNode initialization"' nodeType.FullName)); " is 128.
Long Statement,JSIL.Ast,JSLabelGroupStatement,C:\repos\sq_JSIL\JSIL\AST\JSStatementTypes.cs,ReplaceChild,The length of the statement  "                                throw new InvalidOperationException("Replacing LabelGroupStatement child '" + oldChild + "' with '" + newChild + "' but group already contains the label '" + stmt.Label + "'"); " is 176.
Long Statement,JSIL.Internal,Key,C:\repos\sq_JSIL\JSIL\CILSupport.cs,Equals,The length of the statement  "                        Console.Error.WriteLine("WARNING: Invalid Key passed to Key.Equals. You are probably running a version of Mono with a broken ConcurrentDictionary."); " is 149.
Long Statement,JSIL.Internal,FunctionTransformPipeline,C:\repos\sq_JSIL\JSIL\FunctionTransformPipeline.cs,RunUntilCompletion,The length of the statement  "                    Console.Error.WriteLine("Failed to lock '{0}' for transform pipeline: {1} {2}"' Identifier' lockResult.FailureReason' deadlock); " is 128.
Long Statement,JSIL.Internal,FunctionTransformPipeline,C:\repos\sq_JSIL\JSIL\FunctionTransformPipeline.cs,RunUntilCompletion,The length of the statement  "                                var currentSecondPass = Translator.FunctionCache.GetSecondPass(this.Function.Method' this.Function.Method.QualifiedIdentifier); " is 127.
Long Statement,JSIL.Internal,FunctionTransformPipeline,C:\repos\sq_JSIL\JSIL\FunctionTransformPipeline.cs,RunUntilCompletion,The length of the statement  "                                    Console.WriteLine("// Second pass data changed by pipeline stage '" + currentStage.Method.Name + "' - " + String.Join("' "' differences)); " is 138.
Long Statement,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The length of the statement  "                    if ((alwaysUseIdentifiers || context.EnclosingMethod != null) && !TypeUtil.IsOpenType(returnType' gp => !SignatureCacher.IsTypeArgument(gp))) " is 141.
Long Statement,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The length of the statement  "                        if ((alwaysUseIdentifiers || context.EnclosingMethod != null) && !TypeUtil.IsOpenType(signature.ReturnType' gp => !SignatureCacher.IsTypeArgument(gp))) " is 151.
Long Statement,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The length of the statement  "                            if ((alwaysUseIdentifiers || context.EnclosingMethod != null) && !TypeUtil.IsOpenType(pt' gp => !SignatureCacher.IsTypeArgument(gp))) " is 133.
Long Statement,JSIL.Internal,PackedArrayUtil,C:\repos\sq_JSIL\JSIL\PackedStructArray.cs,CheckInvocationSafety,The length of the statement  "                            "Invalid attempt to pass a normal array as parameter '" + method.Parameters[i].Name + "' to method '" + method.Name + "'. " + " is 125.
Long Statement,JSIL.Internal,PackedArrayUtil,C:\repos\sq_JSIL\JSIL\PackedStructArray.cs,CheckInvocationSafety,The length of the statement  "                            "Invalid attempt to pass a packed array as parameter '" + method.Parameters[i].Name + "' to method '" + method.Name + "'. " + " is 125.
Long Statement,JSIL.Internal,PackedArrayUtil,C:\repos\sq_JSIL\JSIL\PackedStructArray.cs,FilterInvocationResult,The length of the statement  "                    return JSChangeTypeExpression.New(result' PackedArrayUtil.MakePackedArrayType(resultType' returnValueAttribute.Entries.First().Type)' typeSystem); " is 146.
Long Statement,JSIL.Internal,SourceMapBuilder,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,Build,The length of the statement  "            sourceMap.AppendLine(string.Format("\t\"sources\" : [{0}]'"' string.Join("' "' sources.Select(item => "\"" + MakeRelativePath(path' item) + "\"")))); " is 149.
Long Statement,JSIL.Internal,SourceMapBuilder,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,Build,The length of the statement  "            sourceMap.AppendLine(string.Format("\t\"names\" : [{0}]'"' string.Join("' "' names.Select(item => "\"" + item + "\"")))); " is 121.
Long Statement,JSIL.Internal,Mapping,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,Equals,The length of the statement  "                return GeneratedLine == other.GeneratedLine && GeneratedColumn == other.GeneratedColumn && OriginalLine == other.OriginalLine && OriginalColumn == other.OriginalColumn && string.Equals(Source' other.Source) && string.Equals(Name' other.Name); " is 242.
Long Statement,JSIL.Internal,MethodInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,_IsExternal,The length of the statement  "            var result = method.IsNative || method.IsUnmanaged || method.IsUnmanagedExport || method.IsInternalCall || method.IsPInvokeImpl; " is 128.
Long Statement,JSIL.Internal,PolicyExtensions,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,ApplyWritePolicy,The length of the statement  "                    result = new JSIgnoredMemberReference(member.WritePolicy == JSWritePolicy.ThrowError' member' thisExpression' newValue); " is 120.
Long Statement,JSIL.Internal,PolicyExtensions,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,ApplyInvokePolicy,The length of the statement  "                    result = new JSIgnoredMemberReference(member.InvokePolicy == JSInvokePolicy.ThrowError' member' new[] { thisExpression }.Concat(parameters).ToArray()); " is 151.
Long Statement,JSIL.Transforms,CachedSignatureRecord,C:\repos\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,GetHashCode,The length of the statement  "                return (Method != null ? Method.Name.GetHashCode() : 0) ^ Signature.GetHashCode() ^ IsConstructor.GetHashCode() ^ RewritenGenericParametersCount; " is 145.
Long Statement,JSIL.Transforms,AttachSymbolInfoToStatements,C:\repos\sq_JSIL\JSIL\Transforms\AttachSymbolInfoToStatements.cs,VisitNodeInternalDown,The length of the statement  "                var childSymboInfo = node.Children.Where(item => item != null).Select(item => item.SymbolInfo).FirstOrDefault(item => item != null); " is 132.
Long Statement,JSIL.Transforms,IntroducePackedArrays,C:\repos\sq_JSIL\JSIL\Transforms\IntroducePackedArrays.cs,VisitNode,The length of the statement  "                        replacement = new JSNewPackedArrayExpression(leftField.Field.Field.FieldType' nae.ElementType' nae.Dimensions' nae.SizeOrArrayInitializer); " is 139.
Long Statement,JSIL.Transforms,IntroducePackedArrays,C:\repos\sq_JSIL\JSIL\Transforms\IntroducePackedArrays.cs,VisitNode,The length of the statement  "                        replacement = new JSNewPackedArrayExpression(leftField.Field.Field.FieldType' nae.ElementType' nae.SizeOrArrayInitializer); " is 123.
Long Statement,JSIL.Transforms,HoistAllocations,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,DoesValueEscapeFromInvocation,The length of the statement  "                    // HACK for methods that do not have resolvable references. In this case' if NONE of their arguments escape' we're probably still okay. " is 135.
Long Statement,JSIL.Transforms,HoistAllocations,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,VisitNode,The length of the statement  "                        new JSFakeMethod("retarget"' hoistedVariable.GetActualType(TypeSystem)' new TypeReference[] { TypeSystem.Object' TypeSystem.Int32 }' MethodTypes)'  " is 146.
Long Statement,JSIL.Transforms,UnsafeCodeTransforms,C:\repos\sq_JSIL\JSIL\Transforms\UnsafeCodeTransforms.cs,VisitNode,The length of the statement  "            // This allows hoisting to operate when the call is inside a loop' and it reduces GC pressure (since we basically make the struct unpack occur on-demand). " is 154.
Long Statement,JSIL.Transforms,ConvertPropertyAccessesToInvocations,C:\repos\sq_JSIL\JSIL\Transforms\ConvertPropertyAccessesToInvocations.cs,ConstructInvocation,The length of the statement  "                        var actualReturnType = JSExpression.SubstituteTypeArgs(TypeInfo' actualMethodReference.ReturnType' actualMethodReference); " is 122.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The length of the statement  "                    Console.WriteLine("// Not recording fallthrough from {0} to {1} because {0} ends with control flow ({2})"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label' lastEs.Expression); " is 191.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The length of the statement  "                            Console.WriteLine("// Recording fallthrough from {0} to {1}"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label); " is 127.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The length of the statement  "                Console.WriteLine("// Failed to record fallthrough from {0} to {1}"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label); " is 134.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,ExtractExitLabel,The length of the statement  "                    Console.WriteLine("// Cannot extract exit label '{0}' from label group because it contains a goto or exit"' originalLabelName); " is 127.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The length of the statement  "                        Console.WriteLine("// Cannot mark label '{0}' as exit label because it falls through and is not the last label"' onlyRecursiveExitTarget); " is 138.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The length of the statement  "                            Console.WriteLine("// Cannot mark label '{0}' as exit label because this labelgroup already has one"' onlyRecursiveExitTarget); " is 127.
Long Statement,JSIL.Transforms,ExpandCastExpressions,C:\repos\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,The length of the statement  "                                new JSFakeMethod("ToNumber"' targetType' new TypeReference[] { TypeSystem.Double' TypeSystem.Boolean }' MethodTypeFactory)' " is 123.
Long Statement,JSIL.Transforms,ExpandCastExpressions,C:\repos\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,The length of the statement  "                                new JSFakeMethod("ToNumber"' targetType' new TypeReference[] { TypeSystem.Double' TypeSystem.Boolean }' MethodTypeFactory)' " is 123.
Long Statement,JSIL.Transforms,IntroduceCharCasts,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,The length of the statement  "            if (boe.Operator == JSOperator.Assignment && (leftType.FullName == "System.Char") && (rightType.FullName != "System.Char")) " is 123.
Long Statement,JSIL.Transforms,IntroduceCharCasts,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,The length of the statement  "            if (boe.Operator == JSOperator.Assignment && (leftType.FullName != "System.Char") && (rightType.FullName == "System.Char")) " is 123.
Long Statement,JSIL.Transforms,IntroduceCharCasts,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,The length of the statement  "            JSDotExpressionBase parentInvocationDot = (parentInvocation != null) ? parentInvocation.Method as JSDotExpressionBase : null; " is 125.
Long Statement,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The length of the statement  "                            JSBinaryOperatorExpression equality = new JSBinaryOperatorExpression(JSOperator.Equal' ie.ThisReference' ie.Parameters.First().Value' type.Type); " is 145.
Long Statement,JSIL.Transforms,OptimizeArrayEnumerators,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The length of the statement  "                (condInvocation.JSMethod.Method.DeclaringType.Interfaces.ToEnumerable().Any((ii) => ii.Info.FullName == "System.Collections.IEnumerator")) && " is 141.
Long Statement,JSIL.Transforms,StaticAnalyzer,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,The length of the statement  "            var enclosingBoe = GetEnclosingNodes<JSBinaryOperatorExpression>((boe) => boe.Operator is JSAssignmentOperator).FirstOrDefault(); " is 129.
Long Statement,JSIL.Transforms,StaticAnalyzer,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,The length of the statement  "            var enclosingBoe = GetEnclosingNodes<JSBinaryOperatorExpression>((boe) => boe.Operator is JSAssignmentOperator).FirstOrDefault(); " is 129.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The length of the statement  "                var targetAssignmentIndices = (from a in FirstPass.Assignments where target.Identifier.Equals(a.Target) select a.StatementIndex); " is 129.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The length of the statement  "                var targetAccessIndices = (from a in FirstPass.Accesses where target.Identifier.Equals(a.Source) select a.StatementIndex).ToArray(); " is 132.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The length of the statement  "                            Console.WriteLine("Found assignment slot for {0} <- {1} between {2} and {3}"' target' source' assignment' nextAssignment); " is 122.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,ExemptVariablesFromEffectivelyConstantStatus,The length of the statement  "                                    Console.WriteLine("Exempting variable '{0}' from effectively constant status because it is passed to {1} (no static analysis data)"' variableName' invocation.Method ?? invocation.NonJSMethod); " is 192.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,ExemptVariablesFromEffectivelyConstantStatus,The length of the statement  "                                            Console.WriteLine("Exempting variable '{0}' from effectively constant status because {1} {2}"' variableName' invocation.Method ?? invocation.NonJSMethod' reason); " is 162.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The length of the statement  "                if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) { " is 129.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The length of the statement  "                                    Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod)); " is 223.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The length of the statement  "                                Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod)); " is 168.
Long Statement,JSIL.Transforms,IntroduceVariableReferences,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,TransformParameterIntoReference,The length of the statement  "            var newVariable = new JSVariable(parameter.Identifier' new ByReferenceType(parameter.IdentifierType)' parameter.Function); " is 122.
Long Statement,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,The length of the statement  "                        Console.WriteLine(String.Format("Returning false from IsCopyNeeded for parameter {0} because reference count is 1 and it has no aliases"' value)); " is 146.
Long Statement,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the statement  "                throw new InvalidDataException("No second-pass static analysis data for function '" + fn.Method.QualifiedIdentifier + "'"); " is 123.
Long Statement,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsArgumentCopyNeeded,The length of the statement  "                    Console.WriteLine("argument {0} ('{1}') needs no copy because it isn't modified and doesn't escape"' expression' parameterName); " is 128.
Long Statement,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the statement  "                    Console.WriteLine("Cloning this-reference because method mutates this and this-reference is not field/local: {0}"' invocation); " is 127.
Complex Conditional,JSIL,JavascriptFormatterHelper,C:\repos\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The conditional expression  "typeReference is PointerType || typeReference is OptionalModifierType || typeReference is RequiredModifierType || typeReference is PinnedType || typeReference is SentinelType || typeReference is FunctionPointerType                  || (!_coreTypes.Contains(typeReference.FullName) && formatter.TypeInfo.Get(typeReference).IsSuppressDeclaration)"  is complex.
Complex Conditional,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The conditional expression  "(lastExpressionStatement != null) &&                      (                          (lastExpressionStatement.Expression is JSContinueExpression) ||                           (lastExpressionStatement.Expression is JSBreakExpression) ||                          (lastExpressionStatement.Expression is JSGotoExpression)                      )"  is complex.
Complex Conditional,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The conditional expression  "(                      TypeUtil.IsIntegral(oldType) ||                      TypeUtil.IsFloatingPoint(oldType)                  ) &&                  (                      TypeUtil.IsIntegral(newType) ||                      TypeUtil.IsFloatingPoint(newType)                  )"  is complex.
Complex Conditional,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The conditional expression  "!needsTruncation &&                  (                      (ParentNode is JSInvocationExpressionBase) ||                      (ParentNode is JSCastExpression) ||                      (                          (parentBop != null) &&                          (parentBop.Operator is JSAssignmentOperator)                      )                  ) &&                  !TypeUtil.IsPointer(resultType)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp,The conditional expression  "TypeUtil.IsIgnoredType(node.Arguments[0].ExpectedType) ||                  TypeUtil.IsIgnoredType(node.Arguments[1].ExpectedType) ||                  TypeUtil.IsIgnoredType(node.Arguments[0].InferredType) ||                  TypeUtil.IsIgnoredType(node.Arguments[1].InferredType)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp,The conditional expression  "TypeUtil.IsIntegral(leftType) &&                   TypeUtil.IsIntegral(rightType) &&                  TypeUtil.IsIntegral(resultType) &&                  !(op is JSBitwiseOperator)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateFixedInitializer,The conditional expression  "(toTranslate.Code == ILCode.Stloc) &&                   (toTranslate.Arguments[0].Code == ILCode.TernaryOp) &&                  (toTranslate.Arguments[0].Arguments[0].Code == ILCode.LogicAnd) &&                  (toTranslate.Arguments[0].Arguments[1].Code == ILCode.Ldelema)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,The conditional expression  "(result != null) &&                  (expression.ExpectedType != null) &&                  (expression.InferredType != null) &&                  !TypeUtil.TypesAreAssignable(TypeInfo' expression.ExpectedType' expression.InferredType)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,The conditional expression  "(expression.Code != ILCode.InitArray) &&                    (expression.ExpectedType != null) &&                  (expression.InferredType != null) &&                  (TypeUtil.IsArray(expression.InferredType)) &&                  expression.ExpectedType.FullName.StartsWith("System.Collections.") &&                  expression.ExpectedType.FullName.Contains(".IEnumerable")"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,The conditional expression  "(!node.Arguments[0].ExpectedType.IsValueType) &&                  (!node.Arguments[1].ExpectedType.IsValueType) &&                  (node.Arguments[0].ExpectedType == node.Arguments[1].ExpectedType) &&                  (node.Arguments[0].Code == ILCode.Isinst)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,The conditional expression  "(node.Arguments[0].ExpectedType == node.Arguments[1].ExpectedType) &&                  (node.Arguments[0].Code == ILCode.Ldnull || node.Arguments[1].Code == ILCode.Ldnull) &&                  (node.Arguments[0].Code != node.Arguments[1].Code)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,The conditional expression  "(op == JSOperator.GreaterThan && node.Arguments[1].Code == ILCode.Ldnull)                      || (op == JSOperator.LessThan && (node.Arguments[0].Code == ILCode.Ldnull))"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,The conditional expression  "(op == JSOperator.GreaterThanOrEqual && node.Arguments[0].Code == ILCode.Ldnull)                           || (op == JSOperator.LessThanOrEqual && (node.Arguments[1].Code == ILCode.Ldnull))"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_CompoundAssignment,The conditional expression  "(leftThisType != null) &&                      (leftThisType.Rank > 1) &&                      (leftInvocation.JSMethod != null) &&                      (leftInvocation.JSMethod.Method.Name == "Get")"  is complex.
Complex Conditional,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,The conditional expression  "Configuration.CodeGenerator.FreezeImmutableObjects.GetValueOrDefault(false) &&                      (method.Name == ".ctor") &&                      methodInfo.DeclaringType.IsImmutable &&                      TypeUtil.IsStruct(method.DeclaringType)"  is complex.
Complex Conditional,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateField,The conditional expression  "!cctorContext &&                       (defaultValue != null) &&                      (                          defaultValue.HasGlobalStateDependency ||                           !defaultValue.IsConstant ||                          TypeUtil.IsStruct(defaultValue.GetActualType(field.Module.TypeSystem)) ||                          defaultValue is JSNewExpression ||                          defaultValue is JSArrayExpression ||                          defaultValue is JSInvocationExpressionBase ||                          defaultValue is JSNewArrayExpression ||                          defaultValue is JSEnumLiteral ||                          defaultValue is JSCastExpression ||                          defaultValue is JSTypeOfExpression                      )"  is complex.
Complex Conditional,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The conditional expression  "(fi != null) && (fi.IsIgnored || fi.IsExternal || ShouldSkipMember(fi.Member))"  is complex.
Complex Conditional,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,ScopesMatch,The conditional expression  "(sLhs.StartsWith(sRhs) &&                       (sLhs.EndsWith(".dll") || sLhs.EndsWith(".exe"))                  ) ||                   (sRhs.StartsWith(sLhs) &&                       (sRhs.EndsWith(".dll") || sRhs.EndsWith(".exe"))                  )"  is complex.
Complex Conditional,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,TypesAreTriviallyEqual,The conditional expression  "(                      (lhs.GetType() == tTr) ||                      (lhs.GetType() == tTd)                  ) && (                      (rhs.GetType() == tTr) ||                      (rhs.GetType() == tTd)                  )"  is complex.
Complex Conditional,JSIL.Ast,JSCastExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,NewInternal,The conditional expression  "(originalInnerType is ByReferenceType) &&                          TypeUtil.IsNumeric(innerType) &&                          (newType is PointerType) &&                          TypeUtil.IsNumeric(TypeUtil.GetElementType(newType' true))"  is complex.
Complex Conditional,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,EmitThisForParameter,The conditional expression  "tr != null                  && (CurrentMethod == null                  || (CurrentMethod.DeclaringType.GenericParameters != null                  && CurrentMethod.DeclaringType.GenericParameters.Any(p => p.Name == gp.Name)))"  is complex.
Complex Conditional,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The conditional expression  "(                          (signature.ReturnType == null) ||                          (signature.ReturnType.FullName == "System.Void")                      ) &&                      (signature.ParameterCount == 1) &&                      !TypeUtil.IsOpenType(signature.ParameterTypes[0])"  is complex.
Complex Conditional,JSIL.Internal,TypeInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,The conditional expression  "!IsInterface &&                  !IsDelegate &&                  !Definition.IsEnum &&                   !Definition.IsAbstract &&                   !Definition.IsPrimitive"  is complex.
Complex Conditional,JSIL.Internal,TypeInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,BeforeAddProxyMember,The conditional expression  "(proxy.MemberPolicy == JSProxyMemberPolicy.ReplaceNone) ||                      member.CustomAttributes.Any(ShouldNeverReplace) ||                      ((owningMember != null) && (owningMember.CustomAttributes.Any(ShouldNeverReplace)))"  is complex.
Complex Conditional,JSIL.Transforms,HoistAllocations,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,VisitNode,The conditional expression  "isInsideLoop &&                  (parentPassByRef != null) &&                  (parentInvocation != null) &&                  !doesValueEscape"  is complex.
Complex Conditional,JSIL.Transforms,HoistAllocations,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,VisitNode,The conditional expression  "isStruct &&                   isInsideLoop &&                   (parentInvocation != null) &&                  !doesValueEscape"  is complex.
Complex Conditional,JSIL.Transforms,HoistAllocations,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,CreateHoistedVariable,The conditional expression  "(array == null) ||                  (index == null) ||                  index.AllChildrenRecursive.Any(filter) ||                   array.AllChildrenRecursive.Any(filter)"  is complex.
Complex Conditional,JSIL.Transforms,UnsafeCodeTransforms,C:\repos\sq_JSIL\JSIL\Transforms\UnsafeCodeTransforms.cs,VisitNode,The conditional expression  "(ParentNode is JSInvocationExpression) &&                  (invocation != null) &&                  (invocation.JSMethod != null) &&                  invocation.JSMethod.Reference.FullName.Contains("JSIL.Runtime.IPackedArray") &&                  invocation.JSMethod.Reference.FullName.Contains("get_Item(") &&                  Configuration.CodeGenerator.AggressivelyUseElementProxies.GetValueOrDefault(false)"  is complex.
Complex Conditional,JSIL.Transforms,UnsafeCodeTransforms,C:\repos\sq_JSIL\JSIL\Transforms\UnsafeCodeTransforms.cs,VisitNode,The conditional expression  "TypeUtil.IsPointer(leftType) &&                   TypeUtil.IsPointer(rightType) &&                  (boe.Operator is JSAssignmentOperator) &&                  ((leftVar = boe.Left as JSVariable) != null) &&                  ((rightAdd = boe.Right as JSPointerAddExpression) != null) &&                  rightAdd.Pointer.Equals(leftVar) &&                  !rightAdd.MutateInPlace"  is complex.
Complex Conditional,JSIL.Transforms,HandleBooleanAsInteger,C:\repos\sq_JSIL\JSIL\Transforms\HandleBooleanAsInteger.cs,VisitNode,The conditional expression  "(leftIsBool != rightIsBool) &&                   (leftIsNumeric || rightIsNumeric) &&                  !(boe.Operator is JSAssignmentOperator)"  is complex.
Complex Conditional,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The conditional expression  "(lastEs != null) &&                  (                      (lastEs.Expression is JSGotoExpression) ||                      (lastEs.Expression is JSBreakExpression) ||                      (lastEs.Expression is JSContinueExpression)                  )"  is complex.
Complex Conditional,JSIL.Transforms,ExpandCastExpressions,C:\repos\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,The conditional expression  "TypeUtil.TypesAreAssignable(TypeInfo' targetType' innerType) &&                      (                          (TypeUtil.IsFloatingPoint(targetType) == TypeUtil.IsFloatingPoint(currentType)) &&                          (TypeUtil.IsFloatingPoint(targetType) == TypeUtil.IsFloatingPoint(innerType))                      ) &&                      (TypeUtil.IsSigned(targetType) == TypeUtil.IsSigned(innerType)) &&                      (TypeUtil.SizeOfType(targetType) <= TypeUtil.SizeOfType(currentType)) &&                      (TypeUtil.SizeOfType(targetType) >= TypeUtil.SizeOfType(innerType))"  is complex.
Complex Conditional,JSIL.Transforms,IntroduceCharCasts,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,The conditional expression  "isArithmetic &&                   (boe.GetActualType(TypeSystem).FullName == "System.Char") &&                  !(                      (parentInvocation != null) &&                       (parentInvocationDot != null) &&                      (parentInvocationDot.Target is JSStringIdentifier) &&                      (((JSStringIdentifier)parentInvocationDot.Target).Identifier == "String") &&                      (parentInvocationDot.Member is JSFakeMethod) &&                      (((JSFakeMethod)parentInvocationDot.Member).Name == "fromCharCode")                  )"  is complex.
Complex Conditional,JSIL.Transforms,DeoptimizeSwitchStatements,C:\repos\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,The conditional expression  "(invocation != null) &&                  (invocation.Arguments.Count == 2) &&                  (invocation.JSMethod != null) &&                  (invocation.JSMethod.Identifier == "TryGetValue")"  is complex.
Complex Conditional,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The conditional expression  "(method.Reference.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers") &&                      (method.Method.Name == "InitializeArray") &&                      (method.Method.Parameters.Length == 2) &&                      (method.Method.Parameters[0].ParameterType.FullName == "System.Array") &&                      (method.Method.Parameters[1].ParameterType.FullName == "System.RuntimeFieldHandle")"  is complex.
Complex Conditional,JSIL.Transforms,IntroduceEnumCasts,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceEnumCasts.cs,VisitNode,The conditional expression  "resultIsEnum &&                       ((parentCast == null) || (parentCast.NewType != resultType)) &&                       ((parentReinterpret == null) || (parentReinterpret.NewType != resultType))"  is complex.
Complex Conditional,JSIL.Transforms,OptimizeArrayEnumerators,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The conditional expression  "(condInvocation != null) &&                   (condInvocation.JSMethod != null) &&                  (condInvocation.JSMethod.Identifier == "MoveNext") &&                  (condInvocation.JSMethod.Method.DeclaringType.Interfaces.ToEnumerable().Any((ii) => ii.Info.FullName == "System.Collections.IEnumerator")) &&                  ((enumeratorVariable = condInvocation.ThisReference as JSVariable) != null)"  is complex.
Complex Conditional,JSIL.Transforms,PropertyAccessReplacer,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The conditional expression  "(jsm != null) &&                   (jsm.Method.Property == Property.Property) &&                   (ie.ThisReference.Equals(ThisReference)) &&                  (ie.Arguments.Count == 0)"  is complex.
Complex Conditional,JSIL.Transforms,FunctionAnalysis2ndPass,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FunctionAnalysis2ndPass,The conditional expression  "(                      !data.Function.Method.Method.IsStatic &&                       data.Function.Method.Method.DeclaringType.IsImmutable &&                      data.ReassignsThisReference                  ) ||                  data.Function.Method.Method.Name == ".ctor""  is complex.
Complex Conditional,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The conditional expression  "(ie != null) && ie.ConstantIfArgumentsAre &&                      IsEffectivelyConstant(target' ie.ThisReference) &&                      ie.Arguments.All((a) => IsEffectivelyConstant(target' a))"  is complex.
Complex Conditional,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The conditional expression  "(sourceFirstAssigned.StatementIndex >= assignment) &&                          (sourceLastAssigned.StatementIndex < nextAssignment) &&                          (sourceFirstAccessed.StatementIndex >= assignment) &&                          (sourceLastAccessed.StatementIndex <= nextAssignment)"  is complex.
Complex Conditional,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The conditional expression  "(accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference"  is complex.
Complex Conditional,JSIL.Transforms,SimplifyOperators,C:\repos\sq_JSIL\JSIL\Transforms\SimplifyOperators.cs,VisitNode,The conditional expression  "isAssignment && (nestedBoe != null) &&                   (left.IsConstant || (leftVar != null) || left is JSDotExpressionBase) &&                  !(ParentNode is JSVariableDeclarationStatement)"  is complex.
Complex Conditional,JSIL.Transforms,SimplifyOperators,C:\repos\sq_JSIL\JSIL\Transforms\SimplifyOperators.cs,VisitNode,The conditional expression  "areEqual &&                      PrefixOperators.TryGetValue(nestedBoe.Operator' out prefixOperator) &&                      (rightLiteral != null) && (rightLiteral.Value == 1)"  is complex.
Complex Conditional,JSIL.Transforms,VariableReferenceAccessTransformer,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,VisitNode,The conditional expression  "(variable.Identifier != Variable.Identifier) ||                  // Don't transform if we're inside a read-through already                  (ParentNode is JSReadThroughReferenceExpression) ||                  (                      // If we're inside a write-through and on the LHS' don't transform                      (ParentNode is JSWriteThroughReferenceExpression) &&                      (this.CurrentName == "Left")                  )"  is complex.
Complex Conditional,JSIL.Transforms,VariableReferenceAccessTransformer,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,VisitNode,The conditional expression  "!(ParentNode is JSVariableDeclarationStatement) &&                  (leftVar != null) &&                   (leftVar.Identifier == Variable.Identifier) &&                  (boe.Operator is JSAssignmentOperator)"  is complex.
Complex Conditional,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,The conditional expression  "(value is JSLiteral) ||                  (value is JSNewExpression) ||                  (value is JSPassByReferenceExpression) ||                  (value is JSNewBoxedVariable) ||                  (value is JSDefaultValueLiteral) ||                  (value is JSFieldOfExpression)"  is complex.
Complex Conditional,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,The conditional expression  "ReferenceCounts.TryGetValue(rightVar.Identifier' out referenceCount) &&                      (referenceCount == 1) &&                       !rightVar.IsReference &&                       rightVar.IsParameter &&                      !SecondPass.VariableAliases.ContainsKey(rightVar.Identifier)"  is complex.
Complex Conditional,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The conditional expression  "(                          rightVarsMutated ||                           leftVarMutated ||                          IsCopyNeededForAssignmentTarget(boe.Left) ||                           rightVarsAreReferences                      ) &&                      !IsCopyAlwaysUnnecessaryForAssignmentTarget(boe.Left) &&                      !rightVarIsEffectivelyConstantHere"  is complex.
Complex Conditional,JSIL.Transforms,EmulateStructAssignment,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The conditional expression  "!nbv.SuppressClone &&                  IsCopyNeeded(nbv.InitialValue' out relevantParameter) &&                  // We don't need to make a copy if the source value is a reference (like T& this)                  !((initialValueType) != null && initialValueType.IsByReference)"  is complex.
Virtual Method Call from Constructor,JSIL.Ast,JSBinaryOperatorExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSBinaryOperatorExpression,The constructor "JSBinaryOperatorExpression" calls a virtual method "CheckInvariant".
Virtual Method Call from Constructor,JSIL.Ast,JSBinaryOperatorExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSBinaryOperatorExpression,The constructor "JSBinaryOperatorExpression" calls a virtual method "CheckInvariant".
Empty Catch Block,JSIL.Internal,ConstructionState,C:\repos\sq_JSIL\JSIL\Util.cs,Set,The method has an empty catch block.
Magic Number,JSIL,FunctionCache,C:\repos\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: Cache = new ConcurrentCache<QualifiedMemberIdentifier' Entry>(                  Environment.ProcessorCount' 4096' Comparer              );
Magic Number,JSIL,FunctionCache,C:\repos\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: PendingTransformsQueue = new ConcurrentHashQueue<QualifiedMemberIdentifier>(                  Math.Max(1' Environment.ProcessorCount / 4)' 4096' Comparer              );
Magic Number,JSIL,FunctionCache,C:\repos\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: PendingTransformsQueue = new ConcurrentHashQueue<QualifiedMemberIdentifier>(                  Math.Max(1' Environment.ProcessorCount / 4)' 4096' Comparer              );
Magic Number,JSIL,FunctionCache,C:\repos\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: ActiveTransformPipelines = new ConcurrentDictionary<QualifiedMemberIdentifier' FunctionTransformPipeline>(                  Math.Max(1' Environment.ProcessorCount / 4)' 128' Comparer              );
Magic Number,JSIL,FunctionCache,C:\repos\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: ActiveTransformPipelines = new ConcurrentDictionary<QualifiedMemberIdentifier' FunctionTransformPipeline>(                  Math.Max(1' Environment.ProcessorCount / 4)' 128' Comparer              );
Magic Number,JSIL,FunctionCache,C:\repos\sq_JSIL\JSIL\FunctionCache.cs,TryAcquireStaticAnalysisDataLock,The following statement contains a magic number: const int lockTimeoutMs = 33;
Magic Number,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationPrefixForType,The following statement contains a magic number: switch (type.FullName) {                  case "System.Byte":                      parenCount = 1;                      break;                    case "System.SByte":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt16":                      parenCount = 1;                      break;                    case "System.Int16":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt32":                      parenCount = 1;                      break;                    case "System.Int32":                      parenCount = 1;                      break;                    case "System.Single":                      // fround only affects locals at present.                      // FIXME: Does this mean a forced float->double upconvert when it could be omitted by the VM?                      if (isLoad)                          Output.WriteRaw("+");                      else if (targetIsLocal)                          Output.WriteRaw("Math.fround(");                      else                          Output.WriteRaw("+(");                        return;                    case "System.Double":                      if (isLoad)                          Output.WriteRaw("+");                      else                          Output.WriteRaw("+(");                      return;              }
Magic Number,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationPrefixForType,The following statement contains a magic number: switch (type.FullName) {                  case "System.Byte":                      parenCount = 1;                      break;                    case "System.SByte":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt16":                      parenCount = 1;                      break;                    case "System.Int16":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt32":                      parenCount = 1;                      break;                    case "System.Int32":                      parenCount = 1;                      break;                    case "System.Single":                      // fround only affects locals at present.                      // FIXME: Does this mean a forced float->double upconvert when it could be omitted by the VM?                      if (isLoad)                          Output.WriteRaw("+");                      else if (targetIsLocal)                          Output.WriteRaw("Math.fround(");                      else                          Output.WriteRaw("+(");                        return;                    case "System.Double":                      if (isLoad)                          Output.WriteRaw("+");                      else                          Output.WriteRaw("+(");                      return;              }
Magic Number,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,ArgumentsNeedLineBreak,The following statement contains a magic number: return ((arguments.Count > 1) &&                  (                      (CountOfMatchingSubtrees<JSFunctionExpression>(arguments) > 1) ||                      (CountOfMatchingSubtrees<JSInvocationExpression>(arguments) > 1) ||                      (CountOfMatchingSubtrees<JSDelegateInvocationExpression>(arguments) > 1)                  )) ||                  (arguments.Count > 4);
Magic Number,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,CanUseFastOverloadDispatch,The following statement contains a magic number: if (method.DeclaringType.MethodSignatures.TryGet(method.NamedSignature.Name' out mss)) {                  int overloadCount = 0;                    var gaCount = method.GenericParameterNames.Length;                  int argCount = method.Parameters.Length;                    foreach (var signature in mss) {                      if (                          (signature.ParameterCount == argCount)                      )                          overloadCount += 1;                      else if ((signature.GenericParameterNames.Length > 0) || (gaCount > 0)) {                          if (                              (signature.ParameterCount == gaCount) ||                              (signature.GenericParameterNames.Length == argCount) ||                              (signature.GenericParameterNames.Length == gaCount)                          ) {                              overloadCount += 1;                          }                      }                        // If there's only one overload with this argument count' we don't need to use                      //  the expensive overloaded method dispatch path.                        if (overloadCount >= 2)                          return false;                  }                    return true;              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILBuiltinsMethodReplacement,The following statement contains a magic number: switch (methodName) {                  case "CreateNamedFunction`1": {                      JSExpression closureArg = null;                      if (arguments.Length > 3)                          closureArg = arguments[3];                        return JSIL.CreateNamedFunction(                          genericArguments.First()' arguments[0]' arguments[1]' arguments[2]' closureArg                      );                  }                    case "Eval":                      return JSInvocationExpression.InvokeStatic(                          JS.eval' arguments                      );                    case "IsTruthy":                      return new JSUnaryOperatorExpression(                          JSOperator.LogicalNot'                           new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean)'                           TypeSystem.Boolean                      );                    case "IsFalsy":                      return new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean);                    case "get_This":                      return MakeIndirectVariable("this");                    case "get_IsJavascript":                      return new JSBooleanLiteral(true);              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILBuiltinsMethodReplacement,The following statement contains a magic number: switch (methodName) {                  case "CreateNamedFunction`1": {                      JSExpression closureArg = null;                      if (arguments.Length > 3)                          closureArg = arguments[3];                        return JSIL.CreateNamedFunction(                          genericArguments.First()' arguments[0]' arguments[1]' arguments[2]' closureArg                      );                  }                    case "Eval":                      return JSInvocationExpression.InvokeStatic(                          JS.eval' arguments                      );                    case "IsTruthy":                      return new JSUnaryOperatorExpression(                          JSOperator.LogicalNot'                           new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean)'                           TypeSystem.Boolean                      );                    case "IsFalsy":                      return new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean);                    case "get_This":                      return MakeIndirectVariable("this");                    case "get_IsJavascript":                      return new JSBooleanLiteral(true);              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILBuiltinsMethodReplacement,The following statement contains a magic number: switch (methodName) {                  case "CreateNamedFunction`1": {                      JSExpression closureArg = null;                      if (arguments.Length > 3)                          closureArg = arguments[3];                        return JSIL.CreateNamedFunction(                          genericArguments.First()' arguments[0]' arguments[1]' arguments[2]' closureArg                      );                  }                    case "Eval":                      return JSInvocationExpression.InvokeStatic(                          JS.eval' arguments                      );                    case "IsTruthy":                      return new JSUnaryOperatorExpression(                          JSOperator.LogicalNot'                           new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean)'                           TypeSystem.Boolean                      );                    case "IsFalsy":                      return new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean);                    case "get_This":                      return MakeIndirectVariable("this");                    case "get_IsJavascript":                      return new JSBooleanLiteral(true);              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The following statement contains a magic number: switch (typeName) {                  case "JSIL.Builtins":                      return DoJSILBuiltinsMethodReplacement(methodName' genericArguments' arguments' method == null);                    case "JSIL.Verbatim": {                      if (                          (methodName == "Expression") || methodName.StartsWith("Expression`")                      ) {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSIL.Verbatim.Expression must recieve a string literal as an argument");                            JSExpression commaFirstClause = null;                          IDictionary<string' JSExpression> argumentsDict = null;                            if (arguments.Length > 1) {                              var argumentsExpression = arguments[1];                              var argumentsArray = argumentsExpression as JSNewArrayExpression;                                if (method == null || method.Method.Parameters[1].ParameterType is GenericParameter) {                                  // This call was made dynamically or through generic version of method' so the parameters are not an array.                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < (arguments.Length - 1); i++)                                      argumentsDict.Add(String.Format("{0}"' i)' arguments[i + 1]);                              } else if (argumentsArray == null) {                                  // The array is static so we need to pull elements out of it after assigning it a name.                                  // FIXME: Only handles up to 40 elements.                                  var argumentsExpressionType = argumentsExpression.GetActualType(TypeSystem);                                  var temporaryVariable = MakeTemporaryVariable(argumentsExpressionType);                                  var temporaryAssignment = new JSBinaryOperatorExpression(JSOperator.Assignment' temporaryVariable' argumentsExpression' argumentsExpressionType);                                    commaFirstClause = temporaryAssignment;                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < 40; i++)                                      argumentsDict.Add(String.Format("{0}"' i)' new JSIndexerExpression(temporaryVariable' JSLiteral.New(i)));                              } else {                                  var argumentsArrayExpression = argumentsArray.SizeOrArrayInitializer as JSArrayExpression;                                    if (argumentsArrayExpression == null)                                      throw new NotImplementedException("Literal array must have values");                                    argumentsDict = new Dictionary<string' JSExpression>();                                    int i = 0;                                  foreach (var value in argumentsArrayExpression.Values) {                                      argumentsDict.Add(String.Format("{0}"' i)' value);                                        i += 1;                                  }                              }                          }                            var verbatimLiteral = new JSVerbatimLiteral(                              methodName' expression.Value' argumentsDict                          );                            if (commaFirstClause != null)                              return new JSCommaExpression(commaFirstClause' verbatimLiteral);                          else                              return verbatimLiteral;                      } else {                          throw new NotImplementedException("Verbatim method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSGlobal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression != null)                              return new JSDotExpression(                                  JSIL.GlobalNamespace' new JSStringIdentifier(expression.Value' TypeSystem.Object' true)                              );                          else                              return new JSIndexerExpression(                                  JSIL.GlobalNamespace' arguments[0]' TypeSystem.Object                              );                      } else {                          throw new NotImplementedException("JSGlobal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSLocal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSLocal must recieve a string literal as an index");                            return new JSStringIdentifier(expression.Value' TypeSystem.Object' true);                      } else {                          throw new NotImplementedException("JSLocal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.Services": {                      if (methodName == "Get") {                          if (arguments.Length != 2)                              throw new InvalidOperationException("JSIL.Services.Get must receive two arguments");                            var serviceName = arguments[0];                          var shouldThrow = arguments[1];                            return JSInvocationExpression.InvokeStatic(                              new JSRawOutputIdentifier(TypeSystem.Object' "JSIL.Host.getService")'                              new[] {                                  serviceName'                                  new JSUnaryOperatorExpression(JSOperator.LogicalNot' shouldThrow' TypeSystem.Boolean)                              }' true                          );                      } else {                          throw new NotImplementedException("JSIL.Services method not implemented: " + methodName);                      }                      break;                  }              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The following statement contains a magic number: switch (typeName) {                  case "JSIL.Builtins":                      return DoJSILBuiltinsMethodReplacement(methodName' genericArguments' arguments' method == null);                    case "JSIL.Verbatim": {                      if (                          (methodName == "Expression") || methodName.StartsWith("Expression`")                      ) {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSIL.Verbatim.Expression must recieve a string literal as an argument");                            JSExpression commaFirstClause = null;                          IDictionary<string' JSExpression> argumentsDict = null;                            if (arguments.Length > 1) {                              var argumentsExpression = arguments[1];                              var argumentsArray = argumentsExpression as JSNewArrayExpression;                                if (method == null || method.Method.Parameters[1].ParameterType is GenericParameter) {                                  // This call was made dynamically or through generic version of method' so the parameters are not an array.                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < (arguments.Length - 1); i++)                                      argumentsDict.Add(String.Format("{0}"' i)' arguments[i + 1]);                              } else if (argumentsArray == null) {                                  // The array is static so we need to pull elements out of it after assigning it a name.                                  // FIXME: Only handles up to 40 elements.                                  var argumentsExpressionType = argumentsExpression.GetActualType(TypeSystem);                                  var temporaryVariable = MakeTemporaryVariable(argumentsExpressionType);                                  var temporaryAssignment = new JSBinaryOperatorExpression(JSOperator.Assignment' temporaryVariable' argumentsExpression' argumentsExpressionType);                                    commaFirstClause = temporaryAssignment;                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < 40; i++)                                      argumentsDict.Add(String.Format("{0}"' i)' new JSIndexerExpression(temporaryVariable' JSLiteral.New(i)));                              } else {                                  var argumentsArrayExpression = argumentsArray.SizeOrArrayInitializer as JSArrayExpression;                                    if (argumentsArrayExpression == null)                                      throw new NotImplementedException("Literal array must have values");                                    argumentsDict = new Dictionary<string' JSExpression>();                                    int i = 0;                                  foreach (var value in argumentsArrayExpression.Values) {                                      argumentsDict.Add(String.Format("{0}"' i)' value);                                        i += 1;                                  }                              }                          }                            var verbatimLiteral = new JSVerbatimLiteral(                              methodName' expression.Value' argumentsDict                          );                            if (commaFirstClause != null)                              return new JSCommaExpression(commaFirstClause' verbatimLiteral);                          else                              return verbatimLiteral;                      } else {                          throw new NotImplementedException("Verbatim method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSGlobal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression != null)                              return new JSDotExpression(                                  JSIL.GlobalNamespace' new JSStringIdentifier(expression.Value' TypeSystem.Object' true)                              );                          else                              return new JSIndexerExpression(                                  JSIL.GlobalNamespace' arguments[0]' TypeSystem.Object                              );                      } else {                          throw new NotImplementedException("JSGlobal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSLocal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSLocal must recieve a string literal as an index");                            return new JSStringIdentifier(expression.Value' TypeSystem.Object' true);                      } else {                          throw new NotImplementedException("JSLocal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.Services": {                      if (methodName == "Get") {                          if (arguments.Length != 2)                              throw new InvalidOperationException("JSIL.Services.Get must receive two arguments");                            var serviceName = arguments[0];                          var shouldThrow = arguments[1];                            return JSInvocationExpression.InvokeStatic(                              new JSRawOutputIdentifier(TypeSystem.Object' "JSIL.Host.getService")'                              new[] {                                  serviceName'                                  new JSUnaryOperatorExpression(JSOperator.LogicalNot' shouldThrow' TypeSystem.Boolean)                              }' true                          );                      } else {                          throw new NotImplementedException("JSIL.Services method not implemented: " + methodName);                      }                      break;                  }              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_TernaryOp,The following statement contains a magic number: var right = node.Arguments[2];
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DetermineOutputTypeForMultiply,The following statement contains a magic number: if (TypeUtil.IsSigned(leftType) != TypeUtil.IsSigned(rightType)) {                  // Promote up to Int64 if signs don't match' just in case.                  return TypeSystem.Int64;              } else if (TypeUtil.SizeOfType(largerType) < 4) {                  // Muls are always at least int32.                  if (TypeUtil.IsSigned(largerType).Value) {                      return TypeSystem.Int32;                  } else {                      return TypeSystem.UInt32;                  }              } else {                  // Otherwise' return the largest type.                  return largerType;              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Stelem,The following statement contains a magic number: var rhs = TranslateNode(node.Arguments[2]);
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Newobj,The following statement contains a magic number: if (TypeUtil.IsDelegateType(constructor.DeclaringType)) {                  return Translate_Newobj_Delegate(node' constructor' arguments.ToArray());              } else if (constructor.DeclaringType.IsArray)              {                  var arrayType = (ArrayType) constructor.DeclaringType;                  if (!arrayType.IsVector)                  {                      JSExpression[] dimensions;                      if (arguments.Count == arrayType.Rank)                      {                          dimensions = new JSExpression[arrayType.Rank*2];                          for (int i = 0; i < arrayType.Rank; i++)                          {                              dimensions[2*i] = new JSIntegerLiteral(0' typeof (int));                              dimensions[2*i + 1] = arguments[i];                          }                      }                      else                      {                          dimensions = arguments.ToArray();                      }                      return JSIL.NewMultidimensionalArray(TypeUtil.GetElementType(constructor.DeclaringType' true)'                          dimensions);                  }                  else                  {                      return JSIL.NewArray(TypeUtil.GetElementType(constructor.DeclaringType' true)' arguments[0]);                  }              } else if (TypeUtil.IsNullable(constructor.DeclaringType)) {                  if (arguments.Count == 0)                      return new JSNullLiteral(constructor.DeclaringType);                  else                      return arguments[0];              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Newobj,The following statement contains a magic number: if (TypeUtil.IsDelegateType(constructor.DeclaringType)) {                  return Translate_Newobj_Delegate(node' constructor' arguments.ToArray());              } else if (constructor.DeclaringType.IsArray)              {                  var arrayType = (ArrayType) constructor.DeclaringType;                  if (!arrayType.IsVector)                  {                      JSExpression[] dimensions;                      if (arguments.Count == arrayType.Rank)                      {                          dimensions = new JSExpression[arrayType.Rank*2];                          for (int i = 0; i < arrayType.Rank; i++)                          {                              dimensions[2*i] = new JSIntegerLiteral(0' typeof (int));                              dimensions[2*i + 1] = arguments[i];                          }                      }                      else                      {                          dimensions = arguments.ToArray();                      }                      return JSIL.NewMultidimensionalArray(TypeUtil.GetElementType(constructor.DeclaringType' true)'                          dimensions);                  }                  else                  {                      return JSIL.NewArray(TypeUtil.GetElementType(constructor.DeclaringType' true)' arguments[0]);                  }              } else if (TypeUtil.IsNullable(constructor.DeclaringType)) {                  if (arguments.Count == 0)                      return new JSNullLiteral(constructor.DeclaringType);                  else                      return arguments[0];              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Newobj,The following statement contains a magic number: if (TypeUtil.IsDelegateType(constructor.DeclaringType)) {                  return Translate_Newobj_Delegate(node' constructor' arguments.ToArray());              } else if (constructor.DeclaringType.IsArray)              {                  var arrayType = (ArrayType) constructor.DeclaringType;                  if (!arrayType.IsVector)                  {                      JSExpression[] dimensions;                      if (arguments.Count == arrayType.Rank)                      {                          dimensions = new JSExpression[arrayType.Rank*2];                          for (int i = 0; i < arrayType.Rank; i++)                          {                              dimensions[2*i] = new JSIntegerLiteral(0' typeof (int));                              dimensions[2*i + 1] = arguments[i];                          }                      }                      else                      {                          dimensions = arguments.ToArray();                      }                      return JSIL.NewMultidimensionalArray(TypeUtil.GetElementType(constructor.DeclaringType' true)'                          dimensions);                  }                  else                  {                      return JSIL.NewArray(TypeUtil.GetElementType(constructor.DeclaringType' true)' arguments[0]);                  }              } else if (TypeUtil.IsNullable(constructor.DeclaringType)) {                  if (arguments.Count == 0)                      return new JSNullLiteral(constructor.DeclaringType);                  else                      return arguments[0];              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_InitArray,The following statement contains a magic number: if (TypeUtil.TypesAreEqual(TypeSystem.Object' at) && rank < 2)                  return initializer;              else {                  if (!isVector) {                      return JSIL.NewMultidimensionalArray(                          at.ElementType' TypeUtil.GetArrayDimensions(at)' initializer                      );                  } else {                      return JSIL.NewArray(                          at.ElementType' initializer                      );                  }              }
Magic Number,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,NeedsExplicitThis,The following statement contains a magic number: if (methodInfo.IsVirtual) {                  if (sameThisReference)                      return false;                  else                      return true;              } else {                  if (sameThisReference && !isSelf)                      return false;                    // If the method was defined in a generic class' overloaded dispatch won't be sufficient                  //  because of generic parameters.                  if (!declaringTypeDef.IsGenericInstance && !declaringTypeDef.HasGenericParameters) {                      var definitionCount = declaringTypeInfo.MethodSignatures.GetDefinitionCountOf(methodInfo);                        if (definitionCount < 2)                          return false;                  }                    return true;              }
Magic Number,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,AssemblyTranslator,The following statement contains a magic number: if (typeInfoProvider != null) {                  TypeInfoProvider = typeInfoProvider;                  OwnsTypeInfoProvider = false;                    if (configuration.Assemblies.Proxies.Count > 0)                      throw new InvalidOperationException("Cannot reuse an existing type provider if explicitly loading proxies");              } else {                  TypeInfoProvider = new JSIL.TypeInfoProvider();                  OwnsTypeInfoProvider = true;                    if (useDefaultProxies) {                      var defaultProxyAssembly =                          GetDefaultProxyAssembly(configuration.FrameworkVersion.GetValueOrDefault(4.0));                        if (defaultProxyAssembly == null)                          throw new InvalidOperationException("No default proxy assembly was loaded.");                        AddProxyAssembly(defaultProxyAssembly);                      }                                  foreach (var fn in configuration.Assemblies.Proxies.Distinct())                      AddProxyAssembly(fn);              }
Magic Number,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,GetDefaultProxyAssembly,The following statement contains a magic number: try {                  if (frameworkVersion == 4.0) {                      proxyPath = Path.Combine(proxyFolder' "JSIL.Proxies.4.0.dll");                  } else {                      throw new ArgumentOutOfRangeException(                          "frameworkVersion"'                          String.Format("Framework version '{0}' not supported"' frameworkVersion)                      );                  }                    return Assembly.LoadFile(proxyPath);              } catch (FileNotFoundException fnf) {                  throw new FileNotFoundException(                      String.Format("Could not load the .NET proxies assembly from '{0}'."' proxyPath)'                      fnf                  );              }
Magic Number,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,GetParallelOptions,The following statement contains a magic number: return new ParallelOptions {                  MaxDegreeOfParallelism = Configuration.UseThreads.GetValueOrDefault(false)                       ? (Environment.ProcessorCount + 2)                       : 1              };
Magic Number,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,The following statement contains a magic number: for (int i = 0; i < assemblies.Length; i++) {                  pr.OnProgressChanged(i' assemblies.Length * 2);                  GetMethodsToAnalyze(assemblies[i]' methodsToAnalyze);              }
Magic Number,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,TriggerAutomaticGC,The following statement contains a magic number: if (Configuration.TuneGarbageCollection.GetValueOrDefault(true))  #if TARGETTING_FX_4_5                  GC.Collect(2' GCCollectionMode.Optimized' false);  #else                  GC.Collect(2' GCCollectionMode.Optimized);
Magic Number,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,AnalyzeFunctions,The following statement contains a magic number: Func<int' ParallelLoopState' DecompilerContext' DecompilerContext> analyzeAMethod = (_' loopState' ctx) => {                  MethodToAnalyze m;                  if (!methodsToAnalyze.TryTake(out m))                      throw new InvalidDataException("Method collection mutated during analysis. Try setting UseThreads=false (and report an issue!)");                    ctx.CurrentModule = m.MD.Module;                  ctx.CurrentType = m.MD.DeclaringType;                  ctx.CurrentMethod = m.MD;                    try {                      TranslateMethodExpression(ctx' m.MD' m.MD' m.MI);                  } catch (Exception exc) {                      throw new Exception("Error occurred while translating method '" + m.MD.FullName + "'."' exc);                  }                    var j = Interlocked.Increment(ref i);                  pr.OnProgressChanged(mc + j' mc * 2);                    return ctx;              };
Magic Number,JSIL,AssemblyTranslator,C:\repos\sq_JSIL\JSIL\AssemblyTranslator.cs,RunTransformsOnAllFunctions,The following statement contains a magic number: const int autoGcInterval = 256;
Magic Number,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: if (IsNativeInteger(type))                  return 4;
Magic Number,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: var levelOfParallelism = Math.Max(1' Environment.ProcessorCount / 2);
Magic Number,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: ProxiesByName = new ConcurrentCache<HashedString' ProxiesByNameRecord>(                  levelOfParallelism' 256' new HashedStringComparer()              );
Magic Number,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: TypeAssignabilityCache = new ConcurrentCache<Tuple<string' string>' bool>(levelOfParallelism' 4096);
Magic Number,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: TypeInformation = new ConcurrentCache<TypeIdentifier' TypeInfo>(levelOfParallelism' 4096' TypeIdentifier.Comparer);
Magic Number,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: ModuleInformation = new ConcurrentCache<string' ModuleInfo>(levelOfParallelism' 256' StringComparer.Ordinal);
Magic Number,JSIL.Ast.Enumerators,JSNodeChildEnumerator,C:\repos\sq_JSIL\JSIL\AST\Enumerators.cs,JSNodeChildEnumerator,The following statement contains a magic number: _Index = IncludeSelf ? -2 : -1;
Magic Number,JSIL.Ast.Enumerators,JSNodeChildEnumerator,C:\repos\sq_JSIL\JSIL\AST\Enumerators.cs,Reset,The following statement contains a magic number: _Index = IncludeSelf ? -2 : -1;
Magic Number,JSIL.Ast,JSBinaryOperatorExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,New,The following statement contains a magic number: if (values.Count < 2)                  throw new ArgumentException();
Magic Number,JSIL.Ast,JSBinaryOperatorExpression,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,New,The following statement contains a magic number: for (int i = 2' c = values.Count; i < c; i++) {                  var next = new JSBinaryOperatorExpression(op' current.Right' values[i]' expectedType);                  current.Right = next;                  current = next;              }
Magic Number,JSIL.Ast,JSPointerExpressionUtil,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetNativeSizeOfElement,The following statement contains a magic number: switch (elementType.FullName) {                  case "System.Byte":                  case "System.SByte":                      return 1;                    case "System.Int16":                  case "System.UInt16":                      return 2;                    case "System.Int32":                  case "System.UInt32":                  case "System.Single":                      return 4;                    case "System.Int64":                  case "System.UInt64":                  case "System.Double":                      return 8;              }
Magic Number,JSIL.Ast,JSPointerExpressionUtil,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetNativeSizeOfElement,The following statement contains a magic number: switch (elementType.FullName) {                  case "System.Byte":                  case "System.SByte":                      return 1;                    case "System.Int16":                  case "System.UInt16":                      return 2;                    case "System.Int32":                  case "System.UInt32":                  case "System.Single":                      return 4;                    case "System.Int64":                  case "System.UInt64":                  case "System.Double":                      return 8;              }
Magic Number,JSIL.Ast,JSPointerExpressionUtil,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetNativeSizeOfElement,The following statement contains a magic number: switch (elementType.FullName) {                  case "System.Byte":                  case "System.SByte":                      return 1;                    case "System.Int16":                  case "System.UInt16":                      return 2;                    case "System.Int32":                  case "System.UInt32":                  case "System.Single":                      return 4;                    case "System.Int64":                  case "System.UInt64":                  case "System.Double":                      return 8;              }
Magic Number,JSIL.Internal,BugChecks,C:\repos\sq_JSIL\JSIL\BugChecks.cs,BrokenConcurrentDictionary,The following statement contains a magic number: var dict = new ConcurrentDictionary<MyKey' string>(1' 2);
Magic Number,JSIL.Internal,CachingMetadataResolver,C:\repos\sq_JSIL\JSIL\CILSupport.cs,CachingMetadataResolver,The following statement contains a magic number: Cache = new ConcurrentCache<Key' TypeDefinition>(                  Environment.ProcessorCount' 4096' new KeyComparer()              );
Magic Number,JSIL.Internal,FunctionTransformPipeline,C:\repos\sq_JSIL\JSIL\FunctionTransformPipeline.cs,RunUntilCompletion,The following statement contains a magic number: const int lockTimeoutMs = 250;
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,ClampByte,The following statement contains a magic number: if (value < 0)                  return 0;              else if (value > 255)                  return 255;              else                  return (byte)value;
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,ClampByte,The following statement contains a magic number: if (value < 0)                  return 0;              else if (value > 255)                  return 255;              else                  return (byte)value;
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: if ((value >= ValueMax) && (saturation <= SaturationMin))                  return FromRGB(255' 255' 255);
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: if ((value >= ValueMax) && (saturation <= SaturationMin))                  return FromRGB(255' 255' 255);
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: if ((value >= ValueMax) && (saturation <= SaturationMin))                  return FromRGB(255' 255' 255);
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: int range = value * 255 / ValueMax;
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: int rb = colorRange - b + (c * 2);
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: switch (segment) {                  case 0:                      return FromRGB(ClampByte(a)' ClampByte(b)' ClampByte(c));                  case 1:                      return FromRGB(ClampByte(rb)' ClampByte(a)' ClampByte(c));                  case 2:                      return FromRGB(ClampByte(c)' ClampByte(a)' ClampByte(b));                  case 3:                      return FromRGB(ClampByte(c)' ClampByte(rb)' ClampByte(a));                  case 4:                      return FromRGB(ClampByte(b)' ClampByte(c)' ClampByte(a));                  case 5:                      return FromRGB(ClampByte(a)' ClampByte(c)' ClampByte(rb));                  default:                      throw new ArgumentException("Invalid color");              }
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: switch (segment) {                  case 0:                      return FromRGB(ClampByte(a)' ClampByte(b)' ClampByte(c));                  case 1:                      return FromRGB(ClampByte(rb)' ClampByte(a)' ClampByte(c));                  case 2:                      return FromRGB(ClampByte(c)' ClampByte(a)' ClampByte(b));                  case 3:                      return FromRGB(ClampByte(c)' ClampByte(rb)' ClampByte(a));                  case 4:                      return FromRGB(ClampByte(b)' ClampByte(c)' ClampByte(a));                  case 5:                      return FromRGB(ClampByte(a)' ClampByte(c)' ClampByte(rb));                  default:                      throw new ArgumentException("Invalid color");              }
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: switch (segment) {                  case 0:                      return FromRGB(ClampByte(a)' ClampByte(b)' ClampByte(c));                  case 1:                      return FromRGB(ClampByte(rb)' ClampByte(a)' ClampByte(c));                  case 2:                      return FromRGB(ClampByte(c)' ClampByte(a)' ClampByte(b));                  case 3:                      return FromRGB(ClampByte(c)' ClampByte(rb)' ClampByte(a));                  case 4:                      return FromRGB(ClampByte(b)' ClampByte(c)' ClampByte(a));                  case 5:                      return FromRGB(ClampByte(a)' ClampByte(c)' ClampByte(rb));                  default:                      throw new ArgumentException("Invalid color");              }
Magic Number,JSIL.Internal,HTMLColor,C:\repos\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: switch (segment) {                  case 0:                      return FromRGB(ClampByte(a)' ClampByte(b)' ClampByte(c));                  case 1:                      return FromRGB(ClampByte(rb)' ClampByte(a)' ClampByte(c));                  case 2:                      return FromRGB(ClampByte(c)' ClampByte(a)' ClampByte(b));                  case 3:                      return FromRGB(ClampByte(c)' ClampByte(rb)' ClampByte(a));                  case 4:                      return FromRGB(ClampByte(b)' ClampByte(c)' ClampByte(a));                  case 5:                      return FromRGB(ClampByte(a)' ClampByte(c)' ClampByte(rb));                  default:                      throw new ArgumentException("Invalid color");              }
Magic Number,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,CommaSeparatedList,The following statement contains a magic number: CommaSeparatedListCore(                  values' (value) => {                      if (valueType == ListValueType.Primitive)                          Value(value as dynamic);                      else if (valueType == ListValueType.Identifier)                          Identifier(value as dynamic' context);                      else if (valueType == ListValueType.TypeIdentifier)                          TypeIdentifier(value as dynamic' context' false);                      else if (valueType == ListValueType.TypeReference)                          TypeReference((TypeReference)value' context);                      else                          WriteRaw(value.ToString());                  }'                    ((valueType == ListValueType.TypeIdentifier) || (valueType == ListValueType.TypeReference)) ?                      2 : 4              );
Magic Number,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,CommaSeparatedList,The following statement contains a magic number: CommaSeparatedListCore(                  values' (value) => {                      if (valueType == ListValueType.Primitive)                          Value(value as dynamic);                      else if (valueType == ListValueType.Identifier)                          Identifier(value as dynamic' context);                      else if (valueType == ListValueType.TypeIdentifier)                          TypeIdentifier(value as dynamic' context' false);                      else if (valueType == ListValueType.TypeReference)                          TypeReference((TypeReference)value' context);                      else                          WriteRaw(value.ToString());                  }'                    ((valueType == ListValueType.TypeIdentifier) || (valueType == ListValueType.TypeReference)) ?                      2 : 4              );
Magic Number,JSIL.Internal,MethodSignature,C:\repos\sq_JSIL\JSIL\MethodSignature.cs,GetHashCode,The following statement contains a magic number: hash ^= (GenericParameterCount) << 16;
Magic Number,JSIL.Internal,Mapping,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = GeneratedLine.GetHashCode();                      hashCode = (hashCode*397) ^ GeneratedColumn.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalLine.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalColumn.GetHashCode();                      hashCode = (hashCode*397) ^ (Source != null ? Source.GetHashCode() : 0);                      hashCode = (hashCode*397) ^ (Name != null ? Name.GetHashCode() : 0);                      return hashCode;                  }
Magic Number,JSIL.Internal,Mapping,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = GeneratedLine.GetHashCode();                      hashCode = (hashCode*397) ^ GeneratedColumn.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalLine.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalColumn.GetHashCode();                      hashCode = (hashCode*397) ^ (Source != null ? Source.GetHashCode() : 0);                      hashCode = (hashCode*397) ^ (Name != null ? Name.GetHashCode() : 0);                      return hashCode;                  }
Magic Number,JSIL.Internal,Mapping,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = GeneratedLine.GetHashCode();                      hashCode = (hashCode*397) ^ GeneratedColumn.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalLine.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalColumn.GetHashCode();                      hashCode = (hashCode*397) ^ (Source != null ? Source.GetHashCode() : 0);                      hashCode = (hashCode*397) ^ (Name != null ? Name.GetHashCode() : 0);                      return hashCode;                  }
Magic Number,JSIL.Internal,Mapping,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = GeneratedLine.GetHashCode();                      hashCode = (hashCode*397) ^ GeneratedColumn.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalLine.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalColumn.GetHashCode();                      hashCode = (hashCode*397) ^ (Source != null ? Source.GetHashCode() : 0);                      hashCode = (hashCode*397) ^ (Name != null ? Name.GetHashCode() : 0);                      return hashCode;                  }
Magic Number,JSIL.Internal,Mapping,C:\repos\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = GeneratedLine.GetHashCode();                      hashCode = (hashCode*397) ^ GeneratedColumn.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalLine.GetHashCode();                      hashCode = (hashCode*397) ^ OriginalColumn.GetHashCode();                      hashCode = (hashCode*397) ^ (Source != null ? Source.GetHashCode() : 0);                      hashCode = (hashCode*397) ^ (Name != null ? Name.GetHashCode() : 0);                      return hashCode;                  }
Magic Number,JSIL.Internal,TypeInfo,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,The following statement contains a magic number: foreach (var proxy in Proxies.ToEnumerable()) {                  var seenMethods = new HashSet<MethodDefinition>();                    foreach (var property in proxy.Properties.Values) {                      var p = (PropertyInfo)AddProxyMember(proxy' property);                        if (property.GetMethod != null) {                          if (!property.CustomAttributes.Any(ShouldNeverReplace))                              AddProxyMember(proxy' property.GetMethod' p);                            seenMethods.Add(property.GetMethod);                      }                        if (property.SetMethod != null) {                          if (!property.CustomAttributes.Any(ShouldNeverReplace))                              AddProxyMember(proxy' property.SetMethod' p);                            seenMethods.Add(property.SetMethod);                      }                  }                    foreach (var evt in proxy.Events.Values) {                      var e = (EventInfo)AddProxyMember(proxy' evt);                        if (evt.AddMethod != null) {                          if (!evt.CustomAttributes.Any(ShouldNeverReplace))                              AddProxyMember(proxy' evt.AddMethod' e);                            seenMethods.Add(evt.AddMethod);                      }                        if (evt.RemoveMethod != null) {                          if (!evt.CustomAttributes.Any(ShouldNeverReplace))                              AddProxyMember(proxy' evt.RemoveMethod' e);                            seenMethods.Add(evt.RemoveMethod);                      }                  }                    foreach (var field in proxy.Fields.Values) {                      if (isStatic && !field.IsStatic)                          continue;                        AddProxyMember(proxy' field);                  }                    foreach (var method in proxy.Methods.Values) {                      if (seenMethods.Contains(method))                          continue;                        if (isStatic && !method.IsStatic)                          continue;                        // The constructor may be compiler-generated' so only replace if it has the attribute.                      if ((method.Name == ".ctor") && (method.Parameters.Count == 0)) {                          if (!method.CustomAttributes.Any((ca) => ca.AttributeType.FullName == "JSIL.Proxy.JSReplaceConstructor"))                              continue;                      }                        AddProxyMember(proxy' method);                  }                    if (proxy.ExtraStaticConstructor != null) {                      var name = String.Format(".cctor{0}"' ExtraStaticConstructors.Count + 2);                      var escIdentifier = new MemberIdentifier(source' proxy.ExtraStaticConstructor' name);                      var escInfo = new MethodInfo(this' escIdentifier' proxy.ExtraStaticConstructor' Proxies' proxy);                      escInfo.ForcedNewName = name;                      ExtraStaticConstructors.Add(escInfo);                  }                    if (proxy.MemberPolicy == JSProxyMemberPolicy.ReplaceAll) {                      var previousMembers = Members.ToArray();                      Members.Clear();                      foreach (var member in previousMembers) {                          if (member.Value.IsFromProxy)                              Members.TryAdd(member.Key' member.Value);                      }                  }              }
Magic Number,JSIL.Internal,Util,C:\repos\sq_JSIL\JSIL\Util.cs,EscapeIdentifier,The following statement contains a magic number: for (int i = 0' l = identifier.Length; i < l; i++) {                  var ch = identifier[i];                    switch (ch) {                      case '.':                          if (escapingMode != EscapingMode.MemberIdentifier)                              sb.Append(".");                          else {                              sb.Append("_");                              isEscaped = true;                          }                      break;                      case '/':                          if (escapingMode == EscapingMode.MemberIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else if (escapingMode == EscapingMode.TypeIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else                              sb.Append("/");                      break;                      case '+':                          if (escapingMode == EscapingMode.MemberIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else if (escapingMode == EscapingMode.TypeIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else                              sb.Append("+");                      break;                      case '`':                          if (escapingMode != EscapingMode.String) {                              sb.Append("$b");                          } else {                              sb.Append("`");                          }                          isEscaped = true;                      break;                      case '~':                          sb.Append("$t");                          isEscaped = true;                      break;                      case ':':                          sb.Append("$co");                          isEscaped = true;                      break;                      case '<':                          sb.Append("$l");                          isEscaped = true;                      break;                      case '>':                          sb.Append("$g");                          isEscaped = true;                      break;                      case '(':                          sb.Append("$lp");                          isEscaped = true;                      break;                      case ')':                          sb.Append("$rp");                          isEscaped = true;                      break;                      case '{':                          sb.Append("$lc");                          isEscaped = true;                      break;                      case '}':                          sb.Append("$rc");                          isEscaped = true;                      break;                      case '[':                          sb.Append("$lb");                          isEscaped = true;                      break;                      case ']':                          sb.Append("$rb");                          isEscaped = true;                      break;                      case '@':                          sb.Append("$at");                          isEscaped = true;                      break;                      case '-':                          sb.Append("$da");                          isEscaped = true;                      break;                      case '=':                          sb.Append("$eq");                          isEscaped = true;                      break;                      case ' ':                          sb.Append("$sp");                          isEscaped = true;                      break;                      case '?':                          sb.Append("$qu");                          isEscaped = true;                      break;                      case '!':                          sb.Append("$ex");                          isEscaped = true;                      break;                      case '*':                          sb.Append("$as");                          isEscaped = true;                      break;                      case '&':                          sb.Append("$am");                          isEscaped = true;                      break;                      case ''':                          sb.Append("$cm");                          isEscaped = true;                      break;                      case '|':                          sb.Append("$vb");                          isEscaped = true;                      break;                      case '\'':                          sb.Append("$q");                          isEscaped = true;                      break;                      default:                          if ((ch <= 32) || (ch >= 127)) {                              sb.AppendFormat("${0:x}"' (int)ch);                              isEscaped = true;                          } else                              sb.Append(ch);                      break;                  }              }
Magic Number,JSIL.Internal,Util,C:\repos\sq_JSIL\JSIL\Util.cs,EscapeIdentifier,The following statement contains a magic number: for (int i = 0' l = identifier.Length; i < l; i++) {                  var ch = identifier[i];                    switch (ch) {                      case '.':                          if (escapingMode != EscapingMode.MemberIdentifier)                              sb.Append(".");                          else {                              sb.Append("_");                              isEscaped = true;                          }                      break;                      case '/':                          if (escapingMode == EscapingMode.MemberIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else if (escapingMode == EscapingMode.TypeIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else                              sb.Append("/");                      break;                      case '+':                          if (escapingMode == EscapingMode.MemberIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else if (escapingMode == EscapingMode.TypeIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else                              sb.Append("+");                      break;                      case '`':                          if (escapingMode != EscapingMode.String) {                              sb.Append("$b");                          } else {                              sb.Append("`");                          }                          isEscaped = true;                      break;                      case '~':                          sb.Append("$t");                          isEscaped = true;                      break;                      case ':':                          sb.Append("$co");                          isEscaped = true;                      break;                      case '<':                          sb.Append("$l");                          isEscaped = true;                      break;                      case '>':                          sb.Append("$g");                          isEscaped = true;                      break;                      case '(':                          sb.Append("$lp");                          isEscaped = true;                      break;                      case ')':                          sb.Append("$rp");                          isEscaped = true;                      break;                      case '{':                          sb.Append("$lc");                          isEscaped = true;                      break;                      case '}':                          sb.Append("$rc");                          isEscaped = true;                      break;                      case '[':                          sb.Append("$lb");                          isEscaped = true;                      break;                      case ']':                          sb.Append("$rb");                          isEscaped = true;                      break;                      case '@':                          sb.Append("$at");                          isEscaped = true;                      break;                      case '-':                          sb.Append("$da");                          isEscaped = true;                      break;                      case '=':                          sb.Append("$eq");                          isEscaped = true;                      break;                      case ' ':                          sb.Append("$sp");                          isEscaped = true;                      break;                      case '?':                          sb.Append("$qu");                          isEscaped = true;                      break;                      case '!':                          sb.Append("$ex");                          isEscaped = true;                      break;                      case '*':                          sb.Append("$as");                          isEscaped = true;                      break;                      case '&':                          sb.Append("$am");                          isEscaped = true;                      break;                      case ''':                          sb.Append("$cm");                          isEscaped = true;                      break;                      case '|':                          sb.Append("$vb");                          isEscaped = true;                      break;                      case '\'':                          sb.Append("$q");                          isEscaped = true;                      break;                      default:                          if ((ch <= 32) || (ch >= 127)) {                              sb.AppendFormat("${0:x}"' (int)ch);                              isEscaped = true;                          } else                              sb.Append(ch);                      break;                  }              }
Magic Number,JSIL.Internal,Util,C:\repos\sq_JSIL\JSIL\Util.cs,EscapeCharacter,The following statement contains a magic number: switch (character) {                  case '\'':                      return @"\'";                  case '\\':                      return @"\\";                  case '"':                      return "\\\"";                  case '\t':                      return @"\t";                  case '\r':                      return @"\r";                  case '\n':                      return @"\n";                  default: {                      if (forJson || (character > 255))                          return String.Format(@"\u{0:x4}"' (int)character);                      else                          return String.Format(@"\x{0:x2}"' (int)character);                  }              }
Magic Number,JSIL.Internal,Util,C:\repos\sq_JSIL\JSIL\Util.cs,EscapeString,The following statement contains a magic number: foreach (var ch in text) {                  if (ch == quoteCharacter)                      sb.Append(EscapeCharacter(ch' forJson));                  else if (ch == '\\')                      sb.Append(@"\\");                  else if ((ch < ' ') || (ch > 127))                      sb.Append(EscapeCharacter(ch' forJson));                  else                      sb.Append(ch);              }
Magic Number,JSIL.Internal,ConcurrentHashQueue<TValue>,C:\repos\sq_JSIL\JSIL\Util.cs,TryEnqueue,The following statement contains a magic number: if (Counts.TryAdd(value' 1)) {                  Queue.Enqueue(value);                  return true;              } else {                  int existingCount;                  int tryCount = 10;                    while (Counts.TryGetValue(value' out existingCount)) {                      var newCount = existingCount + 1;                        if (Counts.TryUpdate(value' newCount' existingCount))                          return true;                        // Abort after a few tries.                      if ((tryCount--) <= 0)                          return false;                  }              }
Magic Number,JSIL.Internal,ConcurrentHashQueue<TValue>,C:\repos\sq_JSIL\JSIL\Util.cs,TryDequeue,The following statement contains a magic number: if (Queue.TryDequeue(out value)) {                  int existingCount;                  int tryCount = 10;                    while (Counts.TryGetValue(value' out existingCount)) {                      int newCount = existingCount - 1;                        if (newCount <= 0) {                          if (Counts.TryRemove(value' out existingCount))                              return true;                      } else {                          if (Counts.TryUpdate(value' existingCount' newCount))                              return true;                      }                        // Abort after a few tries.                      if ((tryCount--) <= 0)                          return false;                  }              }
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,ImmutableArrayPool,The following statement contains a magic number: int itemSize = Environment.Is64BitProcess                   ? 8                   : 4;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,ImmutableArrayPool,The following statement contains a magic number: int itemSize = Environment.Is64BitProcess                   ? 8                   : 4;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,ImmutableArrayPool,The following statement contains a magic number: try {                  // If it's a blittable type' estimate its in-memory size                  if (!typeof(T).IsClass)                      itemSize = Marshal.SizeOf(typeof(T));              } catch {                  // Non-blittable struct. Make a rough estimate of size (conservative) so we try to stay below LOH threshold.                  itemSize = 32;              }
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: var result = Allocate(2);
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: var result = Allocate(3);
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: result.Array[result.Offset + 2] = c;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: var result = Allocate(4);
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: result.Array[result.Offset + 2] = c;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,C:\repos\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: result.Array[result.Offset + 3] = d;
Magic Number,JSIL.Transforms,FixupStructConstructorInvocations,C:\repos\sq_JSIL\JSIL\Transforms\FixupStructConstructorInvocations.cs,VisitNode,The following statement contains a magic number: if (CurrentName != "DefaultValue") {                  var thisReferenceType = dvl.GetActualType(TypeSystem);                  if (TypeUtil.IsStruct(thisReferenceType) && (parentBoe != null))                      Initializations.Add(new InitializationInfo {                          Type = thisReferenceType'                          DefaultValueLiteral = dvl'                          ParentBinaryExpression = parentBoe'                          BinaryExpressionParent = Stack.Skip(2).First()                      });              }
Magic Number,JSIL.Transforms,FixupStructConstructorInvocations,C:\repos\sq_JSIL\JSIL\Transforms\FixupStructConstructorInvocations.cs,VisitNode,The following statement contains a magic number: if (TypeUtil.IsStruct(thisReferenceType) && (parentBoe != null))                  Initializations.Add(new InitializationInfo {                      Type = thisReferenceType'                      NewExpression = ne'                      ParentBinaryExpression = parentBoe'                      BinaryExpressionParent = Stack.Skip(2).First()                  });
Magic Number,JSIL.Transforms,EmulateInt64,C:\repos\sq_JSIL\JSIL\Transforms\EmulateInt64.cs,GetLongLiteralExpression,The following statement contains a magic number: uint b = (uint)((number >> 24) & 0xffffff);
Magic Number,JSIL.Transforms,EmulateInt64,C:\repos\sq_JSIL\JSIL\Transforms\EmulateInt64.cs,GetLongLiteralExpression,The following statement contains a magic number: uint c = (uint)((number >> 48) & 0xffff);
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: if (TraceLevel >= 3) {                  if (sc.Values != null)                      Console.WriteLine("// Entering case {0}"' sc.Values.FirstOrDefault());                  else                      Console.WriteLine("// Entering case default");              }
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: if (TraceLevel >= 3)                  Console.WriteLine("// Exiting case");
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: if (TraceLevel >= 3)                  Console.WriteLine("// Entering block {0}"' bs.Label ?? bs.GetType().Name);
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: if (isControlFlow) {                  if (TraceLevel >= 3)                      Console.WriteLine("// Count reset");                    AbsoluteJumpsSeenStack.Add(0);              }
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: if (TraceLevel >= 3)                  Console.WriteLine("// Exiting block");
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitControlFlowNode,The following statement contains a magic number: var stackSlice = Stack.Take(3).ToArray();
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitControlFlowNode,The following statement contains a magic number: var parentBlock = stackSlice[2] as JSBlockStatement;
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitControlFlowNode,The following statement contains a magic number: if ((parentEs != null) && (parentBlock == BlockStack.Peek())) {                  AbsoluteJumpsSeen += 1;                    if (AbsoluteJumpsSeen > 1) {                      if (TraceLevel >= 1)                          Console.WriteLine("// Eliminating {0}"' node);                        var replacement = new JSNullExpression();                      ParentNode.ReplaceChild(node' replacement);                      MadeChanges = true;                      return;                  } else {                      if (TraceLevel >= 4)                          Console.WriteLine("// Not eliminating {0}"' node);                  }              }
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The following statement contains a magic number: if ((lastEs != null) &&                  (                      (lastEs.Expression is JSGotoExpression) ||                      (lastEs.Expression is JSBreakExpression) ||                      (lastEs.Expression is JSContinueExpression)                  )                 ) {                  if (TraceLevel >= 3)                      Console.WriteLine("// Not recording fallthrough from {0} to {1} because {0} ends with control flow ({2})"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label' lastEs.Expression);                    return;              }
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The following statement contains a magic number: if (LabelGroupStack.Count > 0) {                  foreach (var lg in LabelGroupStack) {                      LabelGroupLabelData labelData;                        if (lg.TryGetValue(PreviousLabelledStatement.Label' out labelData)) {                          failed = false;                            if (TraceLevel >= 2)                              Console.WriteLine("// Recording fallthrough from {0} to {1}"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label);                            labelData.ExitTargetLabels.Add(CurrentLabelledStatement.Label);                      }                  }              }
Magic Number,JSIL.Transforms,ControlFlowSimplifier,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The following statement contains a magic number: if ((TraceLevel >= 2) && failed)                  Console.WriteLine("// Failed to record fallthrough from {0} to {1}"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label);
Magic Number,JSIL.Transforms,LabelGroupFlattener,C:\repos\sq_JSIL\JSIL\Transforms\LabelGroupBuilder.cs,MaybeFlatten,The following statement contains a magic number: if (                  (labelledGroup != null) &&                  (labelledGroup.Labels.Count == 3)              ) {                  var labels = labelledGroup.Labels.ToArray();                    // Hoist the contents of the entry label into the label that contains this label group.                  var entryLabel = labels[0];                  labelledStatement.ReplaceChildRecursive(labelledGroup' entryLabel.Value);                    // Hoist the single label from this label group into the containing label group'                   //  after the label that contains this label group.                  var hoistedLabel = labels[1];                    // Flattening would create a cycle.                  // FIXME: Why the hell does this happen?                  if (hoistedLabel.Key == keyNode.Value)                      return false;                    var hoistedKeyNode = lgs.Labels.EnqueueAfter(                      keyNode' hoistedLabel.Key' hoistedLabel.Value                  );                    var exitLabel = labels[2];                  // Hoist the contents of the exit label into the label that contains this label group.                  lgs.Labels.EnqueueAfter(                      hoistedKeyNode' hoistedLabel.Key + "_after"' exitLabel.Value                  );                    return FlattenedAGroup = true;              }
Magic Number,JSIL.Transforms,LabelGroupFlattener,C:\repos\sq_JSIL\JSIL\Transforms\LabelGroupBuilder.cs,MaybeFlatten,The following statement contains a magic number: if (                  (labelledGroup != null) &&                  (labelledGroup.Labels.Count == 3)              ) {                  var labels = labelledGroup.Labels.ToArray();                    // Hoist the contents of the entry label into the label that contains this label group.                  var entryLabel = labels[0];                  labelledStatement.ReplaceChildRecursive(labelledGroup' entryLabel.Value);                    // Hoist the single label from this label group into the containing label group'                   //  after the label that contains this label group.                  var hoistedLabel = labels[1];                    // Flattening would create a cycle.                  // FIXME: Why the hell does this happen?                  if (hoistedLabel.Key == keyNode.Value)                      return false;                    var hoistedKeyNode = lgs.Labels.EnqueueAfter(                      keyNode' hoistedLabel.Key' hoistedLabel.Value                  );                    var exitLabel = labels[2];                  // Hoist the contents of the exit label into the label that contains this label group.                  lgs.Labels.EnqueueAfter(                      hoistedKeyNode' hoistedLabel.Key + "_after"' exitLabel.Value                  );                    return FlattenedAGroup = true;              }
Magic Number,JSIL.Transforms,DeoptimizeSwitchStatements,C:\repos\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,The following statement contains a magic number: if ((boe != null) && (boe.Operator == JSOperator.Equal)) {                  var leftVar = boe.Left as JSVariable;                  var leftIgnored = boe.Left as JSIgnoredMemberReference;                  var rightNull = (JSLiteral)(boe.Right as JSDefaultValueLiteral) ?? (JSLiteral)(boe.Right as JSNullLiteral);                    if (rightNull != null) {                      if (leftVar != null) {                          NullChecks[leftVar] = new NullCheck {                              Statement = ifs'                              SwitchVariable = leftVar'                              Goto = ifs.AllChildrenRecursive.OfType<JSGotoExpression>().FirstOrDefault()                          };                      } else if (leftIgnored != null) {                          var leftField = leftIgnored.Member as FieldInfo;                            if (leftField != null) {                              var initializer = Initializers[leftField] = new Initializer {                                  Field = leftField'                                  Statement = ifs'                              };                                foreach (var _invocation in ifs.TrueClause.AllChildrenRecursive.OfType<JSInvocationExpression>()) {                                  if (_invocation.JSMethod == null)                                      continue;                                  if (_invocation.JSMethod.Identifier != "Add")                                      continue;                                  if (_invocation.Arguments.Count != 2)                                      continue;                                    var value = _invocation.Arguments[0];                                  var index = _invocation.Arguments[1] as JSIntegerLiteral;                                  if (index == null)                                      continue;                                    initializer.Values[(int)index.Value] = value;                              }                          }                      }                  }              } else if ((uoe != null) && (uoe.Operator == JSOperator.LogicalNot)) {                  invocation = uoe.Expression as JSInvocationExpression;                  invocationIsInverted = true;              }
Magic Number,JSIL.Transforms,DeoptimizeSwitchStatements,C:\repos\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,The following statement contains a magic number: if (                  (invocation != null) &&                  (invocation.Arguments.Count == 2) &&                  (invocation.JSMethod != null) &&                  (invocation.JSMethod.Identifier == "TryGetValue")              ) {                  var thisIgnored = invocation.ThisReference as JSIgnoredMemberReference;                  var switchVar = invocation.Arguments[0] as JSVariable;                  var outRef = invocation.Arguments[1] as JSPassByReferenceExpression;                    if ((thisIgnored != null) && (switchVar != null) && (outRef != null)) {                      var thisField = thisIgnored.Member as FieldInfo;                      var outReferent = outRef.Referent as JSReferenceExpression;                        if ((thisField != null) && (outReferent != null)) {                          var outVar = outReferent.Referent as JSVariable;                            if (outVar != null) {                              IndexLookups[outVar] = new IndexLookup {                                  OutputVariable = outVar'                                  SwitchVariable = switchVar'                                  Field = thisField'                                  Statement = ifs'                                  Goto = ifs.TrueClause.AllChildrenRecursive.OfType<JSGotoExpression>().FirstOrDefault()'                                  IsInverted = invocationIsInverted                              };                                if (!invocationIsInverted) {                                  var replacement = ifs.TrueClause;                                  ParentNode.ReplaceChild(ifs' replacement);                                  VisitReplacement(replacement);                                  return;                              }                          }                      }                  }              }
Magic Number,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following statement contains a magic number: if (method != null) {                  if (                      (type != null) &&                      (type.Type.FullName == "System.Object")                  ) {                      switch (method.Method.Member.Name) {                          case ".ctor": {                              var replacement = new JSNullExpression();                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "ReferenceEquals": {                              var lhs = ie.Arguments[0];                              var rhs = ie.Arguments[1];                                var lhsType = lhs.GetActualType(TypeSystem);                              var rhsType = rhs.GetActualType(TypeSystem);                                JSNode replacement;                                // Structs can never compare equal with ReferenceEquals                              if (TypeUtil.IsStruct(lhsType) || TypeUtil.IsStruct(rhsType))                                  replacement = JSLiteral.New(false);                              else                                  replacement = new JSBinaryOperatorExpression(                                      JSOperator.Equal'                                      lhs' rhs'                                      TypeSystem.Boolean                                  );                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "GetType": {                              JSNode replacement;                                var thisType = JSExpression.DeReferenceType(thisExpression.GetActualType(TypeSystem)' false);                              if ((thisType is GenericInstanceType) && thisType.FullName.StartsWith("System.Nullable")) {                                  var git = (GenericInstanceType)thisType;                                    replacement = new JSTernaryOperatorExpression(                                      new JSBinaryOperatorExpression(                                          JSOperator.NotEqual'                                          thisExpression' new JSNullLiteral(thisType)'                                          TypeSystem.Boolean                                      )'                                      new JSTypeOfExpression(git.GenericArguments[0])'                                      JSIL.ThrowNullReferenceException()'                                      TypeSystem.SystemType()                                  );                              } else {                                  replacement = JSIL.GetTypeOf(thisExpression);                              }                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }                  } else if (                      (type != null) &&                      (type.Type.FullName == "System.ValueType")                  ) {                      switch (method.Method.Member.Name) {                          case "Equals": {                              var replacement = JSIL.StructEquals(ie.ThisReference' ie.Arguments.First());                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }                  } else if (                      (type != null) &&                      IsNullable(type.Type)                  ) {                      var t = (type.Type as GenericInstanceType).GenericArguments[0];                      var @null = JSLiteral.Null(t);                      var @default = new JSDefaultValueLiteral(t);                        switch (method.Method.Member.Name) {                          case ".ctor":                              JSExpression value;                              if (ie.Arguments.Count == 0) {                                  value = @null;                              } else {                                  value = ie.Arguments[0];                              }                                JSExpression replacementNode;                                var readThroughReference = ie.ThisReference as JSReadThroughReferenceExpression;                              if (readThroughReference != null)                              {                                  replacementNode = new JSWriteThroughReferenceExpression(readThroughReference.Variable' value);                              }                              else                              {                                  var readThroughPointer = ie.ThisReference as JSReadThroughPointerExpression;                                  if (readThroughPointer != null)                                  {                                      replacementNode = new JSWriteThroughPointerExpression(readThroughPointer.Pointer' value'                                          type.Type' readThroughPointer.OffsetInBytes);                                  }                                  else                                  {                                      replacementNode = new JSBinaryOperatorExpression(JSOperator.Assignment' ie.ThisReference'                                          value' type.Type);                                  }                              }                                ParentNode.ReplaceChild(ie' replacementNode);                              VisitReplacement(replacementNode);                                break;                            case "GetValueOrDefault": {                              var replacement = JSIL.ValueOfNullableOrDefault(                                  ie.ThisReference'                                  (ie.Arguments.Count == 0)                                      ? @default                                      : ie.Arguments[0]                              );                                if (ParentNode is JSResultReferenceExpression) {                                  // HACK: Replacing the invocation inside a result reference is incorrect' so we need to walk up the stack                                  //  and replace the result reference with the ternary instead.                                  _ResultReferenceReplacement = replacement;                              } else {                                  ParentNode.ReplaceChild(ie' replacement);                                  VisitReplacement(replacement);                              }                                break;                          }                            case "Equals":                              JSBinaryOperatorExpression equality = new JSBinaryOperatorExpression(JSOperator.Equal' ie.ThisReference' ie.Parameters.First().Value' type.Type);                              ParentNode.ReplaceChild(ie' equality);                              VisitReplacement(equality);                              break;                            default:                              throw new NotImplementedException(method.Method.Member.FullName);                      }                        return;                  } else if (                      (type != null) &&                      TypeUtil.TypesAreEqual(TypeSystem.String' type.Type) &&                      (method.Method.Name == "Concat")                  ) {                      if (ie.Arguments.Count > 2) {                          if (ie.Arguments.All(                              (arg) => TypeUtil.TypesAreEqual(                                  TypeSystem.String' arg.GetActualType(TypeSystem)                              )                          )) {                              var boe = JSBinaryOperatorExpression.New(                                  JSOperator.Add'                                  ie.Arguments'                                  TypeSystem.String                              );                                ParentNode.ReplaceChild(                                  ie'                                  boe                              );                                VisitReplacement(boe);                          }                      } else if (                          // HACK: Fix for #239' only convert concat call into + if both sides are non-null literals                          (ie.Arguments.Count == 2)                      ) {                          var lhs = ie.Arguments[0];                          var rhs = ie.Arguments[1];                            var isAddOk = (lhs is JSStringLiteral) && (rhs is JSStringLiteral);                            var lhsType = TypeUtil.DereferenceType(lhs.GetActualType(TypeSystem));                          if (!(                              TypeUtil.TypesAreEqual(TypeSystem.String' lhsType) ||                              TypeUtil.TypesAreEqual(TypeSystem.Char' lhsType)                          )) {                              lhs = JSInvocationExpression.InvokeMethod(lhsType' JS.toString' lhs' null);                              isAddOk = true;                          }                            var rhsType = TypeUtil.DereferenceType(rhs.GetActualType(TypeSystem));                          if (!(                              TypeUtil.TypesAreEqual(TypeSystem.String' rhsType) ||                              TypeUtil.TypesAreEqual(TypeSystem.Char' rhsType)                          )) {                              rhs = JSInvocationExpression.InvokeMethod(rhsType' JS.toString' rhs' null);                              isAddOk = true;                          }                            if (isAddOk) {                              var boe = new JSBinaryOperatorExpression(                                  JSOperator.Add' lhs' rhs' TypeSystem.String                              );                                ParentNode.ReplaceChild(                                  ie' boe                              );                                VisitReplacement(boe);                          }                      } else if (                          TypeUtil.GetTypeDefinition(ie.Arguments[0].GetActualType(TypeSystem)).FullName == "System.Array"                      ) {                      } else {                          var firstArg = ie.Arguments.FirstOrDefault();                            ParentNode.ReplaceChild(                              ie' firstArg                          );                            if (firstArg != null)                              VisitReplacement(firstArg);                      }                      return;                  } else if (                      TypeUtil.IsDelegateType(method.Reference.DeclaringType) &&                      (method.Method.Name == "Invoke")                  ) {                      var newIe = new JSDelegateInvocationExpression(                          thisExpression' ie.GetActualType(TypeSystem)' ie.Arguments.ToArray()                      );                      ParentNode.ReplaceChild(ie' newIe);                        VisitReplacement(newIe);                      return;                  } else if (                      (method.Reference.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers") &&                      (method.Method.Name == "InitializeArray") &&                      (method.Method.Parameters.Length == 2) &&                      (method.Method.Parameters[0].ParameterType.FullName == "System.Array") &&                      (method.Method.Parameters[1].ParameterType.FullName == "System.RuntimeFieldHandle")                  ) {                      var array = ie.Arguments[0];                      var arrayType = array.GetActualType(TypeSystem);                      var field = ie.Arguments[1].SelfAndChildrenRecursive.OfType<JSField>().First();                      var initializer = JSArrayExpression.UnpackArrayInitializer(arrayType' field.Field.Member.InitialValue);                        var copy = JSIL.ShallowCopy(array' initializer' arrayType);                      ParentNode.ReplaceChild(ie' copy);                      VisitReplacement(copy);                      return;                  } else if (                      method.Reference.DeclaringType.FullName == "System.Reflection.Assembly"                  ) {                      switch (method.Reference.Name) {                          case "GetExecutingAssembly": {                              var assembly = Method.DeclaringType.Module.Assembly;                              var asmNode = new JSReflectionAssembly(assembly);                              ParentNode.ReplaceChild(ie' asmNode);                              VisitReplacement(asmNode);                                return;                          }                      }                  }              }
Magic Number,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following statement contains a magic number: if (method != null) {                  if (                      (type != null) &&                      (type.Type.FullName == "System.Object")                  ) {                      switch (method.Method.Member.Name) {                          case ".ctor": {                              var replacement = new JSNullExpression();                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "ReferenceEquals": {                              var lhs = ie.Arguments[0];                              var rhs = ie.Arguments[1];                                var lhsType = lhs.GetActualType(TypeSystem);                              var rhsType = rhs.GetActualType(TypeSystem);                                JSNode replacement;                                // Structs can never compare equal with ReferenceEquals                              if (TypeUtil.IsStruct(lhsType) || TypeUtil.IsStruct(rhsType))                                  replacement = JSLiteral.New(false);                              else                                  replacement = new JSBinaryOperatorExpression(                                      JSOperator.Equal'                                      lhs' rhs'                                      TypeSystem.Boolean                                  );                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "GetType": {                              JSNode replacement;                                var thisType = JSExpression.DeReferenceType(thisExpression.GetActualType(TypeSystem)' false);                              if ((thisType is GenericInstanceType) && thisType.FullName.StartsWith("System.Nullable")) {                                  var git = (GenericInstanceType)thisType;                                    replacement = new JSTernaryOperatorExpression(                                      new JSBinaryOperatorExpression(                                          JSOperator.NotEqual'                                          thisExpression' new JSNullLiteral(thisType)'                                          TypeSystem.Boolean                                      )'                                      new JSTypeOfExpression(git.GenericArguments[0])'                                      JSIL.ThrowNullReferenceException()'                                      TypeSystem.SystemType()                                  );                              } else {                                  replacement = JSIL.GetTypeOf(thisExpression);                              }                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }                  } else if (                      (type != null) &&                      (type.Type.FullName == "System.ValueType")                  ) {                      switch (method.Method.Member.Name) {                          case "Equals": {                              var replacement = JSIL.StructEquals(ie.ThisReference' ie.Arguments.First());                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }                  } else if (                      (type != null) &&                      IsNullable(type.Type)                  ) {                      var t = (type.Type as GenericInstanceType).GenericArguments[0];                      var @null = JSLiteral.Null(t);                      var @default = new JSDefaultValueLiteral(t);                        switch (method.Method.Member.Name) {                          case ".ctor":                              JSExpression value;                              if (ie.Arguments.Count == 0) {                                  value = @null;                              } else {                                  value = ie.Arguments[0];                              }                                JSExpression replacementNode;                                var readThroughReference = ie.ThisReference as JSReadThroughReferenceExpression;                              if (readThroughReference != null)                              {                                  replacementNode = new JSWriteThroughReferenceExpression(readThroughReference.Variable' value);                              }                              else                              {                                  var readThroughPointer = ie.ThisReference as JSReadThroughPointerExpression;                                  if (readThroughPointer != null)                                  {                                      replacementNode = new JSWriteThroughPointerExpression(readThroughPointer.Pointer' value'                                          type.Type' readThroughPointer.OffsetInBytes);                                  }                                  else                                  {                                      replacementNode = new JSBinaryOperatorExpression(JSOperator.Assignment' ie.ThisReference'                                          value' type.Type);                                  }                              }                                ParentNode.ReplaceChild(ie' replacementNode);                              VisitReplacement(replacementNode);                                break;                            case "GetValueOrDefault": {                              var replacement = JSIL.ValueOfNullableOrDefault(                                  ie.ThisReference'                                  (ie.Arguments.Count == 0)                                      ? @default                                      : ie.Arguments[0]                              );                                if (ParentNode is JSResultReferenceExpression) {                                  // HACK: Replacing the invocation inside a result reference is incorrect' so we need to walk up the stack                                  //  and replace the result reference with the ternary instead.                                  _ResultReferenceReplacement = replacement;                              } else {                                  ParentNode.ReplaceChild(ie' replacement);                                  VisitReplacement(replacement);                              }                                break;                          }                            case "Equals":                              JSBinaryOperatorExpression equality = new JSBinaryOperatorExpression(JSOperator.Equal' ie.ThisReference' ie.Parameters.First().Value' type.Type);                              ParentNode.ReplaceChild(ie' equality);                              VisitReplacement(equality);                              break;                            default:                              throw new NotImplementedException(method.Method.Member.FullName);                      }                        return;                  } else if (                      (type != null) &&                      TypeUtil.TypesAreEqual(TypeSystem.String' type.Type) &&                      (method.Method.Name == "Concat")                  ) {                      if (ie.Arguments.Count > 2) {                          if (ie.Arguments.All(                              (arg) => TypeUtil.TypesAreEqual(                                  TypeSystem.String' arg.GetActualType(TypeSystem)                              )                          )) {                              var boe = JSBinaryOperatorExpression.New(                                  JSOperator.Add'                                  ie.Arguments'                                  TypeSystem.String                              );                                ParentNode.ReplaceChild(                                  ie'                                  boe                              );                                VisitReplacement(boe);                          }                      } else if (                          // HACK: Fix for #239' only convert concat call into + if both sides are non-null literals                          (ie.Arguments.Count == 2)                      ) {                          var lhs = ie.Arguments[0];                          var rhs = ie.Arguments[1];                            var isAddOk = (lhs is JSStringLiteral) && (rhs is JSStringLiteral);                            var lhsType = TypeUtil.DereferenceType(lhs.GetActualType(TypeSystem));                          if (!(                              TypeUtil.TypesAreEqual(TypeSystem.String' lhsType) ||                              TypeUtil.TypesAreEqual(TypeSystem.Char' lhsType)                          )) {                              lhs = JSInvocationExpression.InvokeMethod(lhsType' JS.toString' lhs' null);                              isAddOk = true;                          }                            var rhsType = TypeUtil.DereferenceType(rhs.GetActualType(TypeSystem));                          if (!(                              TypeUtil.TypesAreEqual(TypeSystem.String' rhsType) ||                              TypeUtil.TypesAreEqual(TypeSystem.Char' rhsType)                          )) {                              rhs = JSInvocationExpression.InvokeMethod(rhsType' JS.toString' rhs' null);                              isAddOk = true;                          }                            if (isAddOk) {                              var boe = new JSBinaryOperatorExpression(                                  JSOperator.Add' lhs' rhs' TypeSystem.String                              );                                ParentNode.ReplaceChild(                                  ie' boe                              );                                VisitReplacement(boe);                          }                      } else if (                          TypeUtil.GetTypeDefinition(ie.Arguments[0].GetActualType(TypeSystem)).FullName == "System.Array"                      ) {                      } else {                          var firstArg = ie.Arguments.FirstOrDefault();                            ParentNode.ReplaceChild(                              ie' firstArg                          );                            if (firstArg != null)                              VisitReplacement(firstArg);                      }                      return;                  } else if (                      TypeUtil.IsDelegateType(method.Reference.DeclaringType) &&                      (method.Method.Name == "Invoke")                  ) {                      var newIe = new JSDelegateInvocationExpression(                          thisExpression' ie.GetActualType(TypeSystem)' ie.Arguments.ToArray()                      );                      ParentNode.ReplaceChild(ie' newIe);                        VisitReplacement(newIe);                      return;                  } else if (                      (method.Reference.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers") &&                      (method.Method.Name == "InitializeArray") &&                      (method.Method.Parameters.Length == 2) &&                      (method.Method.Parameters[0].ParameterType.FullName == "System.Array") &&                      (method.Method.Parameters[1].ParameterType.FullName == "System.RuntimeFieldHandle")                  ) {                      var array = ie.Arguments[0];                      var arrayType = array.GetActualType(TypeSystem);                      var field = ie.Arguments[1].SelfAndChildrenRecursive.OfType<JSField>().First();                      var initializer = JSArrayExpression.UnpackArrayInitializer(arrayType' field.Field.Member.InitialValue);                        var copy = JSIL.ShallowCopy(array' initializer' arrayType);                      ParentNode.ReplaceChild(ie' copy);                      VisitReplacement(copy);                      return;                  } else if (                      method.Reference.DeclaringType.FullName == "System.Reflection.Assembly"                  ) {                      switch (method.Reference.Name) {                          case "GetExecutingAssembly": {                              var assembly = Method.DeclaringType.Module.Assembly;                              var asmNode = new JSReflectionAssembly(assembly);                              ParentNode.ReplaceChild(ie' asmNode);                              VisitReplacement(asmNode);                                return;                          }                      }                  }              }
Magic Number,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following statement contains a magic number: if (method != null) {                  if (                      (type != null) &&                      (type.Type.FullName == "System.Object")                  ) {                      switch (method.Method.Member.Name) {                          case ".ctor": {                              var replacement = new JSNullExpression();                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "ReferenceEquals": {                              var lhs = ie.Arguments[0];                              var rhs = ie.Arguments[1];                                var lhsType = lhs.GetActualType(TypeSystem);                              var rhsType = rhs.GetActualType(TypeSystem);                                JSNode replacement;                                // Structs can never compare equal with ReferenceEquals                              if (TypeUtil.IsStruct(lhsType) || TypeUtil.IsStruct(rhsType))                                  replacement = JSLiteral.New(false);                              else                                  replacement = new JSBinaryOperatorExpression(                                      JSOperator.Equal'                                      lhs' rhs'                                      TypeSystem.Boolean                                  );                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "GetType": {                              JSNode replacement;                                var thisType = JSExpression.DeReferenceType(thisExpression.GetActualType(TypeSystem)' false);                              if ((thisType is GenericInstanceType) && thisType.FullName.StartsWith("System.Nullable")) {                                  var git = (GenericInstanceType)thisType;                                    replacement = new JSTernaryOperatorExpression(                                      new JSBinaryOperatorExpression(                                          JSOperator.NotEqual'                                          thisExpression' new JSNullLiteral(thisType)'                                          TypeSystem.Boolean                                      )'                                      new JSTypeOfExpression(git.GenericArguments[0])'                                      JSIL.ThrowNullReferenceException()'                                      TypeSystem.SystemType()                                  );                              } else {                                  replacement = JSIL.GetTypeOf(thisExpression);                              }                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }                  } else if (                      (type != null) &&                      (type.Type.FullName == "System.ValueType")                  ) {                      switch (method.Method.Member.Name) {                          case "Equals": {                              var replacement = JSIL.StructEquals(ie.ThisReference' ie.Arguments.First());                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }                  } else if (                      (type != null) &&                      IsNullable(type.Type)                  ) {                      var t = (type.Type as GenericInstanceType).GenericArguments[0];                      var @null = JSLiteral.Null(t);                      var @default = new JSDefaultValueLiteral(t);                        switch (method.Method.Member.Name) {                          case ".ctor":                              JSExpression value;                              if (ie.Arguments.Count == 0) {                                  value = @null;                              } else {                                  value = ie.Arguments[0];                              }                                JSExpression replacementNode;                                var readThroughReference = ie.ThisReference as JSReadThroughReferenceExpression;                              if (readThroughReference != null)                              {                                  replacementNode = new JSWriteThroughReferenceExpression(readThroughReference.Variable' value);                              }                              else                              {                                  var readThroughPointer = ie.ThisReference as JSReadThroughPointerExpression;                                  if (readThroughPointer != null)                                  {                                      replacementNode = new JSWriteThroughPointerExpression(readThroughPointer.Pointer' value'                                          type.Type' readThroughPointer.OffsetInBytes);                                  }                                  else                                  {                                      replacementNode = new JSBinaryOperatorExpression(JSOperator.Assignment' ie.ThisReference'                                          value' type.Type);                                  }                              }                                ParentNode.ReplaceChild(ie' replacementNode);                              VisitReplacement(replacementNode);                                break;                            case "GetValueOrDefault": {                              var replacement = JSIL.ValueOfNullableOrDefault(                                  ie.ThisReference'                                  (ie.Arguments.Count == 0)                                      ? @default                                      : ie.Arguments[0]                              );                                if (ParentNode is JSResultReferenceExpression) {                                  // HACK: Replacing the invocation inside a result reference is incorrect' so we need to walk up the stack                                  //  and replace the result reference with the ternary instead.                                  _ResultReferenceReplacement = replacement;                              } else {                                  ParentNode.ReplaceChild(ie' replacement);                                  VisitReplacement(replacement);                              }                                break;                          }                            case "Equals":                              JSBinaryOperatorExpression equality = new JSBinaryOperatorExpression(JSOperator.Equal' ie.ThisReference' ie.Parameters.First().Value' type.Type);                              ParentNode.ReplaceChild(ie' equality);                              VisitReplacement(equality);                              break;                            default:                              throw new NotImplementedException(method.Method.Member.FullName);                      }                        return;                  } else if (                      (type != null) &&                      TypeUtil.TypesAreEqual(TypeSystem.String' type.Type) &&                      (method.Method.Name == "Concat")                  ) {                      if (ie.Arguments.Count > 2) {                          if (ie.Arguments.All(                              (arg) => TypeUtil.TypesAreEqual(                                  TypeSystem.String' arg.GetActualType(TypeSystem)                              )                          )) {                              var boe = JSBinaryOperatorExpression.New(                                  JSOperator.Add'                                  ie.Arguments'                                  TypeSystem.String                              );                                ParentNode.ReplaceChild(                                  ie'                                  boe                              );                                VisitReplacement(boe);                          }                      } else if (                          // HACK: Fix for #239' only convert concat call into + if both sides are non-null literals                          (ie.Arguments.Count == 2)                      ) {                          var lhs = ie.Arguments[0];                          var rhs = ie.Arguments[1];                            var isAddOk = (lhs is JSStringLiteral) && (rhs is JSStringLiteral);                            var lhsType = TypeUtil.DereferenceType(lhs.GetActualType(TypeSystem));                          if (!(                              TypeUtil.TypesAreEqual(TypeSystem.String' lhsType) ||                              TypeUtil.TypesAreEqual(TypeSystem.Char' lhsType)                          )) {                              lhs = JSInvocationExpression.InvokeMethod(lhsType' JS.toString' lhs' null);                              isAddOk = true;                          }                            var rhsType = TypeUtil.DereferenceType(rhs.GetActualType(TypeSystem));                          if (!(                              TypeUtil.TypesAreEqual(TypeSystem.String' rhsType) ||                              TypeUtil.TypesAreEqual(TypeSystem.Char' rhsType)                          )) {                              rhs = JSInvocationExpression.InvokeMethod(rhsType' JS.toString' rhs' null);                              isAddOk = true;                          }                            if (isAddOk) {                              var boe = new JSBinaryOperatorExpression(                                  JSOperator.Add' lhs' rhs' TypeSystem.String                              );                                ParentNode.ReplaceChild(                                  ie' boe                              );                                VisitReplacement(boe);                          }                      } else if (                          TypeUtil.GetTypeDefinition(ie.Arguments[0].GetActualType(TypeSystem)).FullName == "System.Array"                      ) {                      } else {                          var firstArg = ie.Arguments.FirstOrDefault();                            ParentNode.ReplaceChild(                              ie' firstArg                          );                            if (firstArg != null)                              VisitReplacement(firstArg);                      }                      return;                  } else if (                      TypeUtil.IsDelegateType(method.Reference.DeclaringType) &&                      (method.Method.Name == "Invoke")                  ) {                      var newIe = new JSDelegateInvocationExpression(                          thisExpression' ie.GetActualType(TypeSystem)' ie.Arguments.ToArray()                      );                      ParentNode.ReplaceChild(ie' newIe);                        VisitReplacement(newIe);                      return;                  } else if (                      (method.Reference.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers") &&                      (method.Method.Name == "InitializeArray") &&                      (method.Method.Parameters.Length == 2) &&                      (method.Method.Parameters[0].ParameterType.FullName == "System.Array") &&                      (method.Method.Parameters[1].ParameterType.FullName == "System.RuntimeFieldHandle")                  ) {                      var array = ie.Arguments[0];                      var arrayType = array.GetActualType(TypeSystem);                      var field = ie.Arguments[1].SelfAndChildrenRecursive.OfType<JSField>().First();                      var initializer = JSArrayExpression.UnpackArrayInitializer(arrayType' field.Field.Member.InitialValue);                        var copy = JSIL.ShallowCopy(array' initializer' arrayType);                      ParentNode.ReplaceChild(ie' copy);                      VisitReplacement(copy);                      return;                  } else if (                      method.Reference.DeclaringType.FullName == "System.Reflection.Assembly"                  ) {                      switch (method.Reference.Name) {                          case "GetExecutingAssembly": {                              var assembly = Method.DeclaringType.Module.Assembly;                              var asmNode = new JSReflectionAssembly(assembly);                              ParentNode.ReplaceChild(ie' asmNode);                              VisitReplacement(asmNode);                                return;                          }                      }                  }              }
Magic Number,JSIL.Transforms,IntroduceEnumCasts,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceEnumCasts.cs,VisitNode,The following statement contains a magic number: if (LogicalOperators.Contains(boe.Operator)) {                  if (eitherIsEnum) {                      if (leftIsEnum) {                          var cast = JSInvocationExpression.InvokeMethod(                              JS.valueOf(TypeSystem.Int32)' boe.Left' null' true                          );                            boe.ReplaceChild(boe.Left' cast);                      }                        if (rightIsEnum) {                          var cast = JSInvocationExpression.InvokeMethod(                              JS.valueOf(TypeSystem.Int32)' boe.Right' null' true                          );                            boe.ReplaceChild(boe.Right' cast);                      }                  }              } else if (BitwiseOperators.Contains(boe.Operator)) {                  var parentCast = ParentNode as JSCastExpression;                  var parentReinterpret = Stack.Skip(2).FirstOrDefault() as JSChangeTypeExpression;                    if (resultIsEnum &&                       ((parentCast == null) || (parentCast.NewType != resultType)) &&                       ((parentReinterpret == null) || (parentReinterpret.NewType != resultType))                  ) {                      var cast = CastToEnumType(boe' resultType);                        ParentNode.ReplaceChild(boe' cast);                      VisitReplacement(cast);                  }              } else if (                  leftIsEnum &&                  ((replacement = DeconstructMutationAssignment(boe' TypeSystem' TypeSystem.Int32)) != null)              ) {                  ParentNode.ReplaceChild(boe' replacement);                  VisitReplacement(replacement);                  return;              }
Magic Number,JSIL.Transforms,OptimizeArrayEnumerators,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The following statement contains a magic number: if (                  (condInvocation != null) &&                   (condInvocation.JSMethod != null) &&                  (condInvocation.JSMethod.Identifier == "MoveNext") &&                  (condInvocation.JSMethod.Method.DeclaringType.Interfaces.ToEnumerable().Any((ii) => ii.Info.FullName == "System.Collections.IEnumerator")) &&                  ((enumeratorVariable = condInvocation.ThisReference as JSVariable) != null)              ) {                  var enumeratorType = condInvocation.JSMethod.Method.DeclaringType;                    while (EnableEnumeratorRemoval) {                      var enumeratorAssignmentBeforeLoop = (                          from boe in SeenAssignments                          let boeLeftVar = (boe.Left as JSVariable)                          where (boeLeftVar != null) && (boeLeftVar.Name == enumeratorVariable.Name)                          select boe                      ).LastOrDefault();                        if (enumeratorAssignmentBeforeLoop == null)                          break;                        var enumeratorValue = enumeratorAssignmentBeforeLoop.Right;                      var assignmentInvocation = enumeratorValue as JSInvocationExpression;                      if (assignmentInvocation == null) {                          var rre = enumeratorValue as JSResultReferenceExpression;                          if (rre != null)                              assignmentInvocation = rre.Referent as JSInvocationExpression;                      }                        if (assignmentInvocation == null)                          break;                        var jsm = assignmentInvocation.JSMethod;                      if (jsm == null)                          break;                        var attrParams2 = jsm.Method.Metadata.GetAttributeParameters("JSIL.Meta.JSUnderlyingArray");                      if (attrParams2 != null) {                          var arrayMember = (string)attrParams2[0].Value;                          var lengthMember = (string)attrParams2[1].Value;                            var replacement = ReplaceWhileLoopAndEnumerator(                              wl' assignmentInvocation.ThisReference'                               condInvocation.ThisReference' condInvocation.JSMethod.Method.DeclaringType'                              arrayMember' lengthMember                          );                          ParentNode.ReplaceChild(wl' replacement);                            EnumeratorsToKill.Add(enumeratorVariable);                            VisitReplacement(replacement);                            return;                      }                        break;                  }                    var attrParams = enumeratorType.Metadata.GetAttributeParameters("JSIL.Meta.JSIsArrayEnumerator");                    if (attrParams != null) {                      var arrayMember = (string)attrParams[0].Value;                      var indexMember = (string)attrParams[1].Value;                      var lengthMember = (string)attrParams[2].Value;                        var replacement = ReplaceWhileLoop(                          wl' condInvocation.ThisReference' condInvocation.JSMethod.Method.DeclaringType'                          arrayMember' indexMember' lengthMember                      );                      ParentNode.ReplaceChild(wl' replacement);                        VisitReplacement(replacement);                        return;                  }              }
Magic Number,JSIL.Transforms,StaticAnalyzer,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,The following statement contains a magic number: if (                  (ParentNode is JSPassByReferenceExpression) ||                  (                      (ParentNode is JSReferenceExpression) &&                      (Stack.Skip(2).FirstOrDefault() is JSPassByReferenceExpression)                  )              ) {                  State.VariablesPassedByRef.Add(variable.Name);              }
Magic Number,JSIL.Transforms,FunctionAnalysis2ndPass,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FunctionAnalysis2ndPass,The following statement contains a magic number: if (parms != null) {                  ModifiedVariables = new HashSet<string>();                  foreach (var p in parms) {                      var s = p.Value as string;                      if (s != null)                          ModifiedVariables.Add(s);                  }              } else {                  ModifiedVariables = new HashSet<string>();                    foreach (var kvp in data.ModificationCount) {                      var isParameter = parameterNames.Contains(kvp.Key);                        if (                          kvp.Value >=                           (isParameter                               ? 1                               : 2                          )                      ) {                          ModifiedVariables.Add(kvp.Key);                      }                  }                    if (TraceModifications && (ModifiedVariables.Count > 0))                      Console.WriteLine("Tagged variables as modified due to modification count: {0}"' String.Join("' "' ModifiedVariables));                    foreach (var v in Data.VariablesPassedByRef) {                      if (TraceModifications)                          Console.WriteLine("Tagging variable '{0}' as modified because it is passed byref"' v);                        ModifiedVariables.Add(v);                  }                    foreach (var invocation in Data.Invocations) {                      if (invocation.Method != null)                          invocationSecondPass = functionCache.GetSecondPass(invocation.Method' Data.Identifier);                      else                          invocationSecondPass = null;                        foreach (var invocationKvp in invocation.ThisAndVariables) {                          if (invocationKvp.Value.Count == 0)                              continue;                            bool modified;                            if (invocationSecondPass != null) {                              modified = invocationSecondPass.IsVariableModified(invocationKvp.Key);                          } else {                              modified = true;                          }                            if (                              (invocationKvp.Value.Count == 1)                               && modified                          ) {                              var relevantVariable = invocationKvp.Value.Array[invocationKvp.Value.Offset];                                if (TraceModifications)                                  Console.WriteLine("Parameter '{0}::{1}' modified; flagging variable '{2}'"' GetMethodName(invocation.Method)' invocationKvp.Key' relevantVariable);                                ModifiedVariables.Add(relevantVariable);                          }                      }                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The following statement contains a magic number: if (v != null) {                  // Ensure that we never treat a local variable as constant if functions we call allow it to escape                  //  or modify it' because that can completely invalidate our purity analysis.                  if (VariablesExemptedFromEffectivelyConstantStatus.Contains(v.Identifier))                      return false;                    var sourceAssignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  if (sourceAssignments.Length < 1)                      return v.IsParameter;                    var sourceAccesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  if (sourceAccesses.Length < 1)                      return false;                    var targetAssignmentIndices = (from a in FirstPass.Assignments where target.Identifier.Equals(a.Target) select a.StatementIndex);                  var targetAccessIndices = (from a in FirstPass.Accesses where target.Identifier.Equals(a.Source) select a.StatementIndex).ToArray();                  var targetUseIndices = targetAccessIndices.Concat(targetAssignmentIndices).ToArray();                    if (sourceAssignments.Length == 1) {                      if (targetAccessIndices.All((tai) => tai > sourceAssignments[0].StatementIndex))                          return true;                  }                    var sourceFirstAssigned = sourceAssignments.First();                  var sourceLastAssigned = sourceAssignments.Last();                    var sourceFirstAccessed = sourceAccesses.First();                  var sourceLastAccessed = sourceAccesses.Last();                    bool foundAssignmentSlot = false;                    for (int i = 0' c = targetUseIndices.Length; i < c; i++) {                      int assignment = targetUseIndices[i]' nextAssignment = int.MaxValue;                      if (i < c - 1)                          nextAssignment = targetUseIndices[i + 1];                        if (                          (sourceFirstAssigned.StatementIndex >= assignment) &&                          (sourceLastAssigned.StatementIndex < nextAssignment) &&                          (sourceFirstAccessed.StatementIndex >= assignment) &&                          (sourceLastAccessed.StatementIndex <= nextAssignment)                      ) {                          if (TraceLevel >= 5)                              Console.WriteLine("Found assignment slot for {0} <- {1} between {2} and {3}"' target' source' assignment' nextAssignment);                            foundAssignmentSlot = true;                          break;                      }                  }                    if (!foundAssignmentSlot)                      return false;                    return true;              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,ExemptVariablesFromEffectivelyConstantStatus,The following statement contains a magic number: foreach (var invocation in FirstPass.Invocations) {                  var invocationSecondPass = GetSecondPass(invocation.Method);                    if (invocationSecondPass == null) {                      foreach (var kvp in invocation.ThisAndVariables) {                          foreach (var variableName in kvp.Value.ToEnumerable()) {                              if (!VariablesExemptedFromEffectivelyConstantStatus.Contains(variableName)) {                                  if (TraceLevel >= 2)                                      Console.WriteLine("Exempting variable '{0}' from effectively constant status because it is passed to {1} (no static analysis data)"' variableName' invocation.Method ?? invocation.NonJSMethod);                              }                                VariablesExemptedFromEffectivelyConstantStatus.Add(variableName);                          }                      }                    } else {                        foreach (var kvp in invocation.ThisAndVariables) {                          var argumentName = kvp.Key;                          string reason = null;                            if (                              (invocationSecondPass.Data != null) &&                              invocationSecondPass.Data.SideEffects.Any((se) => se.Variable == argumentName)                          ) {                              reason = "touches it with side effects";                          } else if (                              // FIXME: Should this include return?                              invocationSecondPass.DoesVariableEscape(argumentName' false)                          ) {                              reason = "allows it to escape";                          }                            if (reason != null) {                              foreach (var variableName in kvp.Value.ToEnumerable()) {                                  if (ShouldExemptVariableFromEffectivelyConstantStatus(variableName)) {                                      if (!VariablesExemptedFromEffectivelyConstantStatus.Contains(variableName)) {                                          if (TraceLevel >= 2)                                              Console.WriteLine("Exempting variable '{0}' from effectively constant status because {1} {2}"' variableName' invocation.Method ?? invocation.NonJSMethod' reason);                                      }                                        VariablesExemptedFromEffectivelyConstantStatus.Add(variableName);                                  }                              }                            }                      }                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,ExemptVariablesFromEffectivelyConstantStatus,The following statement contains a magic number: foreach (var invocation in FirstPass.Invocations) {                  var invocationSecondPass = GetSecondPass(invocation.Method);                    if (invocationSecondPass == null) {                      foreach (var kvp in invocation.ThisAndVariables) {                          foreach (var variableName in kvp.Value.ToEnumerable()) {                              if (!VariablesExemptedFromEffectivelyConstantStatus.Contains(variableName)) {                                  if (TraceLevel >= 2)                                      Console.WriteLine("Exempting variable '{0}' from effectively constant status because it is passed to {1} (no static analysis data)"' variableName' invocation.Method ?? invocation.NonJSMethod);                              }                                VariablesExemptedFromEffectivelyConstantStatus.Add(variableName);                          }                      }                    } else {                        foreach (var kvp in invocation.ThisAndVariables) {                          var argumentName = kvp.Key;                          string reason = null;                            if (                              (invocationSecondPass.Data != null) &&                              invocationSecondPass.Data.SideEffects.Any((se) => se.Variable == argumentName)                          ) {                              reason = "touches it with side effects";                          } else if (                              // FIXME: Should this include return?                              invocationSecondPass.DoesVariableEscape(argumentName' false)                          ) {                              reason = "allows it to escape";                          }                            if (reason != null) {                              foreach (var variableName in kvp.Value.ToEnumerable()) {                                  if (ShouldExemptVariableFromEffectivelyConstantStatus(variableName)) {                                      if (!VariablesExemptedFromEffectivelyConstantStatus.Contains(variableName)) {                                          if (TraceLevel >= 2)                                              Console.WriteLine("Exempting variable '{0}' from effectively constant status because {1} {2}"' variableName' invocation.Method ?? invocation.NonJSMethod' reason);                                      }                                        VariablesExemptedFromEffectivelyConstantStatus.Add(variableName);                                  }                              }                            }                      }                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,C:\repos\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: foreach (var v in fn.AllVariables.Values.ToArray()) {                  if (v.IsThis || v.IsParameter)                      continue;                    var assignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.Target) select a).ToArray();                  var reassignments = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  var accesses = (from a in FirstPass.Accesses where v.Identifier.Equals(a.Source) select a).ToArray();                  var invocations = (from i in FirstPass.Invocations where v.Name == i.ThisVariable select i).ToArray();                  var unsafeInvocations = FilterInvocations(invocations);                  var isPassedByReference = FirstPass.VariablesPassedByRef.Contains(v.Name);                    if (assignments.FirstOrDefault() == null) {                      if ((accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference) {                          if (TraceLevel >= 1)                              Console.WriteLine("Eliminating {0} because it is never used."' v);                            if (!DryRun) {                              EliminatedVariables.Add(v);                              EliminateVariable(fn' v' new JSEliminatedVariable(v)' fn.Method.QualifiedIdentifier);                                // We've invalidated the static analysis data so the best choice is to abort.                              break;                          }                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Never found an initial assignment for {0}."' v);                      }                        continue;                  }                    var valueType = v.GetActualType(TypeSystem);                  if (TypeUtil.IsIgnoredType(valueType))                      continue;                    if (FirstPass.VariablesPassedByRef.Contains(v.Name)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is passed by reference."' v);                        continue;                  }                    if (unsafeInvocations.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; methods are invoked on it multiple times that are not provably safe."' v);                        continue;                  }                    if ((from a in accesses where a.IsControlFlow select a).FirstOrDefault() != null) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it participates in control flow."' v);                        continue;                  }                    if (assignments.Length > 1) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it is reassigned."' v);                        continue;                  }                    var replacementAssignment = assignments.First();                  var replacement = replacementAssignment.NewValue;                  if (replacement.SelfAndChildrenRecursive.Contains(v)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains a self-reference."' v);                        continue;                  }                    if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; it contains an assignment."' v);                        continue;                  }                    var copies = (from a in FirstPass.Assignments where v.Identifier.Equals(a.SourceVariable) select a).ToArray();                  if (                      (copies.Length + accesses.Length) > 1                  ) {                      if (CanSkipUsageVeto(replacement)) {                          if (TraceLevel >= 5)                              Console.WriteLine("Skipping veto of elimination for {0} because it is a literal."' v);                      } else {                          if (TraceLevel >= 2)                              Console.WriteLine("Cannot eliminate {0}; it is used multiple times."' v);                            continue;                      }                  }                    if (!IsEffectivelyConstant(v' replacement)) {                      if (TraceLevel >= 2)                          Console.WriteLine("Cannot eliminate {0}; {1} is not a constant expression."' v' replacement);                        continue;                  }                    var replacementField = JSPointerExpressionUtil.UnwrapExpression(replacement) as JSFieldAccess;                  if (replacementField == null) {                      var replacementRef = replacement as JSReferenceExpression;                      if (replacementRef != null)                          replacementField = replacementRef.Referent as JSFieldAccess;                  }                    var _affectedFields = replacement.SelfAndChildrenRecursive.OfType<JSField>();                  if (replacementField != null)                      _affectedFields = _affectedFields.Concat(new[] { replacementField.Field });                    var affectedFields = new HashSet<FieldInfo>((from jsf in _affectedFields select jsf.Field));                  _affectedFields = null;                    if ((affectedFields.Count > 0) || (replacementField != null))                  {                      var firstAssignment = assignments.FirstOrDefault();                      var lastAccess = accesses.LastOrDefault();                        bool invalidatedByLaterFieldAccess = false;                        foreach (var fieldAccess in FirstPass.FieldAccesses) {                          // Note that we only compare the FieldInfo' not the this-reference.                          // Otherwise' aliasing (accessing the same field through two this references) would cause us                          //  to incorrectly eliminate a local.                          if (!affectedFields.Contains(fieldAccess.Field.Field))                              continue;                            // Ignore field accesses before the replacement was initialized                          if (fieldAccess.NodeIndex <= replacementAssignment.NodeIndex)                              continue;                            // If the field access comes after the last use of the temporary' we don't care                          if ((lastAccess != null) && (fieldAccess.StatementIndex > lastAccess.StatementIndex))                              continue;                            // It's a read' so no impact on whether this optimization is valid                          if (fieldAccess.IsRead)                              continue;                            // If the field is initonly/immutable it can't change                          if (fieldAccess.Field.Field.IsImmutable)                              continue;                            if (TraceLevel >= 2)                              Console.WriteLine(String.Format("Cannot eliminate {0}; {1} is potentially mutated later"' v' fieldAccess.Field.Field));                            invalidatedByLaterFieldAccess = true;                          break;                      }                        if (invalidatedByLaterFieldAccess)                          continue;                        foreach (var invocation in FirstPass.Invocations) {                          // If the invocation comes after (or is) the last use of the temporary' we don't care                          if ((lastAccess != null) && (invocation.StatementIndex >= lastAccess.StatementIndex))                              continue;                            // Same goes for the first assignment.                          if ((firstAssignment != null) && (invocation.StatementIndex <= firstAssignment.StatementIndex))                              continue;                            var invocationSecondPass = GetSecondPass(invocation.Method);                          if (                              (invocationSecondPass == null) ||                              (invocationSecondPass.MutatedFields == null)                          ) {                              if (invocation.ThisAndVariables.Any((kvp) => kvp.Value.ToEnumerable().Contains(v.Identifier))) {                                  if (TraceLevel >= 2)                                      Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod));                                    invalidatedByLaterFieldAccess = true;                              }                          } else if (affectedFields.Any(invocationSecondPass.FieldIsMutatedRecursively)) {                              if (TraceLevel >= 2)                                  Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod));                                invalidatedByLaterFieldAccess = true;                          }                      }                        if (invalidatedByLaterFieldAccess)                          continue;                  }                    if (TraceLevel >= 1)                      Console.WriteLine(String.Format("Eliminating {0} <- {1}"' v' replacement));                    if (!DryRun) {                      EliminatedVariables.Add(v);                      EliminateVariable(fn' v' replacement' fn.Method.QualifiedIdentifier);                        // We've invalidated the static analysis data so the best choice is to abort.                      break;                  }              }
Magic Number,JSIL.Transforms,IntroduceVariableDeclarations,C:\repos\sq_JSIL\JSIL\Transforms\IntroduceVariableDeclarations.cs,VisitNode,The following statement contains a magic number: if (                  (leftVar != null) && isAssignment && !leftVar.IsParameter              ) {                  if (ToDeclare.Contains(leftVar) && !CouldntDeclare.Contains(leftVar) && !SeenAlready.Contains(leftVar)) {                      var superParent = Stack.Skip(2).FirstOrDefault();                      if ((superParent != null) && (ParentNode is JSStatement)) {                          ToDeclare.Remove(leftVar);                          ToReplace.Add(new KeyValuePair<JSNode' JSNode>(ParentNode' new JSVariableDeclarationStatement(boe)));                            VisitChildren(boe);                          return;                      } else {                          CouldntDeclare.Add(leftVar);                      }                  }              }
Missing Default,JSIL,JavascriptAssemblyEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitPrimitiveDefinition,The following switch statement is missing a default case: switch (typedef.FullName) {                  case "System.Boolean":                      isIntegral = true;                      isNumeric = true;                      break;                  case "System.Char":                      isIntegral = true;                      isNumeric = true;                      break;                  case "System.Byte":                  case "System.SByte":                  case "System.UInt16":                  case "System.Int16":                  case "System.UInt32":                  case "System.Int32":                  case "System.UInt64":                  case "System.Int64":                      isIntegral = true;                      isNumeric = true;                      break;                  case "System.Single":                  case "System.Double":                  case "System.Decimal":                      isIntegral = false;                      isNumeric = true;                      break;              }
Missing Default,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationPrefixForType,The following switch statement is missing a default case: switch (type.FullName) {                  case "System.Byte":                      parenCount = 1;                      break;                    case "System.SByte":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt16":                      parenCount = 1;                      break;                    case "System.Int16":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt32":                      parenCount = 1;                      break;                    case "System.Int32":                      parenCount = 1;                      break;                    case "System.Single":                      // fround only affects locals at present.                      // FIXME: Does this mean a forced float->double upconvert when it could be omitted by the VM?                      if (isLoad)                          Output.WriteRaw("+");                      else if (targetIsLocal)                          Output.WriteRaw("Math.fround(");                      else                          Output.WriteRaw("+(");                        return;                    case "System.Double":                      if (isLoad)                          Output.WriteRaw("+");                      else                          Output.WriteRaw("+(");                      return;              }
Missing Default,JSIL,JavascriptAstEmitter,C:\repos\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationForType,The following switch statement is missing a default case: switch (type.FullName) {                  case "System.Byte":                      if (isLoad)                          Output.WriteRaw(" | 0)");                      else                          Output.WriteRaw(" & 0xFF)");                      break;                    case "System.SByte":                      if (isLoad)                          Output.WriteRaw(" | 0)");                      else                          Output.WriteRaw(" + 0x80 & 0xFF) - 0x80)");                      break;                    case "System.UInt16":                      if (isLoad)                          Output.WriteRaw(" | 0)");                      else                          Output.WriteRaw(" & 0xFFFF)");                      break;                    case "System.Int16":                      if (isLoad)                          Output.WriteRaw(" | 0)");                      else                          Output.WriteRaw(" + 0x8000 & 0xFFFF) - 0x8000)");                      break;                    case "System.UInt32":                      Output.WriteRaw(" >>> 0)");                      break;                    case "System.Int32":                      Output.WriteRaw(" | 0)");                      break;                    case "System.Single":                      // fround only affects locals at present.                      // FIXME: Does this mean a forced float->double upconvert when it could be omitted by the VM?                      if (isLoad)                          return;                      else if (targetIsLocal)                          Output.WriteRaw(")");                      else                          Output.WriteRaw(")");                        return;                    case "System.Double":                      if (isLoad)                          return;                      else                          Output.WriteRaw(")");                      return;              }
Missing Default,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILBuiltinsMethodReplacement,The following switch statement is missing a default case: switch (methodName) {                  case "CreateNamedFunction`1": {                      JSExpression closureArg = null;                      if (arguments.Length > 3)                          closureArg = arguments[3];                        return JSIL.CreateNamedFunction(                          genericArguments.First()' arguments[0]' arguments[1]' arguments[2]' closureArg                      );                  }                    case "Eval":                      return JSInvocationExpression.InvokeStatic(                          JS.eval' arguments                      );                    case "IsTruthy":                      return new JSUnaryOperatorExpression(                          JSOperator.LogicalNot'                           new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean)'                           TypeSystem.Boolean                      );                    case "IsFalsy":                      return new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean);                    case "get_This":                      return MakeIndirectVariable("this");                    case "get_IsJavascript":                      return new JSBooleanLiteral(true);              }
Missing Default,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The following switch statement is missing a default case: switch (typeName) {                  case "JSIL.Builtins":                      return DoJSILBuiltinsMethodReplacement(methodName' genericArguments' arguments' method == null);                    case "JSIL.Verbatim": {                      if (                          (methodName == "Expression") || methodName.StartsWith("Expression`")                      ) {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSIL.Verbatim.Expression must recieve a string literal as an argument");                            JSExpression commaFirstClause = null;                          IDictionary<string' JSExpression> argumentsDict = null;                            if (arguments.Length > 1) {                              var argumentsExpression = arguments[1];                              var argumentsArray = argumentsExpression as JSNewArrayExpression;                                if (method == null || method.Method.Parameters[1].ParameterType is GenericParameter) {                                  // This call was made dynamically or through generic version of method' so the parameters are not an array.                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < (arguments.Length - 1); i++)                                      argumentsDict.Add(String.Format("{0}"' i)' arguments[i + 1]);                              } else if (argumentsArray == null) {                                  // The array is static so we need to pull elements out of it after assigning it a name.                                  // FIXME: Only handles up to 40 elements.                                  var argumentsExpressionType = argumentsExpression.GetActualType(TypeSystem);                                  var temporaryVariable = MakeTemporaryVariable(argumentsExpressionType);                                  var temporaryAssignment = new JSBinaryOperatorExpression(JSOperator.Assignment' temporaryVariable' argumentsExpression' argumentsExpressionType);                                    commaFirstClause = temporaryAssignment;                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < 40; i++)                                      argumentsDict.Add(String.Format("{0}"' i)' new JSIndexerExpression(temporaryVariable' JSLiteral.New(i)));                              } else {                                  var argumentsArrayExpression = argumentsArray.SizeOrArrayInitializer as JSArrayExpression;                                    if (argumentsArrayExpression == null)                                      throw new NotImplementedException("Literal array must have values");                                    argumentsDict = new Dictionary<string' JSExpression>();                                    int i = 0;                                  foreach (var value in argumentsArrayExpression.Values) {                                      argumentsDict.Add(String.Format("{0}"' i)' value);                                        i += 1;                                  }                              }                          }                            var verbatimLiteral = new JSVerbatimLiteral(                              methodName' expression.Value' argumentsDict                          );                            if (commaFirstClause != null)                              return new JSCommaExpression(commaFirstClause' verbatimLiteral);                          else                              return verbatimLiteral;                      } else {                          throw new NotImplementedException("Verbatim method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSGlobal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression != null)                              return new JSDotExpression(                                  JSIL.GlobalNamespace' new JSStringIdentifier(expression.Value' TypeSystem.Object' true)                              );                          else                              return new JSIndexerExpression(                                  JSIL.GlobalNamespace' arguments[0]' TypeSystem.Object                              );                      } else {                          throw new NotImplementedException("JSGlobal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSLocal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSLocal must recieve a string literal as an index");                            return new JSStringIdentifier(expression.Value' TypeSystem.Object' true);                      } else {                          throw new NotImplementedException("JSLocal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.Services": {                      if (methodName == "Get") {                          if (arguments.Length != 2)                              throw new InvalidOperationException("JSIL.Services.Get must receive two arguments");                            var serviceName = arguments[0];                          var shouldThrow = arguments[1];                            return JSInvocationExpression.InvokeStatic(                              new JSRawOutputIdentifier(TypeSystem.Object' "JSIL.Host.getService")'                              new[] {                                  serviceName'                                  new JSUnaryOperatorExpression(JSOperator.LogicalNot' shouldThrow' TypeSystem.Boolean)                              }' true                          );                      } else {                          throw new NotImplementedException("JSIL.Services method not implemented: " + methodName);                      }                      break;                  }              }
Missing Default,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoNonJSILMethodReplacement,The following switch statement is missing a default case: switch (method.Method.Member.FullName) {                  // Doing this replacement here enables more elimination of temporary variables                  case "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)":                  case "System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle)":                  case "System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle'System.RuntimeTypeHandle)":                  case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle)":                  case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)":                      return arguments.First();              }
Missing Default,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,DoPropertyReplacement,The following switch statement is missing a default case: switch (method.Method.Name) {                      case "get_HasValue":                          return JSIL.NullableHasValue(thisExpression);                        case "get_Value":                          return JSIL.ValueOfNullable(thisExpression);                  }
Missing Default,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Mul,The following switch statement is missing a default case: switch (outputType.FullName) {                          case "System.UInt32":                              return new JSUInt32MultiplyExpression(                                  left' right' TypeSystem                              );                            case "System.Int32":                              return new JSInt32MultiplyExpression(                                  left' right' TypeSystem                              );                      }
Missing Default,JSIL,ILBlockTranslator,C:\repos\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_IntegerConstantCore,The following switch statement is missing a default case: switch (ilCode) {                  case ILCode.Ldc_I4:                      if (isUnsigned)                          return new JSIntegerLiteral((uint)((int)value)' typeof(uint));                      else                          return new JSIntegerLiteral(value' typeof(int));                    case ILCode.Ldc_I8:                      if (isUnsigned)                          return new JSIntegerLiteral(value' typeof(ulong));                      else                          return new JSIntegerLiteral(value' typeof(long));              }
Missing Default,JSIL,TypeUtil,C:\repos\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following switch statement is missing a default case: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Missing Default,JSIL,TypeInfoProvider,C:\repos\sq_JSIL\JSIL\TypeInfoProvider.cs,_MakeProxiesByFullName,The following switch statement is missing a default case: switch (arg.Type.FullName) {                      case "System.Type": {                              proxyTargets = new ArraySegment<string>(new string[] {                                   ((TypeReference)arg.Value).FullName                              });                                break;                          }                      case "System.Type[]": {                              var values = (CustomAttributeArgument[])arg.Value;                              proxyTargets = new ArraySegment<string>((from v in values select ((TypeReference)v.Value).FullName)                                  .ToArray());                                break;                          }                      case "System.String": {                              proxyTargets = new ArraySegment<string>(new string[] {                                   (string)arg.Value                              });                                break;                          }                      case "System.String[]": {                              var values = (CustomAttributeArgument[])arg.Value;                              proxyTargets = new ArraySegment<string>((from v in values select (string)v.Value)                                  .ToArray());                                break;                          }                  }
Missing Default,JSIL.Ast,JSPointerExpressionUtil,C:\repos\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetNativeSizeOfElement,The following switch statement is missing a default case: switch (elementType.FullName) {                  case "System.Byte":                  case "System.SByte":                      return 1;                    case "System.Int16":                  case "System.UInt16":                      return 2;                    case "System.Int32":                  case "System.UInt32":                  case "System.Single":                      return 4;                    case "System.Int64":                  case "System.UInt64":                  case "System.Double":                      return 8;              }
Missing Default,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,GetContainingAssemblyName,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {                  case MetadataScopeType.AssemblyNameReference:                      return ((AssemblyNameReference)scope).FullName;                  case MetadataScopeType.ModuleReference:                      throw new NotImplementedException("Module references not implemented");                  case MetadataScopeType.ModuleDefinition:                      var assembly = ((ModuleDefinition)scope).Assembly;                      if (assembly != null)                          return assembly.FullName;                      else                          return "<Assembly Not Loaded>";              }
Missing Default,JSIL.Internal,JavascriptFormatter,C:\repos\sq_JSIL\JSIL\JavascriptFormatter.cs,DefaultValue,The following switch statement is missing a default case: switch (fullName) {                  case "System.Nullable`1":                      WriteRaw("null");                      return;                  case "System.Single":                  case "System.Double":                  case "System.Decimal":                      Value(0.0);                      return;              }
Missing Default,JSIL.Internal,MemberInfo<T>,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,MemberInfo,The following switch statement is missing a default case: switch (param.Type.FullName) {                          case "JSIL.Meta.JSReadPolicy":                              _ReadPolicy = (JSReadPolicy)param.Value;                          break;                          case "JSIL.Meta.JSWritePolicy":                              _WritePolicy = (JSWritePolicy)param.Value;                          break;                          case "JSIL.Meta.JSInvokePolicy":                              _InvokePolicy = (JSInvokePolicy)param.Value;                          break;                      }
Missing Default,JSIL.Internal,PolicyExtensions,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,ApplyReadPolicy,The following switch statement is missing a default case: switch (member.ReadPolicy) {                  case JSReadPolicy.ReturnDefaultValue:                      result = new JSDefaultValueLiteral(member.ReturnType);                      return true;                  case JSReadPolicy.LogWarning:                  case JSReadPolicy.ThrowError:                      result = new JSIgnoredMemberReference(member.ReadPolicy == JSReadPolicy.ThrowError' member' thisExpression);                      return true;              }
Missing Default,JSIL.Internal,PolicyExtensions,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,ApplyWritePolicy,The following switch statement is missing a default case: switch (member.WritePolicy) {                  case JSWritePolicy.DiscardValue:                      result = new JSNullExpression();                      return true;                  case JSWritePolicy.LogWarning:                  case JSWritePolicy.ThrowError:                      result = new JSIgnoredMemberReference(member.WritePolicy == JSWritePolicy.ThrowError' member' thisExpression' newValue);                      return true;              }
Missing Default,JSIL.Internal,PolicyExtensions,C:\repos\sq_JSIL\JSIL\TypeInformation.cs,ApplyInvokePolicy,The following switch statement is missing a default case: switch (member.InvokePolicy) {                  case JSInvokePolicy.ReturnDefaultValue:                      result = new JSDefaultValueLiteral(member.ReturnType);                      return true;                  case JSInvokePolicy.LogWarning:                  case JSInvokePolicy.ThrowError:                      result = new JSIgnoredMemberReference(member.InvokePolicy == JSInvokePolicy.ThrowError' member' new[] { thisExpression }.Concat(parameters).ToArray());                      return true;              }
Missing Default,JSIL.Threading,TrackedLock,C:\repos\sq_JSIL\JSIL\Threading.cs,BlockingEnter,The following switch statement is missing a default case: switch (result.FailureReason) {                      case TrackedLockFailureReason.HeldByCurrentThread:                          throw new LockAlreadyHeldException();                      case TrackedLockFailureReason.Deadlock:                          throw new DeadlockAvertedException(deadlock.A' deadlock.B);                  }
Missing Default,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following switch statement is missing a default case: switch (method.Method.Member.Name) {                          case ".ctor": {                              var replacement = new JSNullExpression();                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "ReferenceEquals": {                              var lhs = ie.Arguments[0];                              var rhs = ie.Arguments[1];                                var lhsType = lhs.GetActualType(TypeSystem);                              var rhsType = rhs.GetActualType(TypeSystem);                                JSNode replacement;                                // Structs can never compare equal with ReferenceEquals                              if (TypeUtil.IsStruct(lhsType) || TypeUtil.IsStruct(rhsType))                                  replacement = JSLiteral.New(false);                              else                                  replacement = new JSBinaryOperatorExpression(                                      JSOperator.Equal'                                      lhs' rhs'                                      TypeSystem.Boolean                                  );                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "GetType": {                              JSNode replacement;                                var thisType = JSExpression.DeReferenceType(thisExpression.GetActualType(TypeSystem)' false);                              if ((thisType is GenericInstanceType) && thisType.FullName.StartsWith("System.Nullable")) {                                  var git = (GenericInstanceType)thisType;                                    replacement = new JSTernaryOperatorExpression(                                      new JSBinaryOperatorExpression(                                          JSOperator.NotEqual'                                          thisExpression' new JSNullLiteral(thisType)'                                          TypeSystem.Boolean                                      )'                                      new JSTypeOfExpression(git.GenericArguments[0])'                                      JSIL.ThrowNullReferenceException()'                                      TypeSystem.SystemType()                                  );                              } else {                                  replacement = JSIL.GetTypeOf(thisExpression);                              }                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }
Missing Default,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following switch statement is missing a default case: switch (method.Method.Member.Name) {                          case "Equals": {                              var replacement = JSIL.StructEquals(ie.ThisReference' ie.Arguments.First());                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }
Missing Default,JSIL.Transforms,ReplaceMethodCalls,C:\repos\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following switch statement is missing a default case: switch (method.Reference.Name) {                          case "GetExecutingAssembly": {                              var assembly = Method.DeclaringType.Module.Assembly;                              var asmNode = new JSReflectionAssembly(assembly);                              ParentNode.ReplaceChild(ie' asmNode);                              VisitReplacement(asmNode);                                return;                          }                      }
