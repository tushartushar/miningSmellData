Implementation smell,Namespace,Class,File,Method,Description
Long Method,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The method has 115 lines of code.
Long Method,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,BeginEmitTypeDefinition,The method has 110 lines of code.
Long Method,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitCachedValues,The method has 121 lines of code.
Long Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The method has 124 lines of code.
Long Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The method has 170 lines of code.
Long Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp_Pointer,The method has 106 lines of code.
Long Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The method has 103 lines of code.
Long Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,The method has 113 lines of code.
Long Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_CompoundAssignment,The method has 126 lines of code.
Long Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,The method has 103 lines of code.
Long Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,The method has 121 lines of code.
Long Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateField,The method has 100 lines of code.
Long Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The method has 232 lines of code.
Long Method,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,TypesAreEqual,The method has 108 lines of code.
Long Method,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,TypeReferenceInternal,The method has 105 lines of code.
Long Method,JSIL.Internal,TypeInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,The method has 206 lines of code.
Long Method,JSIL.Internal,Util,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,EscapeIdentifier,The method has 146 lines of code.
Long Method,JSIL.Transforms,ExpandCastExpressions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,The method has 195 lines of code.
Long Method,JSIL.Transforms,ReplaceMethodCalls,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The method has 241 lines of code.
Long Method,JSIL.Transforms,SimplifyLoops,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\SimplifyLoops.cs,VisitNode,The method has 119 lines of code.
Long Method,JSIL.Transforms,FunctionAnalysis2ndPass,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FunctionAnalysis2ndPass,The method has 220 lines of code.
Long Method,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The method has 116 lines of code.
Long Method,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The method has 163 lines of code.
Complex Method,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInstance,Cyclomatic complexity of the method is 8
Complex Method,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,Cyclomatic complexity of the method is 19
Complex Method,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitInterfaceDefinition,Cyclomatic complexity of the method is 13
Complex Method,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitCustomAttributes,Cyclomatic complexity of the method is 8
Complex Method,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitMethodDefinition,Cyclomatic complexity of the method is 8
Complex Method,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitPInvokeInfo,Cyclomatic complexity of the method is 13
Complex Method,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,BeginEmitTypeDefinition,Cyclomatic complexity of the method is 14
Complex Method,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitCachedValues,Cyclomatic complexity of the method is 12
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationPrefixForType,Cyclomatic complexity of the method is 14
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationForType,Cyclomatic complexity of the method is 15
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,Cyclomatic complexity of the method is 11
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,Cyclomatic complexity of the method is 12
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,NeedParensForBinaryOperator,Cyclomatic complexity of the method is 12
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,Cyclomatic complexity of the method is 14
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,CountOfMatchingSubtrees,Cyclomatic complexity of the method is 8
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,CanUseFastOverloadDispatch,Cyclomatic complexity of the method is 8
Complex Method,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,Cyclomatic complexity of the method is 24
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,ILBlockTranslator,Cyclomatic complexity of the method is 9
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate,Cyclomatic complexity of the method is 8
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp_Pointer,Cyclomatic complexity of the method is 22
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp,Cyclomatic complexity of the method is 13
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,HandleJSReplacement,Cyclomatic complexity of the method is 10
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,Cyclomatic complexity of the method is 21
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_PropertyCall,Cyclomatic complexity of the method is 9
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,Cyclomatic complexity of the method is 12
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,Cyclomatic complexity of the method is 13
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,Cyclomatic complexity of the method is 11
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_CompoundAssignment,Cyclomatic complexity of the method is 24
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Stloc,Cyclomatic complexity of the method is 10
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Stobj,Cyclomatic complexity of the method is 8
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_LoadIntegerConstant,Cyclomatic complexity of the method is 9
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Conv,Cyclomatic complexity of the method is 13
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Newobj,Cyclomatic complexity of the method is 9
Complex Method,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,NeedsExplicitThis,Cyclomatic complexity of the method is 9
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,AssemblyTranslator,Cyclomatic complexity of the method is 9
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,LoadAssembly,Cyclomatic complexity of the method is 12
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,Cyclomatic complexity of the method is 14
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,DoProxyDiagnostics,Cyclomatic complexity of the method is 15
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,DeclareType,Cyclomatic complexity of the method is 13
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,EmitTypeMethodExpressions,Cyclomatic complexity of the method is 12
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeDefinition,Cyclomatic complexity of the method is 8
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,Cyclomatic complexity of the method is 13
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateField,Cyclomatic complexity of the method is 15
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,Cyclomatic complexity of the method is 23
Complex Method,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,ShouldTranslateMethodBody,Cyclomatic complexity of the method is 9
Complex Method,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,IsReferenceType,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,IsStruct,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,Cyclomatic complexity of the method is 9
Complex Method,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,IsOpenType,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,TypesAreEqual,Cyclomatic complexity of the method is 31
Complex Method,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,TypesAreAssignable,Cyclomatic complexity of the method is 11
Complex Method,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,ExpandPositionalGenericParameters,Cyclomatic complexity of the method is 12
Complex Method,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,_MakeProxiesByFullName,Cyclomatic complexity of the method is 9
Complex Method,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,AddProxyAssemblies,Cyclomatic complexity of the method is 10
Complex Method,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,EnqueueType,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,ConstructTypeInformation,Cyclomatic complexity of the method is 8
Complex Method,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,GetProxies,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Ast.Enumerators,JSNodeChildEnumerator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\Enumerators.cs,MoveNext,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Ast,JSAstVisitor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSAstVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Ast,JSAstVisitor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSAstVisitor.cs,VisitChildren,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Ast,JSReferenceExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,TryDereference,Cyclomatic complexity of the method is 16
Complex Method,JSIL.Ast,JSReferenceExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,TryMaterialize,Cyclomatic complexity of the method is 14
Complex Method,JSIL.Ast,JSArrayExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,UnpackArrayInitializer,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Ast,JSCastExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,NewInternal,Cyclomatic complexity of the method is 24
Complex Method,JSIL.Ast,JSPointerExpressionUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,OffsetFromBytesToElements,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Ast,JSIntegerLiteral,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSLiteralTypes.cs,GetActualType,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Ast,JSNode,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSNodeTypes.cs,EnsureTypeIdsAreAssigned,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Ast,JSExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSNodeTypes.cs,SubstituteTypeArgs,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Ast,JSExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSNodeTypes.cs,EqualsImpl,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Ast,JSLabelGroupStatement,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSStatementTypes.cs,ReplaceChild,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Ast.Traversal,JSNodeTraversalData,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\Traversal.cs,JSNodeTraversalData,Cyclomatic complexity of the method is 14
Complex Method,JSIL.Ast.Traversal,JSNodeTraversalData,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\Traversal.cs,MakeFieldRecord,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,Cyclomatic complexity of the method is 12
Complex Method,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,TypeReferenceInternal,Cyclomatic complexity of the method is 17
Complex Method,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,TypeReference,Cyclomatic complexity of the method is 14
Complex Method,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,TypeIdentifier,Cyclomatic complexity of the method is 13
Complex Method,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,Cyclomatic complexity of the method is 13
Complex Method,JSIL.Internal,MemberIdentifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\MemberIdentifier.cs,GetParameterTypes,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Internal,MemberIdentifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\MemberIdentifier.cs,TypesAreEqual,Cyclomatic complexity of the method is 16
Complex Method,JSIL.Internal,MemberIdentifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\MemberIdentifier.cs,Equals,Cyclomatic complexity of the method is 12
Complex Method,JSIL.Internal,MethodSignature,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\MethodSignature.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Internal,SourceMapBuilder,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,Build,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Internal,ProxyInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,ProxyInfo,Cyclomatic complexity of the method is 23
Complex Method,JSIL.Internal,ProxyInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,IsMatch,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Internal,TypeInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,Cyclomatic complexity of the method is 53
Complex Method,JSIL.Internal,MemberInfo<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,MemberInfo,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Internal,Util,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,EscapeIdentifier,Cyclomatic complexity of the method is 37
Complex Method,JSIL.Internal,Util,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,EscapeCharacter,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Translator,Configuration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,MergeInto,Cyclomatic complexity of the method is 18
Complex Method,JSIL.Translator,CodeGeneratorConfiguration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,MergeInto,Cyclomatic complexity of the method is 29
Complex Method,JSIL.Transforms,GenericTypesRewriter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,ResolveTypeReference,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,UnsafeCodeTransforms,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\UnsafeCodeTransforms.cs,ExtractOffsetFromPointerExpression,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,EmulateInt64,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\EmulateInt64.cs,GetVerb,Cyclomatic complexity of the method is 17
Complex Method,JSIL.Transforms,ConvertPropertyAccessesToInvocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ConvertPropertyAccessesToInvocations.cs,ConstructInvocation,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,ComputeRecursiveExitLabel,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,Cyclomatic complexity of the method is 14
Complex Method,JSIL.Transforms,ExpandCastExpressions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,Cyclomatic complexity of the method is 33
Complex Method,JSIL.Transforms,IntroduceCharCasts,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,Cyclomatic complexity of the method is 18
Complex Method,JSIL.Transforms,LabelEntry,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\LabelGroupBuilder.cs,EnsureLabelGroupExists,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Transforms,DeoptimizeSwitchStatements,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,Cyclomatic complexity of the method is 17
Complex Method,JSIL.Transforms,DeoptimizeSwitchStatements,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Transforms,ReplaceMethodCalls,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,Cyclomatic complexity of the method is 28
Complex Method,JSIL.Transforms,IntroduceEnumCasts,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceEnumCasts.cs,VisitNode,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,SimplifyLoops,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\SimplifyLoops.cs,VisitNode,Cyclomatic complexity of the method is 22
Complex Method,JSIL.Transforms,OptimizeArrayEnumerators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Transforms,StaticAnalyzer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Transforms,StaticAnalyzer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Transforms,StaticAnalyzer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Transforms,FunctionAnalysis2ndPass,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FunctionAnalysis2ndPass,Cyclomatic complexity of the method is 48
Complex Method,JSIL.Transforms,FunctionAnalysis2ndPass,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,Cyclomatic complexity of the method is 27
Complex Method,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,ExemptVariablesFromEffectivelyConstantStatus,Cyclomatic complexity of the method is 15
Complex Method,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,Cyclomatic complexity of the method is 51
Complex Method,JSIL.Transforms,SimplifyOperators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\SimplifyOperators.cs,VisitNode,Cyclomatic complexity of the method is 12
Complex Method,JSIL.Transforms,IntroduceVariableReferences,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,GetConstructedReference,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Transforms,IntroduceVariableReferences,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,VisitNode,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,Cyclomatic complexity of the method is 18
Complex Method,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,Cyclomatic complexity of the method is 9
Complex Method,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,PostOptimizeAssignment,Cyclomatic complexity of the method is 17
Long Parameter List,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The method has 5 parameters. Parameters: formatter' typeReference' context' replaceMode' useStandartSubstitution
Long Parameter List,JSIL,DefinitelyTypedBaseEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitCustomAttributes,The method has 5 parameters. Parameters: context' declaringType' member' astEmitter' standalone
Long Parameter List,JSIL,DefinitelyTypedBaseEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitMethodDefinition,The method has 7 parameters. Parameters: context' methodRef' method' astEmitter' stubbed' dollar' methodInfo
Long Parameter List,JSIL,DefinitelyTypedBaseEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitField,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' defaultValue
Long Parameter List,JSIL,DefinitelyTypedBaseEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitConstant,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' value
Long Parameter List,JSIL,DefinitelyTypedEmptyAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,DefinitelyTypedEmptyAstEmitter,The method has 5 parameters. Parameters: output' jsil' typeSystem' typeInfo' configuration
Long Parameter List,JSIL,FunctionCache,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionCache.cs,Create,The method has 7 parameters. Parameters: info' methodDef' method' identifier' translator' parameters' body
Long Parameter List,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitCustomAttributes,The method has 5 parameters. Parameters: context' declaringType' member' astEmitter' standalone
Long Parameter List,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitMethodDefinition,The method has 7 parameters. Parameters: context' methodRef' method' astEmitter' stubbed' dollar' methodInfo
Long Parameter List,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitOverrides,The method has 5 parameters. Parameters: context' typeInfo' method' methodInfo' astEmitter
Long Parameter List,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitMarshalInfo,The method has 5 parameters. Parameters: methodRef' method' attributes' mi' astEmitter
Long Parameter List,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitFieldOrConstant,The method has 6 parameters. Parameters: context' astEmitter' field' dollar' defaultValue' isConstant
Long Parameter List,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitField,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' defaultValue
Long Parameter List,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitConstant,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' value
Long Parameter List,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,JavascriptAstEmitter,The method has 5 parameters. Parameters: output' jsil' typeSystem' typeInfo' configuration
Long Parameter List,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,ILBlockTranslator,The method has 9 parameters. Parameters: translator' context' methodReference' methodDefinition' methodSymbols' ilb' parameters' allVariables' referenceReplacer
Long Parameter List,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,HandleJSReplacement,The method has 6 parameters. Parameters: method' methodInfo' thisExpression' arguments' resultType' explicitThis
Long Parameter List,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoMethodReplacement,The method has 7 parameters. Parameters: method' thisExpression' arguments' virtual' static' explicitThis' suppressThisClone
Long Parameter List,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The method has 5 parameters. Parameters: typeName' methodName' method' genericArguments' arguments
Long Parameter List,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_PropertyCall,The method has 5 parameters. Parameters: thisExpression' method' arguments' virtual' static
Long Parameter List,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoPropertyReplacement,The method has 6 parameters. Parameters: thisExpression' thisType' method' arguments' virtual' static
Long Parameter List,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateSwitchCase,The method has 5 parameters. Parameters: block' conditionType' exitLabelName' needExitLabel' epilogue
Long Parameter List,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,NeedsExplicitThis,The method has 6 parameters. Parameters: declaringType' declaringTypeDef' declaringTypeInfo' isSelf' thisReferenceType' methodInfo
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,AssemblyTranslator,The method has 7 parameters. Parameters: configuration' typeInfoProvider' manifest' assemblyDataResolver' onProxyAssemblyLoaded' analyzers' emitterGroupFactories
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,AssemblyLoadErrorWrapper,The method has 5 parameters. Parameters: loader' assemblyName' readerParameters' useSymbols' mainAssemblyPath
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The method has 5 parameters. Parameters: assemblyEmitter' context' assembly' outputStream' sourceMapBuilder
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateModule,The method has 6 parameters. Parameters: context' assemblyEmitter' module' sealedTypes' declaredTypes' stubbed
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,DeclareType,The method has 7 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' declaredTypes' stubbed' isImported
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,DeclareNestedTypes,The method has 7 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' declaredTypes' stubbed' skipped
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,EmitTypeMethodExpressions,The method has 7 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' stubbed' dollar' nextDisambiguatedId
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeDefinition,The method has 7 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' stubbed' dollar' cachers
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,GetAllVariablesForMethod,The method has 5 parameters. Parameters: context' parameters' methodBody' ignoredVariables' enableUnsafeCode
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateField,The method has 5 parameters. Parameters: field' defaultValues' cctorContext' dollar' fieldSelfIdentifier
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The method has 8 parameters. Parameters: context' typedef' astEmitter' assemblyEmitter' cctor' stubbed' dollar' cachers
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,CreateMethodInformation,The method has 5 parameters. Parameters: methodInfo' stubbed' isExternal' isJSReplaced' methodIsProxied
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,ShouldTranslateMethodBody,The method has 6 parameters. Parameters: method' methodInfo' stubbed' isExternal' isJSReplaced' methodIsProxied
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,EmitAndDefineMethod,The method has 11 parameters. Parameters: context' methodRef' method' astEmitter' assemblyEmitter' stubbed' dollar' cachers' nextDisambiguatedId' methodInfo' bodyTransformer
Long Parameter List,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,EmitMethodBody,The method has 10 parameters. Parameters: context' methodRef' method' astEmitter' assemblyEmitter' stubbed' cachers' nextDisambiguatedId' methodInfo' bodyTransformer
Long Parameter List,JSIL,JSILIdentifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SpecialIdentifiers.cs,CreateNamedFunction,The method has 5 parameters. Parameters: resultType' name' argumentNames' body' closure
Long Parameter List,JSIL,TranslationResult,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TranslationResult.cs,AddFile,The method has 6 parameters. Parameters: type' filename' bytes' position' properties' sourceMapBuilder
Long Parameter List,JSIL.Ast,JSFunctionExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSFunctionExpression,The method has 5 parameters. Parameters: method' allVariables' parameters' body' methodTypes
Long Parameter List,JSIL.Ast,JSMethodPointerInfoExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSMethodPointerInfoExpression,The method has 5 parameters. Parameters: reference' method' methodTypes' isVirtual' genericArguments
Long Parameter List,JSIL.Ast,JSPropertyAccess,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSPropertyAccess,The method has 7 parameters. Parameters: thisReference' property' isWrite' typeQualified' originalType' originalMethod' isVirtualCall
Long Parameter List,JSIL.Ast,JSInvocationExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSInvocationExpression,The method has 7 parameters. Parameters: type' method' thisReference' arguments' explicitThis' constantIfArgumentsAre' suppressThisClone
Long Parameter List,JSIL.Ast,JSInvocationExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,InvokeMethod,The method has 6 parameters. Parameters: type' method' thisReference' arguments' constantIfArgumentsAre' suppressThisClone
Long Parameter List,JSIL.Ast,JSInvocationExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,InvokeMethod,The method has 6 parameters. Parameters: type' method' thisReference' arguments' constantIfArgumentsAre' suppressThisClone
Long Parameter List,JSIL.Ast,JSInvocationExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,InvokeBaseMethod,The method has 5 parameters. Parameters: type' method' thisReference' arguments' constantIfArgumentsAre
Long Parameter List,JSIL.Ast,JSInvocationExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,InvokeBaseMethod,The method has 5 parameters. Parameters: type' method' thisReference' arguments' constantIfArgumentsAre
Long Parameter List,JSIL.Ast,JSMemberDescriptor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSMemberDescriptor,The method has 5 parameters. Parameters: isPublic' isStatic' isVirtual' isReadonly' offset
Long Parameter List,JSIL.Ast,JSBinaryOperatorExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSBinaryOperatorExpression,The method has 5 parameters. Parameters: op' lhs' rhs' actualType' canSimplify
Long Parameter List,JSIL.Ast,JSBinaryOperatorExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSBinaryOperatorExpression,The method has 5 parameters. Parameters: op' lhs' rhs' actualType' extraValues
Long Parameter List,JSIL.Ast,JSCastExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,New,The method has 5 parameters. Parameters: inner' newType' typeSystem' force' isCoercion
Long Parameter List,JSIL.Ast,JSCastExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,NewInternal,The method has 5 parameters. Parameters: inner' newType' typeSystem' force' make
Long Parameter List,JSIL.Ast,JSFieldDeclaration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSFieldDeclaration,The method has 5 parameters. Parameters: fieldInfo' descriptor' name' fieldType' defaultValue
Long Parameter List,JSIL.Ast,JSConstantDeclaration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSConstantDeclaration,The method has 5 parameters. Parameters: fieldInfo' descriptor' name' fieldType' value
Long Parameter List,JSIL.Ast,JSCachedMethod,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSIdentifierTypes.cs,JSCachedMethod,The method has 5 parameters. Parameters: reference' method' methodTypes' genericArguments' index
Long Parameter List,JSIL.Ast,JSFakeMethod,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSIdentifierTypes.cs,JSFakeMethod,The method has 6 parameters. Parameters: name' returnType' parameterTypes' methodTypes' genericArguments' escape
Long Parameter List,JSIL.Ast,JSVerbatimLiteral,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSLiteralTypes.cs,JSVerbatimLiteral,The method has 5 parameters. Parameters: description' expression' variables' type' isConstantIfArgumentsAre
Long Parameter List,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,JavascriptFormatter,The method has 7 parameters. Parameters: output' sourceMapBuilder' typeInfo' manifest' assembly' configuration' stubbed
Long Parameter List,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,MemberDescriptor,The method has 5 parameters. Parameters: isPublic' isStatic' isVirtual' isReadonly' offset
Long Parameter List,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The method has 6 parameters. Parameters: method' signature' context' forConstructor' allowCache' alwaysUseIdentifiers
Long Parameter List,JSIL.Internal,MemberIdentifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\MemberIdentifier.cs,MemberIdentifier,The method has 6 parameters. Parameters: isStatic' type' name' returnType' parameterTypes' genericArgumentCount
Long Parameter List,JSIL.Internal,PackedArrayUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\PackedStructArray.cs,FilterInvocationResult,The method has 5 parameters. Parameters: methodReference' method' result' typeInfo' typeSystem
Long Parameter List,JSIL.Internal,PackedArrayUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\PackedStructArray.cs,GetItem,The method has 6 parameters. Parameters: targetType' targetTypeInfo' target' index' methodTypes' proxy
Long Parameter List,JSIL.Internal,Mapping,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,Mapping,The method has 6 parameters. Parameters: generatedLine' generatedColumn' originalLine' originalColumn' source' name
Long Parameter List,JSIL.Internal,TypeInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,The method has 6 parameters. Parameters: source' module' type' declaringType' baseClass' identifier
Long Parameter List,JSIL.Internal,MemberInfo<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,MemberInfo,The method has 7 parameters. Parameters: parent' identifier' member' proxies' isIgnored' isExternal' sourceProxy
Long Parameter List,JSIL.Internal,FieldInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,FieldInfo,The method has 5 parameters. Parameters: parent' identifier' field' proxies' sourceProxy
Long Parameter List,JSIL.Internal,PropertyInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,PropertyInfo,The method has 5 parameters. Parameters: parent' identifier' property' proxies' sourceProxy
Long Parameter List,JSIL.Internal,EventInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,EventInfo,The method has 5 parameters. Parameters: parent' identifier' evt' proxies' sourceProxy
Long Parameter List,JSIL.Internal,MethodInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,MethodInfo,The method has 5 parameters. Parameters: parent' identifier' method' proxies' sourceProxy
Long Parameter List,JSIL.Internal,MethodInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,MethodInfo,The method has 6 parameters. Parameters: parent' identifier' method' proxies' property' sourceProxy
Long Parameter List,JSIL.Internal,MethodInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,MethodInfo,The method has 6 parameters. Parameters: parent' identifier' method' proxies' evt' sourceProxy
Long Parameter List,JSIL.Compiler.Extensibility,IAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitCustomAttributes,The method has 5 parameters. Parameters: context' declaringType' member' astEmitter' standalone
Long Parameter List,JSIL.Compiler.Extensibility,IAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitMethodDefinition,The method has 7 parameters. Parameters: context' methodRef' method' astEmitter' stubbed' dollar' methodInfo
Long Parameter List,JSIL.Compiler.Extensibility,IAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitField,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' defaultValue
Long Parameter List,JSIL.Compiler.Extensibility,IAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitConstant,The method has 5 parameters. Parameters: context' astEmitter' field' dollar' value
Long Parameter List,JSIL.Compiler.Extensibility,IFunctionTransformer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Extensibility\IAnalyzer.cs,MaybeReplaceMethodCall,The method has 7 parameters. Parameters: caller' method' methodInfo' thisExpression' arguments' resultType' explicitThis
Long Parameter List,JSIL.Transforms,SignatureCacher,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,SignatureCacher,The method has 5 parameters. Parameters: typeInfo' localCachingEnabled' preferLocalCacheForGenericMethodSignatures' preferLocalCacheForGenericInterfaceMethodSignatures' useMethodSignaturePerMethod
Long Parameter List,JSIL.Transforms,SignatureCacher,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,WriteSignatureToOutput,The method has 6 parameters. Parameters: output' enclosingFunction' methodReference' methodSignature' referenceContext' forConstructor
Long Parameter List,JSIL.Transforms,SignatureCacher,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,WriteInterfaceMemberToOutput,The method has 6 parameters. Parameters: output' astEmitter' enclosingFunction' jsMethod' method' referenceContext
Long Parameter List,JSIL.Transforms,HoistAllocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,CreateHoistedVariable,The method has 5 parameters. Parameters: update' type' array' index' defaultValue
Long Parameter List,JSIL.Transforms,ExpandCastExpressions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,ExpandCastExpressions,The method has 6 parameters. Parameters: typeSystem' js' jsil' typeInfo' methodTypeFactory' emulateInt64
Long Parameter List,JSIL.Transforms,IntroduceEnumCasts,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceEnumCasts.cs,IntroduceEnumCasts,The method has 5 parameters. Parameters: typeSystem' js' typeInfo' methodTypes' functionSource
Long Parameter List,JSIL.Transforms,OptimizeArrayEnumerators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,ReplaceWhileLoop,The method has 6 parameters. Parameters: wl' enumerator' enumeratorType' arrayMember' indexMember' lengthMember
Long Parameter List,JSIL.Transforms,OptimizeArrayEnumerators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,ReplaceWhileLoopAndEnumerator,The method has 6 parameters. Parameters: wl' backingStore' enumerator' enumeratorType' arrayMember' lengthMember
Long Parameter List,JSIL.Transforms,Access,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Access,The method has 5 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' source' isControlFlow
Long Parameter List,JSIL.Transforms,Assignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Assignment,The method has 8 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' target' newValue' operator' targetType' sourceType
Long Parameter List,JSIL.Transforms,SideEffect,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,SideEffect,The method has 5 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' variable' type
Long Parameter List,JSIL.Transforms,FieldAccess,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FieldAccess,The method has 5 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' field' isRead
Long Parameter List,JSIL.Transforms,Invocation,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Invocation,The method has 7 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' type' method' nonJSMethod' variables
Long Parameter List,JSIL.Transforms,Invocation,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,Invocation,The method has 7 parameters. Parameters: parentNodeIndices' statementIndex' nodeIndex' thisVariable' method' nonJSMethod' variables
Long Parameter List,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,EliminateSingleUseTemporaries,The method has 5 parameters. Parameters: member' functionSource' typeSystem' variables' typeInfo
Long Parameter List,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,EmulateStructAssignment,The method has 7 parameters. Parameters: member' functionSource' typeSystem' typeInfo' clr' methodTypes' optimizeCopies
Long Identifier,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitAssemblyReferences,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericMethodSignatureWithoutResultType,The length of the parameter additionalArgsForNameCalculation is 32.
Long Identifier,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericArgumentsIfNeed,The length of the parameter additionalArgsForNameCalculation is 32.
Long Identifier,JSIL,DefinitelyTypedBaseEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitAssemblyReferences,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitAssemblyReferences,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The length of the parameter wrapAssemblyInImmediatelyInvokedFunctionExpression is 50.
Long Identifier,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,DeclareAssembly,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL.Internal,TypeInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,,The length of the parameter DeferredMethodSignatureSetUpdates is 33.
Long Identifier,JSIL.Internal,TypeInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,,The length of the parameter DeferredStaticMethodSignatureSetUpdates is 39.
Long Identifier,JSIL.Translator,Configuration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter GenerateSkeletonsForStubbedAssemblies is 37.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter DisableGenericSignaturesLocalCache is 34.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter PreferLocalCacheForGenericMethodSignatures is 42.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter PreferLocalCacheForGenericInterfaceMethodSignatures is 51.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter CacheOneMethodSignaturePerMethod is 32.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter EliminatePointlessFinallyBlocks is 31.
Long Identifier,JSIL.Translator,CodeGeneratorConfiguration,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Configuration.cs,,The length of the parameter AutoGenerateEventAccessorsInSkeletons is 37.
Long Identifier,JSIL.Compiler.Extensibility,IAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Extensibility\Emitter.cs,EmitAssemblyReferences,The length of the parameter assemblyDeclarationReplacement is 30.
Long Identifier,JSIL.Transforms,SignatureCacher,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,SignatureCacher,The length of the parameter preferLocalCacheForGenericMethodSignatures is 42.
Long Identifier,JSIL.Transforms,SignatureCacher,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,SignatureCacher,The length of the parameter preferLocalCacheForGenericInterfaceMethodSignatures is 51.
Long Identifier,JSIL.Transforms,SignatureCacher,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,,The length of the parameter PreferLocalCacheForGenericMethodSignatures is 42.
Long Identifier,JSIL.Transforms,SignatureCacher,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,,The length of the parameter PreferLocalCacheForGenericInterfaceMethodSignatures is 51.
Long Identifier,JSIL.Transforms,CachedSignatureRecord,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,CachedSignatureRecord,The length of the parameter rewritenGenericParametersCount is 30.
Long Identifier,JSIL.Transforms,CachedSignatureRecord,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,,The length of the parameter RewritenGenericParametersCount is 30.
Long Identifier,JSIL.Transforms,CachedInterfaceMemberRecord,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,CachedInterfaceMemberRecord,The length of the parameter rewritenGenericParametersCount is 30.
Long Identifier,JSIL.Transforms,CachedInterfaceMemberRecord,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,,The length of the parameter RewritenGenericParametersCount is 30.
Long Identifier,JSIL.Transforms,EliminatePointlessRetargeting,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminatePointlessRetargeting.cs,IsCachedValueValidForGivenCacheKey,The length of the parameter cachedValueLastInitializationNodeIndex is 38.
Long Identifier,JSIL.Transforms,LabelGroupLabelData,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,,The length of the parameter TimesUsedAsRecursiveExitTarget is 30.
Long Identifier,JSIL.Transforms,OptimizeArrayEnumerators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The length of the parameter enumeratorAssignmentBeforeLoop is 30.
Long Identifier,JSIL.Transforms,FunctionAnalysis2ndPass,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,,The length of the parameter ViolatesThisReferenceImmutability is 33.
Long Identifier,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,,The length of the parameter VariablesExemptedFromEffectivelyConstantStatus is 46.
Long Identifier,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,The length of the parameter allowImmutabilityOptimizations is 30.
Long Identifier,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the parameter thisReferenceNeedsCopyAndReassignment is 37.
Long Identifier,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the parameter rightVarIsEffectivelyConstantHere is 33.
Long Identifier,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the parameter rightVarIsEffectivelyConstantHere is 33.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitHeader,The length of the statement  "            Formatter.WriteRaw("import {$private as $asmJsilCore' StaticType as $StaticType' Type as $Type' NullArg as $Null} from \"./JSIL.Core\""); " is 137.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitAssemblyReferences,The length of the statement  "                        Formatter.WriteRaw(string.Format("import {{$private as {0}}} from \"./{1}\""' referenceOverride.Key.IDString' referenceOverride.Value)); " is 136.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInstance,The length of the statement  "                var instanceFields = typedef.Fields.Where(it => it.IsPublic && !it.IsStatic && !Translator.ShouldSkipMember(it)).OrderBy(md => md.Name); " is 136.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInstance,The length of the statement  "                     || (it.SetMethod != null && it.SetMethod.IsPublic && !it.SetMethod.IsStatic && !Translator.ShouldSkipMember(it.SetMethod)))) " is 124.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInstance,The length of the statement  "                var instanceMethods = typedef.Methods.Where(it => it.IsPublic && !it.IsStatic && !it.IsConstructor && !Translator.ShouldSkipMember(it)).OrderBy(md => md.Name); " is 159.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassInOutType,The length of the statement  "            var interfaces = typedef.Interfaces.Where(it => DefinitelyTypedUtilities.IsTypePublic(it) && !Translator.ShouldSkipMember(it)); " is 127.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "            var staticFields = typedef.Fields.Where(it => it.IsPublic && it.IsStatic && !Translator.ShouldSkipMember(it)).OrderBy(md => md.Name); " is 133.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "                     || (it.SetMethod != null && it.SetMethod.IsPublic && it.SetMethod.IsStatic && !Translator.ShouldSkipMember(it.SetMethod)))) " is 123.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "            var constructors = typedef.Methods.Where(it => it.IsPublic && !it.IsStatic && it.IsConstructor && !Translator.ShouldSkipMember(it)); " is 132.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "            var staticMethods = typedef.Methods.Where(it => it.IsPublic && it.IsStatic && !it.IsConstructor && !Translator.ShouldSkipMember(it)).OrderBy(it => it.Name); " is 156.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitClassStatic,The length of the statement  "                var instanceMethods = typedef.Methods.Where(it => it.IsPublic && !Translator.ShouldSkipMember(it)).GroupBy(method => method.Name).OrderBy(group => group.Key); " is 158.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitMethod,The length of the statement  "                    Formatter.WriteGenericMethodSignatureWithoutResultType(method.GenericParameters' method.DeclaringType.GenericParameters); " is 121.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitInterfaceMethod,The length of the statement  "                Formatter.CommaSeparatedList(DefinitelyTypedUtilities.BuildGenericParemetersMap(method.GenericParameters' method.DeclaringType.GenericParameters)' pair => { " is 156.
Long Statement,JSIL,DefinitelyTypedInternalsEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitInterfaceMethod,The length of the statement  "                    Formatter.WriteGenericArgumentsIfNeed(new[] { DefinitelyTypedUtilities.GetGenericParameterInstanceParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterInParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterOutParameterName(pair.Value) }); " is 274.
Long Statement,JSIL,DefinitelyTypedExportEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,EmitHeader,The length of the statement  "            Formatter.WriteRaw(string.Format("import {{$private as $this}} from \"./internals/{0}\""' Formatter.Assembly.FullName)); " is 120.
Long Statement,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The length of the statement  "                    map = DefinitelyTypedUtilities.BuildGenericParemetersMap(((MethodDefinition) gp.Owner).GenericParameters' ((MethodDefinition) gp.Owner).DeclaringType.GenericParameters); " is 169.
Long Statement,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The length of the statement  "            } else if (typeReference is PointerType || typeReference is OptionalModifierType || typeReference is RequiredModifierType || typeReference is PinnedType || typeReference is SentinelType || typeReference is FunctionPointerType " is 225.
Long Statement,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericMethodSignatureWithoutResultType,The length of the statement  "            formatter.CommaSeparatedList(DefinitelyTypedUtilities.BuildGenericParemetersMap(args' additionalArgsForNameCalculation)' pair => { " is 130.
Long Statement,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericMethodSignatureWithoutResultType,The length of the statement  "                formatter.WriteGenericArgumentsIfNeed(new[] { DefinitelyTypedUtilities.GetGenericParameterInstanceParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterInParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterOutParameterName(pair.Value)}); " is 273.
Long Statement,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteGenericArgumentsIfNeed,The length of the statement  "                    .SelectMany(pair => new[] { DefinitelyTypedUtilities.GetGenericParameterInstanceParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterInParameterName(pair.Value)' DefinitelyTypedUtilities.GetGenericParameterOutParameterName(pair.Value)})); " is 256.
Long Statement,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,TranslateAttributeConstructorArgument,The length of the statement  "                    throw new NotImplementedException(String.Format("Attribute arguments of type '{0}' are not implemented."' ca.Type.FullName)); " is 125.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "            var offsetInElements = JSPointerExpressionUtil.OffsetFromBytesToElements(delta' TypeUtil.GetElementType(pae.Pointer.GetActualType(TypeSystem)' true)); " is 150.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "            var regex = new Regex(@"(\$\$|\$(?'name'((etypeof|typeof|assemblyof|explicitThis|declaringType)\([a-zA-Z0-9_]([a-zA-Z0-9_]*)\))|([a-zA-Z0-9_]([a-zA-Z0-9_]*)))|(?'text'[^\$]*)|)"' RegexOptions.ExplicitCapture); " is 209.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "            foreach (var line in verbatim.Expression.Split(new string[] { Environment.NewLine }' StringSplitOptions.RemoveEmptyEntries)) { " is 126.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "                // Like with packed array elements' if we're passing the result of a pointer dereference directly to a function' pass a proxy instead. " is 134.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The length of the statement  "                // If the pointer has been hoisted the proxy will be reused' which reduces GC pressure and allows unpacking to happen on demand. " is 128.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,AddSourceMapInfo,The length of the statement  "                //Output.Comment(string.Join("; "' node.SymbolInfo.SequencePoints.Select(item => item.StartLine + ":" + item.StartColumn))); " is 124.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,AddSourceMapInfo,The length of the statement  "                Output.SourceMapBuilder.AddInfo(Output.OutputWithPositionInfo.Line' Output.OutputWithPositionInfo.Column' node.SymbolInfo.SequencePoints); " is 138.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,AddSourceMapInfoEnd,The length of the statement  "                Output.SourceMapBuilder.AddInfoEnd(Output.OutputWithPositionInfo.Line' Output.OutputWithPositionInfo.Column' node.SymbolInfo.SequencePoints); " is 141.
Long Statement,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,AddSourceMapInfoEnd,The length of the statement  "                //Output.Comment("--" + string.Join("; "' node.SymbolInfo.SequencePoints.Select(item => item.EndLine + ":" + item.EndColumn))); " is 127.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,HandleJSReplacement,The length of the statement  "                        foreach (var kvp in methodInfo.GenericParameterNames.Zip(genericMethod.GenericArguments' (n' p) => new { Name = n' Value = p })) { " is 130.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,HandleJSReplacement,The length of the statement  "                        argsDict["etypeof(" + kvp.Name + ")"] = Translate_TypeOf(typeSpecification != null ? typeSpecification.ElementType : type.GetElementType()); " is 140.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoMethodReplacement,The length of the statement  "                    result = JSInvocationExpression.InvokeMethod(method.Reference.DeclaringType' method' thisExpression' arguments' suppressThisClone: suppressThisClone); " is 150.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The length of the statement  "                                var temporaryAssignment = new JSBinaryOperatorExpression(JSOperator.Assignment' temporaryVariable' argumentsExpression' argumentsExpressionType); " is 145.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoNonJSILMethodReplacement,The length of the statement  "                case "System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle'System.RuntimeTypeHandle)": " is 139.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoNonJSILMethodReplacement,The length of the statement  "                case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)": " is 135.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,AddSymbolInfo,The length of the statement  "                                .Where(item => !(item.SequencePoint.StartLine == item.SequencePoint.EndLine && item.SequencePoint.StartColumn == item.SequencePoint.EndColumn)) " is 143.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateSwitchCase,The length of the statement  "                var switchBreaks = (from be in jsBlock.AllChildrenRecursive.OfType<JSBreakExpression>() where be.TargetLoop == null select be); " is 127.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_CompoundAssignment_MultidimensionalArray,The length of the statement  "            Func<JSExpression[]' JSExpression' JSInvocationExpressionBase> makeSetter = (_indices' _value) => JSInvocationExpression.InvokeMethod( " is 134.
Long Statement,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Ldlen,The length of the statement  "                return new JSUntranslatableExpression(String.Format("Retrieving the length of a type with no length property: {0}"' argType.FullName)); " is 135.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,Translate,The length of the statement  "                    Console.Error.WriteLine("// WARNING: Bug checks have been suppressed. You may be running JSIL on a broken/unsupported .NET runtime."); " is 134.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,The length of the statement  "            var results = EmitterGroupFactories.Select(item => new {EmitterGroup = item' TranslationResult = new TranslationResult(this.Configuration' assemblyPath' Manifest)}).ToList(); " is 174.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,The length of the statement  "                                    var formatter = new JavascriptFormatter(tw' sourceMapBuilder' this.TypeInfoProvider' Manifest' assembly' Configuration' stubbed); " is 129.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,AnalyzeFunctions,The length of the statement  "                    throw new InvalidDataException("Method collection mutated during analysis. Try setting UseThreads=false (and report an issue!)"); " is 129.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,GetMethodsToAnalyze,The length of the statement  "                                    typeList.AddRange(TypeInfoProvider.FindTypeProxy(new TypeIdentifier(info.Definition)).ProxiedTypes.Select(item => item.Resolve())); " is 131.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The length of the statement  "                assemblyDeclarationReplacement = (string) metadata.GetAttributeParameters("JSIL.Meta.JSRepaceAssemblyDeclaration")[0].Value; " is 124.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateSingleAssemblyInternal,The length of the statement  "            var wrapAssemblyInImmediatelyInvokedFunctionExpression = Configuration.InlineAssemblyReferences.GetValueOrDefault(false); " is 121.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,DeclareType,The length of the statement  "                    DeclareType(context' declaringType' astEmitter' assemblyEmitter' declaredTypes' IsStubbed(declaringType.Module.Assembly)); " is 122.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,The length of the statement  "                    allVariables = GetAllVariablesForMethod(context' decompiler.Parameters' ilb' ignoredVariables' Configuration.CodeGenerator.EnableUnsafeCode.GetValueOrDefault(false)); " is 166.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,The length of the statement  "                    var freezeInvocation = translator.SpecialIdentifiers.JSIL.FreezeImmutableObject(new JSIndirectVariable(translator.Variables' "this"' method)); " is 142.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The length of the statement  "                    context' astBuilder.Parameters' block' ignoreReasons' Configuration.CodeGenerator.EnableUnsafeCode.GetValueOrDefault(false) " is 123.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The length of the statement  "                        this' ctx' realCctor' realCctor' ReadMethodSymbolsIfSourceMapEnabled(realCctor)' block' astBuilder.Parameters' variables " is 120.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The length of the statement  "                            // If the field's value is of an ignored type then we ignore the initialization since it probably won't translate anyway. " is 121.
Long Statement,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The length of the statement  "                                // TODO: Expand this to include 'new X' expressions that are effectively constant' by using static analysis to ensure that " is 122.
Long Statement,JSIL,JavascriptEmitterGroupFactory,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,GenerateManifest,The length of the statement  "                result.AddFile("Manifest"' Path.GetFileName(assemblyPath) + ".manifest.js"' new ArraySegment<byte>(ms.GetBuffer()' 0' (int) ms.Length)' 0); " is 139.
Long Statement,JSIL,JSILIdentifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SpecialIdentifiers.cs,NewElementReference,The length of the statement  "                throw new ArgumentException("Cannot create a reference to an element of a value of type '" + arrayType.FullName + "'"' target.ToString()); " is 138.
Long Statement,JSIL,JSILIdentifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SpecialIdentifiers.cs,CreateNamedFunction,The length of the statement  "            // FIXME: We should do a cast of the result to ensure it's actually the requested result type instead of just a raw JS function " is 127.
Long Statement,JSIL.Ast,JSAstVisitor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSAstVisitor.cs,GetEnclosingNodes,The length of the statement  "            // https://connect.microsoft.com/VisualStudio/feedback/details/781746/c-compiler-produces-incorrect-code-for-use-of-enumerator-structs-inside-enumerator-functions " is 162.
Long Statement,JSIL.Ast,JSResultReferenceExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,ReplaceChild,The length of the statement  "                    throw new InvalidOperationException("Replacing an invocation expression inside a result reference with a non invocation expression"); " is 133.
Long Statement,JSIL.Ast,JSInvocationExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetActualType,The length of the statement  "                return _ActualType = SubstituteTypeArgs(targetMethod.Method.Source' targetMethod.Reference.ReturnType' targetMethod.Reference); " is 127.
Long Statement,JSIL.Ast,JSArrayExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,UnpackArrayInitializer,The length of the statement  "                        return new JSUntranslatableExpression(String.Format("Array initializers with element type '{0}' not implemented"' elementType.FullName)); " is 137.
Long Statement,JSIL.Ast,JSCastExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,NewInternal,The length of the statement  "                    return new JSUntranslatableExpression("Cannot cast reference of type '" + currentDerefed.FullName + "' to type '" + newDerefed.FullName + "'"); " is 143.
Long Statement,JSIL.Ast,JSMethod,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSIdentifierTypes.cs,GetNameForInstanceReference,The length of the statement  "            // For methods that implement a method of a closed generic interface' we need to ensure we fully-qualify their name when necessary. " is 131.
Long Statement,JSIL.Ast,JSVerbatimLiteral,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSLiteralTypes.cs,ToString,The length of the statement  "                variablesText = String.Join("' "' (from kvp in Variables select String.Format("{0}={1}"' kvp.Key' kvp.Value)).ToArray()); " is 121.
Long Statement,JSIL.Ast,JSNode,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSNodeTypes.cs,GetTypeId,The length of the statement  "                throw new InvalidOperationException(string.Format("Node type '{0}' was loaded after JSNode initialization"' nodeType.FullName)); " is 128.
Long Statement,JSIL.Ast,JSLabelGroupStatement,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSStatementTypes.cs,ReplaceChild,The length of the statement  "                                throw new InvalidOperationException("Replacing LabelGroupStatement child '" + oldChild + "' with '" + newChild + "' but group already contains the label '" + stmt.Label + "'"); " is 176.
Long Statement,JSIL.Internal,Key,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\CILSupport.cs,Equals,The length of the statement  "                        Console.Error.WriteLine("WARNING: Invalid Key passed to Key.Equals. You are probably running a version of Mono with a broken ConcurrentDictionary."); " is 149.
Long Statement,JSIL.Internal,FunctionTransformPipeline,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionTransformPipeline.cs,RunUntilCompletion,The length of the statement  "                    Console.Error.WriteLine("Failed to lock '{0}' for transform pipeline: {1} {2}"' Identifier' lockResult.FailureReason' deadlock); " is 128.
Long Statement,JSIL.Internal,FunctionTransformPipeline,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionTransformPipeline.cs,RunUntilCompletion,The length of the statement  "                                var currentSecondPass = Translator.FunctionCache.GetSecondPass(this.Function.Method' this.Function.Method.QualifiedIdentifier); " is 127.
Long Statement,JSIL.Internal,FunctionTransformPipeline,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionTransformPipeline.cs,RunUntilCompletion,The length of the statement  "                                    Console.WriteLine("// Second pass data changed by pipeline stage '" + currentStage.Method.Name + "' - " + String.Join("' "' differences)); " is 138.
Long Statement,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The length of the statement  "                    if ((alwaysUseIdentifiers || context.EnclosingMethod != null) && !TypeUtil.IsOpenType(returnType' gp => !SignatureCacher.IsTypeArgument(gp))) " is 141.
Long Statement,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The length of the statement  "                        if ((alwaysUseIdentifiers || context.EnclosingMethod != null) && !TypeUtil.IsOpenType(signature.ReturnType' gp => !SignatureCacher.IsTypeArgument(gp))) " is 151.
Long Statement,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The length of the statement  "                            if ((alwaysUseIdentifiers || context.EnclosingMethod != null) && !TypeUtil.IsOpenType(pt' gp => !SignatureCacher.IsTypeArgument(gp))) " is 133.
Long Statement,JSIL.Internal,PackedArrayUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\PackedStructArray.cs,CheckInvocationSafety,The length of the statement  "                            "Invalid attempt to pass a normal array as parameter '" + method.Parameters[i].Name + "' to method '" + method.Name + "'. " + " is 125.
Long Statement,JSIL.Internal,PackedArrayUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\PackedStructArray.cs,CheckInvocationSafety,The length of the statement  "                            "Invalid attempt to pass a packed array as parameter '" + method.Parameters[i].Name + "' to method '" + method.Name + "'. " + " is 125.
Long Statement,JSIL.Internal,PackedArrayUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\PackedStructArray.cs,FilterInvocationResult,The length of the statement  "                    return JSChangeTypeExpression.New(result' PackedArrayUtil.MakePackedArrayType(resultType' returnValueAttribute.Entries.First().Type)' typeSystem); " is 146.
Long Statement,JSIL.Internal,SourceMapBuilder,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,Build,The length of the statement  "            sourceMap.AppendLine(string.Format("\t\"sources\" : [{0}]'"' string.Join("' "' sources.Select(item => "\"" + MakeRelativePath(path' item) + "\"")))); " is 149.
Long Statement,JSIL.Internal,SourceMapBuilder,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,Build,The length of the statement  "            sourceMap.AppendLine(string.Format("\t\"names\" : [{0}]'"' string.Join("' "' names.Select(item => "\"" + item + "\"")))); " is 121.
Long Statement,JSIL.Internal,Mapping,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,Equals,The length of the statement  "                return GeneratedLine == other.GeneratedLine && GeneratedColumn == other.GeneratedColumn && OriginalLine == other.OriginalLine && OriginalColumn == other.OriginalColumn && string.Equals(Source' other.Source) && string.Equals(Name' other.Name); " is 242.
Long Statement,JSIL.Internal,MethodInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,_IsExternal,The length of the statement  "            var result = method.IsNative || method.IsUnmanaged || method.IsUnmanagedExport || method.IsInternalCall || method.IsPInvokeImpl; " is 128.
Long Statement,JSIL.Internal,PolicyExtensions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,ApplyWritePolicy,The length of the statement  "                    result = new JSIgnoredMemberReference(member.WritePolicy == JSWritePolicy.ThrowError' member' thisExpression' newValue); " is 120.
Long Statement,JSIL.Internal,PolicyExtensions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,ApplyInvokePolicy,The length of the statement  "                    result = new JSIgnoredMemberReference(member.InvokePolicy == JSInvokePolicy.ThrowError' member' new[] { thisExpression }.Concat(parameters).ToArray()); " is 151.
Long Statement,JSIL.Transforms,CachedSignatureRecord,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\CacheSignatures.cs,GetHashCode,The length of the statement  "                return (Method != null ? Method.Name.GetHashCode() : 0) ^ Signature.GetHashCode() ^ IsConstructor.GetHashCode() ^ RewritenGenericParametersCount; " is 145.
Long Statement,JSIL.Transforms,AttachSymbolInfoToStatements,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\AttachSymbolInfoToStatements.cs,VisitNodeInternalDown,The length of the statement  "                var childSymboInfo = node.Children.Where(item => item != null).Select(item => item.SymbolInfo).FirstOrDefault(item => item != null); " is 132.
Long Statement,JSIL.Transforms,IntroducePackedArrays,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroducePackedArrays.cs,VisitNode,The length of the statement  "                        replacement = new JSNewPackedArrayExpression(leftField.Field.Field.FieldType' nae.ElementType' nae.Dimensions' nae.SizeOrArrayInitializer); " is 139.
Long Statement,JSIL.Transforms,IntroducePackedArrays,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroducePackedArrays.cs,VisitNode,The length of the statement  "                        replacement = new JSNewPackedArrayExpression(leftField.Field.Field.FieldType' nae.ElementType' nae.SizeOrArrayInitializer); " is 123.
Long Statement,JSIL.Transforms,HoistAllocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,DoesValueEscapeFromInvocation,The length of the statement  "                    // HACK for methods that do not have resolvable references. In this case' if NONE of their arguments escape' we're probably still okay. " is 135.
Long Statement,JSIL.Transforms,HoistAllocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,VisitNode,The length of the statement  "                        new JSFakeMethod("retarget"' hoistedVariable.GetActualType(TypeSystem)' new TypeReference[] { TypeSystem.Object' TypeSystem.Int32 }' MethodTypes)'  " is 146.
Long Statement,JSIL.Transforms,UnsafeCodeTransforms,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\UnsafeCodeTransforms.cs,VisitNode,The length of the statement  "            // This allows hoisting to operate when the call is inside a loop' and it reduces GC pressure (since we basically make the struct unpack occur on-demand). " is 154.
Long Statement,JSIL.Transforms,ConvertPropertyAccessesToInvocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ConvertPropertyAccessesToInvocations.cs,ConstructInvocation,The length of the statement  "                        var actualReturnType = JSExpression.SubstituteTypeArgs(TypeInfo' actualMethodReference.ReturnType' actualMethodReference); " is 122.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The length of the statement  "                    Console.WriteLine("// Not recording fallthrough from {0} to {1} because {0} ends with control flow ({2})"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label' lastEs.Expression); " is 191.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The length of the statement  "                            Console.WriteLine("// Recording fallthrough from {0} to {1}"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label); " is 127.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The length of the statement  "                Console.WriteLine("// Failed to record fallthrough from {0} to {1}"' PreviousLabelledStatement.Label' CurrentLabelledStatement.Label); " is 134.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,ExtractExitLabel,The length of the statement  "                    Console.WriteLine("// Cannot extract exit label '{0}' from label group because it contains a goto or exit"' originalLabelName); " is 127.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The length of the statement  "                        Console.WriteLine("// Cannot mark label '{0}' as exit label because it falls through and is not the last label"' onlyRecursiveExitTarget); " is 138.
Long Statement,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The length of the statement  "                            Console.WriteLine("// Cannot mark label '{0}' as exit label because this labelgroup already has one"' onlyRecursiveExitTarget); " is 127.
Long Statement,JSIL.Transforms,ExpandCastExpressions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,The length of the statement  "                                new JSFakeMethod("ToNumber"' targetType' new TypeReference[] { TypeSystem.Double' TypeSystem.Boolean }' MethodTypeFactory)' " is 123.
Long Statement,JSIL.Transforms,ExpandCastExpressions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,The length of the statement  "                                new JSFakeMethod("ToNumber"' targetType' new TypeReference[] { TypeSystem.Double' TypeSystem.Boolean }' MethodTypeFactory)' " is 123.
Long Statement,JSIL.Transforms,IntroduceCharCasts,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,The length of the statement  "            if (boe.Operator == JSOperator.Assignment && (leftType.FullName == "System.Char") && (rightType.FullName != "System.Char")) " is 123.
Long Statement,JSIL.Transforms,IntroduceCharCasts,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,The length of the statement  "            if (boe.Operator == JSOperator.Assignment && (leftType.FullName != "System.Char") && (rightType.FullName == "System.Char")) " is 123.
Long Statement,JSIL.Transforms,IntroduceCharCasts,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,The length of the statement  "            JSDotExpressionBase parentInvocationDot = (parentInvocation != null) ? parentInvocation.Method as JSDotExpressionBase : null; " is 125.
Long Statement,JSIL.Transforms,ReplaceMethodCalls,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The length of the statement  "                            JSBinaryOperatorExpression equality = new JSBinaryOperatorExpression(JSOperator.Equal' ie.ThisReference' ie.Parameters.First().Value' type.Type); " is 145.
Long Statement,JSIL.Transforms,OptimizeArrayEnumerators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The length of the statement  "                (condInvocation.JSMethod.Method.DeclaringType.Interfaces.ToEnumerable().Any((ii) => ii.Info.FullName == "System.Collections.IEnumerator")) && " is 141.
Long Statement,JSIL.Transforms,StaticAnalyzer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,The length of the statement  "            var enclosingBoe = GetEnclosingNodes<JSBinaryOperatorExpression>((boe) => boe.Operator is JSAssignmentOperator).FirstOrDefault(); " is 129.
Long Statement,JSIL.Transforms,StaticAnalyzer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,The length of the statement  "            var enclosingBoe = GetEnclosingNodes<JSBinaryOperatorExpression>((boe) => boe.Operator is JSAssignmentOperator).FirstOrDefault(); " is 129.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The length of the statement  "                var targetAssignmentIndices = (from a in FirstPass.Assignments where target.Identifier.Equals(a.Target) select a.StatementIndex); " is 129.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The length of the statement  "                var targetAccessIndices = (from a in FirstPass.Accesses where target.Identifier.Equals(a.Source) select a.StatementIndex).ToArray(); " is 132.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The length of the statement  "                            Console.WriteLine("Found assignment slot for {0} <- {1} between {2} and {3}"' target' source' assignment' nextAssignment); " is 122.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,ExemptVariablesFromEffectivelyConstantStatus,The length of the statement  "                                    Console.WriteLine("Exempting variable '{0}' from effectively constant status because it is passed to {1} (no static analysis data)"' variableName' invocation.Method ?? invocation.NonJSMethod); " is 192.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,ExemptVariablesFromEffectivelyConstantStatus,The length of the statement  "                                            Console.WriteLine("Exempting variable '{0}' from effectively constant status because {1} {2}"' variableName' invocation.Method ?? invocation.NonJSMethod' reason); " is 162.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The length of the statement  "                if (replacement.SelfAndChildrenRecursive.OfType<JSBinaryOperatorExpression>().Any(boe => boe.Operator is JSAssignmentOperator)) { " is 129.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The length of the statement  "                                    Console.WriteLine(String.Format("Cannot eliminate {0}; a method call without field mutation data ({1}) is invoked between its initialization and use with it as an argument"' v' invocation.Method ?? invocation.NonJSMethod)); " is 223.
Long Statement,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The length of the statement  "                                Console.WriteLine(String.Format("Cannot eliminate {0}; a method call ({1}) potentially mutates a field it references"' v' invocation.Method ?? invocation.NonJSMethod)); " is 168.
Long Statement,JSIL.Transforms,IntroduceVariableReferences,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,TransformParameterIntoReference,The length of the statement  "            var newVariable = new JSVariable(parameter.Identifier' new ByReferenceType(parameter.IdentifierType)' parameter.Function); " is 122.
Long Statement,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,The length of the statement  "                        Console.WriteLine(String.Format("Returning false from IsCopyNeeded for parameter {0} because reference count is 1 and it has no aliases"' value)); " is 146.
Long Statement,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the statement  "                throw new InvalidDataException("No second-pass static analysis data for function '" + fn.Method.QualifiedIdentifier + "'"); " is 123.
Long Statement,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsArgumentCopyNeeded,The length of the statement  "                    Console.WriteLine("argument {0} ('{1}') needs no copy because it isn't modified and doesn't escape"' expression' parameterName); " is 128.
Long Statement,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The length of the statement  "                    Console.WriteLine("Cloning this-reference because method mutates this and this-reference is not field/local: {0}"' invocation); " is 127.
Complex Conditional,JSIL,JavascriptFormatterHelper,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\DefinitelyTypedAssemblyEmitter.cs,WriteTypeReference,The conditional expression  "typeReference is PointerType || typeReference is OptionalModifierType || typeReference is RequiredModifierType || typeReference is PinnedType || typeReference is SentinelType || typeReference is FunctionPointerType                  || (!_coreTypes.Contains(typeReference.FullName) && formatter.TypeInfo.Get(typeReference).IsSuppressDeclaration)"  is complex.
Complex Conditional,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The conditional expression  "(lastExpressionStatement != null) &&                      (                          (lastExpressionStatement.Expression is JSContinueExpression) ||                           (lastExpressionStatement.Expression is JSBreakExpression) ||                          (lastExpressionStatement.Expression is JSGotoExpression)                      )"  is complex.
Complex Conditional,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The conditional expression  "(                      TypeUtil.IsIntegral(oldType) ||                      TypeUtil.IsFloatingPoint(oldType)                  ) &&                  (                      TypeUtil.IsIntegral(newType) ||                      TypeUtil.IsFloatingPoint(newType)                  )"  is complex.
Complex Conditional,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,VisitNode,The conditional expression  "!needsTruncation &&                  (                      (ParentNode is JSInvocationExpressionBase) ||                      (ParentNode is JSCastExpression) ||                      (                          (parentBop != null) &&                          (parentBop.Operator is JSAssignmentOperator)                      )                  ) &&                  !TypeUtil.IsPointer(resultType)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp,The conditional expression  "TypeUtil.IsIgnoredType(node.Arguments[0].ExpectedType) ||                  TypeUtil.IsIgnoredType(node.Arguments[1].ExpectedType) ||                  TypeUtil.IsIgnoredType(node.Arguments[0].InferredType) ||                  TypeUtil.IsIgnoredType(node.Arguments[1].InferredType)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_BinaryOp,The conditional expression  "TypeUtil.IsIntegral(leftType) &&                   TypeUtil.IsIntegral(rightType) &&                  TypeUtil.IsIntegral(resultType) &&                  !(op is JSBitwiseOperator)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateFixedInitializer,The conditional expression  "(toTranslate.Code == ILCode.Stloc) &&                   (toTranslate.Arguments[0].Code == ILCode.TernaryOp) &&                  (toTranslate.Arguments[0].Arguments[0].Code == ILCode.LogicAnd) &&                  (toTranslate.Arguments[0].Arguments[1].Code == ILCode.Ldelema)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,The conditional expression  "(result != null) &&                  (expression.ExpectedType != null) &&                  (expression.InferredType != null) &&                  !TypeUtil.TypesAreAssignable(TypeInfo' expression.ExpectedType' expression.InferredType)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,TranslateNode,The conditional expression  "(expression.Code != ILCode.InitArray) &&                    (expression.ExpectedType != null) &&                  (expression.InferredType != null) &&                  (TypeUtil.IsArray(expression.InferredType)) &&                  expression.ExpectedType.FullName.StartsWith("System.Collections.") &&                  expression.ExpectedType.FullName.Contains(".IEnumerable")"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,The conditional expression  "(!node.Arguments[0].ExpectedType.IsValueType) &&                  (!node.Arguments[1].ExpectedType.IsValueType) &&                  (node.Arguments[0].ExpectedType == node.Arguments[1].ExpectedType) &&                  (node.Arguments[0].Code == ILCode.Isinst)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,The conditional expression  "(node.Arguments[0].ExpectedType == node.Arguments[1].ExpectedType) &&                  (node.Arguments[0].Code == ILCode.Ldnull || node.Arguments[1].Code == ILCode.Ldnull) &&                  (node.Arguments[0].Code != node.Arguments[1].Code)"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,The conditional expression  "(op == JSOperator.GreaterThan && node.Arguments[1].Code == ILCode.Ldnull)                      || (op == JSOperator.LessThan && (node.Arguments[0].Code == ILCode.Ldnull))"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_ComparisonOperator,The conditional expression  "(op == JSOperator.GreaterThanOrEqual && node.Arguments[0].Code == ILCode.Ldnull)                           || (op == JSOperator.LessThanOrEqual && (node.Arguments[1].Code == ILCode.Ldnull))"  is complex.
Complex Conditional,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_CompoundAssignment,The conditional expression  "(leftThisType != null) &&                      (leftThisType.Rank > 1) &&                      (leftInvocation.JSMethod != null) &&                      (leftInvocation.JSMethod.Method.Name == "Get")"  is complex.
Complex Conditional,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateMethodExpression,The conditional expression  "Configuration.CodeGenerator.FreezeImmutableObjects.GetValueOrDefault(false) &&                      (method.Name == ".ctor") &&                      methodInfo.DeclaringType.IsImmutable &&                      TypeUtil.IsStruct(method.DeclaringType)"  is complex.
Complex Conditional,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateField,The conditional expression  "!cctorContext &&                       (defaultValue != null) &&                      (                          defaultValue.HasGlobalStateDependency ||                           !defaultValue.IsConstant ||                          TypeUtil.IsStruct(defaultValue.GetActualType(field.Module.TypeSystem)) ||                          defaultValue is JSNewExpression ||                          defaultValue is JSArrayExpression ||                          defaultValue is JSInvocationExpressionBase ||                          defaultValue is JSNewArrayExpression ||                          defaultValue is JSEnumLiteral ||                          defaultValue is JSCastExpression ||                          defaultValue is JSTypeOfExpression                      )"  is complex.
Complex Conditional,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateTypeStaticConstructor,The conditional expression  "(fi != null) && (fi.IsIgnored || fi.IsExternal || ShouldSkipMember(fi.Member))"  is complex.
Complex Conditional,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,ScopesMatch,The conditional expression  "(sLhs.StartsWith(sRhs) &&                       (sLhs.EndsWith(".dll") || sLhs.EndsWith(".exe"))                  ) ||                   (sRhs.StartsWith(sLhs) &&                       (sRhs.EndsWith(".dll") || sRhs.EndsWith(".exe"))                  )"  is complex.
Complex Conditional,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,TypesAreTriviallyEqual,The conditional expression  "(                      (lhs.GetType() == tTr) ||                      (lhs.GetType() == tTd)                  ) && (                      (rhs.GetType() == tTr) ||                      (rhs.GetType() == tTd)                  )"  is complex.
Complex Conditional,JSIL.Ast,JSCastExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,NewInternal,The conditional expression  "(originalInnerType is ByReferenceType) &&                          TypeUtil.IsNumeric(innerType) &&                          (newType is PointerType) &&                          TypeUtil.IsNumeric(TypeUtil.GetElementType(newType' true))"  is complex.
Complex Conditional,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,EmitThisForParameter,The conditional expression  "tr != null                  && (CurrentMethod == null                  || (CurrentMethod.DeclaringType.GenericParameters != null                  && CurrentMethod.DeclaringType.GenericParameters.Any(p => p.Name == gp.Name)))"  is complex.
Complex Conditional,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,Signature,The conditional expression  "(                          (signature.ReturnType == null) ||                          (signature.ReturnType.FullName == "System.Void")                      ) &&                      (signature.ParameterCount == 1) &&                      !TypeUtil.IsOpenType(signature.ParameterTypes[0])"  is complex.
Complex Conditional,JSIL.Internal,TypeInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,The conditional expression  "!IsInterface &&                  !IsDelegate &&                  !Definition.IsEnum &&                   !Definition.IsAbstract &&                   !Definition.IsPrimitive"  is complex.
Complex Conditional,JSIL.Internal,TypeInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,BeforeAddProxyMember,The conditional expression  "(proxy.MemberPolicy == JSProxyMemberPolicy.ReplaceNone) ||                      member.CustomAttributes.Any(ShouldNeverReplace) ||                      ((owningMember != null) && (owningMember.CustomAttributes.Any(ShouldNeverReplace)))"  is complex.
Complex Conditional,JSIL.Transforms,HoistAllocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,VisitNode,The conditional expression  "isInsideLoop &&                  (parentPassByRef != null) &&                  (parentInvocation != null) &&                  !doesValueEscape"  is complex.
Complex Conditional,JSIL.Transforms,HoistAllocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,VisitNode,The conditional expression  "isStruct &&                   isInsideLoop &&                   (parentInvocation != null) &&                  !doesValueEscape"  is complex.
Complex Conditional,JSIL.Transforms,HoistAllocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\AllocationHoisting.cs,CreateHoistedVariable,The conditional expression  "(array == null) ||                  (index == null) ||                  index.AllChildrenRecursive.Any(filter) ||                   array.AllChildrenRecursive.Any(filter)"  is complex.
Complex Conditional,JSIL.Transforms,UnsafeCodeTransforms,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\UnsafeCodeTransforms.cs,VisitNode,The conditional expression  "(ParentNode is JSInvocationExpression) &&                  (invocation != null) &&                  (invocation.JSMethod != null) &&                  invocation.JSMethod.Reference.FullName.Contains("JSIL.Runtime.IPackedArray") &&                  invocation.JSMethod.Reference.FullName.Contains("get_Item(") &&                  Configuration.CodeGenerator.AggressivelyUseElementProxies.GetValueOrDefault(false)"  is complex.
Complex Conditional,JSIL.Transforms,UnsafeCodeTransforms,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\UnsafeCodeTransforms.cs,VisitNode,The conditional expression  "TypeUtil.IsPointer(leftType) &&                   TypeUtil.IsPointer(rightType) &&                  (boe.Operator is JSAssignmentOperator) &&                  ((leftVar = boe.Left as JSVariable) != null) &&                  ((rightAdd = boe.Right as JSPointerAddExpression) != null) &&                  rightAdd.Pointer.Equals(leftVar) &&                  !rightAdd.MutateInPlace"  is complex.
Complex Conditional,JSIL.Transforms,HandleBooleanAsInteger,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\HandleBooleanAsInteger.cs,VisitNode,The conditional expression  "(leftIsBool != rightIsBool) &&                   (leftIsNumeric || rightIsNumeric) &&                  !(boe.Operator is JSAssignmentOperator)"  is complex.
Complex Conditional,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The conditional expression  "(lastEs != null) &&                  (                      (lastEs.Expression is JSGotoExpression) ||                      (lastEs.Expression is JSBreakExpression) ||                      (lastEs.Expression is JSContinueExpression)                  )"  is complex.
Complex Conditional,JSIL.Transforms,ExpandCastExpressions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ExpandCastExpressions.cs,VisitNode,The conditional expression  "TypeUtil.TypesAreAssignable(TypeInfo' targetType' innerType) &&                      (                          (TypeUtil.IsFloatingPoint(targetType) == TypeUtil.IsFloatingPoint(currentType)) &&                          (TypeUtil.IsFloatingPoint(targetType) == TypeUtil.IsFloatingPoint(innerType))                      ) &&                      (TypeUtil.IsSigned(targetType) == TypeUtil.IsSigned(innerType)) &&                      (TypeUtil.SizeOfType(targetType) <= TypeUtil.SizeOfType(currentType)) &&                      (TypeUtil.SizeOfType(targetType) >= TypeUtil.SizeOfType(innerType))"  is complex.
Complex Conditional,JSIL.Transforms,IntroduceCharCasts,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceCharCasts.cs,VisitNode,The conditional expression  "isArithmetic &&                   (boe.GetActualType(TypeSystem).FullName == "System.Char") &&                  !(                      (parentInvocation != null) &&                       (parentInvocationDot != null) &&                      (parentInvocationDot.Target is JSStringIdentifier) &&                      (((JSStringIdentifier)parentInvocationDot.Target).Identifier == "String") &&                      (parentInvocationDot.Member is JSFakeMethod) &&                      (((JSFakeMethod)parentInvocationDot.Member).Name == "fromCharCode")                  )"  is complex.
Complex Conditional,JSIL.Transforms,DeoptimizeSwitchStatements,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,The conditional expression  "(invocation != null) &&                  (invocation.Arguments.Count == 2) &&                  (invocation.JSMethod != null) &&                  (invocation.JSMethod.Identifier == "TryGetValue")"  is complex.
Complex Conditional,JSIL.Transforms,ReplaceMethodCalls,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The conditional expression  "(method.Reference.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers") &&                      (method.Method.Name == "InitializeArray") &&                      (method.Method.Parameters.Length == 2) &&                      (method.Method.Parameters[0].ParameterType.FullName == "System.Array") &&                      (method.Method.Parameters[1].ParameterType.FullName == "System.RuntimeFieldHandle")"  is complex.
Complex Conditional,JSIL.Transforms,IntroduceEnumCasts,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceEnumCasts.cs,VisitNode,The conditional expression  "resultIsEnum &&                       ((parentCast == null) || (parentCast.NewType != resultType)) &&                       ((parentReinterpret == null) || (parentReinterpret.NewType != resultType))"  is complex.
Complex Conditional,JSIL.Transforms,OptimizeArrayEnumerators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The conditional expression  "(condInvocation != null) &&                   (condInvocation.JSMethod != null) &&                  (condInvocation.JSMethod.Identifier == "MoveNext") &&                  (condInvocation.JSMethod.Method.DeclaringType.Interfaces.ToEnumerable().Any((ii) => ii.Info.FullName == "System.Collections.IEnumerator")) &&                  ((enumeratorVariable = condInvocation.ThisReference as JSVariable) != null)"  is complex.
Complex Conditional,JSIL.Transforms,PropertyAccessReplacer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The conditional expression  "(jsm != null) &&                   (jsm.Method.Property == Property.Property) &&                   (ie.ThisReference.Equals(ThisReference)) &&                  (ie.Arguments.Count == 0)"  is complex.
Complex Conditional,JSIL.Transforms,FunctionAnalysis2ndPass,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,FunctionAnalysis2ndPass,The conditional expression  "(                      !data.Function.Method.Method.IsStatic &&                       data.Function.Method.Method.DeclaringType.IsImmutable &&                      data.ReassignsThisReference                  ) ||                  data.Function.Method.Method.Name == ".ctor""  is complex.
Complex Conditional,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The conditional expression  "(ie != null) && ie.ConstantIfArgumentsAre &&                      IsEffectivelyConstant(target' ie.ThisReference) &&                      ie.Arguments.All((a) => IsEffectivelyConstant(target' a))"  is complex.
Complex Conditional,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The conditional expression  "(sourceFirstAssigned.StatementIndex >= assignment) &&                          (sourceLastAssigned.StatementIndex < nextAssignment) &&                          (sourceFirstAccessed.StatementIndex >= assignment) &&                          (sourceLastAccessed.StatementIndex <= nextAssignment)"  is complex.
Complex Conditional,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The conditional expression  "(accesses.Length == 0) && (invocations.Length == 0) && (reassignments.Length == 0) && !isPassedByReference"  is complex.
Complex Conditional,JSIL.Transforms,SimplifyOperators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\SimplifyOperators.cs,VisitNode,The conditional expression  "isAssignment && (nestedBoe != null) &&                   (left.IsConstant || (leftVar != null) || left is JSDotExpressionBase) &&                  !(ParentNode is JSVariableDeclarationStatement)"  is complex.
Complex Conditional,JSIL.Transforms,SimplifyOperators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\SimplifyOperators.cs,VisitNode,The conditional expression  "areEqual &&                      PrefixOperators.TryGetValue(nestedBoe.Operator' out prefixOperator) &&                      (rightLiteral != null) && (rightLiteral.Value == 1)"  is complex.
Complex Conditional,JSIL.Transforms,VariableReferenceAccessTransformer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,VisitNode,The conditional expression  "(variable.Identifier != Variable.Identifier) ||                  // Don't transform if we're inside a read-through already                  (ParentNode is JSReadThroughReferenceExpression) ||                  (                      // If we're inside a write-through and on the LHS' don't transform                      (ParentNode is JSWriteThroughReferenceExpression) &&                      (this.CurrentName == "Left")                  )"  is complex.
Complex Conditional,JSIL.Transforms,VariableReferenceAccessTransformer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceVariableReferences.cs,VisitNode,The conditional expression  "!(ParentNode is JSVariableDeclarationStatement) &&                  (leftVar != null) &&                   (leftVar.Identifier == Variable.Identifier) &&                  (boe.Operator is JSAssignmentOperator)"  is complex.
Complex Conditional,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,The conditional expression  "(value is JSLiteral) ||                  (value is JSNewExpression) ||                  (value is JSPassByReferenceExpression) ||                  (value is JSNewBoxedVariable) ||                  (value is JSDefaultValueLiteral) ||                  (value is JSFieldOfExpression)"  is complex.
Complex Conditional,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,IsCopyNeeded,The conditional expression  "ReferenceCounts.TryGetValue(rightVar.Identifier' out referenceCount) &&                      (referenceCount == 1) &&                       !rightVar.IsReference &&                       rightVar.IsParameter &&                      !SecondPass.VariableAliases.ContainsKey(rightVar.Identifier)"  is complex.
Complex Conditional,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The conditional expression  "(                          rightVarsMutated ||                           leftVarMutated ||                          IsCopyNeededForAssignmentTarget(boe.Left) ||                           rightVarsAreReferences                      ) &&                      !IsCopyAlwaysUnnecessaryForAssignmentTarget(boe.Left) &&                      !rightVarIsEffectivelyConstantHere"  is complex.
Complex Conditional,JSIL.Transforms,EmulateStructAssignment,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EmulateStructAssignment.cs,VisitNode,The conditional expression  "!nbv.SuppressClone &&                  IsCopyNeeded(nbv.InitialValue' out relevantParameter) &&                  // We don't need to make a copy if the source value is a reference (like T& this)                  !((initialValueType) != null && initialValueType.IsByReference)"  is complex.
Virtual Method Call from Constructor,JSIL.Ast,JSBinaryOperatorExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSBinaryOperatorExpression,The constructor "JSBinaryOperatorExpression" calls a virtual method "CheckInvariant".
Virtual Method Call from Constructor,JSIL.Ast,JSBinaryOperatorExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,JSBinaryOperatorExpression,The constructor "JSBinaryOperatorExpression" calls a virtual method "CheckInvariant".
Empty Catch Block,JSIL.Internal,ConstructionState,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,Set,The method has an empty catch block.
Magic Number,JSIL,FunctionCache,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: Cache = new ConcurrentCache<QualifiedMemberIdentifier' Entry>(                  Environment.ProcessorCount' 4096' Comparer              );
Magic Number,JSIL,FunctionCache,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: PendingTransformsQueue = new ConcurrentHashQueue<QualifiedMemberIdentifier>(                  Math.Max(1' Environment.ProcessorCount / 4)' 4096' Comparer              );
Magic Number,JSIL,FunctionCache,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: PendingTransformsQueue = new ConcurrentHashQueue<QualifiedMemberIdentifier>(                  Math.Max(1' Environment.ProcessorCount / 4)' 4096' Comparer              );
Magic Number,JSIL,FunctionCache,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: ActiveTransformPipelines = new ConcurrentDictionary<QualifiedMemberIdentifier' FunctionTransformPipeline>(                  Math.Max(1' Environment.ProcessorCount / 4)' 128' Comparer              );
Magic Number,JSIL,FunctionCache,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionCache.cs,FunctionCache,The following statement contains a magic number: ActiveTransformPipelines = new ConcurrentDictionary<QualifiedMemberIdentifier' FunctionTransformPipeline>(                  Math.Max(1' Environment.ProcessorCount / 4)' 128' Comparer              );
Magic Number,JSIL,FunctionCache,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionCache.cs,TryAcquireStaticAnalysisDataLock,The following statement contains a magic number: const int lockTimeoutMs = 33;
Magic Number,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationPrefixForType,The following statement contains a magic number: switch (type.FullName) {                  case "System.Byte":                      parenCount = 1;                      break;                    case "System.SByte":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt16":                      parenCount = 1;                      break;                    case "System.Int16":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt32":                      parenCount = 1;                      break;                    case "System.Int32":                      parenCount = 1;                      break;                    case "System.Single":                      // fround only affects locals at present.                      // FIXME: Does this mean a forced float->double upconvert when it could be omitted by the VM?                      if (isLoad)                          Output.WriteRaw("+");                      else if (targetIsLocal)                          Output.WriteRaw("Math.fround(");                      else                          Output.WriteRaw("+(");                        return;                    case "System.Double":                      if (isLoad)                          Output.WriteRaw("+");                      else                          Output.WriteRaw("+(");                      return;              }
Magic Number,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationPrefixForType,The following statement contains a magic number: switch (type.FullName) {                  case "System.Byte":                      parenCount = 1;                      break;                    case "System.SByte":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt16":                      parenCount = 1;                      break;                    case "System.Int16":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt32":                      parenCount = 1;                      break;                    case "System.Int32":                      parenCount = 1;                      break;                    case "System.Single":                      // fround only affects locals at present.                      // FIXME: Does this mean a forced float->double upconvert when it could be omitted by the VM?                      if (isLoad)                          Output.WriteRaw("+");                      else if (targetIsLocal)                          Output.WriteRaw("Math.fround(");                      else                          Output.WriteRaw("+(");                        return;                    case "System.Double":                      if (isLoad)                          Output.WriteRaw("+");                      else                          Output.WriteRaw("+(");                      return;              }
Magic Number,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,ArgumentsNeedLineBreak,The following statement contains a magic number: return ((arguments.Count > 1) &&                  (                      (CountOfMatchingSubtrees<JSFunctionExpression>(arguments) > 1) ||                      (CountOfMatchingSubtrees<JSInvocationExpression>(arguments) > 1) ||                      (CountOfMatchingSubtrees<JSDelegateInvocationExpression>(arguments) > 1)                  )) ||                  (arguments.Count > 4);
Magic Number,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,CanUseFastOverloadDispatch,The following statement contains a magic number: overloadCount >= 2
Magic Number,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILBuiltinsMethodReplacement,The following statement contains a magic number: switch (methodName) {                  case "CreateNamedFunction`1": {                      JSExpression closureArg = null;                      if (arguments.Length > 3)                          closureArg = arguments[3];                        return JSIL.CreateNamedFunction(                          genericArguments.First()' arguments[0]' arguments[1]' arguments[2]' closureArg                      );                  }                    case "Eval":                      return JSInvocationExpression.InvokeStatic(                          JS.eval' arguments                      );                    case "IsTruthy":                      return new JSUnaryOperatorExpression(                          JSOperator.LogicalNot'                           new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean)'                           TypeSystem.Boolean                      );                    case "IsFalsy":                      return new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean);                    case "get_This":                      return MakeIndirectVariable("this");                    case "get_IsJavascript":                      return new JSBooleanLiteral(true);              }
Magic Number,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILBuiltinsMethodReplacement,The following statement contains a magic number: switch (methodName) {                  case "CreateNamedFunction`1": {                      JSExpression closureArg = null;                      if (arguments.Length > 3)                          closureArg = arguments[3];                        return JSIL.CreateNamedFunction(                          genericArguments.First()' arguments[0]' arguments[1]' arguments[2]' closureArg                      );                  }                    case "Eval":                      return JSInvocationExpression.InvokeStatic(                          JS.eval' arguments                      );                    case "IsTruthy":                      return new JSUnaryOperatorExpression(                          JSOperator.LogicalNot'                           new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean)'                           TypeSystem.Boolean                      );                    case "IsFalsy":                      return new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean);                    case "get_This":                      return MakeIndirectVariable("this");                    case "get_IsJavascript":                      return new JSBooleanLiteral(true);              }
Magic Number,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILBuiltinsMethodReplacement,The following statement contains a magic number: switch (methodName) {                  case "CreateNamedFunction`1": {                      JSExpression closureArg = null;                      if (arguments.Length > 3)                          closureArg = arguments[3];                        return JSIL.CreateNamedFunction(                          genericArguments.First()' arguments[0]' arguments[1]' arguments[2]' closureArg                      );                  }                    case "Eval":                      return JSInvocationExpression.InvokeStatic(                          JS.eval' arguments                      );                    case "IsTruthy":                      return new JSUnaryOperatorExpression(                          JSOperator.LogicalNot'                           new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean)'                           TypeSystem.Boolean                      );                    case "IsFalsy":                      return new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean);                    case "get_This":                      return MakeIndirectVariable("this");                    case "get_IsJavascript":                      return new JSBooleanLiteral(true);              }
Magic Number,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The following statement contains a magic number: switch (typeName) {                  case "JSIL.Builtins":                      return DoJSILBuiltinsMethodReplacement(methodName' genericArguments' arguments' method == null);                    case "JSIL.Verbatim": {                      if (                          (methodName == "Expression") || methodName.StartsWith("Expression`")                      ) {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSIL.Verbatim.Expression must recieve a string literal as an argument");                            JSExpression commaFirstClause = null;                          IDictionary<string' JSExpression> argumentsDict = null;                            if (arguments.Length > 1) {                              var argumentsExpression = arguments[1];                              var argumentsArray = argumentsExpression as JSNewArrayExpression;                                if (method == null || method.Method.Parameters[1].ParameterType is GenericParameter) {                                  // This call was made dynamically or through generic version of method' so the parameters are not an array.                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < (arguments.Length - 1); i++)                                      argumentsDict.Add(String.Format("{0}"' i)' arguments[i + 1]);                              } else if (argumentsArray == null) {                                  // The array is static so we need to pull elements out of it after assigning it a name.                                  // FIXME: Only handles up to 40 elements.                                  var argumentsExpressionType = argumentsExpression.GetActualType(TypeSystem);                                  var temporaryVariable = MakeTemporaryVariable(argumentsExpressionType);                                  var temporaryAssignment = new JSBinaryOperatorExpression(JSOperator.Assignment' temporaryVariable' argumentsExpression' argumentsExpressionType);                                    commaFirstClause = temporaryAssignment;                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < 40; i++)                                      argumentsDict.Add(String.Format("{0}"' i)' new JSIndexerExpression(temporaryVariable' JSLiteral.New(i)));                              } else {                                  var argumentsArrayExpression = argumentsArray.SizeOrArrayInitializer as JSArrayExpression;                                    if (argumentsArrayExpression == null)                                      throw new NotImplementedException("Literal array must have values");                                    argumentsDict = new Dictionary<string' JSExpression>();                                    int i = 0;                                  foreach (var value in argumentsArrayExpression.Values) {                                      argumentsDict.Add(String.Format("{0}"' i)' value);                                        i += 1;                                  }                              }                          }                            var verbatimLiteral = new JSVerbatimLiteral(                              methodName' expression.Value' argumentsDict                          );                            if (commaFirstClause != null)                              return new JSCommaExpression(commaFirstClause' verbatimLiteral);                          else                              return verbatimLiteral;                      } else {                          throw new NotImplementedException("Verbatim method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSGlobal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression != null)                              return new JSDotExpression(                                  JSIL.GlobalNamespace' new JSStringIdentifier(expression.Value' TypeSystem.Object' true)                              );                          else                              return new JSIndexerExpression(                                  JSIL.GlobalNamespace' arguments[0]' TypeSystem.Object                              );                      } else {                          throw new NotImplementedException("JSGlobal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSLocal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSLocal must recieve a string literal as an index");                            return new JSStringIdentifier(expression.Value' TypeSystem.Object' true);                      } else {                          throw new NotImplementedException("JSLocal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.Services": {                      if (methodName == "Get") {                          if (arguments.Length != 2)                              throw new InvalidOperationException("JSIL.Services.Get must receive two arguments");                            var serviceName = arguments[0];                          var shouldThrow = arguments[1];                            return JSInvocationExpression.InvokeStatic(                              new JSRawOutputIdentifier(TypeSystem.Object' "JSIL.Host.getService")'                              new[] {                                  serviceName'                                  new JSUnaryOperatorExpression(JSOperator.LogicalNot' shouldThrow' TypeSystem.Boolean)                              }' true                          );                      } else {                          throw new NotImplementedException("JSIL.Services method not implemented: " + methodName);                      }                      break;                  }              }
Magic Number,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The following statement contains a magic number: switch (typeName) {                  case "JSIL.Builtins":                      return DoJSILBuiltinsMethodReplacement(methodName' genericArguments' arguments' method == null);                    case "JSIL.Verbatim": {                      if (                          (methodName == "Expression") || methodName.StartsWith("Expression`")                      ) {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSIL.Verbatim.Expression must recieve a string literal as an argument");                            JSExpression commaFirstClause = null;                          IDictionary<string' JSExpression> argumentsDict = null;                            if (arguments.Length > 1) {                              var argumentsExpression = arguments[1];                              var argumentsArray = argumentsExpression as JSNewArrayExpression;                                if (method == null || method.Method.Parameters[1].ParameterType is GenericParameter) {                                  // This call was made dynamically or through generic version of method' so the parameters are not an array.                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < (arguments.Length - 1); i++)                                      argumentsDict.Add(String.Format("{0}"' i)' arguments[i + 1]);                              } else if (argumentsArray == null) {                                  // The array is static so we need to pull elements out of it after assigning it a name.                                  // FIXME: Only handles up to 40 elements.                                  var argumentsExpressionType = argumentsExpression.GetActualType(TypeSystem);                                  var temporaryVariable = MakeTemporaryVariable(argumentsExpressionType);                                  var temporaryAssignment = new JSBinaryOperatorExpression(JSOperator.Assignment' temporaryVariable' argumentsExpression' argumentsExpressionType);                                    commaFirstClause = temporaryAssignment;                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < 40; i++)                                      argumentsDict.Add(String.Format("{0}"' i)' new JSIndexerExpression(temporaryVariable' JSLiteral.New(i)));                              } else {                                  var argumentsArrayExpression = argumentsArray.SizeOrArrayInitializer as JSArrayExpression;                                    if (argumentsArrayExpression == null)                                      throw new NotImplementedException("Literal array must have values");                                    argumentsDict = new Dictionary<string' JSExpression>();                                    int i = 0;                                  foreach (var value in argumentsArrayExpression.Values) {                                      argumentsDict.Add(String.Format("{0}"' i)' value);                                        i += 1;                                  }                              }                          }                            var verbatimLiteral = new JSVerbatimLiteral(                              methodName' expression.Value' argumentsDict                          );                            if (commaFirstClause != null)                              return new JSCommaExpression(commaFirstClause' verbatimLiteral);                          else                              return verbatimLiteral;                      } else {                          throw new NotImplementedException("Verbatim method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSGlobal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression != null)                              return new JSDotExpression(                                  JSIL.GlobalNamespace' new JSStringIdentifier(expression.Value' TypeSystem.Object' true)                              );                          else                              return new JSIndexerExpression(                                  JSIL.GlobalNamespace' arguments[0]' TypeSystem.Object                              );                      } else {                          throw new NotImplementedException("JSGlobal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSLocal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSLocal must recieve a string literal as an index");                            return new JSStringIdentifier(expression.Value' TypeSystem.Object' true);                      } else {                          throw new NotImplementedException("JSLocal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.Services": {                      if (methodName == "Get") {                          if (arguments.Length != 2)                              throw new InvalidOperationException("JSIL.Services.Get must receive two arguments");                            var serviceName = arguments[0];                          var shouldThrow = arguments[1];                            return JSInvocationExpression.InvokeStatic(                              new JSRawOutputIdentifier(TypeSystem.Object' "JSIL.Host.getService")'                              new[] {                                  serviceName'                                  new JSUnaryOperatorExpression(JSOperator.LogicalNot' shouldThrow' TypeSystem.Boolean)                              }' true                          );                      } else {                          throw new NotImplementedException("JSIL.Services method not implemented: " + methodName);                      }                      break;                  }              }
Magic Number,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_TernaryOp,The following statement contains a magic number: var right = node.Arguments[2];
Magic Number,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Stelem,The following statement contains a magic number: var rhs = TranslateNode(node.Arguments[2]);
Magic Number,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_InitArray,The following statement contains a magic number: TypeUtil.TypesAreEqual(TypeSystem.Object' at) && rank < 2
Magic Number,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,GetDefaultProxyAssembly,The following statement contains a magic number: frameworkVersion == 4.0
Magic Number,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,GetParallelOptions,The following statement contains a magic number: return new ParallelOptions {                  MaxDegreeOfParallelism = Configuration.UseThreads.GetValueOrDefault(false)                       ? (Environment.ProcessorCount + 2)                       : 1              };
Magic Number,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TranslateInternal,The following statement contains a magic number: pr.OnProgressChanged(i' assemblies.Length * 2);
Magic Number,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,TriggerAutomaticGC,The following statement contains a magic number: GC.Collect(2' GCCollectionMode.Optimized);
Magic Number,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,AnalyzeFunctions,The following statement contains a magic number: Func<int' ParallelLoopState' DecompilerContext' DecompilerContext> analyzeAMethod = (_' loopState' ctx) => {                  MethodToAnalyze m;                  if (!methodsToAnalyze.TryTake(out m))                      throw new InvalidDataException("Method collection mutated during analysis. Try setting UseThreads=false (and report an issue!)");                    ctx.CurrentModule = m.MD.Module;                  ctx.CurrentType = m.MD.DeclaringType;                  ctx.CurrentMethod = m.MD;                    try {                      TranslateMethodExpression(ctx' m.MD' m.MD' m.MI);                  } catch (Exception exc) {                      throw new Exception("Error occurred while translating method '" + m.MD.FullName + "'."' exc);                  }                    var j = Interlocked.Increment(ref i);                  pr.OnProgressChanged(mc + j' mc * 2);                    return ctx;              };
Magic Number,JSIL,AssemblyTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AssemblyTranslator.cs,RunTransformsOnAllFunctions,The following statement contains a magic number: const int autoGcInterval = 256;
Magic Number,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Magic Number,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following statement contains a magic number: return 4;
Magic Number,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: var levelOfParallelism = Math.Max(1' Environment.ProcessorCount / 2);
Magic Number,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: ProxiesByName = new ConcurrentCache<HashedString' ProxiesByNameRecord>(                  levelOfParallelism' 256' new HashedStringComparer()              );
Magic Number,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: TypeAssignabilityCache = new ConcurrentCache<Tuple<string' string>' bool>(levelOfParallelism' 4096);
Magic Number,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: TypeInformation = new ConcurrentCache<TypeIdentifier' TypeInfo>(levelOfParallelism' 4096' TypeIdentifier.Comparer);
Magic Number,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,TypeInfoProvider,The following statement contains a magic number: ModuleInformation = new ConcurrentCache<string' ModuleInfo>(levelOfParallelism' 256' StringComparer.Ordinal);
Magic Number,JSIL.Ast.Enumerators,JSNodeChildEnumerator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\Enumerators.cs,JSNodeChildEnumerator,The following statement contains a magic number: _Index = IncludeSelf ? -2 : -1;
Magic Number,JSIL.Ast.Enumerators,JSNodeChildEnumerator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\Enumerators.cs,Reset,The following statement contains a magic number: _Index = IncludeSelf ? -2 : -1;
Magic Number,JSIL.Ast,JSBinaryOperatorExpression,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,New,The following statement contains a magic number: values.Count < 2
Magic Number,JSIL.Ast,JSPointerExpressionUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetNativeSizeOfElement,The following statement contains a magic number: switch (elementType.FullName) {                  case "System.Byte":                  case "System.SByte":                      return 1;                    case "System.Int16":                  case "System.UInt16":                      return 2;                    case "System.Int32":                  case "System.UInt32":                  case "System.Single":                      return 4;                    case "System.Int64":                  case "System.UInt64":                  case "System.Double":                      return 8;              }
Magic Number,JSIL.Ast,JSPointerExpressionUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetNativeSizeOfElement,The following statement contains a magic number: switch (elementType.FullName) {                  case "System.Byte":                  case "System.SByte":                      return 1;                    case "System.Int16":                  case "System.UInt16":                      return 2;                    case "System.Int32":                  case "System.UInt32":                  case "System.Single":                      return 4;                    case "System.Int64":                  case "System.UInt64":                  case "System.Double":                      return 8;              }
Magic Number,JSIL.Ast,JSPointerExpressionUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetNativeSizeOfElement,The following statement contains a magic number: switch (elementType.FullName) {                  case "System.Byte":                  case "System.SByte":                      return 1;                    case "System.Int16":                  case "System.UInt16":                      return 2;                    case "System.Int32":                  case "System.UInt32":                  case "System.Single":                      return 4;                    case "System.Int64":                  case "System.UInt64":                  case "System.Double":                      return 8;              }
Magic Number,JSIL.Internal,BugChecks,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\BugChecks.cs,BrokenConcurrentDictionary,The following statement contains a magic number: var dict = new ConcurrentDictionary<MyKey' string>(1' 2);
Magic Number,JSIL.Internal,CachingMetadataResolver,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\CILSupport.cs,CachingMetadataResolver,The following statement contains a magic number: Cache = new ConcurrentCache<Key' TypeDefinition>(                  Environment.ProcessorCount' 4096' new KeyComparer()              );
Magic Number,JSIL.Internal,FunctionTransformPipeline,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\FunctionTransformPipeline.cs,RunUntilCompletion,The following statement contains a magic number: const int lockTimeoutMs = 250;
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: return FromRGB(255' 255' 255);
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: return FromRGB(255' 255' 255);
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: return FromRGB(255' 255' 255);
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: int range = value * 255 / ValueMax;
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: int rb = colorRange - b + (c * 2);
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: switch (segment) {                  case 0:                      return FromRGB(ClampByte(a)' ClampByte(b)' ClampByte(c));                  case 1:                      return FromRGB(ClampByte(rb)' ClampByte(a)' ClampByte(c));                  case 2:                      return FromRGB(ClampByte(c)' ClampByte(a)' ClampByte(b));                  case 3:                      return FromRGB(ClampByte(c)' ClampByte(rb)' ClampByte(a));                  case 4:                      return FromRGB(ClampByte(b)' ClampByte(c)' ClampByte(a));                  case 5:                      return FromRGB(ClampByte(a)' ClampByte(c)' ClampByte(rb));                  default:                      throw new ArgumentException("Invalid color");              }
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: switch (segment) {                  case 0:                      return FromRGB(ClampByte(a)' ClampByte(b)' ClampByte(c));                  case 1:                      return FromRGB(ClampByte(rb)' ClampByte(a)' ClampByte(c));                  case 2:                      return FromRGB(ClampByte(c)' ClampByte(a)' ClampByte(b));                  case 3:                      return FromRGB(ClampByte(c)' ClampByte(rb)' ClampByte(a));                  case 4:                      return FromRGB(ClampByte(b)' ClampByte(c)' ClampByte(a));                  case 5:                      return FromRGB(ClampByte(a)' ClampByte(c)' ClampByte(rb));                  default:                      throw new ArgumentException("Invalid color");              }
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: switch (segment) {                  case 0:                      return FromRGB(ClampByte(a)' ClampByte(b)' ClampByte(c));                  case 1:                      return FromRGB(ClampByte(rb)' ClampByte(a)' ClampByte(c));                  case 2:                      return FromRGB(ClampByte(c)' ClampByte(a)' ClampByte(b));                  case 3:                      return FromRGB(ClampByte(c)' ClampByte(rb)' ClampByte(a));                  case 4:                      return FromRGB(ClampByte(b)' ClampByte(c)' ClampByte(a));                  case 5:                      return FromRGB(ClampByte(a)' ClampByte(c)' ClampByte(rb));                  default:                      throw new ArgumentException("Invalid color");              }
Magic Number,JSIL.Internal,HTMLColor,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\HTMLColor.cs,FromHSV,The following statement contains a magic number: switch (segment) {                  case 0:                      return FromRGB(ClampByte(a)' ClampByte(b)' ClampByte(c));                  case 1:                      return FromRGB(ClampByte(rb)' ClampByte(a)' ClampByte(c));                  case 2:                      return FromRGB(ClampByte(c)' ClampByte(a)' ClampByte(b));                  case 3:                      return FromRGB(ClampByte(c)' ClampByte(rb)' ClampByte(a));                  case 4:                      return FromRGB(ClampByte(b)' ClampByte(c)' ClampByte(a));                  case 5:                      return FromRGB(ClampByte(a)' ClampByte(c)' ClampByte(rb));                  default:                      throw new ArgumentException("Invalid color");              }
Magic Number,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,CommaSeparatedList,The following statement contains a magic number: CommaSeparatedListCore(                  values' (value) => {                      if (valueType == ListValueType.Primitive)                          Value(value as dynamic);                      else if (valueType == ListValueType.Identifier)                          Identifier(value as dynamic' context);                      else if (valueType == ListValueType.TypeIdentifier)                          TypeIdentifier(value as dynamic' context' false);                      else if (valueType == ListValueType.TypeReference)                          TypeReference((TypeReference)value' context);                      else                          WriteRaw(value.ToString());                  }'                    ((valueType == ListValueType.TypeIdentifier) || (valueType == ListValueType.TypeReference)) ?                      2 : 4              );
Magic Number,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,CommaSeparatedList,The following statement contains a magic number: CommaSeparatedListCore(                  values' (value) => {                      if (valueType == ListValueType.Primitive)                          Value(value as dynamic);                      else if (valueType == ListValueType.Identifier)                          Identifier(value as dynamic' context);                      else if (valueType == ListValueType.TypeIdentifier)                          TypeIdentifier(value as dynamic' context' false);                      else if (valueType == ListValueType.TypeReference)                          TypeReference((TypeReference)value' context);                      else                          WriteRaw(value.ToString());                  }'                    ((valueType == ListValueType.TypeIdentifier) || (valueType == ListValueType.TypeReference)) ?                      2 : 4              );
Magic Number,JSIL.Internal,MethodSignature,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\MethodSignature.cs,GetHashCode,The following statement contains a magic number: hash ^= (GenericParameterCount) << 16;
Magic Number,JSIL.Internal,Mapping,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode*397) ^ GeneratedColumn.GetHashCode();
Magic Number,JSIL.Internal,Mapping,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode*397) ^ OriginalLine.GetHashCode();
Magic Number,JSIL.Internal,Mapping,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode*397) ^ OriginalColumn.GetHashCode();
Magic Number,JSIL.Internal,Mapping,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode*397) ^ (Source != null ? Source.GetHashCode() : 0);
Magic Number,JSIL.Internal,Mapping,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\SourceMapBuilder.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode*397) ^ (Name != null ? Name.GetHashCode() : 0);
Magic Number,JSIL.Internal,TypeInfo,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,TypeInfo,The following statement contains a magic number: var name = String.Format(".cctor{0}"' ExtraStaticConstructors.Count + 2);
Magic Number,JSIL.Internal,Util,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,EscapeIdentifier,The following statement contains a magic number: switch (ch) {                      case '.':                          if (escapingMode != EscapingMode.MemberIdentifier)                              sb.Append(".");                          else {                              sb.Append("_");                              isEscaped = true;                          }                      break;                      case '/':                          if (escapingMode == EscapingMode.MemberIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else if (escapingMode == EscapingMode.TypeIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else                              sb.Append("/");                      break;                      case '+':                          if (escapingMode == EscapingMode.MemberIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else if (escapingMode == EscapingMode.TypeIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else                              sb.Append("+");                      break;                      case '`':                          if (escapingMode != EscapingMode.String) {                              sb.Append("$b");                          } else {                              sb.Append("`");                          }                          isEscaped = true;                      break;                      case '~':                          sb.Append("$t");                          isEscaped = true;                      break;                      case ':':                          sb.Append("$co");                          isEscaped = true;                      break;                      case '<':                          sb.Append("$l");                          isEscaped = true;                      break;                      case '>':                          sb.Append("$g");                          isEscaped = true;                      break;                      case '(':                          sb.Append("$lp");                          isEscaped = true;                      break;                      case ')':                          sb.Append("$rp");                          isEscaped = true;                      break;                      case '{':                          sb.Append("$lc");                          isEscaped = true;                      break;                      case '}':                          sb.Append("$rc");                          isEscaped = true;                      break;                      case '[':                          sb.Append("$lb");                          isEscaped = true;                      break;                      case ']':                          sb.Append("$rb");                          isEscaped = true;                      break;                      case '@':                          sb.Append("$at");                          isEscaped = true;                      break;                      case '-':                          sb.Append("$da");                          isEscaped = true;                      break;                      case '=':                          sb.Append("$eq");                          isEscaped = true;                      break;                      case ' ':                          sb.Append("$sp");                          isEscaped = true;                      break;                      case '?':                          sb.Append("$qu");                          isEscaped = true;                      break;                      case '!':                          sb.Append("$ex");                          isEscaped = true;                      break;                      case '*':                          sb.Append("$as");                          isEscaped = true;                      break;                      case '&':                          sb.Append("$am");                          isEscaped = true;                      break;                      case ''':                          sb.Append("$cm");                          isEscaped = true;                      break;                      case '|':                          sb.Append("$vb");                          isEscaped = true;                      break;                      case '\'':                          sb.Append("$q");                          isEscaped = true;                      break;                      default:                          if ((ch <= 32) || (ch >= 127)) {                              sb.AppendFormat("${0:x}"' (int)ch);                              isEscaped = true;                          } else                              sb.Append(ch);                      break;                  }
Magic Number,JSIL.Internal,Util,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,EscapeIdentifier,The following statement contains a magic number: switch (ch) {                      case '.':                          if (escapingMode != EscapingMode.MemberIdentifier)                              sb.Append(".");                          else {                              sb.Append("_");                              isEscaped = true;                          }                      break;                      case '/':                          if (escapingMode == EscapingMode.MemberIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else if (escapingMode == EscapingMode.TypeIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else                              sb.Append("/");                      break;                      case '+':                          if (escapingMode == EscapingMode.MemberIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else if (escapingMode == EscapingMode.TypeIdentifier) {                              sb.Append("_");                              isEscaped = true;                          } else                              sb.Append("+");                      break;                      case '`':                          if (escapingMode != EscapingMode.String) {                              sb.Append("$b");                          } else {                              sb.Append("`");                          }                          isEscaped = true;                      break;                      case '~':                          sb.Append("$t");                          isEscaped = true;                      break;                      case ':':                          sb.Append("$co");                          isEscaped = true;                      break;                      case '<':                          sb.Append("$l");                          isEscaped = true;                      break;                      case '>':                          sb.Append("$g");                          isEscaped = true;                      break;                      case '(':                          sb.Append("$lp");                          isEscaped = true;                      break;                      case ')':                          sb.Append("$rp");                          isEscaped = true;                      break;                      case '{':                          sb.Append("$lc");                          isEscaped = true;                      break;                      case '}':                          sb.Append("$rc");                          isEscaped = true;                      break;                      case '[':                          sb.Append("$lb");                          isEscaped = true;                      break;                      case ']':                          sb.Append("$rb");                          isEscaped = true;                      break;                      case '@':                          sb.Append("$at");                          isEscaped = true;                      break;                      case '-':                          sb.Append("$da");                          isEscaped = true;                      break;                      case '=':                          sb.Append("$eq");                          isEscaped = true;                      break;                      case ' ':                          sb.Append("$sp");                          isEscaped = true;                      break;                      case '?':                          sb.Append("$qu");                          isEscaped = true;                      break;                      case '!':                          sb.Append("$ex");                          isEscaped = true;                      break;                      case '*':                          sb.Append("$as");                          isEscaped = true;                      break;                      case '&':                          sb.Append("$am");                          isEscaped = true;                      break;                      case ''':                          sb.Append("$cm");                          isEscaped = true;                      break;                      case '|':                          sb.Append("$vb");                          isEscaped = true;                      break;                      case '\'':                          sb.Append("$q");                          isEscaped = true;                      break;                      default:                          if ((ch <= 32) || (ch >= 127)) {                              sb.AppendFormat("${0:x}"' (int)ch);                              isEscaped = true;                          } else                              sb.Append(ch);                      break;                  }
Magic Number,JSIL.Internal,Util,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,EscapeCharacter,The following statement contains a magic number: switch (character) {                  case '\'':                      return @"\'";                  case '\\':                      return @"\\";                  case '"':                      return "\\\"";                  case '\t':                      return @"\t";                  case '\r':                      return @"\r";                  case '\n':                      return @"\n";                  default: {                      if (forJson || (character > 255))                          return String.Format(@"\u{0:x4}"' (int)character);                      else                          return String.Format(@"\x{0:x2}"' (int)character);                  }              }
Magic Number,JSIL.Internal,ConcurrentHashQueue<TValue>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,TryDequeue,The following statement contains a magic number: int tryCount = 10;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,ImmutableArrayPool,The following statement contains a magic number: int itemSize = Environment.Is64BitProcess                   ? 8                   : 4;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,ImmutableArrayPool,The following statement contains a magic number: int itemSize = Environment.Is64BitProcess                   ? 8                   : 4;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: var result = Allocate(2);
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: var result = Allocate(3);
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: result.Array[result.Offset + 2] = c;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: var result = Allocate(4);
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: result.Array[result.Offset + 2] = c;
Magic Number,JSIL.Internal,ImmutableArrayPool<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Util.cs,Elements,The following statement contains a magic number: result.Array[result.Offset + 3] = d;
Magic Number,JSIL.Transforms,FixupStructConstructorInvocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\FixupStructConstructorInvocations.cs,VisitNode,The following statement contains a magic number: Initializations.Add(new InitializationInfo {                          Type = thisReferenceType'                          DefaultValueLiteral = dvl'                          ParentBinaryExpression = parentBoe'                          BinaryExpressionParent = Stack.Skip(2).First()                      });
Magic Number,JSIL.Transforms,FixupStructConstructorInvocations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\FixupStructConstructorInvocations.cs,VisitNode,The following statement contains a magic number: Initializations.Add(new InitializationInfo {                      Type = thisReferenceType'                      NewExpression = ne'                      ParentBinaryExpression = parentBoe'                      BinaryExpressionParent = Stack.Skip(2).First()                  });
Magic Number,JSIL.Transforms,EmulateInt64,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\EmulateInt64.cs,GetLongLiteralExpression,The following statement contains a magic number: uint b = (uint)((number >> 24) & 0xffffff);
Magic Number,JSIL.Transforms,EmulateInt64,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\EmulateInt64.cs,GetLongLiteralExpression,The following statement contains a magic number: uint c = (uint)((number >> 48) & 0xffff);
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 3
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 3
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 3
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 3
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 3
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitControlFlowNode,The following statement contains a magic number: var stackSlice = Stack.Take(3).ToArray();
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,VisitControlFlowNode,The following statement contains a magic number: var parentBlock = stackSlice[2] as JSBlockStatement;
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The following statement contains a magic number: TraceLevel >= 3
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,ControlFlowSimplifier,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\ControlFlowSimplifier.cs,CheckForFallthrough,The following statement contains a magic number: (TraceLevel >= 2) && failed
Magic Number,JSIL.Transforms,LabelGroupFlattener,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\LabelGroupBuilder.cs,MaybeFlatten,The following statement contains a magic number: var exitLabel = labels[2];
Magic Number,JSIL.Transforms,LabelGroupFlattener,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\LabelGroupBuilder.cs,MaybeFlatten,The following statement contains a magic number: (labelledGroup != null) &&                  (labelledGroup.Labels.Count == 3)
Magic Number,JSIL.Transforms,DeoptimizeSwitchStatements,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\DeoptimizeSwitchStatements.cs,VisitNode,The following statement contains a magic number: (invocation != null) &&                  (invocation.Arguments.Count == 2) &&                  (invocation.JSMethod != null) &&                  (invocation.JSMethod.Identifier == "TryGetValue")
Magic Number,JSIL.Transforms,OptimizeArrayEnumerators,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\OptimizeArrayEnumerators.cs,VisitNode,The following statement contains a magic number: var lengthMember = (string)attrParams[2].Value;
Magic Number,JSIL.Transforms,StaticAnalyzer,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\StaticAnalyzer.cs,VisitNode,The following statement contains a magic number: (ParentNode is JSPassByReferenceExpression) ||                  (                      (ParentNode is JSReferenceExpression) &&                      (Stack.Skip(2).FirstOrDefault() is JSPassByReferenceExpression)                  )
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,IsEffectivelyConstant,The following statement contains a magic number: TraceLevel >= 5
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,ExemptVariablesFromEffectivelyConstantStatus,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 5
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,EliminateSingleUseTemporaries,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\StaticAnalysis\EliminateSingleUseTemporaries.cs,VisitNode,The following statement contains a magic number: TraceLevel >= 2
Magic Number,JSIL.Transforms,IntroduceVariableDeclarations,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\IntroduceVariableDeclarations.cs,VisitNode,The following statement contains a magic number: var superParent = Stack.Skip(2).FirstOrDefault();
Missing Default,JSIL,JavascriptAssemblyEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAssemblyEmitter.cs,EmitPrimitiveDefinition,The following switch statement is missing a default case: switch (typedef.FullName) {                  case "System.Boolean":                      isIntegral = true;                      isNumeric = true;                      break;                  case "System.Char":                      isIntegral = true;                      isNumeric = true;                      break;                  case "System.Byte":                  case "System.SByte":                  case "System.UInt16":                  case "System.Int16":                  case "System.UInt32":                  case "System.Int32":                  case "System.UInt64":                  case "System.Int64":                      isIntegral = true;                      isNumeric = true;                      break;                  case "System.Single":                  case "System.Double":                  case "System.Decimal":                      isIntegral = false;                      isNumeric = true;                      break;              }
Missing Default,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationPrefixForType,The following switch statement is missing a default case: switch (type.FullName) {                  case "System.Byte":                      parenCount = 1;                      break;                    case "System.SByte":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt16":                      parenCount = 1;                      break;                    case "System.Int16":                      if (isLoad)                          parenCount = 1;                      else                          parenCount = 2;                      break;                    case "System.UInt32":                      parenCount = 1;                      break;                    case "System.Int32":                      parenCount = 1;                      break;                    case "System.Single":                      // fround only affects locals at present.                      // FIXME: Does this mean a forced float->double upconvert when it could be omitted by the VM?                      if (isLoad)                          Output.WriteRaw("+");                      else if (targetIsLocal)                          Output.WriteRaw("Math.fround(");                      else                          Output.WriteRaw("+(");                        return;                    case "System.Double":                      if (isLoad)                          Output.WriteRaw("+");                      else                          Output.WriteRaw("+(");                      return;              }
Missing Default,JSIL,JavascriptAstEmitter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptAstEmitter.cs,WriteTruncationForType,The following switch statement is missing a default case: switch (type.FullName) {                  case "System.Byte":                      if (isLoad)                          Output.WriteRaw(" | 0)");                      else                          Output.WriteRaw(" & 0xFF)");                      break;                    case "System.SByte":                      if (isLoad)                          Output.WriteRaw(" | 0)");                      else                          Output.WriteRaw(" + 0x80 & 0xFF) - 0x80)");                      break;                    case "System.UInt16":                      if (isLoad)                          Output.WriteRaw(" | 0)");                      else                          Output.WriteRaw(" & 0xFFFF)");                      break;                    case "System.Int16":                      if (isLoad)                          Output.WriteRaw(" | 0)");                      else                          Output.WriteRaw(" + 0x8000 & 0xFFFF) - 0x8000)");                      break;                    case "System.UInt32":                      Output.WriteRaw(" >>> 0)");                      break;                    case "System.Int32":                      Output.WriteRaw(" | 0)");                      break;                    case "System.Single":                      // fround only affects locals at present.                      // FIXME: Does this mean a forced float->double upconvert when it could be omitted by the VM?                      if (isLoad)                          return;                      else if (targetIsLocal)                          Output.WriteRaw(")");                      else                          Output.WriteRaw(")");                        return;                    case "System.Double":                      if (isLoad)                          return;                      else                          Output.WriteRaw(")");                      return;              }
Missing Default,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILBuiltinsMethodReplacement,The following switch statement is missing a default case: switch (methodName) {                  case "CreateNamedFunction`1": {                      JSExpression closureArg = null;                      if (arguments.Length > 3)                          closureArg = arguments[3];                        return JSIL.CreateNamedFunction(                          genericArguments.First()' arguments[0]' arguments[1]' arguments[2]' closureArg                      );                  }                    case "Eval":                      return JSInvocationExpression.InvokeStatic(                          JS.eval' arguments                      );                    case "IsTruthy":                      return new JSUnaryOperatorExpression(                          JSOperator.LogicalNot'                           new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean)'                           TypeSystem.Boolean                      );                    case "IsFalsy":                      return new JSUnaryOperatorExpression(JSOperator.LogicalNot' arguments.First()' TypeSystem.Boolean);                    case "get_This":                      return MakeIndirectVariable("this");                    case "get_IsJavascript":                      return new JSBooleanLiteral(true);              }
Missing Default,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoJSILMethodReplacement,The following switch statement is missing a default case: switch (typeName) {                  case "JSIL.Builtins":                      return DoJSILBuiltinsMethodReplacement(methodName' genericArguments' arguments' method == null);                    case "JSIL.Verbatim": {                      if (                          (methodName == "Expression") || methodName.StartsWith("Expression`")                      ) {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSIL.Verbatim.Expression must recieve a string literal as an argument");                            JSExpression commaFirstClause = null;                          IDictionary<string' JSExpression> argumentsDict = null;                            if (arguments.Length > 1) {                              var argumentsExpression = arguments[1];                              var argumentsArray = argumentsExpression as JSNewArrayExpression;                                if (method == null || method.Method.Parameters[1].ParameterType is GenericParameter) {                                  // This call was made dynamically or through generic version of method' so the parameters are not an array.                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < (arguments.Length - 1); i++)                                      argumentsDict.Add(String.Format("{0}"' i)' arguments[i + 1]);                              } else if (argumentsArray == null) {                                  // The array is static so we need to pull elements out of it after assigning it a name.                                  // FIXME: Only handles up to 40 elements.                                  var argumentsExpressionType = argumentsExpression.GetActualType(TypeSystem);                                  var temporaryVariable = MakeTemporaryVariable(argumentsExpressionType);                                  var temporaryAssignment = new JSBinaryOperatorExpression(JSOperator.Assignment' temporaryVariable' argumentsExpression' argumentsExpressionType);                                    commaFirstClause = temporaryAssignment;                                    argumentsDict = new Dictionary<string' JSExpression>();                                    for (var i = 0; i < 40; i++)                                      argumentsDict.Add(String.Format("{0}"' i)' new JSIndexerExpression(temporaryVariable' JSLiteral.New(i)));                              } else {                                  var argumentsArrayExpression = argumentsArray.SizeOrArrayInitializer as JSArrayExpression;                                    if (argumentsArrayExpression == null)                                      throw new NotImplementedException("Literal array must have values");                                    argumentsDict = new Dictionary<string' JSExpression>();                                    int i = 0;                                  foreach (var value in argumentsArrayExpression.Values) {                                      argumentsDict.Add(String.Format("{0}"' i)' value);                                        i += 1;                                  }                              }                          }                            var verbatimLiteral = new JSVerbatimLiteral(                              methodName' expression.Value' argumentsDict                          );                            if (commaFirstClause != null)                              return new JSCommaExpression(commaFirstClause' verbatimLiteral);                          else                              return verbatimLiteral;                      } else {                          throw new NotImplementedException("Verbatim method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSGlobal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression != null)                              return new JSDotExpression(                                  JSIL.GlobalNamespace' new JSStringIdentifier(expression.Value' TypeSystem.Object' true)                              );                          else                              return new JSIndexerExpression(                                  JSIL.GlobalNamespace' arguments[0]' TypeSystem.Object                              );                      } else {                          throw new NotImplementedException("JSGlobal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.JSLocal": {                      if (methodName == "get_Item") {                          var expression = arguments[0] as JSStringLiteral;                          if (expression == null)                              throw new InvalidOperationException("JSLocal must recieve a string literal as an index");                            return new JSStringIdentifier(expression.Value' TypeSystem.Object' true);                      } else {                          throw new NotImplementedException("JSLocal method not implemented: " + methodName);                      }                      break;                  }                    case "JSIL.Services": {                      if (methodName == "Get") {                          if (arguments.Length != 2)                              throw new InvalidOperationException("JSIL.Services.Get must receive two arguments");                            var serviceName = arguments[0];                          var shouldThrow = arguments[1];                            return JSInvocationExpression.InvokeStatic(                              new JSRawOutputIdentifier(TypeSystem.Object' "JSIL.Host.getService")'                              new[] {                                  serviceName'                                  new JSUnaryOperatorExpression(JSOperator.LogicalNot' shouldThrow' TypeSystem.Boolean)                              }' true                          );                      } else {                          throw new NotImplementedException("JSIL.Services method not implemented: " + methodName);                      }                      break;                  }              }
Missing Default,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoNonJSILMethodReplacement,The following switch statement is missing a default case: switch (method.Method.Member.FullName) {                  // Doing this replacement here enables more elimination of temporary variables                  case "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)":                  case "System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle)":                  case "System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle'System.RuntimeTypeHandle)":                  case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle)":                  case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)":                      return arguments.First();              }
Missing Default,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,DoPropertyReplacement,The following switch statement is missing a default case: switch (method.Method.Name) {                      case "get_HasValue":                          return JSIL.NullableHasValue(thisExpression);                        case "get_Value":                          return JSIL.ValueOfNullable(thisExpression);                  }
Missing Default,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_Mul,The following switch statement is missing a default case: switch (outputType.FullName) {                          case "System.UInt32":                              return new JSUInt32MultiplyExpression(                                  left' right' TypeSystem                              );                            case "System.Int32":                              return new JSInt32MultiplyExpression(                                  left' right' TypeSystem                              );                      }
Missing Default,JSIL,ILBlockTranslator,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\ILBlockTranslator.cs,Translate_IntegerConstantCore,The following switch statement is missing a default case: switch (ilCode) {                  case ILCode.Ldc_I4:                      if (isUnsigned)                          return new JSIntegerLiteral((uint)((int)value)' typeof(uint));                      else                          return new JSIntegerLiteral(value' typeof(int));                    case ILCode.Ldc_I8:                      if (isUnsigned)                          return new JSIntegerLiteral(value' typeof(ulong));                      else                          return new JSIntegerLiteral(value' typeof(long));              }
Missing Default,JSIL,TypeUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeUtil.cs,SizeOfType,The following switch statement is missing a default case: switch (type.MetadataType) {                  case MetadataType.Boolean:                      return 1;                    case MetadataType.Byte:                  case MetadataType.SByte:                      return 1;                    case MetadataType.UInt16:                  case MetadataType.Int16:                      return 2;                    case MetadataType.UInt32:                  case MetadataType.Int32:                      return 4;                    case MetadataType.UInt64:                  case MetadataType.Int64:                      return 8;                    case MetadataType.Single:                      return 4;                    case MetadataType.Double:                      return 8;                    case MetadataType.UIntPtr:                  case MetadataType.IntPtr:                      return 4;              }
Missing Default,JSIL,TypeInfoProvider,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInfoProvider.cs,_MakeProxiesByFullName,The following switch statement is missing a default case: switch (arg.Type.FullName) {                      case "System.Type": {                              proxyTargets = new ArraySegment<string>(new string[] {                                   ((TypeReference)arg.Value).FullName                              });                                break;                          }                      case "System.Type[]": {                              var values = (CustomAttributeArgument[])arg.Value;                              proxyTargets = new ArraySegment<string>((from v in values select ((TypeReference)v.Value).FullName)                                  .ToArray());                                break;                          }                      case "System.String": {                              proxyTargets = new ArraySegment<string>(new string[] {                                   (string)arg.Value                              });                                break;                          }                      case "System.String[]": {                              var values = (CustomAttributeArgument[])arg.Value;                              proxyTargets = new ArraySegment<string>((from v in values select (string)v.Value)                                  .ToArray());                                break;                          }                  }
Missing Default,JSIL.Ast,JSPointerExpressionUtil,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\AST\JSExpressionTypes.cs,GetNativeSizeOfElement,The following switch statement is missing a default case: switch (elementType.FullName) {                  case "System.Byte":                  case "System.SByte":                      return 1;                    case "System.Int16":                  case "System.UInt16":                      return 2;                    case "System.Int32":                  case "System.UInt32":                  case "System.Single":                      return 4;                    case "System.Int64":                  case "System.UInt64":                  case "System.Double":                      return 8;              }
Missing Default,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,GetContainingAssemblyName,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {                  case MetadataScopeType.AssemblyNameReference:                      return ((AssemblyNameReference)scope).FullName;                  case MetadataScopeType.ModuleReference:                      throw new NotImplementedException("Module references not implemented");                  case MetadataScopeType.ModuleDefinition:                      var assembly = ((ModuleDefinition)scope).Assembly;                      if (assembly != null)                          return assembly.FullName;                      else                          return "<Assembly Not Loaded>";              }
Missing Default,JSIL.Internal,JavascriptFormatter,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\JavascriptFormatter.cs,DefaultValue,The following switch statement is missing a default case: switch (fullName) {                  case "System.Nullable`1":                      WriteRaw("null");                      return;                  case "System.Single":                  case "System.Double":                  case "System.Decimal":                      Value(0.0);                      return;              }
Missing Default,JSIL.Internal,MemberInfo<T>,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,MemberInfo,The following switch statement is missing a default case: switch (param.Type.FullName) {                          case "JSIL.Meta.JSReadPolicy":                              _ReadPolicy = (JSReadPolicy)param.Value;                          break;                          case "JSIL.Meta.JSWritePolicy":                              _WritePolicy = (JSWritePolicy)param.Value;                          break;                          case "JSIL.Meta.JSInvokePolicy":                              _InvokePolicy = (JSInvokePolicy)param.Value;                          break;                      }
Missing Default,JSIL.Internal,PolicyExtensions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,ApplyReadPolicy,The following switch statement is missing a default case: switch (member.ReadPolicy) {                  case JSReadPolicy.ReturnDefaultValue:                      result = new JSDefaultValueLiteral(member.ReturnType);                      return true;                  case JSReadPolicy.LogWarning:                  case JSReadPolicy.ThrowError:                      result = new JSIgnoredMemberReference(member.ReadPolicy == JSReadPolicy.ThrowError' member' thisExpression);                      return true;              }
Missing Default,JSIL.Internal,PolicyExtensions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,ApplyWritePolicy,The following switch statement is missing a default case: switch (member.WritePolicy) {                  case JSWritePolicy.DiscardValue:                      result = new JSNullExpression();                      return true;                  case JSWritePolicy.LogWarning:                  case JSWritePolicy.ThrowError:                      result = new JSIgnoredMemberReference(member.WritePolicy == JSWritePolicy.ThrowError' member' thisExpression' newValue);                      return true;              }
Missing Default,JSIL.Internal,PolicyExtensions,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\TypeInformation.cs,ApplyInvokePolicy,The following switch statement is missing a default case: switch (member.InvokePolicy) {                  case JSInvokePolicy.ReturnDefaultValue:                      result = new JSDefaultValueLiteral(member.ReturnType);                      return true;                  case JSInvokePolicy.LogWarning:                  case JSInvokePolicy.ThrowError:                      result = new JSIgnoredMemberReference(member.InvokePolicy == JSInvokePolicy.ThrowError' member' new[] { thisExpression }.Concat(parameters).ToArray());                      return true;              }
Missing Default,JSIL.Threading,TrackedLock,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Threading.cs,BlockingEnter,The following switch statement is missing a default case: switch (result.FailureReason) {                      case TrackedLockFailureReason.HeldByCurrentThread:                          throw new LockAlreadyHeldException();                      case TrackedLockFailureReason.Deadlock:                          throw new DeadlockAvertedException(deadlock.A' deadlock.B);                  }
Missing Default,JSIL.Transforms,ReplaceMethodCalls,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following switch statement is missing a default case: switch (method.Method.Member.Name) {                          case ".ctor": {                              var replacement = new JSNullExpression();                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "ReferenceEquals": {                              var lhs = ie.Arguments[0];                              var rhs = ie.Arguments[1];                                var lhsType = lhs.GetActualType(TypeSystem);                              var rhsType = rhs.GetActualType(TypeSystem);                                JSNode replacement;                                // Structs can never compare equal with ReferenceEquals                              if (TypeUtil.IsStruct(lhsType) || TypeUtil.IsStruct(rhsType))                                  replacement = JSLiteral.New(false);                              else                                  replacement = new JSBinaryOperatorExpression(                                      JSOperator.Equal'                                      lhs' rhs'                                      TypeSystem.Boolean                                  );                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                            case "GetType": {                              JSNode replacement;                                var thisType = JSExpression.DeReferenceType(thisExpression.GetActualType(TypeSystem)' false);                              if ((thisType is GenericInstanceType) && thisType.FullName.StartsWith("System.Nullable")) {                                  var git = (GenericInstanceType)thisType;                                    replacement = new JSTernaryOperatorExpression(                                      new JSBinaryOperatorExpression(                                          JSOperator.NotEqual'                                          thisExpression' new JSNullLiteral(thisType)'                                          TypeSystem.Boolean                                      )'                                      new JSTypeOfExpression(git.GenericArguments[0])'                                      JSIL.ThrowNullReferenceException()'                                      TypeSystem.SystemType()                                  );                              } else {                                  replacement = JSIL.GetTypeOf(thisExpression);                              }                                ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }
Missing Default,JSIL.Transforms,ReplaceMethodCalls,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following switch statement is missing a default case: switch (method.Method.Member.Name) {                          case "Equals": {                              var replacement = JSIL.StructEquals(ie.ThisReference' ie.Arguments.First());                              ParentNode.ReplaceChild(ie' replacement);                              VisitReplacement(replacement);                                return;                          }                      }
Missing Default,JSIL.Transforms,ReplaceMethodCalls,D:\research\architectureSmells\repos1\sq_JSIL\JSIL\Transforms\ReplaceMethodCalls.cs,VisitNode,The following switch statement is missing a default case: switch (method.Reference.Name) {                          case "GetExecutingAssembly": {                              var assembly = Method.DeclaringType.Module.Assembly;                              var asmNode = new JSReflectionAssembly(assembly);                              ParentNode.ReplaceChild(ie' asmNode);                              VisitReplacement(asmNode);                                return;                          }                      }
