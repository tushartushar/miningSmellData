Implementation smell,Namespace,Class,File,Method,Description
Long Method,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The method has 304 lines of code.
Long Method,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,InternalMain,The method has 113 lines of code.
Long Method,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,The method has 111 lines of code.
Complex Method,Mono.Options,Option,C:\repos\sq_JSIL\Upstream\Options.cs,Option,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,C:\repos\sq_JSIL\Upstream\Options.cs,ParsePrototype,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,WriteOptionDescriptions,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,WriteOptionPrototype,Cyclomatic complexity of the method is 8
Complex Method,JSIL.Compiler,Configuration,C:\repos\sq_JSIL\Compiler\Configuration.cs,MergeInto,Cyclomatic complexity of the method is 14
Complex Method,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,PurgeDuplicateFilesFromBuildGroup,Cyclomatic complexity of the method is 11
Complex Method,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,Cyclomatic complexity of the method is 24
Complex Method,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,InternalMain,Cyclomatic complexity of the method is 10
Complex Method,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,Cyclomatic complexity of the method is 14
Long Parameter List,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,GetOptionParts,The method has 5 parameters. Parameters: argument' flag' name' sep' value
Long Parameter List,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,WriteDescription,The method has 5 parameters. Parameters: o' value' prefix' firstWidth' remWidth
Long Parameter List,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The method has 6 parameters. Parameters: arguments' buildGroups' profiles' analyzers' emitterFactories' assemblyCache
Long Parameter List,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,CreateTranslator,The method has 5 parameters. Parameters: configuration' manifest' assemblyCache' emitterFactories' analyzers
Long Parameter List,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,EmitLog,The method has 5 parameters. Parameters: logPath' configuration' inputFile' outputs' ignoredMethods
Long Parameter List,JSIL.Compiler.Extensibility,IProfile,C:\repos\sq_JSIL\Compiler\Extensibility\IProfile.cs,Translate,The method has 5 parameters. Parameters: variables' translator' configuration' assemblyPath' scanForProxies
Long Parameter List,JSIL.Compiler.Profiles,BaseProfile,C:\repos\sq_JSIL\Compiler\Profiles\Base.cs,Translate,The method has 5 parameters. Parameters: variables' translator' configuration' assemblyPath' scanForProxies
Long Parameter List,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,ParseSolutionFile,The method has 5 parameters. Parameters: solutionFile' buildConfiguration' buildPlatform' globalProperties' manager
Long Parameter List,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,The method has 6 parameters. Parameters: solutionFile' buildConfiguration' buildPlatform' buildTarget' logVerbosity' inProcess
Long Parameter List,JSIL.SolutionBuilder,BuildResult,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,BuildResult,The method has 5 parameters. Parameters: solutionPath' outputFiles' projectsBuilt' targetFiles' allItemsBuilt
Long Identifier,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,,The length of the parameter CachedTypeInfoProviderConfiguration is 35.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,TryReadAssembly,The length of the statement  "                Console.Error.WriteLine("//     Reason: " + ex.Message.Trim().Replace(Environment.NewLine' Environment.NewLine + "// ")); " is 121.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,PurgeDuplicateFilesFromBuildGroup,The length of the statement  "                            InformationWriteLine("// Not translating '{0}' directly because '{1}' references it."' Path.GetFileName(kvpOuter.Filename)' Path.GetFileName(kvpInner.Filename)); " is 161.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The length of the statement  "                        "When building one or more solution files' specifies the level of log verbosity. Valid options are 'Quiet'' 'Minimal'' 'Normal'' 'Detailed'' and 'Diagnostic'."' " is 160.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The length of the statement  "                        "This ensures that correct type information is provided (as different versions of the framework use different standard libraries). " + " is 134.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The length of the statement  "                        "Loads one or more project profiles from the specified profile assembly. Note that this does not force the profiles to be used."' " is 129.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The length of the statement  "                    Console.WriteLine("==== JSILc v{0}.{1}.{2} ===="' asmName.Version.Major' asmName.Version.Minor' asmName.Version.Revision); " is 122.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The length of the statement  "                    Console.WriteLine("Specify one or more compiled assemblies (dll/exe) to translate them. Symbols will be loaded if they exist in the same directory."); " is 150.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The length of the statement  "                    Console.WriteLine("You can also specify Visual Studio solution files (sln) to build them and automatically translate their output(s)."); " is 136.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The length of the statement  "                        logWriter.WriteLine("Elapsed build time: {0:0000.0} second(s)."' TimeSpan.FromTicks(buildEnded - buildStarted).TotalSeconds); " is 125.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The length of the statement  "                        logWriter.WriteLine("Elapsed processing time: {0:0000.0} second(s)."' TimeSpan.FromTicks(processEnded - processStarted).TotalSeconds); " is 134.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,InternalMain,The length of the statement  "            var commandLineConfiguration = ParseCommandLine(arguments' buildGroups' profiles' analyzers' emitterFactoryCreators' assemblyCache); " is 132.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,InternalMain,The length of the statement  "                    buildGroup.Profile.RegisterPostprocessors(emitterFactories.Values' localConfig' filename' buildGroup.SkippedAssemblies); " is 120.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,InternalMain,The length of the statement  "                        var outputs = buildGroup.Profile.Translate(localVariables' translator' localConfig' filename' localConfig.UseLocalProxies.GetValueOrDefault(true)); " is 147.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,InternalMain,The length of the statement  "                            Console.Error.WriteLine("// {0} method(s) were ignored during translation. See the log for a list."' ignoredMethods.Count); " is 123.
Long Statement,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,EmitLog,The length of the statement  "            logText.AppendLine(String.Format("// JSILc v{0}.{1}.{2}"' asmName.Version.Major' asmName.Version.Minor' asmName.Version.Revision)); " is 131.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,OutOfProcessBuild,The length of the statement  "                        Console.Error.WriteLine("// Out-of-process solution build terminated unexpectedly with code {0}!"' childProcess.ExitCode); " is 122.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,The length of the statement  "                Console.Error.WriteLine("// Running target '{2}' of '{0}' ({1}) ..."' JSIL.Compiler.Program.ShortenPath(solutionFile)' configString' buildTarget); " is 146.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,The length of the statement  "                Console.Error.WriteLine("// Running target '{1}' of '{0}' ..."' JSIL.Compiler.Program.ShortenPath(solutionFile)' buildTarget); " is 126.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,The length of the statement  "                Console.Error.WriteLine("// WARNING: Your solution file contains project dependencies. MSBuild ignores these' so your build may fail. If it does' try building it in Visual Studio first to resolve the dependencies."); " is 216.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,The length of the statement  "                    Console.Error.WriteLine("// Failed to save generated project '{0}': {1}"' Path.GetFileName(project.FullPath)' exc.Message); " is 123.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,The length of the statement  "                        Console.Error.WriteLine("// Ignoring build output '" + Path.GetFileName(builtItem.OutputPath) + "' due to unknown file type."); " is 127.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,Build,The length of the statement  "            throw new NotImplementedException("Solution building is only supported on Windows when JSILc is compiled using MSBuild/Visual Studio."); " is 136.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,ExtractChildProjectResults,The length of the statement  "            var pResultsDictionary = tResultsCache.GetProperty("ResultsDictionary"' BindingFlags.NonPublic | BindingFlags.Instance); " is 120.
Long Statement,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,ExtractChildProjectResults,The length of the statement  "            IDictionary<int' Microsoft.Build.Execution.BuildResult> resultsDictionary = oResultsDictionary as Dictionary<int' Microsoft.Build.Execution.BuildResult>; " is 153.
Complex Conditional,Mono.Options,Option,C:\repos\sq_JSIL\Upstream\Options.cs,Option,The conditional expression  "Array.IndexOf (names' "<>") >= 0 &&   					((names.Length == 1 && this.type != OptionValueType.None) ||  					 (names.Length > 1 && this.MaxValueCount > 1))"  is complex.
Complex Conditional,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,ParseBool,The conditional expression  "n.Length >= 1 && (n [n.Length-1] == '+' || n [n.Length-1] == '-') &&  					Contains ((rn = n.Substring (0' n.Length-1)))"  is complex.
Empty Catch Block,JSIL.Utilities,TemporaryAppDomain,C:\repos\sq_JSIL\Compiler\Profiles\ResourceConverter.cs,TemporaryAppDomain,The method has an empty catch block.
Empty Catch Block,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,OutOfProcessBuild,The method has an empty catch block.
Empty Catch Block,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,OutOfProcessBuild,The method has an empty catch block.
Magic Number,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,Add,The following statement contains a magic number: Option p = new ActionOption (prototype' description' 2'   					delegate (OptionValueCollection v) {action (v [0]' v [1]);});
Magic Number,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  				int written = 0;    				Category c = p as Category;  				if (c != null) {  					WriteDescription (o' p.Description' ""' 80' 80);  					continue;  				}    				if (!WriteOptionPrototype (o' p' ref written))  					continue;    				if (written < OptionWidth)  					o.Write (new string (' '' OptionWidth - written));  				else {  					o.WriteLine ();  					o.Write (new string (' '' OptionWidth));  				}    				WriteDescription (o' p.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);  			}
Magic Number,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  				int written = 0;    				Category c = p as Category;  				if (c != null) {  					WriteDescription (o' p.Description' ""' 80' 80);  					continue;  				}    				if (!WriteOptionPrototype (o' p' ref written))  					continue;    				if (written < OptionWidth)  					o.Write (new string (' '' OptionWidth - written));  				else {  					o.WriteLine ();  					o.Write (new string (' '' OptionWidth));  				}    				WriteDescription (o' p.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);  			}
Magic Number,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  				int written = 0;    				Category c = p as Category;  				if (c != null) {  					WriteDescription (o' p.Description' ""' 80' 80);  					continue;  				}    				if (!WriteOptionPrototype (o' p' ref written))  					continue;    				if (written < OptionWidth)  					o.Write (new string (' '' OptionWidth - written));  				else {  					o.WriteLine ();  					o.Write (new string (' '' OptionWidth));  				}    				WriteDescription (o' p.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);  			}
Magic Number,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (ArgumentSource s in sources) {  				string[] names = s.GetNames ();  				if (names == null || names.Length == 0)  					continue;    				int written = 0;    				Write (o' ref written' "  ");  				Write (o' ref written' names [0]);  				for (int i = 1; i < names.Length; ++i) {  					Write (o' ref written' "' ");  					Write (o' ref written' names [i]);  				}    				if (written < OptionWidth)  					o.Write (new string (' '' OptionWidth - written));  				else {  					o.WriteLine ();  					o.Write (new string (' '' OptionWidth));  				}    				WriteDescription (o' s.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);  			}
Magic Number,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The following statement contains a magic number: foreach (var solution in                       (from fn in filenames where Path.GetExtension(fn) == ".sln" select fn)                      ) {                    var solutionFullPath = Path.GetFullPath(solution);                  var solutionDir = Path.GetDirectoryName(solutionFullPath);                    if (solutionDir == null) {                      Console.Error.WriteLine("// Can't process solution '{0}' - path seems malformed"' solution);                      continue;                  }                    // Fail early if a solution file is missing                  if (!File.Exists(solutionFullPath))                      throw new FileNotFoundException(solutionFullPath);                    var solutionConfigPath = Path.Combine(                      solutionDir'                      String.Format("{0}.jsilconfig"' Path.GetFileName(solutionFullPath))                  );                  var solutionConfig = File.Exists(solutionConfigPath)                      ? new Configuration[] { LoadConfiguration(solutionConfigPath) }                      : new Configuration[] {  };                    var mergedSolutionConfig = MergeConfigurations(baseConfig' solutionConfig);                  var config = MergeConfigurations(mergedSolutionConfig' commandLineConfig);                  var buildStarted = DateTime.UtcNow.Ticks;                                    var buildResult = SolutionBuilder.SolutionBuilder.Build(                      solutionFullPath'                      config.SolutionBuilder.Configuration'                      config.SolutionBuilder.Platform'                      config.SolutionBuilder.Target ?? "Build"'                      config.SolutionBuilder.LogVerbosity                  );                    var jss = new JavaScriptSerializer {                      MaxJsonLength = (1024 * 1024) * 64                  };                    var buildResultJson = jss.Serialize(buildResult);                  buildResult = jss.Deserialize<SolutionBuilder.BuildResult>(buildResultJson);                    var buildEnded = DateTime.UtcNow.Ticks;                    IProfile profile = defaultProfile;                    foreach (var candidateProfile in profiles.Values) {                      if (!candidateProfile.IsAppropriateForSolution(buildResult))                          continue;                        InformationWriteLine("// Auto-selected the profile '{0}' for this project."' candidateProfile.GetType().Name);                      profile = candidateProfile;                      break;                  }                    var localVariables = config.ApplyTo(new VariableSet());                  localVariables["SolutionDirectory"] = () => solutionDir;                    // HACK to let you use assemblyname/etc when copying output files.                  var buildResultAssembly =                      buildResult.OutputFiles.FirstOrDefault((fn) => Path.GetExtension(fn) == ".exe") ??                      buildResult.OutputFiles.FirstOrDefault((fn) => Path.GetExtension(fn) == ".dll");                    if (buildResultAssembly != null) {                      localVariables.SetAssemblyPath(buildResultAssembly);                  }                    var processStarted = DateTime.UtcNow.Ticks;                  profile.ProcessBuildResult(                      localVariables'                      profile.GetConfiguration(config)'                      buildResult                  );                  var processEnded = DateTime.UtcNow.Ticks;                    {                      var logPath = localVariables.ExpandPath(String.Format(                          "%outputdirectory%/{0}.buildlog"' Path.GetFileName(solution)                      )' false);                        if (!Directory.Exists(Path.GetDirectoryName(logPath)))                          Directory.CreateDirectory(Path.GetDirectoryName(logPath));                                            using (var logWriter = new StreamWriter(logPath' false' Encoding.UTF8)) {                          logWriter.WriteLine(                              "Build of solution '{0}' processed {1} task(s) and produced {2} result file(s):"'                              solution' buildResult.AllItemsBuilt.Length' buildResult.OutputFiles.Length                          );                            foreach (var of in buildResult.OutputFiles)                              logWriter.WriteLine(of);                            logWriter.WriteLine("----");                          logWriter.WriteLine("Elapsed build time: {0:0000.0} second(s)."' TimeSpan.FromTicks(buildEnded - buildStarted).TotalSeconds);                          logWriter.WriteLine("Selected profile '{0}' to process results of this build."' profile.GetType().Name);                          logWriter.WriteLine("Elapsed processing time: {0:0000.0} second(s)."' TimeSpan.FromTicks(processEnded - processStarted).TotalSeconds);                      }                  }                    var outputFiles = buildResult.OutputFiles.Concat(                      (from eo in config.SolutionBuilder.ExtraOutputs                       let expanded = localVariables.ExpandPath(eo' true)                       select expanded)                  ).ToArray();                    if (outputFiles.Length > 0) {                      var sa = new HashSet<string>();                        var group = new BuildGroup {                          BaseConfiguration = mergedSolutionConfig'                          BaseVariables = localVariables'                          FilesToBuild = PurgeDuplicateFilesFromBuildGroup(outputFiles' assemblyCache' sa)'                          Profile = profile'                      };                      group.SkippedAssemblies = sa.ToArray();                        buildGroups.Add(group);                  }              }
Magic Number,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The following statement contains a magic number: foreach (var solution in                       (from fn in filenames where Path.GetExtension(fn) == ".sln" select fn)                      ) {                    var solutionFullPath = Path.GetFullPath(solution);                  var solutionDir = Path.GetDirectoryName(solutionFullPath);                    if (solutionDir == null) {                      Console.Error.WriteLine("// Can't process solution '{0}' - path seems malformed"' solution);                      continue;                  }                    // Fail early if a solution file is missing                  if (!File.Exists(solutionFullPath))                      throw new FileNotFoundException(solutionFullPath);                    var solutionConfigPath = Path.Combine(                      solutionDir'                      String.Format("{0}.jsilconfig"' Path.GetFileName(solutionFullPath))                  );                  var solutionConfig = File.Exists(solutionConfigPath)                      ? new Configuration[] { LoadConfiguration(solutionConfigPath) }                      : new Configuration[] {  };                    var mergedSolutionConfig = MergeConfigurations(baseConfig' solutionConfig);                  var config = MergeConfigurations(mergedSolutionConfig' commandLineConfig);                  var buildStarted = DateTime.UtcNow.Ticks;                                    var buildResult = SolutionBuilder.SolutionBuilder.Build(                      solutionFullPath'                      config.SolutionBuilder.Configuration'                      config.SolutionBuilder.Platform'                      config.SolutionBuilder.Target ?? "Build"'                      config.SolutionBuilder.LogVerbosity                  );                    var jss = new JavaScriptSerializer {                      MaxJsonLength = (1024 * 1024) * 64                  };                    var buildResultJson = jss.Serialize(buildResult);                  buildResult = jss.Deserialize<SolutionBuilder.BuildResult>(buildResultJson);                    var buildEnded = DateTime.UtcNow.Ticks;                    IProfile profile = defaultProfile;                    foreach (var candidateProfile in profiles.Values) {                      if (!candidateProfile.IsAppropriateForSolution(buildResult))                          continue;                        InformationWriteLine("// Auto-selected the profile '{0}' for this project."' candidateProfile.GetType().Name);                      profile = candidateProfile;                      break;                  }                    var localVariables = config.ApplyTo(new VariableSet());                  localVariables["SolutionDirectory"] = () => solutionDir;                    // HACK to let you use assemblyname/etc when copying output files.                  var buildResultAssembly =                      buildResult.OutputFiles.FirstOrDefault((fn) => Path.GetExtension(fn) == ".exe") ??                      buildResult.OutputFiles.FirstOrDefault((fn) => Path.GetExtension(fn) == ".dll");                    if (buildResultAssembly != null) {                      localVariables.SetAssemblyPath(buildResultAssembly);                  }                    var processStarted = DateTime.UtcNow.Ticks;                  profile.ProcessBuildResult(                      localVariables'                      profile.GetConfiguration(config)'                      buildResult                  );                  var processEnded = DateTime.UtcNow.Ticks;                    {                      var logPath = localVariables.ExpandPath(String.Format(                          "%outputdirectory%/{0}.buildlog"' Path.GetFileName(solution)                      )' false);                        if (!Directory.Exists(Path.GetDirectoryName(logPath)))                          Directory.CreateDirectory(Path.GetDirectoryName(logPath));                                            using (var logWriter = new StreamWriter(logPath' false' Encoding.UTF8)) {                          logWriter.WriteLine(                              "Build of solution '{0}' processed {1} task(s) and produced {2} result file(s):"'                              solution' buildResult.AllItemsBuilt.Length' buildResult.OutputFiles.Length                          );                            foreach (var of in buildResult.OutputFiles)                              logWriter.WriteLine(of);                            logWriter.WriteLine("----");                          logWriter.WriteLine("Elapsed build time: {0:0000.0} second(s)."' TimeSpan.FromTicks(buildEnded - buildStarted).TotalSeconds);                          logWriter.WriteLine("Selected profile '{0}' to process results of this build."' profile.GetType().Name);                          logWriter.WriteLine("Elapsed processing time: {0:0000.0} second(s)."' TimeSpan.FromTicks(processEnded - processStarted).TotalSeconds);                      }                  }                    var outputFiles = buildResult.OutputFiles.Concat(                      (from eo in config.SolutionBuilder.ExtraOutputs                       let expanded = localVariables.ExpandPath(eo' true)                       select expanded)                  ).ToArray();                    if (outputFiles.Length > 0) {                      var sa = new HashSet<string>();                        var group = new BuildGroup {                          BaseConfiguration = mergedSolutionConfig'                          BaseVariables = localVariables'                          FilesToBuild = PurgeDuplicateFilesFromBuildGroup(outputFiles' assemblyCache' sa)'                          Profile = profile'                      };                      group.SkippedAssemblies = sa.ToArray();                        buildGroups.Add(group);                  }              }
Magic Number,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,ParseCommandLine,The following statement contains a magic number: foreach (var solution in                       (from fn in filenames where Path.GetExtension(fn) == ".sln" select fn)                      ) {                    var solutionFullPath = Path.GetFullPath(solution);                  var solutionDir = Path.GetDirectoryName(solutionFullPath);                    if (solutionDir == null) {                      Console.Error.WriteLine("// Can't process solution '{0}' - path seems malformed"' solution);                      continue;                  }                    // Fail early if a solution file is missing                  if (!File.Exists(solutionFullPath))                      throw new FileNotFoundException(solutionFullPath);                    var solutionConfigPath = Path.Combine(                      solutionDir'                      String.Format("{0}.jsilconfig"' Path.GetFileName(solutionFullPath))                  );                  var solutionConfig = File.Exists(solutionConfigPath)                      ? new Configuration[] { LoadConfiguration(solutionConfigPath) }                      : new Configuration[] {  };                    var mergedSolutionConfig = MergeConfigurations(baseConfig' solutionConfig);                  var config = MergeConfigurations(mergedSolutionConfig' commandLineConfig);                  var buildStarted = DateTime.UtcNow.Ticks;                                    var buildResult = SolutionBuilder.SolutionBuilder.Build(                      solutionFullPath'                      config.SolutionBuilder.Configuration'                      config.SolutionBuilder.Platform'                      config.SolutionBuilder.Target ?? "Build"'                      config.SolutionBuilder.LogVerbosity                  );                    var jss = new JavaScriptSerializer {                      MaxJsonLength = (1024 * 1024) * 64                  };                    var buildResultJson = jss.Serialize(buildResult);                  buildResult = jss.Deserialize<SolutionBuilder.BuildResult>(buildResultJson);                    var buildEnded = DateTime.UtcNow.Ticks;                    IProfile profile = defaultProfile;                    foreach (var candidateProfile in profiles.Values) {                      if (!candidateProfile.IsAppropriateForSolution(buildResult))                          continue;                        InformationWriteLine("// Auto-selected the profile '{0}' for this project."' candidateProfile.GetType().Name);                      profile = candidateProfile;                      break;                  }                    var localVariables = config.ApplyTo(new VariableSet());                  localVariables["SolutionDirectory"] = () => solutionDir;                    // HACK to let you use assemblyname/etc when copying output files.                  var buildResultAssembly =                      buildResult.OutputFiles.FirstOrDefault((fn) => Path.GetExtension(fn) == ".exe") ??                      buildResult.OutputFiles.FirstOrDefault((fn) => Path.GetExtension(fn) == ".dll");                    if (buildResultAssembly != null) {                      localVariables.SetAssemblyPath(buildResultAssembly);                  }                    var processStarted = DateTime.UtcNow.Ticks;                  profile.ProcessBuildResult(                      localVariables'                      profile.GetConfiguration(config)'                      buildResult                  );                  var processEnded = DateTime.UtcNow.Ticks;                    {                      var logPath = localVariables.ExpandPath(String.Format(                          "%outputdirectory%/{0}.buildlog"' Path.GetFileName(solution)                      )' false);                        if (!Directory.Exists(Path.GetDirectoryName(logPath)))                          Directory.CreateDirectory(Path.GetDirectoryName(logPath));                                            using (var logWriter = new StreamWriter(logPath' false' Encoding.UTF8)) {                          logWriter.WriteLine(                              "Build of solution '{0}' processed {1} task(s) and produced {2} result file(s):"'                              solution' buildResult.AllItemsBuilt.Length' buildResult.OutputFiles.Length                          );                            foreach (var of in buildResult.OutputFiles)                              logWriter.WriteLine(of);                            logWriter.WriteLine("----");                          logWriter.WriteLine("Elapsed build time: {0:0000.0} second(s)."' TimeSpan.FromTicks(buildEnded - buildStarted).TotalSeconds);                          logWriter.WriteLine("Selected profile '{0}' to process results of this build."' profile.GetType().Name);                          logWriter.WriteLine("Elapsed processing time: {0:0000.0} second(s)."' TimeSpan.FromTicks(processEnded - processStarted).TotalSeconds);                      }                  }                    var outputFiles = buildResult.OutputFiles.Concat(                      (from eo in config.SolutionBuilder.ExtraOutputs                       let expanded = localVariables.ExpandPath(eo' true)                       select expanded)                  ).ToArray();                    if (outputFiles.Length > 0) {                      var sa = new HashSet<string>();                        var group = new BuildGroup {                          BaseConfiguration = mergedSolutionConfig'                          BaseVariables = localVariables'                          FilesToBuild = PurgeDuplicateFilesFromBuildGroup(outputFiles' assemblyCache' sa)'                          Profile = profile'                      };                      group.SkippedAssemblies = sa.ToArray();                        buildGroups.Add(group);                  }              }
Magic Number,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,MakeProgressHandler,The following statement contains a magic number: const int scale = 40;
Magic Number,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,Main,The following statement contains a magic number: try {                  InternalMain(arguments);              } catch (Exception exc) {                  Console.WriteLine(exc);                  Environment.ExitCode = 1024;                  return;              }
Magic Number,JSIL.Compiler,Program,C:\repos\sq_JSIL\Compiler\Program.cs,InternalMain,The following statement contains a magic number: foreach (var buildGroup in buildGroups) {                  var config = buildGroup.BaseConfiguration;                  var variables = buildGroup.BaseVariables;                    foreach (var filename in buildGroup.FilesToBuild) {                      if (config.Assemblies.Ignored.Any(                          (ignoreRegex) => Regex.IsMatch(filename' ignoreRegex' RegexOptions.IgnoreCase))                      ) {                          InformationWriteLine("// Ignoring build result '{0}' based on configuration."' Path.GetFileName(filename));                          continue;                      }                        string fileConfigPath;                      var fileConfigSearchDir = Path.GetDirectoryName(filename);                      var separators = new char[] { '/'' '\\' };                        do {                          fileConfigPath = Path.Combine(                              fileConfigSearchDir'                              String.Format("{0}.jsilconfig"' Path.GetFileName(filename))                          );                            if (!File.Exists(fileConfigPath))                              fileConfigSearchDir = Path.GetFullPath(Path.Combine(fileConfigSearchDir' ".."));                          else                              break;                      } while (fileConfigSearchDir.IndexOfAny(separators' 3) > 0);                        var fileConfig = File.Exists(fileConfigPath)                          ? new Configuration[] { LoadConfiguration(fileConfigPath)' commandLineConfiguration }                          : new Configuration[] { commandLineConfiguration };                        var localConfig = MergeConfigurations(config' fileConfig);                        if (localConfig.ApplyDefaults.GetValueOrDefault(true))                      {                          localConfig = MergeConfigurations(                              LoadConfiguration(Path.Combine(                                  GetJSILDirectory()'                                  "defaults.jsilconfig"                              ))'                              localConfig                          );                      }                        var localProfile = buildGroup.Profile;                      if (localConfig.Profile != null) {                          if (profiles.ContainsKey(localConfig.Profile))                              localProfile = profiles[localConfig.Profile];                          else                              throw new Exception(String.Format(                                  "No profile named '{0}' was found. Did you load the correct profile assembly?"' localConfig.Profile                              ));                      }                        localConfig = localProfile.GetConfiguration(localConfig);                      var localVariables = localConfig.ApplyTo(variables);                        localVariables.SetAssemblyPath(filename);                        var newProxies = (from p in localConfig.Assemblies.Proxies                                        let newP = MapPath(p' localVariables' true' true)                                        where newP != null                                        select newP).ToArray();                        localConfig.Assemblies.Proxies.Clear();                      localConfig.Assemblies.Proxies.AddRange(newProxies);                        var newAdditionalTranslate = (from p in localConfig.Assemblies.TranslateAdditional                                        let newP = MapPath(p' localVariables' true' true)                                        where newP != null                                        select newP).ToArray();                        localConfig.Assemblies.TranslateAdditional.Clear();                      localConfig.Assemblies.TranslateAdditional.AddRange(newAdditionalTranslate);                        foreach (var analyzer in analyzers.Values)                      {                          Dictionary<string' object> settings = null;                          localConfig.AnalyzerSettings.TryGetValue(analyzer.SettingsKey' out settings);                          analyzer.SetConfiguration(settings);                      }                        var emitterFactories = emitterFactoryCreators.ToDictionary(item => item.Key' item => item.Value());                      emitterFactories[typeof(JavascriptEmitterGroupFactory).Name] = new JavascriptEmitterGroupFactory();                      emitterFactories[typeof(DefinitelyTypedEmitterGroupFactory).Name] = new DefinitelyTypedEmitterGroupFactory();                      buildGroup.Profile.RegisterPostprocessors(emitterFactories.Values' localConfig' filename' buildGroup.SkippedAssemblies);                        using (var translator = CreateTranslator(                         localConfig' manifest' assemblyCache' emitterFactories' analyzers                      )) {                          var ignoredMethods = new List<KeyValuePair<string' string[]>>();                            translator.IgnoredMethod += (methodName' variableNames) =>                              ignoredMethods.Add(new KeyValuePair<string' string[]>(methodName' variableNames));                            var outputs = buildGroup.Profile.Translate(localVariables' translator' localConfig' filename' localConfig.UseLocalProxies.GetValueOrDefault(true));                          if (localConfig.OutputDirectory == null)                              throw new Exception("No output directory was specified!");                            var outputDir = MapPath(localConfig.OutputDirectory' localVariables' false);                          CopiedOutputGatherer.EnsureDirectoryExists(outputDir);                            InformationWriteLine("// Saving output to '{0}'."' ShortenPath(outputDir) + Path.DirectorySeparatorChar);                            // Ensures that the log file contains the name of the profile that was actually used.                          localConfig.Profile = localProfile.GetType().Name;                            if (ignoredMethods.Count > 0)                              Console.Error.WriteLine("// {0} method(s) were ignored during translation. See the log for a list."' ignoredMethods.Count);                            EmitLog(outputDir' localConfig' filename' outputs' ignoredMethods);                            buildGroup.Profile.WriteOutputs(localVariables' outputs' outputDir' Quiet);                            totalFailureCount += translator.Failures.Count;                      }                  }              }
Magic Number,JSIL.Utilities,CopiedOutputGatherer,C:\repos\sq_JSIL\Compiler\Profiles\CopiedOutputGatherer.cs,CopyFile,The following statement contains a magic number: const int maxRetries = 5;
Magic Number,JSIL.Utilities,CopiedOutputGatherer,C:\repos\sq_JSIL\Compiler\Profiles\CopiedOutputGatherer.cs,CopyFile,The following statement contains a magic number: const int retryDelayMs = 500;
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,HandleCommandLine,The following statement contains a magic number: if ((commandLineArgs.Length == 3) && (commandLineArgs[1] == "--buildSolution")) {                  try {                      var jss = new JavaScriptSerializer {                          MaxJsonLength = 1024 * 1024 * 64                      };                        var pipeId = commandLineArgs[2];                        using (var pipe = new NamedPipeClientStream(pipeId)) {                          pipe.Connect(connectTimeoutMs);                            using (var sr = new StreamReader(pipe))                          using (var sw = new StreamWriter(pipe)) {                              var argsJson = sr.ReadLine();                              var argsDict = jss.Deserialize<Dictionary<string' object>>(argsJson);                                var buildResult = Build(                                  (string)argsDict["solutionFile"]'                                  (string)argsDict["buildConfiguration"]'                                  (string)argsDict["buildPlatform"]'                                  (string)argsDict["buildTarget"]'                                  (string)argsDict["logVerbosity"]'                                  true                              );                                var resultJson = jss.Serialize(buildResult);                                sw.WriteLine(resultJson);                              sw.Flush();                              pipe.Flush();                              pipe.WaitForPipeDrain();                          }                      }                  } catch (Exception exc) {                      Console.Error.WriteLine(exc.ToString());                      Environment.Exit(1);                  }                    Environment.Exit(0);              }
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,HandleCommandLine,The following statement contains a magic number: if ((commandLineArgs.Length == 3) && (commandLineArgs[1] == "--buildSolution")) {                  try {                      var jss = new JavaScriptSerializer {                          MaxJsonLength = 1024 * 1024 * 64                      };                        var pipeId = commandLineArgs[2];                        using (var pipe = new NamedPipeClientStream(pipeId)) {                          pipe.Connect(connectTimeoutMs);                            using (var sr = new StreamReader(pipe))                          using (var sw = new StreamWriter(pipe)) {                              var argsJson = sr.ReadLine();                              var argsDict = jss.Deserialize<Dictionary<string' object>>(argsJson);                                var buildResult = Build(                                  (string)argsDict["solutionFile"]'                                  (string)argsDict["buildConfiguration"]'                                  (string)argsDict["buildPlatform"]'                                  (string)argsDict["buildTarget"]'                                  (string)argsDict["logVerbosity"]'                                  true                              );                                var resultJson = jss.Serialize(buildResult);                                sw.WriteLine(resultJson);                              sw.Flush();                              pipe.Flush();                              pipe.WaitForPipeDrain();                          }                      }                  } catch (Exception exc) {                      Console.Error.WriteLine(exc.ToString());                      Environment.Exit(1);                  }                    Environment.Exit(0);              }
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,HandleCommandLine,The following statement contains a magic number: if ((commandLineArgs.Length == 3) && (commandLineArgs[1] == "--buildSolution")) {                  try {                      var jss = new JavaScriptSerializer {                          MaxJsonLength = 1024 * 1024 * 64                      };                        var pipeId = commandLineArgs[2];                        using (var pipe = new NamedPipeClientStream(pipeId)) {                          pipe.Connect(connectTimeoutMs);                            using (var sr = new StreamReader(pipe))                          using (var sw = new StreamWriter(pipe)) {                              var argsJson = sr.ReadLine();                              var argsDict = jss.Deserialize<Dictionary<string' object>>(argsJson);                                var buildResult = Build(                                  (string)argsDict["solutionFile"]'                                  (string)argsDict["buildConfiguration"]'                                  (string)argsDict["buildPlatform"]'                                  (string)argsDict["buildTarget"]'                                  (string)argsDict["logVerbosity"]'                                  true                              );                                var resultJson = jss.Serialize(buildResult);                                sw.WriteLine(resultJson);                              sw.Flush();                              pipe.Flush();                              pipe.WaitForPipeDrain();                          }                      }                  } catch (Exception exc) {                      Console.Error.WriteLine(exc.ToString());                      Environment.Exit(1);                  }                    Environment.Exit(0);              }
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,HandleCommandLine,The following statement contains a magic number: if ((commandLineArgs.Length == 3) && (commandLineArgs[1] == "--buildSolution")) {                  try {                      var jss = new JavaScriptSerializer {                          MaxJsonLength = 1024 * 1024 * 64                      };                        var pipeId = commandLineArgs[2];                        using (var pipe = new NamedPipeClientStream(pipeId)) {                          pipe.Connect(connectTimeoutMs);                            using (var sr = new StreamReader(pipe))                          using (var sw = new StreamWriter(pipe)) {                              var argsJson = sr.ReadLine();                              var argsDict = jss.Deserialize<Dictionary<string' object>>(argsJson);                                var buildResult = Build(                                  (string)argsDict["solutionFile"]'                                  (string)argsDict["buildConfiguration"]'                                  (string)argsDict["buildPlatform"]'                                  (string)argsDict["buildTarget"]'                                  (string)argsDict["logVerbosity"]'                                  true                              );                                var resultJson = jss.Serialize(buildResult);                                sw.WriteLine(resultJson);                              sw.Flush();                              pipe.Flush();                              pipe.WaitForPipeDrain();                          }                      }                  } catch (Exception exc) {                      Console.Error.WriteLine(exc.ToString());                      Environment.Exit(1);                  }                    Environment.Exit(0);              }
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,HandleCommandLine,The following statement contains a magic number: if ((commandLineArgs.Length == 3) && (commandLineArgs[1] == "--buildSolution")) {                  try {                      var jss = new JavaScriptSerializer {                          MaxJsonLength = 1024 * 1024 * 64                      };                        var pipeId = commandLineArgs[2];                        using (var pipe = new NamedPipeClientStream(pipeId)) {                          pipe.Connect(connectTimeoutMs);                            using (var sr = new StreamReader(pipe))                          using (var sw = new StreamWriter(pipe)) {                              var argsJson = sr.ReadLine();                              var argsDict = jss.Deserialize<Dictionary<string' object>>(argsJson);                                var buildResult = Build(                                  (string)argsDict["solutionFile"]'                                  (string)argsDict["buildConfiguration"]'                                  (string)argsDict["buildPlatform"]'                                  (string)argsDict["buildTarget"]'                                  (string)argsDict["logVerbosity"]'                                  true                              );                                var resultJson = jss.Serialize(buildResult);                                sw.WriteLine(resultJson);                              sw.Flush();                              pipe.Flush();                              pipe.WaitForPipeDrain();                          }                      }                  } catch (Exception exc) {                      Console.Error.WriteLine(exc.ToString());                      Environment.Exit(1);                  }                    Environment.Exit(0);              }
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,OutOfProcessBuild,The following statement contains a magic number: var jss = new JavaScriptSerializer {                  MaxJsonLength = 1024 * 1024 * 64              };
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,OutOfProcessBuild,The following statement contains a magic number: var jss = new JavaScriptSerializer {                  MaxJsonLength = 1024 * 1024 * 64              };
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,OutOfProcessBuild,The following statement contains a magic number: var jss = new JavaScriptSerializer {                  MaxJsonLength = 1024 * 1024 * 64              };
Magic Number,JSIL.SolutionBuilder,SolutionBuilder,C:\repos\sq_JSIL\Compiler\SolutionBuilder.cs,OutOfProcessBuild,The following statement contains a magic number: using (var pipe = new NamedPipeServerStream(                  pipeId' PipeDirection.InOut' 1' PipeTransmissionMode.Message' PipeOptions.Asynchronous              )) {                  var psi = new ProcessStartInfo {                      FileName = Process.GetCurrentProcess().MainModule.FileName'                      Arguments = String.Format("--buildSolution {0}"' pipeId)'                      WorkingDirectory = Environment.CurrentDirectory'                      CreateNoWindow = false'                      UseShellExecute = false'                      ErrorDialog = false                                      };                  var childProcess = Process.Start(psi);                  if (childProcess == null)                      throw new InvalidOperationException("Failed to start child process");                    var connectedEvent = new ManualResetEventSlim(false);                  var exitedEvent = new ManualResetEventSlim(false);                    try {                      var connectAR = pipe.BeginWaitForConnection((_) => connectedEvent.Set()' null);                        try {                          childProcess.Exited += (s' e) => exitedEvent.Set();                          if (childProcess.HasExited)                              exitedEvent.Set();                      } catch {                      }                        WaitHandle.WaitAny(                          new[] { connectedEvent.WaitHandle' exitedEvent.WaitHandle }' startupTimeoutMs                      );                        if (connectedEvent.IsSet) {                          pipe.EndWaitForConnection(connectAR);                      } else if (exitedEvent.IsSet) {                          Console.Error.WriteLine("// Out-of-process solution build terminated unexpectedly with code {0}!"' childProcess.ExitCode);                          Environment.Exit(1);                      } else {                          Console.Error.WriteLine("// Out-of-process solution build timed out!");                          Environment.Exit(2);                      }                        using (var sr = new StreamReader(pipe))                      using (var sw = new StreamWriter(pipe)) {                          sw.WriteLine(argsJson);                          sw.Flush();                          pipe.Flush();                          pipe.WaitForPipeDrain();                            var resultJson = sr.ReadLine();                          var buildResult = jss.Deserialize<BuildResult>(resultJson);                            Console.Error.WriteLine("// Out-of-process solution build completed successfully.");                            return buildResult;                      }                  } finally {                      try {                          if (!childProcess.HasExited)                              childProcess.Kill();                      } catch {                      }                        childProcess.Dispose();                  }              }
Missing Default,Mono.Options,OptionSet,C:\repos\sq_JSIL\Upstream\Options.cs,Parse,The following switch statement is missing a default case: switch (p.OptionValueType) {  					case OptionValueType.None:  						c.OptionValues.Add (n);  						c.Option.Invoke (c);  						break;  					case OptionValueType.Optional:  					case OptionValueType.Required:   						ParseValue (v' c);  						break;  				}
