Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Amb,The method has 106 lines of code.
Long Method,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Merge,The method has 232 lines of code.
Long Statement,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Defer,The length of the statement  "                await foreach (var item in (await factory().ConfigureAwait(false)).WithCancellation(cancellationToken).ConfigureAwait(false)) " is 125.
Long Statement,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Defer,The length of the statement  "                await foreach (var item in (await factory(cancellationToken).ConfigureAwait(false)).WithCancellation(cancellationToken).ConfigureAwait(false)) " is 142.
Long Statement,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Do,The length of the statement  "            return DoCore(source' new Action<TSource>(observer.OnNext)' new Action<Exception>(observer.OnError)' new Action(observer.OnCompleted)); " is 135.
Long Statement,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,MaxAsync,The length of the statement  "            static async ValueTask<TSource> Core(IAsyncEnumerable<TSource> source' IComparer<TSource>? comparer' CancellationToken cancellationToken) " is 137.
Long Statement,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,MinAsync,The length of the statement  "            static async ValueTask<TSource> Core(IAsyncEnumerable<TSource> source' IComparer<TSource>? comparer' CancellationToken cancellationToken) " is 137.
Long Statement,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Using,The length of the statement  "                await foreach (var item in (await enumerableFactory(resource).ConfigureAwait(false)).WithCancellation(cancellationToken).ConfigureAwait(false)) " is 143.
Long Statement,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Using,The length of the statement  "                await foreach (var item in (await enumerableFactory(resource' cancellationToken).ConfigureAwait(false)).WithCancellation(cancellationToken).ConfigureAwait(false)) " is 162.
Long Statement,System.Linq,Set<TElement>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Linq.Async\System\Linq\Set.cs,Add,The length of the statement  "            Debug.Assert(!_haveRemoved' "This class is optimized for never calling Add after Remove. If your changes need to do so' undo that optimization."); " is 146.
Empty Catch Block,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,AwaitMoveNextAsyncAndDispose,The method has an empty catch block.
Empty Catch Block,System.Linq,OnErrorResumeNextAsyncIterator<TSource>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\Operators\OnErrorResumeNext.cs,MoveNextCore,The method has an empty catch block.
Magic Number,System.Linq,Set<TElement>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Linq.Async\System\Linq\Set.cs,Set,The following statement contains a magic number: _buckets = new int[7];
Magic Number,System.Linq,Set<TElement>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Linq.Async\System\Linq\Set.cs,Set,The following statement contains a magic number: _slots = new Slot[7];
Magic Number,System.Linq,Set<TElement>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Linq.Async\System\Linq\Set.cs,Resize,The following statement contains a magic number: var newSize = checked((Count * 2) + 1);
Duplicate Code,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Merge,The method contains a code clone-set at the following line numbers (starting from the method definition): ((85' 104)' (221' 240))
Duplicate Code,System.Linq,AsyncEnumerableEx,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\AsyncEnumerableEx.cs,Merge,The method contains a code clone-set at the following line numbers (starting from the method definition): ((128' 158)' (252' 282))
Missing Default,System.Linq,DistinctAsyncIterator<TSource;TKey>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\Operators\Distinct.cs,MoveNextCore,The following switch statement is missing a default case: switch (_state)                  {                      case AsyncIteratorState.Allocated:                          _enumerator = _source.GetAsyncEnumerator(_cancellationToken);                            if (!await _enumerator.MoveNextAsync().ConfigureAwait(false))                          {                              await DisposeAsync().ConfigureAwait(false);                              return false;                          }                            var element = _enumerator.Current;                          _set = new Set<TKey>(_comparer);                          _set.Add(_keySelector(element));                          _current = element;                            _state = AsyncIteratorState.Iterating;                          return true;                        case AsyncIteratorState.Iterating:                          while (await _enumerator!.MoveNextAsync().ConfigureAwait(false))                          {                              element = _enumerator.Current;                                if (_set!.Add(_keySelector(element)))                              {                                  _current = element;                                  return true;                              }                          }                            break;                  }
Missing Default,System.Linq,DistinctAsyncIteratorWithTask<TSource;TKey>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\Operators\Distinct.cs,MoveNextCore,The following switch statement is missing a default case: switch (_state)                  {                      case AsyncIteratorState.Allocated:                          _enumerator = _source.GetAsyncEnumerator(_cancellationToken);                            if (!await _enumerator.MoveNextAsync().ConfigureAwait(false))                          {                              await DisposeAsync().ConfigureAwait(false);                              return false;                          }                            var element = _enumerator.Current;                          _set = new Set<TKey>(_comparer);                          _set.Add(await _keySelector(element).ConfigureAwait(false));                          _current = element;                            _state = AsyncIteratorState.Iterating;                          return true;                        case AsyncIteratorState.Iterating:                          while (await _enumerator!.MoveNextAsync().ConfigureAwait(false))                          {                              element = _enumerator.Current;                                if (_set!.Add(await _keySelector(element).ConfigureAwait(false)))                              {                                  _current = element;                                  return true;                              }                          }                            break;                  }
Missing Default,System.Linq,DistinctAsyncIteratorWithTaskAndCancellation<TSource;TKey>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\Operators\Distinct.cs,MoveNextCore,The following switch statement is missing a default case: switch (_state)                  {                      case AsyncIteratorState.Allocated:                          _enumerator = _source.GetAsyncEnumerator(_cancellationToken);                            if (!await _enumerator.MoveNextAsync().ConfigureAwait(false))                          {                              await DisposeAsync().ConfigureAwait(false);                              return false;                          }                            var element = _enumerator.Current;                          _set = new Set<TKey>(_comparer);                          _set.Add(await _keySelector(element' _cancellationToken).ConfigureAwait(false));                          _current = element;                            _state = AsyncIteratorState.Iterating;                          return true;                        case AsyncIteratorState.Iterating:                          while (await _enumerator!.MoveNextAsync().ConfigureAwait(false))                          {                              element = _enumerator.Current;                                if (_set!.Add(await _keySelector(element' _cancellationToken).ConfigureAwait(false)))                              {                                  _current = element;                                  return true;                              }                          }                            break;                  }
Missing Default,System.Linq,OnErrorResumeNextAsyncIterator<TSource>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\Operators\OnErrorResumeNext.cs,MoveNextCore,The following switch statement is missing a default case: switch (_state)                  {                      case AsyncIteratorState.Allocated:                          _sourcesEnumerator = _sources.GetEnumerator();                            _state = AsyncIteratorState.Iterating;                          goto case AsyncIteratorState.Iterating;                        case AsyncIteratorState.Iterating:                          while (true)                          {                              if (_enumerator == null)                              {                                  if (!_sourcesEnumerator!.MoveNext())                                  {                                      break; // while -- done' nothing else to do                                  }                                    _enumerator = _sourcesEnumerator.Current.GetAsyncEnumerator(_cancellationToken);                              }                                try                              {                                  if (await _enumerator.MoveNextAsync().ConfigureAwait(false))                                  {                                      _current = _enumerator.Current;                                      return true;                                  }                              }                              catch                              {                                  // Ignore                              }                                // Done with the current one' go to the next                              await _enumerator.DisposeAsync().ConfigureAwait(false);                              _enumerator = null;                          }                            break; // case                  }
Missing Default,System.Linq,TimeoutAsyncIterator<TSource>,C:\research\architectureSmells\repos\Reactive-Extensions_Rx.NET\Ix.NET\Source\System.Interactive.Async\System\Linq\Operators\Timeout.cs,MoveNextCore,The following switch statement is missing a default case: switch (_state)                  {                      case AsyncIteratorState.Allocated:                          _sourceCTS = CancellationTokenSource.CreateLinkedTokenSource(_cancellationToken);                          _enumerator = _source.GetAsyncEnumerator(_sourceCTS.Token);                            _state = AsyncIteratorState.Iterating;                          goto case AsyncIteratorState.Iterating;                        case AsyncIteratorState.Iterating:                          var moveNext = _enumerator!.MoveNextAsync();                            if (!moveNext.IsCompleted)                          {                              using var delayCts = CancellationTokenSource.CreateLinkedTokenSource(_cancellationToken);                                var delay = Task.Delay(_timeout' delayCts.Token);                                var next = moveNext.AsTask();                                var winner = await Task.WhenAny(next' delay).ConfigureAwait(false);                                if (winner == delay)                              {                                  // NB: We still have to wait for the MoveNextAsync operation to complete before we can                                  //     dispose _enumerator. The resulting task will be used by DisposeAsync. Also note                                  //     that throwing an exception here causes a call to DisposeAsync' where we pick up                                  //     the task prepared below.                                    // NB: Any exception reported by a timed out MoveNextAsync operation won't be reported                                  //     to the caller' but the task's exception is not marked as observed' so unhandled                                  //     exception handlers can still observe the exception.                                    // REVIEW: Should exceptions reported by a timed out MoveNextAsync operation come out                                  //         when attempting to call DisposeAsync?                                    _loserTask = next.ContinueWith((_' state) => ((IAsyncDisposable)state!).DisposeAsync().AsTask()' _enumerator);                                    _sourceCTS!.Cancel();                                    throw new TimeoutException();                              }                                delayCts.Cancel();                          }                            if (await moveNext.ConfigureAwait(false))                          {                              _current = _enumerator.Current;                              return true;                          }                            break;                  }
