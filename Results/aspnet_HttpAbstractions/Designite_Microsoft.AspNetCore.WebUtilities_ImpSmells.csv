Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,ReadAsync,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.AspNetCore.WebUtilities,QueryHelpers,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\QueryHelpers.cs,ParseNullableQuery,Cyclomatic complexity of the method is 10
Long Parameter List,Microsoft.AspNetCore.WebUtilities,FileBufferingReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\FileBufferingReadStream.cs,FileBufferingReadStream,The method has 5 parameters. Parameters: inner' memoryThreshold' bufferLimit' tempFileDirectoryAccessor' bytePool
Long Parameter List,Microsoft.AspNetCore.WebUtilities,FileBufferingReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\FileBufferingReadStream.cs,FileBufferingReadStream,The method has 5 parameters. Parameters: inner' memoryThreshold' bufferLimit' tempFileDirectory' bytePool
Long Parameter List,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,HttpRequestStreamReader,The method has 5 parameters. Parameters: stream' encoding' bufferSize' bytePool' charPool
Long Parameter List,Microsoft.AspNetCore.WebUtilities,HttpResponseStreamWriter,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpResponseStreamWriter.cs,HttpResponseStreamWriter,The method has 5 parameters. Parameters: stream' encoding' bufferSize' bytePool' charPool
Long Parameter List,Microsoft.AspNetCore.WebUtilities,MultipartReaderStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartReaderStream.cs,CompareBuffers,The method has 5 parameters. Parameters: buffer1' offset1' buffer2' offset2' count
Long Identifier,Microsoft.AspNetCore.WebUtilities,MultipartReaderStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartReaderStream.cs,SubMatch,The length of the parameter segmentEndMinusMatchBytesLength is 31.
Long Statement,Microsoft.AspNetCore.WebUtilities,BufferedReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\BufferedReadStream.cs,EnsureBuffered,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(minCount)' minCount' "The value must be smaller than the buffer size: " + _buffer.Length.ToString()); " is 146.
Long Statement,Microsoft.AspNetCore.WebUtilities,BufferedReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\BufferedReadStream.cs,EnsureBufferedAsync,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(minCount)' minCount' "The value must be smaller than the buffer size: " + _buffer.Length.ToString()); " is 146.
Long Statement,Microsoft.AspNetCore.WebUtilities,BufferedReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\BufferedReadStream.cs,EnsureBufferedAsync,The length of the statement  "                int read = await _inner.ReadAsync(_buffer' _bufferOffset + _bufferCount' _buffer.Length - _bufferCount - _bufferOffset' cancellationToken); " is 139.
Long Statement,Microsoft.AspNetCore.WebUtilities,FileBufferingReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\FileBufferingReadStream.cs,ReadAsync,The length of the statement  "                return await _buffer.ReadAsync(buffer' offset' (int)Math.Min(count' _buffer.Length - _buffer.Position)' cancellationToken); " is 123.
Long Statement,Microsoft.AspNetCore.WebUtilities,MultipartReaderStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartReaderStream.cs,Read,The length of the statement  "                Debug.Assert(FinalBoundaryFound || string.Equals(string.Empty' remainder' StringComparison.Ordinal)' "Un-expected data found on the boundary line: " + remainder); " is 162.
Long Statement,Microsoft.AspNetCore.WebUtilities,MultipartReaderStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartReaderStream.cs,ReadAsync,The length of the statement  "                var remainder = await _innerStream.ReadLineAsync(lengthLimit: 100' cancellationToken: cancellationToken); // Whitespace may exceed the buffer. " is 142.
Long Statement,Microsoft.AspNetCore.WebUtilities,MultipartReaderStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartReaderStream.cs,ReadAsync,The length of the statement  "                Debug.Assert(FinalBoundaryFound || string.Equals(string.Empty' remainder' StringComparison.Ordinal)' "Un-expected data found on the boundary line: " + remainder); " is 162.
Magic Number,Microsoft.AspNetCore.WebUtilities,BufferedReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\BufferedReadStream.cs,ReadLine,The following statement contains a magic number: using (var builder = new MemoryStream(200))              {                  bool foundCR = false' foundCRLF = false;                    while (!foundCRLF && EnsureBuffered())                  {                      if (builder.Length > lengthLimit)                      {                          throw new InvalidDataException($"Line length limit {lengthLimit} exceeded.");                      }                      ProcessLineChar(builder' ref foundCR' ref foundCRLF);                  }                    return DecodeLine(builder' foundCRLF);              }
Magic Number,Microsoft.AspNetCore.WebUtilities,BufferedReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\BufferedReadStream.cs,ReadLineAsync,The following statement contains a magic number: using (var builder = new MemoryStream(200))              {                  bool foundCR = false' foundCRLF = false;                    while (!foundCRLF && await EnsureBufferedAsync(cancellationToken))                  {                      if (builder.Length > lengthLimit)                      {                          throw new InvalidDataException($"Line length limit {lengthLimit} exceeded.");                      }                        ProcessLineChar(builder' ref foundCR' ref foundCRLF);                  }                    return DecodeLine(builder' foundCRLF);              }
Magic Number,Microsoft.AspNetCore.WebUtilities,BufferedReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\BufferedReadStream.cs,DecodeLine,The following statement contains a magic number: var length = foundCRLF ? builder.Length - 2 : builder.Length;
Magic Number,Microsoft.AspNetCore.WebUtilities,FileBufferingReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\FileBufferingReadStream.cs,CreateTempFile,The following statement contains a magic number: return new FileStream(_tempFileName' FileMode.Create' FileAccess.ReadWrite' FileShare.Delete' 1024 * 16'                  FileOptions.Asynchronous | FileOptions.DeleteOnClose | FileOptions.SequentialScan);
Magic Number,Microsoft.AspNetCore.WebUtilities,FileBufferingReadStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\FileBufferingReadStream.cs,CreateTempFile,The following statement contains a magic number: return new FileStream(_tempFileName' FileMode.Create' FileAccess.ReadWrite' FileShare.Delete' 1024 * 16'                  FileOptions.Asynchronous | FileOptions.DeleteOnClose | FileOptions.SequentialScan);
Magic Number,Microsoft.AspNetCore.WebUtilities,FormReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\FormReader.cs,FormReader,The following statement contains a magic number: _reader = new StreamReader(stream' encoding' detectEncodingFromByteOrderMarks: true' bufferSize: 1024 * 2' leaveOpen: true);
Magic Number,Microsoft.AspNetCore.WebUtilities,FormReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\FormReader.cs,FormReader,The following statement contains a magic number: _reader = new StreamReader(stream' encoding' detectEncodingFromByteOrderMarks: true' bufferSize: 1024 * 2' leaveOpen: true);
Magic Number,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,Read,The following statement contains a magic number: while (count > 0)              {                  var charsRemaining = _charsRead - _charBufferIndex;                  if (charsRemaining == 0)                  {                      charsRemaining = ReadIntoBuffer();                  }                    if (charsRemaining == 0)                  {                      break;  // We're at EOF                  }                    if (charsRemaining > count)                  {                      charsRemaining = count;                  }                    Buffer.BlockCopy(                      _charBuffer'                      _charBufferIndex * 2'                      buffer'                      (index + charsRead) * 2'                      charsRemaining * 2);                  _charBufferIndex += charsRemaining;                    charsRead += charsRemaining;                  count -= charsRemaining;                    // If we got back fewer chars than we asked for' then it's likely the underlying stream is blocked.                  // Send the data back to the caller so they can process it.                  if (_isBlocked)                  {                      break;                  }              }
Magic Number,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,Read,The following statement contains a magic number: while (count > 0)              {                  var charsRemaining = _charsRead - _charBufferIndex;                  if (charsRemaining == 0)                  {                      charsRemaining = ReadIntoBuffer();                  }                    if (charsRemaining == 0)                  {                      break;  // We're at EOF                  }                    if (charsRemaining > count)                  {                      charsRemaining = count;                  }                    Buffer.BlockCopy(                      _charBuffer'                      _charBufferIndex * 2'                      buffer'                      (index + charsRead) * 2'                      charsRemaining * 2);                  _charBufferIndex += charsRemaining;                    charsRead += charsRemaining;                  count -= charsRemaining;                    // If we got back fewer chars than we asked for' then it's likely the underlying stream is blocked.                  // Send the data back to the caller so they can process it.                  if (_isBlocked)                  {                      break;                  }              }
Magic Number,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,Read,The following statement contains a magic number: while (count > 0)              {                  var charsRemaining = _charsRead - _charBufferIndex;                  if (charsRemaining == 0)                  {                      charsRemaining = ReadIntoBuffer();                  }                    if (charsRemaining == 0)                  {                      break;  // We're at EOF                  }                    if (charsRemaining > count)                  {                      charsRemaining = count;                  }                    Buffer.BlockCopy(                      _charBuffer'                      _charBufferIndex * 2'                      buffer'                      (index + charsRead) * 2'                      charsRemaining * 2);                  _charBufferIndex += charsRemaining;                    charsRead += charsRemaining;                  count -= charsRemaining;                    // If we got back fewer chars than we asked for' then it's likely the underlying stream is blocked.                  // Send the data back to the caller so they can process it.                  if (_isBlocked)                  {                      break;                  }              }
Magic Number,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,ReadAsync,The following statement contains a magic number: while (count > 0)              {                  // n is the characters available in _charBuffer                  var n = _charsRead - _charBufferIndex;                    // charBuffer is empty' let's read from the stream                  if (n == 0)                  {                      _charsRead = 0;                      _charBufferIndex = 0;                      _bytesRead = 0;                        // We loop here so that we read in enough bytes to yield at least 1 char.                      // We break out of the loop if the stream is blocked (EOF is reached).                      do                      {                          Debug.Assert(n == 0);                          _bytesRead = await _stream.ReadAsync(                              _byteBuffer'                              0'                              _byteBufferSize);                          if (_bytesRead == 0)  // EOF                          {                              _isBlocked = true;                              break;                          }                            // _isBlocked == whether we read fewer bytes than we asked for.                          _isBlocked = (_bytesRead < _byteBufferSize);                            Debug.Assert(n == 0);                            _charBufferIndex = 0;                          n = _decoder.GetChars(                              _byteBuffer'                              0'                              _bytesRead'                              _charBuffer'                              0);                            Debug.Assert(n > 0);                            _charsRead += n; // Number of chars in StreamReader's buffer.                      }                      while (n == 0);                        if (n == 0)                      {                          break; // We're at EOF                      }                  }                    // Got more chars in charBuffer than the user requested                  if (n > count)                  {                      n = count;                  }                    Buffer.BlockCopy(                      _charBuffer'                      _charBufferIndex * 2'                      buffer'                      (index + charsRead) * 2'                      n * 2);                    _charBufferIndex += n;                    charsRead += n;                  count -= n;                    // This function shouldn't block for an indefinite amount of time'                  // or reading from a network stream won't work right.  If we got                  // fewer bytes than we requested' then we want to break right here.                  if (_isBlocked)                  {                      break;                  }              }
Magic Number,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,ReadAsync,The following statement contains a magic number: while (count > 0)              {                  // n is the characters available in _charBuffer                  var n = _charsRead - _charBufferIndex;                    // charBuffer is empty' let's read from the stream                  if (n == 0)                  {                      _charsRead = 0;                      _charBufferIndex = 0;                      _bytesRead = 0;                        // We loop here so that we read in enough bytes to yield at least 1 char.                      // We break out of the loop if the stream is blocked (EOF is reached).                      do                      {                          Debug.Assert(n == 0);                          _bytesRead = await _stream.ReadAsync(                              _byteBuffer'                              0'                              _byteBufferSize);                          if (_bytesRead == 0)  // EOF                          {                              _isBlocked = true;                              break;                          }                            // _isBlocked == whether we read fewer bytes than we asked for.                          _isBlocked = (_bytesRead < _byteBufferSize);                            Debug.Assert(n == 0);                            _charBufferIndex = 0;                          n = _decoder.GetChars(                              _byteBuffer'                              0'                              _bytesRead'                              _charBuffer'                              0);                            Debug.Assert(n > 0);                            _charsRead += n; // Number of chars in StreamReader's buffer.                      }                      while (n == 0);                        if (n == 0)                      {                          break; // We're at EOF                      }                  }                    // Got more chars in charBuffer than the user requested                  if (n > count)                  {                      n = count;                  }                    Buffer.BlockCopy(                      _charBuffer'                      _charBufferIndex * 2'                      buffer'                      (index + charsRead) * 2'                      n * 2);                    _charBufferIndex += n;                    charsRead += n;                  count -= n;                    // This function shouldn't block for an indefinite amount of time'                  // or reading from a network stream won't work right.  If we got                  // fewer bytes than we requested' then we want to break right here.                  if (_isBlocked)                  {                      break;                  }              }
Magic Number,Microsoft.AspNetCore.WebUtilities,HttpRequestStreamReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\HttpRequestStreamReader.cs,ReadAsync,The following statement contains a magic number: while (count > 0)              {                  // n is the characters available in _charBuffer                  var n = _charsRead - _charBufferIndex;                    // charBuffer is empty' let's read from the stream                  if (n == 0)                  {                      _charsRead = 0;                      _charBufferIndex = 0;                      _bytesRead = 0;                        // We loop here so that we read in enough bytes to yield at least 1 char.                      // We break out of the loop if the stream is blocked (EOF is reached).                      do                      {                          Debug.Assert(n == 0);                          _bytesRead = await _stream.ReadAsync(                              _byteBuffer'                              0'                              _byteBufferSize);                          if (_bytesRead == 0)  // EOF                          {                              _isBlocked = true;                              break;                          }                            // _isBlocked == whether we read fewer bytes than we asked for.                          _isBlocked = (_bytesRead < _byteBufferSize);                            Debug.Assert(n == 0);                            _charBufferIndex = 0;                          n = _decoder.GetChars(                              _byteBuffer'                              0'                              _bytesRead'                              _charBuffer'                              0);                            Debug.Assert(n > 0);                            _charsRead += n; // Number of chars in StreamReader's buffer.                      }                      while (n == 0);                        if (n == 0)                      {                          break; // We're at EOF                      }                  }                    // Got more chars in charBuffer than the user requested                  if (n > count)                  {                      n = count;                  }                    Buffer.BlockCopy(                      _charBuffer'                      _charBufferIndex * 2'                      buffer'                      (index + charsRead) * 2'                      n * 2);                    _charBufferIndex += n;                    charsRead += n;                  count -= n;                    // This function shouldn't block for an indefinite amount of time'                  // or reading from a network stream won't work right.  If we got                  // fewer bytes than we requested' then we want to break right here.                  if (_isBlocked)                  {                      break;                  }              }
Magic Number,Microsoft.AspNetCore.WebUtilities,KeyValueAccumulator,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\KeyValueAccumulator.cs,Append,The following statement contains a magic number: if (_accumulator.TryGetValue(key' out values))              {                  if (values.Count == 0)                  {                      // Marker entry for this key to indicate entry already in expanding list dictionary                      _expandingAccumulator[key].Add(value);                  }                  else if (values.Count == 1)                  {                      // Second value for this key                      _accumulator[key] = new string[] { values[0]' value };                  }                  else                  {                      // Third value for this key                      // Add zero count entry and move to data to expanding list dictionary                      _accumulator[key] = default(StringValues);                        if (_expandingAccumulator == null)                      {                          _expandingAccumulator = new Dictionary<string' List<string>>(StringComparer.OrdinalIgnoreCase);                      }                        // Already 3 entries so use starting allocated as 8; then use List's expansion mechanism for more                      var list = new List<string>(8);                      var array = values.ToArray();                        list.Add(array[0]);                      list.Add(array[1]);                      list.Add(value);                        _expandingAccumulator[key] = list;                  }              }              else              {                  // First value for this key                  _accumulator[key] = new StringValues(value);              }
Magic Number,Microsoft.AspNetCore.WebUtilities,MultipartBoundary,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartBoundary.cs,Initialize,The following statement contains a magic number: FinalBoundaryLength = BoundaryBytes.Length + 2;
Magic Number,Microsoft.AspNetCore.WebUtilities,MultipartReader,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartReader.cs,MultipartReader,The following statement contains a magic number: if (bufferSize < boundary.Length + 8) // Size of the boundary + leading and trailing CRLF + leading and trailing '--' markers.              {                  throw new ArgumentOutOfRangeException(nameof(bufferSize)' bufferSize' "Insufficient buffer space' the buffer must be larger than the boundary: " + boundary);              }
Magic Number,Microsoft.AspNetCore.WebUtilities,MultipartReaderStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartReaderStream.cs,Read,The following statement contains a magic number: if (SubMatch(bufferedData' _boundary.BoundaryBytes' out var matchOffset' out var matchCount))              {                  // We found a possible match' return any data before it.                  if (matchOffset > bufferedData.Offset)                  {                      read = _innerStream.Read(buffer' offset' Math.Min(count' matchOffset - bufferedData.Offset));                      return UpdatePosition(read);                  }                    var length = _boundary.BoundaryBytes.Length;                  Debug.Assert(matchCount == length);                    // "The boundary may be followed by zero or more characters of                  // linear whitespace. It is then terminated by either another CRLF"                  // or -- for the final boundary.                  var boundary = _bytePool.Rent(length);                  read = _innerStream.Read(boundary' 0' length);                  _bytePool.Return(boundary);                  Debug.Assert(read == length); // It should have all been buffered                    var remainder = _innerStream.ReadLine(lengthLimit: 100); // Whitespace may exceed the buffer.                  remainder = remainder.Trim();                  if (string.Equals("--"' remainder' StringComparison.Ordinal))                  {                      FinalBoundaryFound = true;                  }                  Debug.Assert(FinalBoundaryFound || string.Equals(string.Empty' remainder' StringComparison.Ordinal)' "Un-expected data found on the boundary line: " + remainder);                  _finished = true;                  return 0;              }
Magic Number,Microsoft.AspNetCore.WebUtilities,MultipartReaderStream,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartReaderStream.cs,ReadAsync,The following statement contains a magic number: if (SubMatch(bufferedData' _boundary.BoundaryBytes' out matchOffset' out matchCount))              {                  // We found a possible match' return any data before it.                  if (matchOffset > bufferedData.Offset)                  {                      // Sync' it's already buffered                      read = _innerStream.Read(buffer' offset' Math.Min(count' matchOffset - bufferedData.Offset));                      return UpdatePosition(read);                  }                    var length = _boundary.BoundaryBytes.Length;                  Debug.Assert(matchCount == length);                    // "The boundary may be followed by zero or more characters of                  // linear whitespace. It is then terminated by either another CRLF"                  // or -- for the final boundary.                  var boundary = _bytePool.Rent(length);                  read = _innerStream.Read(boundary' 0' length);                  _bytePool.Return(boundary);                  Debug.Assert(read == length); // It should have all been buffered                    var remainder = await _innerStream.ReadLineAsync(lengthLimit: 100' cancellationToken: cancellationToken); // Whitespace may exceed the buffer.                  remainder = remainder.Trim();                  if (string.Equals("--"' remainder' StringComparison.Ordinal))                  {                      FinalBoundaryFound = true;                  }                  Debug.Assert(FinalBoundaryFound || string.Equals(string.Empty' remainder' StringComparison.Ordinal)' "Un-expected data found on the boundary line: " + remainder);                    _finished = true;                  return 0;              }
Magic Number,Microsoft.AspNetCore.WebUtilities,MultipartSectionStreamExtensions,C:\repos\aspnet_HttpAbstractions\src\Microsoft.AspNetCore.WebUtilities\MultipartSectionStreamExtensions.cs,ReadAsStringAsync,The following statement contains a magic number: using (var reader = new StreamReader(                  section.Body'                   streamEncoding'                  detectEncodingFromByteOrderMarks: true'                  bufferSize: 1024'                   leaveOpen: true))              {                  return await reader.ReadToEndAsync();              }
