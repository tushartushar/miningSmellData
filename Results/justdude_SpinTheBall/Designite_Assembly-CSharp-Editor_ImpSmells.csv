Implementation smell,Namespace,Class,File,Method,Description
Long Method,tk2dEditor,BrushRenderer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushRenderer.cs,BuildMeshForBrush,The method has 121 lines of code.
Long Method,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The method has 175 lines of code.
Long Method,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The method has 143 lines of code.
Long Method,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The method has 172 lines of code.
Long Method,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The method has 180 lines of code.
Long Method,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawMaterialEditor,The method has 128 lines of code.
Long Method,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The method has 124 lines of code.
Long Method,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The method has 274 lines of code.
Long Method,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The method has 171 lines of code.
Long Method,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The method has 164 lines of code.
Long Method,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,SetUpSpriteSheets,The method has 120 lines of code.
Long Method,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,UpdatePlatformSpriteCollection,The method has 144 lines of code.
Complex Method,tk2dEditor,Triangulator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Triangulator\tk2dTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 13
Complex Method,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,Cyclomatic complexity of the method is 11
Complex Method,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,HandleGUI,Cyclomatic complexity of the method is 22
Complex Method,tk2dEditor,BrushRenderer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushRenderer.cs,BuildMeshForBrush,Cyclomatic complexity of the method is 25
Complex Method,tk2dEditor.Font,BMFontXmlImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,Cyclomatic complexity of the method is 13
Complex Method,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,Cyclomatic complexity of the method is 27
Complex Method,tk2dEditor.Shared,NaturalComparer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Shared\tk2dNaturalComparer.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,Cyclomatic complexity of the method is 23
Complex Method,tk2dEditor.Atlas,MaxRectsBinPack,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dMaxRectsBinPack.cs,Insert,Cyclomatic complexity of the method is 17
Complex Method,tk2dEditor.Atlas,MaxRectsBinPack,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dMaxRectsBinPack.cs,ScoreRect,Cyclomatic complexity of the method is 17
Complex Method,tk2dEditor.SpriteAnimationEditor,ClipTools,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,OnClipInspectorGUI,Cyclomatic complexity of the method is 12
Complex Method,tk2dEditor.SpriteAnimationEditor,ClipTools,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,BuildTextSpriteList,Cyclomatic complexity of the method is 9
Complex Method,tk2dEditor.SpriteAnimationEditor,ClipTools,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,ProcessSpriteImport,Cyclomatic complexity of the method is 11
Complex Method,tk2dEditor.SpriteAnimationEditor,AutoFillFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,AutoFill,Cyclomatic complexity of the method is 10
Complex Method,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,CheckValidClip,Cyclomatic complexity of the method is 10
Complex Method,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,SetClip,Cyclomatic complexity of the method is 10
Complex Method,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,Cyclomatic complexity of the method is 14
Complex Method,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawFrameInspector,Cyclomatic complexity of the method is 8
Complex Method,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,HandleKeyboardShortcuts,Cyclomatic complexity of the method is 18
Complex Method,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,Cyclomatic complexity of the method is 58
Complex Method,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,Cyclomatic complexity of the method is 38
Complex Method,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,Cyclomatic complexity of the method is 28
Complex Method,tk2dEditor.SpriteCollectionEditor,SpriteCollectionProxy,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorProxy.cs,CopyFromSource,Cyclomatic complexity of the method is 13
Complex Method,tk2dEditor.SpriteCollectionEditor,SpriteCollectionProxy,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorProxy.cs,DeleteUnusedData,Cyclomatic complexity of the method is 30
Complex Method,tk2dEditor.SpriteCollectionEditor,SpriteCollectionProxy,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorProxy.cs,Trim,Cyclomatic complexity of the method is 13
Complex Method,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawMaterialEditor,Cyclomatic complexity of the method is 40
Complex Method,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawSystemSettings,Cyclomatic complexity of the method is 11
Complex Method,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawPlatforms,Cyclomatic complexity of the method is 14
Complex Method,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,Cyclomatic complexity of the method is 12
Complex Method,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawAtlasSettings,Cyclomatic complexity of the method is 11
Complex Method,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,ProcessSpriteSelectionUI,Cyclomatic complexity of the method is 16
Complex Method,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,DrawTextureView,Cyclomatic complexity of the method is 8
Complex Method,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,Cyclomatic complexity of the method is 20
Complex Method,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,Cyclomatic complexity of the method is 60
Complex Method,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,Cyclomatic complexity of the method is 29
Complex Method,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,HandleKeys,Cyclomatic complexity of the method is 18
Complex Method,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,Cyclomatic complexity of the method is 29
Complex Method,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawAttachPointInspector,Cyclomatic complexity of the method is 19
Complex Method,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,Cyclomatic complexity of the method is 15
Complex Method,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,CheckAndFixUpParams,Cyclomatic complexity of the method is 8
Complex Method,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,SetUpSpriteSheets,Cyclomatic complexity of the method is 23
Complex Method,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,FindAssetForPlatform,Cyclomatic complexity of the method is 9
Complex Method,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,UpdatePlatformSpriteCollection,Cyclomatic complexity of the method is 34
Complex Method,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,ImportTMX,Cyclomatic complexity of the method is 9
Complex Method,tk2dEditor.TileMap,TileMapUtility,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapUtility.cs,ResizeTileMap,Cyclomatic complexity of the method is 10
Long Parameter List,tk2dEditor,Triangulator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Triangulator\tk2dTriangulator.cs,Snip,The method has 5 parameters.
Long Parameter List,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,HandleGUI,The method has 5 parameters.
Long Parameter List,tk2dEditor,BrushRenderer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushRenderer.cs,DrawBrush,The method has 5 parameters.
Long Parameter List,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The method has 8 parameters.
Long Parameter List,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Builder,The method has 5 parameters.
Long Parameter List,tk2dEditor.Atlas,MaxRectsBinPack,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dMaxRectsBinPack.cs,ScoreRect,The method has 5 parameters.
Long Parameter List,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The method has 5 parameters.
Long Parameter List,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroupsOverlay,The method has 5 parameters.
Long Parameter List,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroupEx,The method has 6 parameters.
Long Parameter List,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,GetTileCoordinateForSpriteSheet,The method has 5 parameters.
Long Parameter List,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The method has 51 parameters.
Long Parameter List,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The method has 6 parameters.
Long Parameter List,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,UpdatePlatformSpriteCollection,The method has 6 parameters.
Long Parameter List,tk2dEditor.TileMap,TileMapUtility,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapUtility.cs,ResizeTileMap,The method has 5 parameters.
Long Statement,tk2dEditor,tk2dCameraSceneGUI,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Camera\tk2dCameraEditor.cs,PreviewWindowFunc,The length of the statement  "		Rect r = new Rect (previewWindowRect.x + rs.x' Camera.current.pixelHeight - (previewWindowRect.y + rs.y)' rs.width' rs.height); " is 127.
Long Statement,tk2dEditor,tk2dCameraSceneGUI,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Camera\tk2dCameraEditor.cs,PreviewWindowFunc,The length of the statement  "		Vector2 v = new Vector2 (previewWindowRect.x + rs.x' (Camera.current.pixelHeight - previewWindowRect.y - rs.height - heightTweak) + rs.y); " is 138.
Long Statement,tk2dEditor,tk2dCameraSceneGUI,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Camera\tk2dCameraEditor.cs,OnSceneGUI,The length of the statement  "		GameObject go = EditorUtility.CreateGameObjectWithHideFlags ("@tk2dCamera_ScenePreview"' UnityEngine.HideFlags.HideAndDontSave' new System.Type[] { " is 147.
Long Statement,tk2dEditor,tk2dCameraSceneGUI,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Camera\tk2dCameraEditor.cs,OnSceneGUI,The length of the statement  "	previewWindowRect = new Rect (viewportOffsetLeft' Camera.current.pixelHeight - height - viewportOffsetBottom' width' height); " is 125.
Long Statement,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,DrawSelectedTiles,The length of the statement  "		Rect highlightRect = new Rect (rect.x + tx0 * tileSize.width' rect.y + ty0 * tileSize.height' (tx1 - tx0 + 1) * tileSize.width' (ty1 - ty0 + 1) * tileSize.height); " is 163.
Long Statement,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,DrawSelectedTiles,The length of the statement  "			Rect highlightRect = new Rect (rect.x + tx0 * tileSize.width' rect.y + ty0 * tileSize.height' tileSize.width' tileSize.height); " is 127.
Long Statement,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,IsValidSprite,The length of the statement  "	return (spriteId >= 0 && spriteId < spriteCollection.Count && spriteCollection.spriteDefinitions [spriteId] != null && spriteCollection.spriteDefinitions [spriteId].Valid); " is 172.
Long Statement,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,HandleGUI,The length of the statement  "	Vector2 tileLocalPosition = new Vector2 (localClickPosition.x / tileSize.width' localClickPosition.y / tileSize.height); " is 120.
Long Statement,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,HandleGUI,The length of the statement  "		bool multiSelectKeyDown = (Application.platform == RuntimePlatform.OSXEditor) ? Event.current.command : Event.current.control; " is 126.
Long Statement,tk2dEditor,BrushRenderer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushRenderer.cs,BuildMeshForBrush,The length of the statement  "				Vector3 flippedPos = tk2dRuntime.TileMap.BuilderUtil.ApplySpriteVertexTileFlags (tileMap' sprite' sprite.positions [j]' flipH' flipV' rot90); " is 141.
Long Statement,tk2dEditor,BrushRenderer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushRenderer.cs,DrawBrush,The length of the statement  "	Vector4 clipRegion = new Vector4 (visibleRect.x' visibleRect.y' visibleRect.x + visibleRect.width' visibleRect.y + visibleRect.height); " is 135.
Long Statement,tk2dEditor,BrushRenderer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushRenderer.cs,DrawBrush,The length of the statement  "		mat.SetTRS (new Vector3 (rect.x' rect.y + height' 0)' Quaternion.identity' new Vector3 (scale / spriteDef.texelSize.x' -scale / spriteDef.texelSize.y' 1)); " is 155.
Long Statement,tk2dEditor,BrushRenderer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushRenderer.cs,DrawBrushInScratchpad,The length of the statement  "	Vector4 clipRegion = new Vector4 (visibleRect.x' visibleRect.y' visibleRect.x + visibleRect.width' visibleRect.y + visibleRect.height); " is 135.
Long Statement,tk2dEditor.Font,BMFontXmlImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The length of the statement  "		EditorUtility.DisplayDialog ("Fatal error"' "Only one page supported in font. Please change the setting and re-export."' "Ok"); " is 127.
Long Statement,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The length of the statement  "				EditorUtility.DisplayDialog ("Fatal error"' "Only one page supported in font. Please change the setting and re-export."' "Ok"); " is 127.
Long Statement,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,FindBestBinPacker,The length of the statement  "	//                                                         MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestShortSideFit' " is 120.
Long Statement,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,FindBestBinPacker,The length of the statement  "	//                                                         MaxRectsBinPack.FreeRectChoiceHeuristic.RectContactPointRule }; " is 122.
Long Statement,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The length of the statement  "			// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value " is 123.
Long Statement,tk2dEditor.Atlas,MaxRectsBinPack,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dMaxRectsBinPack.cs,FindPositionForNewNodeBestShortSideFit,The length of the statement  "			if (flippedShortSideFit < bestShortSideFit || (flippedShortSideFit == bestShortSideFit && flippedLongSideFit < bestLongSideFit)) { " is 130.
Long Statement,tk2dEditor.Atlas,MaxRectsBinPack,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dMaxRectsBinPack.cs,SplitFreeNode,The length of the statement  "	if (usedNode.x >= freeNode.x + freeNode.width || usedNode.x + usedNode.width <= freeNode.x || usedNode.y >= freeNode.y + freeNode.height || usedNode.y + usedNode.height <= freeNode.y) " is 183.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipTools,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,OnClipInspectorGUI,The length of the statement  "		state.selectedFrame = (state.selectedFrame == -1) ? state.selectedFrame : (frameGroups.Count - 1 - state.selectedFrame); " is 120.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipTools,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,OnClipInspectorGUI,The length of the statement  "	GUIContent addTriggerContent = new GUIContent ("Trigger"' "You can also add a trigger by double clicking on the trigger area"); " is 127.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipTools,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,BuildTextSpriteList,The length of the statement  "		EditorUtility.DisplayDialog ("Text importer failed"' "Current animation clip contains sprites from multiple collections"' "Ok"); " is 128.
Long Statement,tk2dEditor.SpriteAnimationEditor,AutoFillFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,AutoFill,The length of the statement  "	if (selectedFrameGroup.spriteCollection != null && selectedFrameGroup.spriteId >= 0 && selectedFrameGroup.spriteId < selectedFrameGroup.spriteCollection.inst.Count) { " is 166.
Long Statement,tk2dEditor.SpriteAnimationEditor,AutoFillFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,AutoFill,The length of the statement  "				if (nextFrameGroup != null && nextFrameGroup.spriteCollection == selectedFrameGroup.spriteCollection && nextFrameGroup.spriteId == frameToInsert) " is 145.
Long Statement,tk2dEditor.SpriteAnimationEditor,AutoFillFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,OnFrameGroupInspectorGUI,The length of the statement  "	if (GUILayout.Button ("Autofill 1..9"' EditorStyles.miniButton) && AutoFill (frameGroups' state.selectedFrame' false)) { " is 120.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,InitAnimator,The length of the statement  "		#if UNITY_3_0 || UNITY_3_1 || UNITY_3_2 || UNITY_3_3 || UNITY_3_4 || UNITY_3_5 || UNITY_3_6 || UNITY_3_7 || UNITY_3_8 || UNITY_3_9 " is 130.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,CheckValidClip,The length of the statement  "		EditorUtility.DisplayDialog ("Invalid sprite collection found in clip."' "An invalid sprite collection has been found in the selected clip. Please correct this in the inspector."' "Ok"); " is 186.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,CheckValidClip,The length of the statement  "		if (EditorUtility.DisplayDialog ("Invalid sprite found in clip."' "An invalid sprite has been found in the selected clip. Has the sprite been deleted from the collection?\n\nDo you wish to replace this with a valid sprite from the collection?\n\nThis may not be correct' but you will be able to edit the clip after this."' "Yes"' "No")) { " is 338.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,The length of the statement  "	if (GUILayout.Button ("Delete"' GUILayout.Width (46)) && EditorUtility.DisplayDialog ("Delete clip"' "Are you sure you want to delete the selected clip?"' "Yes"' "No")) { " is 170.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,The length of the statement  "	tk2dSpriteAnimationClip.WrapMode newWrapMode = (tk2dSpriteAnimationClip.WrapMode)EditorGUILayout.EnumPopup ("Wrap Mode"' clip.wrapMode); " is 136.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,The length of the statement  "			if (EditorUtility.DisplayDialog ("Wrap mode -> Single"' "This will truncate your clip to a single frame. Do you want to continue?"' "Yes"' "No")) { " is 147.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,The length of the statement  "		if ((animOp.AnimEditOperations & tk2dEditor.SpriteAnimationEditor.AnimEditOperations.ClipContentChanged) != tk2dEditor.SpriteAnimationEditor.AnimEditOperations.None) { " is 167.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,The length of the statement  "		if ((animOp.AnimEditOperations & tk2dEditor.SpriteAnimationEditor.AnimEditOperations.ClipNameChanged) != tk2dEditor.SpriteAnimationEditor.AnimEditOperations.None) { " is 164.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawFrameInspector,The length of the statement  "		if ((animOp.AnimEditOperations & tk2dEditor.SpriteAnimationEditor.AnimEditOperations.ClipContentChanged) != tk2dEditor.SpriteAnimationEditor.AnimEditOperations.None) { " is 167.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawTransportToolbar,The length of the statement  "	tk2dPreferences.inst.gridType = (tk2dGrid.Type)EditorGUILayout.EnumPopup (tk2dPreferences.inst.gridType' EditorStyles.toolbarDropDown' GUILayout.Width (95)); " is 157.
Long Statement,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawInspector,The length of the statement  "	inspectorScrollbar = GUILayout.BeginScrollView (inspectorScrollbar' GUILayout.ExpandHeight (true)' GUILayout.Width (inspectorWidth)); " is 133.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,GetInsertMarkerPositionForFrameGroup,The length of the statement  "	int frame = (frameGroup >= frameGroups.Count) ? (frameGroups [frameGroups.Count - 1].startFrame + frameGroups [frameGroups.Count - 1].frames.Count) : frameGroups [frameGroup].startFrame; " is 186.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,GetRectForFrameGroup,The length of the statement  "	return new Rect (fgRect.x + clipLeftHeaderSpace + frameWidth * frameGroup.startFrame' fgRect.y' frameGroup.frames.Count * frameWidth' fgRect.height); " is 149.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,Draw,The length of the statement  "	clipScrollbar = GUILayout.BeginScrollView (clipScrollbar' GUILayout.Height (clipHeightTotal)' GUILayout.ExpandWidth (true)); " is 124.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,Draw,The length of the statement  "	DrawAxis (clip' new Rect (timelineRect.x + space' timelineRect.y' timelineRect.width - space' timelineRect.height)' frameWidth); " is 128.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,Draw,The length of the statement  "		GUI.Label (new Rect (triggerHelpBox.x' triggerHelpBox.y' 150' triggerHelpBox.height)' "Double click to add triggers"' EditorStyles.whiteMiniLabel); " is 147.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,Draw,The length of the statement  "	DrawFrameGroupsOverlay (frameGroupControlId' new Rect (scrollRect.x + frameGroupRect.x' scrollRect.y + frameGroupRect.y' frameGroupRect.width' frameGroupRect.height)' clip' frameGroups' clipTimeMarker); " is 202.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The length of the statement  "		DrawFrameGroupEx (r' clip' fg' /* highlighted: */currrentFrameGroup == state.selectedFrame' /* showTime: */currrentFrameGroup == state.selectedFrame' /* playHighlight: */clipTimeMarker >= fg.startFrame && clipTimeMarker < fg.startFrame + fg.frames.Count); " is 255.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The length of the statement  "		addFrameButonRect = new Rect (addFrameButonRect.x + addFrameButonRect.width * 0.25f' addFrameButonRect.y + addFrameButonRect.height * 0.25f' addFrameButonRect.height * 0.5f' addFrameButonRect.height * 0.5f); " is 207.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The length of the statement  "	if (GUIUtility.hotControl == controlId && state.type == State.Type.Move && state.activeFrame != -1 && state.insertMarker != -1) { " is 129.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The length of the statement  "	if (ev.type == EventType.KeyDown && GUIUtility.keyboardControl == 0 && state.type == State.Type.None && state.selectedFrame != -1) { " is 132.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The length of the statement  "	if (state.selectedFrame != -1 && (GUIUtility.hotControl == controlId || (GUIUtility.keyboardControl == 0 && state.type == State.Type.None))) { " is 142.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The length of the statement  "		if (ev.type == EventType.KeyDown && (ev.keyCode == KeyCode.Delete || ev.keyCode == KeyCode.Backspace) && frameGroups.Count > 1) { " is 129.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroupsOverlay,The length of the statement  "		DrawFrameGroup (new Rect (Event.current.mousePosition.x - state.frameSelectionOffset.x' frameGroupRect.y - frameGroupRect.height' frameWidth * fg.frames.Count' frameGroupRect.height)' clip' fg); " is 194.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The length of the statement  "	if (state.selectedTrigger != -1 && (GUIUtility.hotControl == controlId || GUIUtility.keyboardControl == 0) && ev.type == EventType.KeyDown) { " is 141.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The length of the statement  "				if (GUIUtility.hotControl == 0 && ev.clickCount == 2 && selectedTriggerRegion >= 0 && selectedTriggerRegion < clip.frames.Length && !clip.frames [selectedTriggerRegion].triggerEvent) { " is 184.
Long Statement,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The length of the statement  "				int selectedTrigger = Mathf.Clamp (GetRoundedSelectedTrigger (triggerRect' ev.mousePosition)' 0' clip.frames.Length - 1); " is 121.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "	GUILayout.BeginVertical (tk2dEditorSkin.SC_BodyBackground' GUILayout.ExpandHeight (true)' GUILayout.ExpandWidth (true)); " is 120.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "		Rect rect = GUILayoutUtility.GetRect (border + font.texture.width' border + font.texture.height' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true)); " is 158.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "	fontEditorScrollBar = GUILayout.BeginScrollView (fontEditorScrollBar' GUILayout.ExpandHeight (true)' GUILayout.Width (host.InspectorWidth)); " is 140.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "				string path = System.IO.Path.GetDirectoryName (bmFontPath).Replace ('\\'' '/') + "/" + System.IO.Path.GetFileName (fontInfo.texturePaths [0]); " is 142.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "	Texture2D newTexture = EditorGUILayout.ObjectField ("Font Texture"' font.texture' typeof(Texture2D)' false) as Texture2D; " is 121.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "				if (tk2dGuiUtility.InfoBoxWithButtons ("The texture importer needs to be reconfigured to be used as a font texture source. " + "Please note that this will globally change this texture importer. "' tk2dGuiUtility.WarningLevel.Info' "Set up") != -1) { " is 249.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "		font.materialId = EditorGUILayout.IntPopup ("Material"' font.materialId' altMaterialNames.ToArray ()' altMaterialIndices.ToArray ()); " is 133.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "		if (tk2dGuiUtility.InfoBoxWithButtons ("A data object is required to build a font. " + "Please create one or drag an existing data object into the inspector slot.\n"' tk2dGuiUtility.WarningLevel.Info' "Create") != -1) { " is 219.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "			Texture2D tex = EditorGUILayout.ObjectField ("Gradient Tex"' font.gradientTexture' typeof(Texture2D)' false) as Texture2D; " is 122.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "	tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal); " is 177.
Long Statement,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The length of the statement  "	if (doDelete && EditorUtility.DisplayDialog ("Delete sprite"' "Are you sure you want to delete the selected font?"' "Yes"' "No")) { " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawMaterialEditor,The length of the statement  "				Material newMaterial = EditorGUILayout.ObjectField (SpriteCollection.altMaterials [i]' typeof(Material)' false) as Material; " is 124.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawMaterialEditor,The length of the statement  "							if (EditorUtility.DisplayDialog ("Delete material"' "This material is in use. Deleting it will reset materials on " + "sprites that use this material.\n" + "Do you wish to proceed?"' "Yes"' "Cancel")) { " is 202.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawSystemSettings,The length of the statement  "			EditorUtility.DisplayDialog ("Please commit the sprite collection before attempting to make it loadable."' "Make loadable."' "Ok"); " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawSystemSettings,The length of the statement  "		if (EditorUtility.DisplayDialog ("Clear references"' "Clearing references will clear references to data (atlases' materials) owned by this sprite collection. " + "This will only remove references' and will not delete the data or textures. " + "Use after duplicating a sprite collection to sever links with the original.\n\n" + "Are you sure you want to do this?"' "Yes"' "No")) { " is 379.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawPlatforms,The length of the statement  "			bool displayDelete = ((SpriteCollection.platforms.Count == 1 && SpriteCollection.platforms [0].name.Length > 0) || (SpriteCollection.platforms.Count > 1 && i > 0)); " is 164.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawPlatforms,The length of the statement  "				if (SpriteCollection.platforms [0].spriteCollection != null && SpriteCollection.platforms [0].spriteCollection.spriteCollection != null) " is 136.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawPlatforms,The length of the statement  "				if (SpriteCollection.platforms [toDelete].spriteCollection != null && SpriteCollection.platforms [toDelete].spriteCollection.spriteCollection != null) " is 150.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawPlatforms,The length of the statement  "		if (SpriteCollection.platforms.Count > 1 || (SpriteCollection.platforms.Count == 1 && SpriteCollection.platforms [0].name.Length > 0)) { " is 136.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The length of the statement  "	SpriteCollection.textureCompression = (tk2dSpriteCollection.TextureCompression)EditorGUILayout.EnumPopup ("Compression"' SpriteCollection.textureCompression); " is 158.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The length of the statement  "	SpriteCollection.userDefinedTextureSettings = EditorGUILayout.Toggle ("User Defined"' SpriteCollection.userDefinedTextureSettings); " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawSpriteCollectionSettings,The length of the statement  "	SpriteCollection.padAmount = EditorGUILayout.IntPopup ("Pad Amount"' SpriteCollection.padAmount' padAmountLabels' padAmountValues); " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawSpriteCollectionSettings,The length of the statement  "		tk2dGuiUtility.InfoBox ("Filter mode is not set to Point." + " Some bleeding will occur at sprite edges."' tk2dGuiUtility.WarningLevel.Info); " is 141.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawSpriteCollectionSettings,The length of the statement  "	SpriteCollection.premultipliedAlpha = EditorGUILayout.Toggle ("Premultiplied Alpha"' SpriteCollection.premultipliedAlpha); " is 122.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawSpriteCollectionSettings,The length of the statement  "	SpriteCollection.normalGenerationMode = (tk2dSpriteCollection.NormalGenerationMode)EditorGUILayout.EnumPopup ("Normal Generation"' SpriteCollection.normalGenerationMode); " is 170.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawAtlasSettings,The length of the statement  "		SpriteCollection.forcedTextureWidth = EditorGUILayout.IntPopup ("Width"' SpriteCollection.forcedTextureWidth' allowedAtlasSizesString' allowedAtlasSizes); " is 154.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawAtlasSettings,The length of the statement  "		SpriteCollection.forcedTextureHeight = EditorGUILayout.IntPopup ("Height"' SpriteCollection.forcedTextureHeight' allowedAtlasSizesString' allowedAtlasSizes); " is 157.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawAtlasSettings,The length of the statement  "		SpriteCollection.maxTextureSize = EditorGUILayout.IntPopup ("Max Size"' SpriteCollection.maxTextureSize' allowedAtlasSizesString' allowedAtlasSizes); " is 149.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawAtlasSettings,The length of the statement  "				EditorUtility.DisplayDialog ("Multiple atlases"' "Multiple atlases not allowed. This sprite collection contains fonts and/or " + "contains diced sprites."' "Ok"); " is 162.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawAtlasSettings,The length of the statement  "		tk2dGuiUtility.InfoBox ("Sprite collections with multiple atlas spanning enabled cannot be used with the Static Sprite" + " Batcher' Fonts' the TileMap Editor and doesn't support Sprite Dicing and material level optimizations.\n\n" + "Avoid using it unless you are simply importing a" + " large sequence of sprites for an animation."' tk2dGuiUtility.WarningLevel.Info); " is 369.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawAtlasSettings,The length of the statement  "	GUIContent remDuplicates = new GUIContent ("Remove Duplicates"' "Remove duplicate textures after trimming and other processing."); " is 130.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,Draw,The length of the statement  "	GUILayout.BeginVertical (tk2dEditorSkin.SC_BodyBackground' GUILayout.ExpandHeight (true)' GUILayout.ExpandWidth (true)); " is 120.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,Draw,The length of the statement  "	settingsScrollbar = GUILayout.BeginScrollView (settingsScrollbar' GUILayout.ExpandHeight (true)' GUILayout.Width (inspectorWidth)); " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,Draw,The length of the statement  "	SpriteCollection.spriteCollection = EditorGUILayout.ObjectField ("Data object"' SpriteCollection.spriteCollection' typeof(tk2dSpriteCollectionData)' false) as tk2dSpriteCollectionData; " is 184.
Long Statement,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,Draw,The length of the statement  "	tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal); " is 177.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,GetNumTilesForSpriteSheet,The length of the statement  "	numTilesX = (tex.width - spriteSheet.tileMarginX + spriteSheet.tileSpacingX) / (spriteSheet.tileSpacingX + spriteSheet.tileWidth); " is 130.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,GetNumTilesForSpriteSheet,The length of the statement  "	numTilesY = (tex.height - spriteSheet.tileMarginY + spriteSheet.tileSpacingY) / (spriteSheet.tileSpacingY + spriteSheet.tileHeight); " is 132.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,DrawGridOverlay,The length of the statement  "			Handles.DrawLine (new Vector3 (rect.x' rect.y + y * zoomAmount' 0)' new Vector3 (rect.x + tex.width * zoomAmount' rect.y + y * zoomAmount' 0)); " is 143.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,DrawGridOverlay,The length of the statement  "			Handles.DrawLine (new Vector3 (rect.x' rect.y + (y + spriteSheet.tileHeight) * zoomAmount' 0)' new Vector3 (rect.x + tex.width * zoomAmount' rect.y + (y + spriteSheet.tileHeight) * zoomAmount' 0)); " is 197.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,DrawGridOverlay,The length of the statement  "			Handles.DrawLine (new Vector3 (rect.x + x * zoomAmount' rect.y' 0)' new Vector3 (rect.x + x * zoomAmount' rect.y + tex.height * zoomAmount' 0)); " is 144.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,DrawGridOverlay,The length of the statement  "			Handles.DrawLine (new Vector3 (rect.x + (x + spriteSheet.tileWidth) * zoomAmount' rect.y' 0)' new Vector3 (rect.x + (x + spriteSheet.tileWidth) * zoomAmount' rect.y + tex.height * zoomAmount' 0)); " is 196.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,ProcessSpriteSelectionUI,The length of the statement  "			bool multiSelectKey = (Application.platform == RuntimePlatform.OSXEditor) ? Event.current.command : Event.current.control; " is 122.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,DrawTextureView,The length of the statement  "	Rect baseRect = GUILayoutUtility.GetRect (border * 2 + width' border * 2 + height' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true)); " is 144.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The length of the statement  "	GUILayout.BeginVertical (tk2dEditorSkin.SC_BodyBackground' GUILayout.ExpandHeight (true)' GUILayout.ExpandWidth (true)); " is 120.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The length of the statement  "	inspectorScrollBar = GUILayout.BeginScrollView (inspectorScrollBar' GUILayout.ExpandHeight (true)' GUILayout.Width (host.InspectorWidth)); " is 138.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The length of the statement  "	Texture2D newTexture = EditorGUILayout.ObjectField ("Texture"' spriteSheet.texture' typeof(Texture2D)' false) as Texture2D; " is 123.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The length of the statement  "				if (tk2dGuiUtility.InfoBoxWithButtons ("The texture importer needs to be reconfigured to be used as a sprite sheet source. " + "Please note that this will globally change this texture importer."' tk2dGuiUtility.WarningLevel.Info' "Set up") != -1) { " is 248.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The length of the statement  "				tk2dGuiUtility.InfoBox ("The sprite sheet is configured to use default padding mode. " + "It is advised to select an explicit padding mode depending on the usage of the " + "sprites within the sprite sheet.\n\n" + "BlackZeroAlpha - Recommended for animations\n" + "Extend - Recommended for tilemaps"' tk2dGuiUtility.WarningLevel.Warning); " is 338.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The length of the statement  "			if (spriteSheet.texture != null && spriteSheet.tileWidth > 0 && spriteSheet.tileWidth <= spriteSheet.texture.width && spriteSheet.tileHeight > 0 && spriteSheet.tileHeight <= spriteSheet.texture.height && GUILayout.Button ("Apply"' EditorStyles.miniButton)) { " is 258.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The length of the statement  "	tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal); " is 177.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The length of the statement  "		string message = "Deleting a sprite sheet will delete all sprites sourced from this sprite sheet. " + "Are you sure you want to do this?"; " is 138.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	var spriteTexture = param.extractRegion ? host.GetTextureForSprite (entry.index) : SpriteCollection.textureParams [entry.index].texture; " is 136.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	EditorGUILayout.BeginVertical (tk2dEditorSkin.SC_InspectorHeaderBG' GUILayout.MaxWidth (host.InspectorWidth)' GUILayout.ExpandHeight (true)); " is 141.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		EditorGUILayout.SelectableLabel (entry.index.ToString ()' EditorStyles.textField' GUILayout.ExpandWidth (true)' GUILayout.Height (16)); " is 135.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "			SpriteCollection.textureParams [entry.index].texture = EditorGUILayout.ObjectField ("Texture"' spriteTexture' typeof(Texture2D)' false) as Texture2D; " is 149.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		if (!editingSpriteSheet && param.hasSpriteSheetId && GUILayout.Button ("Source"' EditorStyles.miniButton' GUILayout.Width (miniButtonWidth))) " is 141.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal); " is 177.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	EditorGUILayout.BeginVertical (tk2dEditorSkin.SC_InspectorBG' GUILayout.MaxWidth (host.InspectorWidth)' GUILayout.ExpandHeight (true)); " is 135.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		param.materialId = EditorGUILayout.IntPopup ("Material"' param.materialId' altMaterialNames.ToArray ()' altMaterialIndices.ToArray ()); " is 135.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		HandleMultiSelection (entries' (a' b) => (a.anchor == b.anchor && a.anchorX == b.anchorX && a.anchorY == b.anchorY)' delegate (tk2dSpriteCollectionDefinition a' tk2dSpriteCollectionDefinition b) { " is 196.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	var newColliderType = (tk2dSpriteCollectionDefinition.ColliderType)EditorGUILayout.EnumPopup ("Collider Type"' param.colliderType); " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		if (newColliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom || newColliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon) " is 151.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		HandleMultiSelection (entries' (a' b) => (a.colliderType == b.colliderType && a.boxColliderMin == b.boxColliderMin && a.boxColliderMax == b.boxColliderMax)' delegate (tk2dSpriteCollectionDefinition a' tk2dSpriteCollectionDefinition b) { " is 236.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		param.polyColliderCap = (tk2dSpriteCollectionDefinition.PolygonColliderCap)EditorGUILayout.EnumPopup ("Collider Cap"' param.polyColliderCap); " is 141.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		param.colliderSmoothSphereCollisions = EditorGUILayout.Toggle (new GUIContent ("SmoothSphereCollisions"' "Smooth Sphere Collisions")' param.colliderSmoothSphereCollisions); " is 172.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		HandleMultiSelection (entries' (a' b) => (a.colliderType == b.colliderType && a.polyColliderCap == b.polyColliderCap && a.colliderConvex == b.colliderConvex && a.colliderSmoothSphereCollisions == b.colliderSmoothSphereCollisions && ComparePolyCollider (a.polyColliderIslands' b.polyColliderIslands))' delegate (tk2dSpriteCollectionDefinition a' tk2dSpriteCollectionDefinition b) { " is 380.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		EditorUtility.DisplayDialog ("Sprite dicing"' "Sprite dicing is unavailable when multiple atlases is enabled. " + "Please disable it and try again."' "Ok"); " is 156.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		GUIContent diceFilter = new GUIContent ("Dice Filter"' "Dice Filter lets you dice and only store a subset of the dices. This lets you perform more optimizations' drawing solid dices with a solid shader.\n\n" + "Complete - Draw all dices (Default).\nSolidOnly - Only draw the solid dices.\nTransparent Only - Only draw transparent dices."); " is 339.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	HandleMultiSelection (entries' (a' b) => a.customSpriteGeometry == b.customSpriteGeometry && a.dice == b.dice && a.diceUnitX == b.diceUnitX && a.diceUnitY == b.diceUnitY && a.diceFilter == b.diceFilter' delegate (tk2dSpriteCollectionDefinition a' tk2dSpriteCollectionDefinition b) { " is 282.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "		HandleMultiSelection (entries' (a' b) => a.disableTrimming == b.disableTrimming' (a' b) => b.disableTrimming = a.disableTrimming); " is 130.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	param.extraPadding = EditorGUILayout.IntPopup ("Extra Padding"' param.extraPadding' extraPadAmountLabels' extraPadAmountValues); " is 128.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal); " is 177.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The length of the statement  "	if (doDelete && EditorUtility.DisplayDialog ("Delete sprite"' "Are you sure you want to delete the selected sprites?"' "Yes"' "No")) { " is 134.
Long Statement,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorView,The length of the statement  "	var spriteTexture = param.extractRegion ? host.GetTextureForSprite (entry.index) : SpriteCollection.textureParams [entry.index].texture; " is 136.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The length of the statement  "	if (r.Contains (Event.current.mousePosition) && Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.C) { " is 128.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The length of the statement  "			cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale; " is 132.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The length of the statement  "		if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) { " is 128.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The length of the statement  "		new Vector3 (param.boxColliderMin.x * editorDisplayScale + origin.x' param.boxColliderMin.y * editorDisplayScale + origin.y' 0.0f)' " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The length of the statement  "		new Vector3 (param.boxColliderMax.x * editorDisplayScale + origin.x' param.boxColliderMin.y * editorDisplayScale + origin.y' 0.0f)' " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The length of the statement  "		new Vector3 (param.boxColliderMax.x * editorDisplayScale + origin.x' param.boxColliderMax.y * editorDisplayScale + origin.y' 0.0f)' " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The length of the statement  "		new Vector3 (param.boxColliderMin.x * editorDisplayScale + origin.x' param.boxColliderMax.y * editorDisplayScale + origin.y' 0.0f)' " is 131.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The length of the statement  "	GUILayout.BeginVertical (tk2dEditorSkin.SC_BodyBackground' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true)); " is 120.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The length of the statement  "		bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom); " is 176.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The length of the statement  "		textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale)); " is 210.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The length of the statement  "		Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale); " is 144.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The length of the statement  "			Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0)); " is 180.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The length of the statement  "			Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0)); " is 184.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The length of the statement  "					if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) { " is 196.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The length of the statement  "						tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale)); " is 158.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawToolbar,The length of the statement  "	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom); " is 176.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawToolbar,The length of the statement  "	mode = GUILayout.Toggle ((mode == Mode.Texture)' new GUIContent ("Sprite"' "Shift+Q")' EditorStyles.toolbarButton) ? Mode.Texture : mode; " is 137.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawToolbar,The length of the statement  "		mode = GUILayout.Toggle ((mode == Mode.Anchor)' new GUIContent ("Anchor"' "Shift+W")' EditorStyles.toolbarButton) ? Mode.Anchor : mode; " is 135.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawToolbar,The length of the statement  "		mode = GUILayout.Toggle ((mode == Mode.Collider)' new GUIContent ("Collider"' "Shift+E")' EditorStyles.toolbarButton) ? Mode.Collider : mode; " is 141.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawToolbar,The length of the statement  "		mode = GUILayout.Toggle ((mode == Mode.AttachPoint)' new GUIContent ("AttachPoint"' "Shift+R")' EditorStyles.toolbarButton) ? Mode.AttachPoint : mode; " is 150.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawToolbar,The length of the statement  "	if ((mode == Mode.Collider && param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon) || (mode == Mode.Texture && param.customSpriteGeometry)) { " is 163.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawToolbar,The length of the statement  "		drawColliderNormals = GUILayout.Toggle (drawColliderNormals' new GUIContent ("Show Normals"' "Shift+N")' EditorStyles.toolbarButton); " is 133.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawAttachPointInspector,The length of the statement  "			tk2dSpriteGuiUtility.SpriteSelector (spriteProxy.spriteCollection' spriteProxy.spriteId' AttachPointSpriteHandler' tmpName); " is 124.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureInspector,The length of the statement  "		param.colliderColor = (tk2dSpriteCollectionDefinition.ColliderColor)EditorGUILayout.EnumPopup ("Display Color"' param.colliderColor); " is 133.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureInspector,The length of the statement  "		tk2dGuiUtility.InfoBox ("Points" + "\nClick drag - move point" + "\nClick hold + delete/bkspace - delete point" + "\nDouble click on line - add point"' tk2dGuiUtility.WarningLevel.Info); " is 186.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureInspector,The length of the statement  "		tk2dGuiUtility.InfoBox ("Islands" + "\nClick hold point + X - delete island" + "\nPress C - create island at cursor" + "\nClick hold point + T - toggle connected" + "\nClick hold point + F - flip island"' tk2dGuiUtility.WarningLevel.Info); " is 239.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureInspector,The length of the statement  "		param.colliderColor = (tk2dSpriteCollectionDefinition.ColliderColor)EditorGUILayout.EnumPopup ("Display Color"' param.colliderColor); " is 133.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureInspector,The length of the statement  "		tk2dGuiUtility.InfoBox ("Points" + "\nClick drag - move point" + "\nClick hold + delete/bkspace - delete point" + "\nDouble click on line - add point"' tk2dGuiUtility.WarningLevel.Info); " is 186.
Long Statement,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureInspector,The length of the statement  "		tk2dGuiUtility.InfoBox ("Islands" + "\nClick hold point + X - delete island" + "\nPress C - create island at cursor" + "\nClick hold point + F - flip island"' tk2dGuiUtility.WarningLevel.Info); " is 193.
Long Statement,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The length of the statement  "			Color newPixel = new Color ((((int)(oldPixel.r * 255.0f + 0.5f) >> quantShiftR) << quantShiftR) / 255.0f' (((int)(oldPixel.g * 255.0f + 0.5f) >> quantShiftG) << quantShiftG) / 255.0f' (((int)(oldPixel.b * 255.0f + 0.5f) >> quantShiftB) << quantShiftB) / 255.0f' (((int)(oldPixel.a * 255.0f + 0.5f) >> quantShiftA) << quantShiftA) / 255.0f); " is 340.
Long Statement,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The length of the statement  "			Color targetColor = new Color ((oldPixel.r == 1.0f) ? 1.0f : newPixel.r' (oldPixel.g == 1.0f) ? 1.0f : newPixel.g' (oldPixel.b == 1.0f) ? 1.0f : newPixel.b' (oldPixel.a == 1.0f) ? 1.0f : newPixel.a); " is 199.
Long Statement,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,CheckAndFixUpParams,The length of the statement  "	if (gen.DoNotUse__TextureRefs != null && gen.textureParams != null && gen.DoNotUse__TextureRefs.Length != gen.textureParams.Length) { " is 133.
Long Statement,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,CheckAndFixUpParams,The length of the statement  "			System.Array.Sort (newTexRefs' (Texture2D a' Texture2D b) => tk2dSpriteGuiUtility.NameCompare (a ? a.name : ""' b ? b.name : "")); " is 130.
Long Statement,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,CheckAndFixUpParams,The length of the statement  "			EditorUtility.DisplayDialog ("Error"' "Multiple atlas spanning is not allowed when there are textures with dicing enabled in the SpriteCollection."' "Ok"); " is 155.
Long Statement,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,SetUpSpriteSheets,The length of the statement  "		if (spriteSheet.tilesX * spriteSheet.tilesY == 0 || (spriteSheet.numTiles != 0 && spriteSheet.numTiles > spriteSheet.tilesX * spriteSheet.tilesY)) { " is 148.
Long Statement,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,SetUpSpriteSheets,The length of the statement  "			EditorUtility.DisplayDialog ("Invalid sprite sheet"' "Sprite sheet '" + spriteSheet.texture.name + "' has an invalid number of tiles"' "Ok"); " is 141.
Long Statement,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,SetUpSpriteSheets,The length of the statement  "			EditorUtility.DisplayDialog ("Invalid sprite sheet"' "Sprite sheet '" + spriteSheet.texture.name + "' doesn't match tile count"' "Ok"); " is 135.
Long Statement,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,SetUpSpriteSheets,The length of the statement  "		int numTiles = (spriteSheet.numTiles == 0) ? (spriteSheet.tilesX * spriteSheet.tilesY) : Mathf.Min (spriteSheet.numTiles' spriteSheet.tilesX * spriteSheet.tilesY); " is 163.
Long Statement,tk2dEditor.SpriteCollectionBuilder,Deprecated,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionBuilderDeprecated.cs,SetUpSpriteSheets,The length of the statement  "					if (gen.textureParams [i].fromSpriteSheet && gen.textureParams [i].regionId == tileIdx && gen.DoNotUse__TextureRefs [i] == spriteSheet.texture) { " is 145.
Long Statement,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,UpdatePlatformSpriteCollection,The length of the statement  "	tk2dEditor.SpriteCollectionEditor.SpriteCollectionProxy proxy = new tk2dEditor.SpriteCollectionEditor.SpriteCollectionProxy (source); " is 133.
Long Statement,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,UpdatePlatformSpriteCollection,The length of the statement  "					texturePath = System.IO.Path.GetDirectoryName (bmFontPath).Replace ('\\'' '/') + "/" + System.IO.Path.GetFileName (fontInfo.texturePaths [0]); " is 142.
Long Statement,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,UpdatePlatformSpriteCollection,The length of the statement  "		if (font.editorData.bmFont != font.bmFont || font.editorData.texture != font.texture || font.editorData.data != font.data) { " is 124.
Long Statement,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,LogNotFoundError,The length of the statement  "	Debug.LogError (string.Format ("Unable to find platform specific {0} '{1}' for platform '{2}'"' assetType' assetName' platformName)); " is 133.
Long Statement,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,PopulateTilemap,The length of the statement  "	tk2dEditor.TileMap.TileMapUtility.ResizeTileMap (tileMap' width' height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 121.
Long Statement,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,CheckZlib,The length of the statement  "		if (EditorUtility.DisplayDialog ("Unable to load required module zlib.net"' "You can get zlib.net by clicking \"Download\" button.\n\n" + "You can also manually get it from http://www.componentace.com/zlib_.NET.htm' and copy the zip file into your Assets folder"' "Download"' "Cancel")) { " is 288.
Complex Conditional,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The conditional expression  "firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize"  is complex.
Complex Conditional,tk2dEditor.Atlas,DisjointRectCollection,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasRect.cs,IsDisjoint,The conditional expression  "(a.x + a.width <= b.x) || (b.x + b.width <= a.x) || (a.y + a.height <= b.y) || (b.y + b.height <= a.y)"  is complex.
Complex Conditional,tk2dEditor.Atlas,MaxRectsBinPack,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dMaxRectsBinPack.cs,SplitFreeNode,The conditional expression  "usedNode.x >= freeNode.x + freeNode.width || usedNode.x + usedNode.width <= freeNode.x || usedNode.y >= freeNode.y + freeNode.height || usedNode.y + usedNode.height <= freeNode.y"  is complex.
Complex Conditional,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The conditional expression  "GUIUtility.hotControl == controlId && state.type == State.Type.Move && state.activeFrame != -1 && state.insertMarker != -1"  is complex.
Complex Conditional,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The conditional expression  "ev.type == EventType.KeyDown && GUIUtility.keyboardControl == 0 && state.type == State.Type.None && state.selectedFrame != -1"  is complex.
Complex Conditional,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The conditional expression  "state.selectedFrame != -1 && (GUIUtility.hotControl == controlId || (GUIUtility.keyboardControl == 0 && state.type == State.Type.None))"  is complex.
Complex Conditional,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The conditional expression  "ev.type == EventType.KeyDown && (ev.keyCode == KeyCode.Delete || ev.keyCode == KeyCode.Backspace) && frameGroups.Count > 1"  is complex.
Complex Conditional,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The conditional expression  "state.selectedTrigger != -1 && (GUIUtility.hotControl == controlId || GUIUtility.keyboardControl == 0) && ev.type == EventType.KeyDown"  is complex.
Complex Conditional,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The conditional expression  "GUIUtility.hotControl == 0 && ev.clickCount == 2 && selectedTriggerRegion >= 0 && selectedTriggerRegion < clip.frames.Length && !clip.frames [selectedTriggerRegion].triggerEvent"  is complex.
Complex Conditional,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,FindSpriteSlotForSpriteSheetCell,The conditional expression  "v.hasSpriteSheetId && v.spriteSheetId == spriteSheetId && v.spriteSheetX == x && v.spriteSheetY == y"  is complex.
Complex Conditional,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,ProcessSpriteSelectionUI,The conditional expression  "tileX >= 0 && tileX < numTilesX && tileY >= 0 && tileY < numTilesY"  is complex.
Complex Conditional,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The conditional expression  "spriteSheet.texture != null && spriteSheet.tileWidth > 0 && spriteSheet.tileWidth <= spriteSheet.texture.width && spriteSheet.tileHeight > 0 && spriteSheet.tileHeight <= spriteSheet.texture.height && GUILayout.Button ("Apply"' EditorStyles.miniButton)"  is complex.
Complex Conditional,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The conditional expression  "deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))"  is complex.
Complex Conditional,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawToolbar,The conditional expression  "(mode == Mode.Collider && param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon) || (mode == Mode.Texture && param.customSpriteGeometry)"  is complex.
Complex Conditional,tk2dEditor.SpriteCollectionBuilder,PlatformBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\tk2dSpriteCollectionPlatformBuilder.cs,UpdatePlatformSpriteCollection,The conditional expression  "!font.InUse || font.texture == null || font.data == null || font.editorData == null || font.bmFont == null"  is complex.
Empty Catch Block,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,Importer,The method has an empty catch block.
Magic Number,tk2dEditor,tk2dCameraSceneGUI,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Camera\tk2dCameraEditor.cs,PreviewWindowFunc,The following statement contains a magic number: switch (Event.current.type) {  case EventType.Repaint: {  	int heightTweak = 19;  	Rect r = new Rect (previewWindowRect.x + rs.x' Camera.current.pixelHeight - (previewWindowRect.y + rs.y)' rs.width' rs.height);  	Vector2 v = new Vector2 (previewWindowRect.x + rs.x' (Camera.current.pixelHeight - previewWindowRect.y - rs.height - heightTweak) + rs.y);  	previewCamera.CopyFrom (target.camera);  	previewCamera.projectionMatrix = target.Editor__GetFinalProjectionMatrix ();  	// Work around a Unity bug  	previewCamera.pixelRect = new Rect (v.x' v.y' r.width' r.height);  	previewCamera.Render ();  	break;  }  }  
Magic Number,tk2dEditor,tk2dCameraSceneGUI,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Camera\tk2dCameraEditor.cs,OnSceneGUI,The following statement contains a magic number: if (width > 200)  	windowCaption += string.Format (" ({0:0} x {1:0})"' resolution.x' resolution.y);  
Magic Number,tk2dEditor,Triangulator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Triangulator\tk2dTriangulator.cs,Triangulate,The following statement contains a magic number: if (n < 3)  	return indices.ToArray ();  
Magic Number,tk2dEditor,Triangulator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Triangulator\tk2dTriangulator.cs,Triangulate,The following statement contains a magic number: for (int m = 0' v = nv - 1; nv > 2;) {  	if ((count--) <= 0)  		return indices.ToArray ();  	int u = v;  	if (nv <= u)  		u = 0;  	v = u + 1;  	if (nv <= v)  		v = 0;  	int w = v + 1;  	if (nv <= w)  		w = 0;  	if (Snip (u' v' w' nv' V)) {  		int a' b' c' s' t;  		a = V [u];  		b = V [v];  		c = V [w];  		indices.Add (a);  		indices.Add (b);  		indices.Add (c);  		m++;  		for (s = v' t = v + 1; t < nv; s++' t++)  			V [s] = V [t];  		nv--;  		count = 2 * nv;  	}  }  
Magic Number,tk2dEditor,Triangulator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Triangulator\tk2dTriangulator.cs,Triangulate,The following statement contains a magic number: for (int m = 0' v = nv - 1; nv > 2;) {  	if ((count--) <= 0)  		return indices.ToArray ();  	int u = v;  	if (nv <= u)  		u = 0;  	v = u + 1;  	if (nv <= v)  		v = 0;  	int w = v + 1;  	if (nv <= w)  		w = 0;  	if (Snip (u' v' w' nv' V)) {  		int a' b' c' s' t;  		a = V [u];  		b = V [v];  		c = V [w];  		indices.Add (a);  		indices.Add (b);  		indices.Add (c);  		m++;  		for (s = v' t = v + 1; t < nv; s++' t++)  			V [s] = V [t];  		nv--;  		count = 2 * nv;  	}  }  
Magic Number,tk2dEditor,Triangulator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Triangulator\tk2dTriangulator.cs,Triangulate,The following statement contains a magic number: if (Snip (u' v' w' nv' V)) {  	int a' b' c' s' t;  	a = V [u];  	b = V [v];  	c = V [w];  	indices.Add (a);  	indices.Add (b);  	indices.Add (c);  	m++;  	for (s = v' t = v + 1; t < nv; s++' t++)  		V [s] = V [t];  	nv--;  	count = 2 * nv;  }  
Magic Number,tk2dEditor,Triangulator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Triangulator\tk2dTriangulator.cs,Triangulate,The following statement contains a magic number: count = 2 * nv;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (multiSelect) {  	List<int> filteredTileSelection = new List<int> ();  	foreach (var v in tileSelection) {  		if (IsValidSprite (spriteCollection' v))  			filteredTileSelection.Add (v);  	}  	brush.type = tk2dTileMapEditorBrush.Type.MultiSelect;  	brush.multiSelectTiles = filteredTileSelection.ToArray ();  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.tiles = new tk2dSparseTile[0];  }  else {  	int tx0 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x0 : tileSelection_x1;  	int tx1 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x1 : tileSelection_x0;  	int ty0 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y0 : tileSelection_y1;  	int ty1 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y1 : tileSelection_y0;  	int numTilesX = tx1 - tx0 + 1;  	int numTilesY = ty1 - ty0 + 1;  	int numValidTiles = 0;  	tileSelection.Clear ();  	List<tk2dSparseTile> tiles = new List<tk2dSparseTile> ();  	for (int y = 0; y < numTilesY; ++y) {  		for (int x = 0; x < numTilesX; ++x) {  			ushort spriteId = (ushort)((y + ty0) * tilesPerRow + (x + tx0));  			if (IsValidSprite (spriteCollection' spriteId)) {  				tiles.Add (new tk2dSparseTile (x' numTilesY - 1 - y' 0' spriteId));  				if (tileSelection.IndexOf (spriteId) == -1)  					tileSelection.Add (spriteId);  				numValidTiles++;  			}  		}  	}  	if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  	else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  	else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  	else  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.type = (rectSelect) ? tk2dTileMapEditorBrush.Type.Rectangle : tk2dTileMapEditorBrush.Type.Single;  	brush.multiSelectTiles = tileSelection.ToArray ();  	brush.tiles = tiles.ToArray ();  }  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (multiSelect) {  	List<int> filteredTileSelection = new List<int> ();  	foreach (var v in tileSelection) {  		if (IsValidSprite (spriteCollection' v))  			filteredTileSelection.Add (v);  	}  	brush.type = tk2dTileMapEditorBrush.Type.MultiSelect;  	brush.multiSelectTiles = filteredTileSelection.ToArray ();  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.tiles = new tk2dSparseTile[0];  }  else {  	int tx0 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x0 : tileSelection_x1;  	int tx1 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x1 : tileSelection_x0;  	int ty0 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y0 : tileSelection_y1;  	int ty1 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y1 : tileSelection_y0;  	int numTilesX = tx1 - tx0 + 1;  	int numTilesY = ty1 - ty0 + 1;  	int numValidTiles = 0;  	tileSelection.Clear ();  	List<tk2dSparseTile> tiles = new List<tk2dSparseTile> ();  	for (int y = 0; y < numTilesY; ++y) {  		for (int x = 0; x < numTilesX; ++x) {  			ushort spriteId = (ushort)((y + ty0) * tilesPerRow + (x + tx0));  			if (IsValidSprite (spriteCollection' spriteId)) {  				tiles.Add (new tk2dSparseTile (x' numTilesY - 1 - y' 0' spriteId));  				if (tileSelection.IndexOf (spriteId) == -1)  					tileSelection.Add (spriteId);  				numValidTiles++;  			}  		}  	}  	if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  	else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  	else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  	else  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.type = (rectSelect) ? tk2dTileMapEditorBrush.Type.Rectangle : tk2dTileMapEditorBrush.Type.Single;  	brush.multiSelectTiles = tileSelection.ToArray ();  	brush.tiles = tiles.ToArray ();  }  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (multiSelect) {  	List<int> filteredTileSelection = new List<int> ();  	foreach (var v in tileSelection) {  		if (IsValidSprite (spriteCollection' v))  			filteredTileSelection.Add (v);  	}  	brush.type = tk2dTileMapEditorBrush.Type.MultiSelect;  	brush.multiSelectTiles = filteredTileSelection.ToArray ();  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.tiles = new tk2dSparseTile[0];  }  else {  	int tx0 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x0 : tileSelection_x1;  	int tx1 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x1 : tileSelection_x0;  	int ty0 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y0 : tileSelection_y1;  	int ty1 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y1 : tileSelection_y0;  	int numTilesX = tx1 - tx0 + 1;  	int numTilesY = ty1 - ty0 + 1;  	int numValidTiles = 0;  	tileSelection.Clear ();  	List<tk2dSparseTile> tiles = new List<tk2dSparseTile> ();  	for (int y = 0; y < numTilesY; ++y) {  		for (int x = 0; x < numTilesX; ++x) {  			ushort spriteId = (ushort)((y + ty0) * tilesPerRow + (x + tx0));  			if (IsValidSprite (spriteCollection' spriteId)) {  				tiles.Add (new tk2dSparseTile (x' numTilesY - 1 - y' 0' spriteId));  				if (tileSelection.IndexOf (spriteId) == -1)  					tileSelection.Add (spriteId);  				numValidTiles++;  			}  		}  	}  	if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  	else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  	else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  	else  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.type = (rectSelect) ? tk2dTileMapEditorBrush.Type.Rectangle : tk2dTileMapEditorBrush.Type.Single;  	brush.multiSelectTiles = tileSelection.ToArray ();  	brush.tiles = tiles.ToArray ();  }  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (multiSelect) {  	List<int> filteredTileSelection = new List<int> ();  	foreach (var v in tileSelection) {  		if (IsValidSprite (spriteCollection' v))  			filteredTileSelection.Add (v);  	}  	brush.type = tk2dTileMapEditorBrush.Type.MultiSelect;  	brush.multiSelectTiles = filteredTileSelection.ToArray ();  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.tiles = new tk2dSparseTile[0];  }  else {  	int tx0 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x0 : tileSelection_x1;  	int tx1 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x1 : tileSelection_x0;  	int ty0 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y0 : tileSelection_y1;  	int ty1 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y1 : tileSelection_y0;  	int numTilesX = tx1 - tx0 + 1;  	int numTilesY = ty1 - ty0 + 1;  	int numValidTiles = 0;  	tileSelection.Clear ();  	List<tk2dSparseTile> tiles = new List<tk2dSparseTile> ();  	for (int y = 0; y < numTilesY; ++y) {  		for (int x = 0; x < numTilesX; ++x) {  			ushort spriteId = (ushort)((y + ty0) * tilesPerRow + (x + tx0));  			if (IsValidSprite (spriteCollection' spriteId)) {  				tiles.Add (new tk2dSparseTile (x' numTilesY - 1 - y' 0' spriteId));  				if (tileSelection.IndexOf (spriteId) == -1)  					tileSelection.Add (spriteId);  				numValidTiles++;  			}  		}  	}  	if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  	else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  	else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  	else  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.type = (rectSelect) ? tk2dTileMapEditorBrush.Type.Rectangle : tk2dTileMapEditorBrush.Type.Single;  	brush.multiSelectTiles = tileSelection.ToArray ();  	brush.tiles = tiles.ToArray ();  }  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (multiSelect) {  	List<int> filteredTileSelection = new List<int> ();  	foreach (var v in tileSelection) {  		if (IsValidSprite (spriteCollection' v))  			filteredTileSelection.Add (v);  	}  	brush.type = tk2dTileMapEditorBrush.Type.MultiSelect;  	brush.multiSelectTiles = filteredTileSelection.ToArray ();  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.tiles = new tk2dSparseTile[0];  }  else {  	int tx0 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x0 : tileSelection_x1;  	int tx1 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x1 : tileSelection_x0;  	int ty0 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y0 : tileSelection_y1;  	int ty1 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y1 : tileSelection_y0;  	int numTilesX = tx1 - tx0 + 1;  	int numTilesY = ty1 - ty0 + 1;  	int numValidTiles = 0;  	tileSelection.Clear ();  	List<tk2dSparseTile> tiles = new List<tk2dSparseTile> ();  	for (int y = 0; y < numTilesY; ++y) {  		for (int x = 0; x < numTilesX; ++x) {  			ushort spriteId = (ushort)((y + ty0) * tilesPerRow + (x + tx0));  			if (IsValidSprite (spriteCollection' spriteId)) {  				tiles.Add (new tk2dSparseTile (x' numTilesY - 1 - y' 0' spriteId));  				if (tileSelection.IndexOf (spriteId) == -1)  					tileSelection.Add (spriteId);  				numValidTiles++;  			}  		}  	}  	if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  	else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  	else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  	else  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.type = (rectSelect) ? tk2dTileMapEditorBrush.Type.Rectangle : tk2dTileMapEditorBrush.Type.Single;  	brush.multiSelectTiles = tileSelection.ToArray ();  	brush.tiles = tiles.ToArray ();  }  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (multiSelect) {  	List<int> filteredTileSelection = new List<int> ();  	foreach (var v in tileSelection) {  		if (IsValidSprite (spriteCollection' v))  			filteredTileSelection.Add (v);  	}  	brush.type = tk2dTileMapEditorBrush.Type.MultiSelect;  	brush.multiSelectTiles = filteredTileSelection.ToArray ();  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.tiles = new tk2dSparseTile[0];  }  else {  	int tx0 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x0 : tileSelection_x1;  	int tx1 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x1 : tileSelection_x0;  	int ty0 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y0 : tileSelection_y1;  	int ty1 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y1 : tileSelection_y0;  	int numTilesX = tx1 - tx0 + 1;  	int numTilesY = ty1 - ty0 + 1;  	int numValidTiles = 0;  	tileSelection.Clear ();  	List<tk2dSparseTile> tiles = new List<tk2dSparseTile> ();  	for (int y = 0; y < numTilesY; ++y) {  		for (int x = 0; x < numTilesX; ++x) {  			ushort spriteId = (ushort)((y + ty0) * tilesPerRow + (x + tx0));  			if (IsValidSprite (spriteCollection' spriteId)) {  				tiles.Add (new tk2dSparseTile (x' numTilesY - 1 - y' 0' spriteId));  				if (tileSelection.IndexOf (spriteId) == -1)  					tileSelection.Add (spriteId);  				numValidTiles++;  			}  		}  	}  	if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  	else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  	else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  	else  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.type = (rectSelect) ? tk2dTileMapEditorBrush.Type.Rectangle : tk2dTileMapEditorBrush.Type.Single;  	brush.multiSelectTiles = tileSelection.ToArray ();  	brush.tiles = tiles.ToArray ();  }  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (multiSelect) {  	List<int> filteredTileSelection = new List<int> ();  	foreach (var v in tileSelection) {  		if (IsValidSprite (spriteCollection' v))  			filteredTileSelection.Add (v);  	}  	brush.type = tk2dTileMapEditorBrush.Type.MultiSelect;  	brush.multiSelectTiles = filteredTileSelection.ToArray ();  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.tiles = new tk2dSparseTile[0];  }  else {  	int tx0 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x0 : tileSelection_x1;  	int tx1 = (tileSelection_x0 < tileSelection_x1) ? tileSelection_x1 : tileSelection_x0;  	int ty0 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y0 : tileSelection_y1;  	int ty1 = (tileSelection_y0 < tileSelection_y1) ? tileSelection_y1 : tileSelection_y0;  	int numTilesX = tx1 - tx0 + 1;  	int numTilesY = ty1 - ty0 + 1;  	int numValidTiles = 0;  	tileSelection.Clear ();  	List<tk2dSparseTile> tiles = new List<tk2dSparseTile> ();  	for (int y = 0; y < numTilesY; ++y) {  		for (int x = 0; x < numTilesX; ++x) {  			ushort spriteId = (ushort)((y + ty0) * tilesPerRow + (x + tx0));  			if (IsValidSprite (spriteCollection' spriteId)) {  				tiles.Add (new tk2dSparseTile (x' numTilesY - 1 - y' 0' spriteId));  				if (tileSelection.IndexOf (spriteId) == -1)  					tileSelection.Add (spriteId);  				numValidTiles++;  			}  		}  	}  	if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  	else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  	else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  	else  		brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  	brush.type = (rectSelect) ? tk2dTileMapEditorBrush.Type.Rectangle : tk2dTileMapEditorBrush.Type.Single;  	brush.multiSelectTiles = tileSelection.ToArray ();  	brush.tiles = tiles.ToArray ();  }  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 1 && numTilesY == 3 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Vertical;  else if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 3 && numTilesY == 1 && numValidTiles == 3)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Horizontal;  else if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,BuildBrush,The following statement contains a magic number: if (numTilesX == 3 && numTilesY == 3 && numValidTiles == 9)  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.Square;  else  	brush.edgeMode = tk2dTileMapEditorBrush.EdgeMode.None;  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	string[] tokens = line.Split (' ');  	if (tokens [0] == "common") {  		fontInfo.lineHeight = int.Parse (FindKeyValue (tokens' "lineHeight"));  		fontInfo.scaleW = int.Parse (FindKeyValue (tokens' "scaleW"));  		fontInfo.scaleH = int.Parse (FindKeyValue (tokens' "scaleH"));  		int pages = int.Parse (FindKeyValue (tokens' "pages"));  		if (pages != 1) {  			EditorUtility.DisplayDialog ("Fatal error"' "Only one page supported in font. Please change the setting and re-export."' "Ok");  			return null;  		}  		fontInfo.numPages = pages;  		if (FindKeyValue (tokens' "packed") != "")  			fontInfo.isPacked = int.Parse (FindKeyValue (tokens' "packed")) != 0;  		fontInfo.texturePaths = new string[pages];  		for (int i = 0; i < pages; ++i)  			fontInfo.texturePaths [i] = string.Empty;  	}  	else if (tokens [0] == "page") {  		int id = int.Parse (FindKeyValue (tokens' "id"));  		string file = FindKeyValue (tokens' "file");  		if (file [0] == '"' && file [file.Length - 1] == '"')  			file = file.Substring (1' file.Length - 2);  		fontInfo.texturePaths [id] = file;  	}  	else if (tokens [0] == "char") {  		Char thisChar = new Char ();  		thisChar.id = int.Parse (FindKeyValue (tokens' "id"));  		thisChar.x = int.Parse (FindKeyValue (tokens' "x"));  		thisChar.y = int.Parse (FindKeyValue (tokens' "y"));  		thisChar.width = int.Parse (FindKeyValue (tokens' "width"));  		thisChar.height = int.Parse (FindKeyValue (tokens' "height"));  		thisChar.xoffset = int.Parse (FindKeyValue (tokens' "xoffset"));  		thisChar.yoffset = int.Parse (FindKeyValue (tokens' "yoffset"));  		thisChar.xadvance = int.Parse (FindKeyValue (tokens' "xadvance"));  		if (fontInfo.isPacked) {  			int chnl = int.Parse (FindKeyValue (tokens' "chnl"));  			thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  		}  		if (thisChar.id == -1)  			thisChar.id = 0;  		fontInfo.chars.Add (thisChar);  	}  	else if (tokens [0] == "kerning") {  		Kerning thisKerning = new Kerning ();  		thisKerning.first = int.Parse (FindKeyValue (tokens' "first"));  		thisKerning.second = int.Parse (FindKeyValue (tokens' "second"));  		thisKerning.amount = int.Parse (FindKeyValue (tokens' "amount"));  		fontInfo.kernings.Add (thisKerning);  	}  }  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	string[] tokens = line.Split (' ');  	if (tokens [0] == "common") {  		fontInfo.lineHeight = int.Parse (FindKeyValue (tokens' "lineHeight"));  		fontInfo.scaleW = int.Parse (FindKeyValue (tokens' "scaleW"));  		fontInfo.scaleH = int.Parse (FindKeyValue (tokens' "scaleH"));  		int pages = int.Parse (FindKeyValue (tokens' "pages"));  		if (pages != 1) {  			EditorUtility.DisplayDialog ("Fatal error"' "Only one page supported in font. Please change the setting and re-export."' "Ok");  			return null;  		}  		fontInfo.numPages = pages;  		if (FindKeyValue (tokens' "packed") != "")  			fontInfo.isPacked = int.Parse (FindKeyValue (tokens' "packed")) != 0;  		fontInfo.texturePaths = new string[pages];  		for (int i = 0; i < pages; ++i)  			fontInfo.texturePaths [i] = string.Empty;  	}  	else if (tokens [0] == "page") {  		int id = int.Parse (FindKeyValue (tokens' "id"));  		string file = FindKeyValue (tokens' "file");  		if (file [0] == '"' && file [file.Length - 1] == '"')  			file = file.Substring (1' file.Length - 2);  		fontInfo.texturePaths [id] = file;  	}  	else if (tokens [0] == "char") {  		Char thisChar = new Char ();  		thisChar.id = int.Parse (FindKeyValue (tokens' "id"));  		thisChar.x = int.Parse (FindKeyValue (tokens' "x"));  		thisChar.y = int.Parse (FindKeyValue (tokens' "y"));  		thisChar.width = int.Parse (FindKeyValue (tokens' "width"));  		thisChar.height = int.Parse (FindKeyValue (tokens' "height"));  		thisChar.xoffset = int.Parse (FindKeyValue (tokens' "xoffset"));  		thisChar.yoffset = int.Parse (FindKeyValue (tokens' "yoffset"));  		thisChar.xadvance = int.Parse (FindKeyValue (tokens' "xadvance"));  		if (fontInfo.isPacked) {  			int chnl = int.Parse (FindKeyValue (tokens' "chnl"));  			thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  		}  		if (thisChar.id == -1)  			thisChar.id = 0;  		fontInfo.chars.Add (thisChar);  	}  	else if (tokens [0] == "kerning") {  		Kerning thisKerning = new Kerning ();  		thisKerning.first = int.Parse (FindKeyValue (tokens' "first"));  		thisKerning.second = int.Parse (FindKeyValue (tokens' "second"));  		thisKerning.amount = int.Parse (FindKeyValue (tokens' "amount"));  		fontInfo.kernings.Add (thisKerning);  	}  }  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: if (tokens [0] == "common") {  	fontInfo.lineHeight = int.Parse (FindKeyValue (tokens' "lineHeight"));  	fontInfo.scaleW = int.Parse (FindKeyValue (tokens' "scaleW"));  	fontInfo.scaleH = int.Parse (FindKeyValue (tokens' "scaleH"));  	int pages = int.Parse (FindKeyValue (tokens' "pages"));  	if (pages != 1) {  		EditorUtility.DisplayDialog ("Fatal error"' "Only one page supported in font. Please change the setting and re-export."' "Ok");  		return null;  	}  	fontInfo.numPages = pages;  	if (FindKeyValue (tokens' "packed") != "")  		fontInfo.isPacked = int.Parse (FindKeyValue (tokens' "packed")) != 0;  	fontInfo.texturePaths = new string[pages];  	for (int i = 0; i < pages; ++i)  		fontInfo.texturePaths [i] = string.Empty;  }  else if (tokens [0] == "page") {  	int id = int.Parse (FindKeyValue (tokens' "id"));  	string file = FindKeyValue (tokens' "file");  	if (file [0] == '"' && file [file.Length - 1] == '"')  		file = file.Substring (1' file.Length - 2);  	fontInfo.texturePaths [id] = file;  }  else if (tokens [0] == "char") {  	Char thisChar = new Char ();  	thisChar.id = int.Parse (FindKeyValue (tokens' "id"));  	thisChar.x = int.Parse (FindKeyValue (tokens' "x"));  	thisChar.y = int.Parse (FindKeyValue (tokens' "y"));  	thisChar.width = int.Parse (FindKeyValue (tokens' "width"));  	thisChar.height = int.Parse (FindKeyValue (tokens' "height"));  	thisChar.xoffset = int.Parse (FindKeyValue (tokens' "xoffset"));  	thisChar.yoffset = int.Parse (FindKeyValue (tokens' "yoffset"));  	thisChar.xadvance = int.Parse (FindKeyValue (tokens' "xadvance"));  	if (fontInfo.isPacked) {  		int chnl = int.Parse (FindKeyValue (tokens' "chnl"));  		thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  	}  	if (thisChar.id == -1)  		thisChar.id = 0;  	fontInfo.chars.Add (thisChar);  }  else if (tokens [0] == "kerning") {  	Kerning thisKerning = new Kerning ();  	thisKerning.first = int.Parse (FindKeyValue (tokens' "first"));  	thisKerning.second = int.Parse (FindKeyValue (tokens' "second"));  	thisKerning.amount = int.Parse (FindKeyValue (tokens' "amount"));  	fontInfo.kernings.Add (thisKerning);  }  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: if (tokens [0] == "common") {  	fontInfo.lineHeight = int.Parse (FindKeyValue (tokens' "lineHeight"));  	fontInfo.scaleW = int.Parse (FindKeyValue (tokens' "scaleW"));  	fontInfo.scaleH = int.Parse (FindKeyValue (tokens' "scaleH"));  	int pages = int.Parse (FindKeyValue (tokens' "pages"));  	if (pages != 1) {  		EditorUtility.DisplayDialog ("Fatal error"' "Only one page supported in font. Please change the setting and re-export."' "Ok");  		return null;  	}  	fontInfo.numPages = pages;  	if (FindKeyValue (tokens' "packed") != "")  		fontInfo.isPacked = int.Parse (FindKeyValue (tokens' "packed")) != 0;  	fontInfo.texturePaths = new string[pages];  	for (int i = 0; i < pages; ++i)  		fontInfo.texturePaths [i] = string.Empty;  }  else if (tokens [0] == "page") {  	int id = int.Parse (FindKeyValue (tokens' "id"));  	string file = FindKeyValue (tokens' "file");  	if (file [0] == '"' && file [file.Length - 1] == '"')  		file = file.Substring (1' file.Length - 2);  	fontInfo.texturePaths [id] = file;  }  else if (tokens [0] == "char") {  	Char thisChar = new Char ();  	thisChar.id = int.Parse (FindKeyValue (tokens' "id"));  	thisChar.x = int.Parse (FindKeyValue (tokens' "x"));  	thisChar.y = int.Parse (FindKeyValue (tokens' "y"));  	thisChar.width = int.Parse (FindKeyValue (tokens' "width"));  	thisChar.height = int.Parse (FindKeyValue (tokens' "height"));  	thisChar.xoffset = int.Parse (FindKeyValue (tokens' "xoffset"));  	thisChar.yoffset = int.Parse (FindKeyValue (tokens' "yoffset"));  	thisChar.xadvance = int.Parse (FindKeyValue (tokens' "xadvance"));  	if (fontInfo.isPacked) {  		int chnl = int.Parse (FindKeyValue (tokens' "chnl"));  		thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  	}  	if (thisChar.id == -1)  		thisChar.id = 0;  	fontInfo.chars.Add (thisChar);  }  else if (tokens [0] == "kerning") {  	Kerning thisKerning = new Kerning ();  	thisKerning.first = int.Parse (FindKeyValue (tokens' "first"));  	thisKerning.second = int.Parse (FindKeyValue (tokens' "second"));  	thisKerning.amount = int.Parse (FindKeyValue (tokens' "amount"));  	fontInfo.kernings.Add (thisKerning);  }  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: if (tokens [0] == "page") {  	int id = int.Parse (FindKeyValue (tokens' "id"));  	string file = FindKeyValue (tokens' "file");  	if (file [0] == '"' && file [file.Length - 1] == '"')  		file = file.Substring (1' file.Length - 2);  	fontInfo.texturePaths [id] = file;  }  else if (tokens [0] == "char") {  	Char thisChar = new Char ();  	thisChar.id = int.Parse (FindKeyValue (tokens' "id"));  	thisChar.x = int.Parse (FindKeyValue (tokens' "x"));  	thisChar.y = int.Parse (FindKeyValue (tokens' "y"));  	thisChar.width = int.Parse (FindKeyValue (tokens' "width"));  	thisChar.height = int.Parse (FindKeyValue (tokens' "height"));  	thisChar.xoffset = int.Parse (FindKeyValue (tokens' "xoffset"));  	thisChar.yoffset = int.Parse (FindKeyValue (tokens' "yoffset"));  	thisChar.xadvance = int.Parse (FindKeyValue (tokens' "xadvance"));  	if (fontInfo.isPacked) {  		int chnl = int.Parse (FindKeyValue (tokens' "chnl"));  		thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  	}  	if (thisChar.id == -1)  		thisChar.id = 0;  	fontInfo.chars.Add (thisChar);  }  else if (tokens [0] == "kerning") {  	Kerning thisKerning = new Kerning ();  	thisKerning.first = int.Parse (FindKeyValue (tokens' "first"));  	thisKerning.second = int.Parse (FindKeyValue (tokens' "second"));  	thisKerning.amount = int.Parse (FindKeyValue (tokens' "amount"));  	fontInfo.kernings.Add (thisKerning);  }  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: if (tokens [0] == "page") {  	int id = int.Parse (FindKeyValue (tokens' "id"));  	string file = FindKeyValue (tokens' "file");  	if (file [0] == '"' && file [file.Length - 1] == '"')  		file = file.Substring (1' file.Length - 2);  	fontInfo.texturePaths [id] = file;  }  else if (tokens [0] == "char") {  	Char thisChar = new Char ();  	thisChar.id = int.Parse (FindKeyValue (tokens' "id"));  	thisChar.x = int.Parse (FindKeyValue (tokens' "x"));  	thisChar.y = int.Parse (FindKeyValue (tokens' "y"));  	thisChar.width = int.Parse (FindKeyValue (tokens' "width"));  	thisChar.height = int.Parse (FindKeyValue (tokens' "height"));  	thisChar.xoffset = int.Parse (FindKeyValue (tokens' "xoffset"));  	thisChar.yoffset = int.Parse (FindKeyValue (tokens' "yoffset"));  	thisChar.xadvance = int.Parse (FindKeyValue (tokens' "xadvance"));  	if (fontInfo.isPacked) {  		int chnl = int.Parse (FindKeyValue (tokens' "chnl"));  		thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  	}  	if (thisChar.id == -1)  		thisChar.id = 0;  	fontInfo.chars.Add (thisChar);  }  else if (tokens [0] == "kerning") {  	Kerning thisKerning = new Kerning ();  	thisKerning.first = int.Parse (FindKeyValue (tokens' "first"));  	thisKerning.second = int.Parse (FindKeyValue (tokens' "second"));  	thisKerning.amount = int.Parse (FindKeyValue (tokens' "amount"));  	fontInfo.kernings.Add (thisKerning);  }  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: if (file [0] == '"' && file [file.Length - 1] == '"')  	file = file.Substring (1' file.Length - 2);  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: file = file.Substring (1' file.Length - 2);  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: if (tokens [0] == "char") {  	Char thisChar = new Char ();  	thisChar.id = int.Parse (FindKeyValue (tokens' "id"));  	thisChar.x = int.Parse (FindKeyValue (tokens' "x"));  	thisChar.y = int.Parse (FindKeyValue (tokens' "y"));  	thisChar.width = int.Parse (FindKeyValue (tokens' "width"));  	thisChar.height = int.Parse (FindKeyValue (tokens' "height"));  	thisChar.xoffset = int.Parse (FindKeyValue (tokens' "xoffset"));  	thisChar.yoffset = int.Parse (FindKeyValue (tokens' "yoffset"));  	thisChar.xadvance = int.Parse (FindKeyValue (tokens' "xadvance"));  	if (fontInfo.isPacked) {  		int chnl = int.Parse (FindKeyValue (tokens' "chnl"));  		thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  	}  	if (thisChar.id == -1)  		thisChar.id = 0;  	fontInfo.chars.Add (thisChar);  }  else if (tokens [0] == "kerning") {  	Kerning thisKerning = new Kerning ();  	thisKerning.first = int.Parse (FindKeyValue (tokens' "first"));  	thisKerning.second = int.Parse (FindKeyValue (tokens' "second"));  	thisKerning.amount = int.Parse (FindKeyValue (tokens' "amount"));  	fontInfo.kernings.Add (thisKerning);  }  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: if (fontInfo.isPacked) {  	int chnl = int.Parse (FindKeyValue (tokens' "chnl"));  	thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  }  
Magic Number,tk2dEditor.Font,BMFontTextImporter,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,Parse,The following statement contains a magic number: thisChar.channel = (int)Mathf.Round (Mathf.Log (chnl) / Mathf.Log (2));  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: foreach (var theChar in fontInfo.chars) {  	tk2dFontChar thisChar = new tk2dFontChar ();  	int id = theChar.id;  	int x = theChar.x;  	int y = theChar.y;  	int width = theChar.width;  	int height = theChar.height;  	int xoffset = theChar.xoffset;  	int yoffset = theChar.yoffset;  	int xadvance = theChar.xadvance + charPadX;  	// special case' if the width and height are zero' the origin doesn't need to be offset  	// handles problematic case highlighted here:  	// http://2dtoolkit.com/forum/index.php/topic'89.msg220.html  	if (width == 0 && height == 0) {  		xoffset = 0;  		yoffset = 0;  	}  	// precompute required data  	if (theChar.texOverride) {  		float w = theChar.texW / texScale;  		float h = theChar.texH / texScale;  		if (theChar.texFlipped) {  			h = theChar.texW / texScale;  			w = theChar.texH / texScale;  		}  		float px = (xoffset + theChar.texOffsetX * texScale) * scale;  		float py = (lineHeight - yoffset - theChar.texOffsetY * texScale) * scale;  		thisChar.p0 = new Vector3 (px' py' 0);  		thisChar.p1 = new Vector3 (px + w * scale' py - h * scale' 0);  		thisChar.uv0 = new Vector2 ((theChar.texX) / texWidth' (theChar.texY + theChar.texH) / texHeight);  		thisChar.uv1 = new Vector2 ((theChar.texX + theChar.texW) / texWidth' (theChar.texY) / texHeight);  		if (flipTextureY) {  			float tmp = 0;  			if (theChar.texFlipped) {  				tmp = thisChar.uv1.x;  				thisChar.uv1.x = thisChar.uv0.x;  				thisChar.uv0.x = tmp;  			}  			else {  				tmp = thisChar.uv1.y;  				thisChar.uv1.y = thisChar.uv0.y;  				thisChar.uv0.y = tmp;  			}  		}  		thisChar.flipped = theChar.texFlipped;  	}  	else {  		float px = xoffset * scale;  		float py = (lineHeight - yoffset) * scale;  		thisChar.p0 = new Vector3 (px' py' 0);  		thisChar.p1 = new Vector3 (px + width * scale' py - height * scale' 0);  		if (flipTextureY) {  			thisChar.uv0 = new Vector2 (x / texWidth' y / texHeight);  			thisChar.uv1 = new Vector2 (thisChar.uv0.x + width / texWidth' thisChar.uv0.y + height / texHeight);  		}  		else {  			thisChar.uv0 = new Vector2 (x / texWidth' 1.0f - y / texHeight);  			thisChar.uv1 = new Vector2 (thisChar.uv0.x + width / texWidth' thisChar.uv0.y - height / texHeight);  		}  		thisChar.flipped = false;  	}  	thisChar.advance = xadvance * scale;  	thisChar.channel = theChar.channel;  	largestWidth = Mathf.Max (thisChar.advance' largestWidth);  	// Needs gradient data  	if (gradientTexture != null) {  		// build it up assuming the first gradient  		float x0 = (float)(0.0f / gradientCount);  		float x1 = (float)(1.0f / gradientCount);  		float y0 = 1.0f;  		float y1 = 0.0f;  		// align to glyph if necessary  		thisChar.gradientUv = new Vector2[4];  		thisChar.gradientUv [0] = new Vector2 (x0' y0);  		thisChar.gradientUv [1] = new Vector2 (x1' y0);  		thisChar.gradientUv [2] = new Vector2 (x0' y1);  		thisChar.gradientUv [3] = new Vector2 (x1' y1);  	}  	if (id <= maxCharId) {  		maxCharWithinBounds = (id > maxCharWithinBounds) ? id : maxCharWithinBounds;  		minChar = (id < minChar) ? id : minChar;  		if (useDictionary)  			charDict [id] = thisChar;  		else  			chars [id] = thisChar;  		++numLocalChars;  	}  }  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: foreach (var theChar in fontInfo.chars) {  	tk2dFontChar thisChar = new tk2dFontChar ();  	int id = theChar.id;  	int x = theChar.x;  	int y = theChar.y;  	int width = theChar.width;  	int height = theChar.height;  	int xoffset = theChar.xoffset;  	int yoffset = theChar.yoffset;  	int xadvance = theChar.xadvance + charPadX;  	// special case' if the width and height are zero' the origin doesn't need to be offset  	// handles problematic case highlighted here:  	// http://2dtoolkit.com/forum/index.php/topic'89.msg220.html  	if (width == 0 && height == 0) {  		xoffset = 0;  		yoffset = 0;  	}  	// precompute required data  	if (theChar.texOverride) {  		float w = theChar.texW / texScale;  		float h = theChar.texH / texScale;  		if (theChar.texFlipped) {  			h = theChar.texW / texScale;  			w = theChar.texH / texScale;  		}  		float px = (xoffset + theChar.texOffsetX * texScale) * scale;  		float py = (lineHeight - yoffset - theChar.texOffsetY * texScale) * scale;  		thisChar.p0 = new Vector3 (px' py' 0);  		thisChar.p1 = new Vector3 (px + w * scale' py - h * scale' 0);  		thisChar.uv0 = new Vector2 ((theChar.texX) / texWidth' (theChar.texY + theChar.texH) / texHeight);  		thisChar.uv1 = new Vector2 ((theChar.texX + theChar.texW) / texWidth' (theChar.texY) / texHeight);  		if (flipTextureY) {  			float tmp = 0;  			if (theChar.texFlipped) {  				tmp = thisChar.uv1.x;  				thisChar.uv1.x = thisChar.uv0.x;  				thisChar.uv0.x = tmp;  			}  			else {  				tmp = thisChar.uv1.y;  				thisChar.uv1.y = thisChar.uv0.y;  				thisChar.uv0.y = tmp;  			}  		}  		thisChar.flipped = theChar.texFlipped;  	}  	else {  		float px = xoffset * scale;  		float py = (lineHeight - yoffset) * scale;  		thisChar.p0 = new Vector3 (px' py' 0);  		thisChar.p1 = new Vector3 (px + width * scale' py - height * scale' 0);  		if (flipTextureY) {  			thisChar.uv0 = new Vector2 (x / texWidth' y / texHeight);  			thisChar.uv1 = new Vector2 (thisChar.uv0.x + width / texWidth' thisChar.uv0.y + height / texHeight);  		}  		else {  			thisChar.uv0 = new Vector2 (x / texWidth' 1.0f - y / texHeight);  			thisChar.uv1 = new Vector2 (thisChar.uv0.x + width / texWidth' thisChar.uv0.y - height / texHeight);  		}  		thisChar.flipped = false;  	}  	thisChar.advance = xadvance * scale;  	thisChar.channel = theChar.channel;  	largestWidth = Mathf.Max (thisChar.advance' largestWidth);  	// Needs gradient data  	if (gradientTexture != null) {  		// build it up assuming the first gradient  		float x0 = (float)(0.0f / gradientCount);  		float x1 = (float)(1.0f / gradientCount);  		float y0 = 1.0f;  		float y1 = 0.0f;  		// align to glyph if necessary  		thisChar.gradientUv = new Vector2[4];  		thisChar.gradientUv [0] = new Vector2 (x0' y0);  		thisChar.gradientUv [1] = new Vector2 (x1' y0);  		thisChar.gradientUv [2] = new Vector2 (x0' y1);  		thisChar.gradientUv [3] = new Vector2 (x1' y1);  	}  	if (id <= maxCharId) {  		maxCharWithinBounds = (id > maxCharWithinBounds) ? id : maxCharWithinBounds;  		minChar = (id < minChar) ? id : minChar;  		if (useDictionary)  			charDict [id] = thisChar;  		else  			chars [id] = thisChar;  		++numLocalChars;  	}  }  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: foreach (var theChar in fontInfo.chars) {  	tk2dFontChar thisChar = new tk2dFontChar ();  	int id = theChar.id;  	int x = theChar.x;  	int y = theChar.y;  	int width = theChar.width;  	int height = theChar.height;  	int xoffset = theChar.xoffset;  	int yoffset = theChar.yoffset;  	int xadvance = theChar.xadvance + charPadX;  	// special case' if the width and height are zero' the origin doesn't need to be offset  	// handles problematic case highlighted here:  	// http://2dtoolkit.com/forum/index.php/topic'89.msg220.html  	if (width == 0 && height == 0) {  		xoffset = 0;  		yoffset = 0;  	}  	// precompute required data  	if (theChar.texOverride) {  		float w = theChar.texW / texScale;  		float h = theChar.texH / texScale;  		if (theChar.texFlipped) {  			h = theChar.texW / texScale;  			w = theChar.texH / texScale;  		}  		float px = (xoffset + theChar.texOffsetX * texScale) * scale;  		float py = (lineHeight - yoffset - theChar.texOffsetY * texScale) * scale;  		thisChar.p0 = new Vector3 (px' py' 0);  		thisChar.p1 = new Vector3 (px + w * scale' py - h * scale' 0);  		thisChar.uv0 = new Vector2 ((theChar.texX) / texWidth' (theChar.texY + theChar.texH) / texHeight);  		thisChar.uv1 = new Vector2 ((theChar.texX + theChar.texW) / texWidth' (theChar.texY) / texHeight);  		if (flipTextureY) {  			float tmp = 0;  			if (theChar.texFlipped) {  				tmp = thisChar.uv1.x;  				thisChar.uv1.x = thisChar.uv0.x;  				thisChar.uv0.x = tmp;  			}  			else {  				tmp = thisChar.uv1.y;  				thisChar.uv1.y = thisChar.uv0.y;  				thisChar.uv0.y = tmp;  			}  		}  		thisChar.flipped = theChar.texFlipped;  	}  	else {  		float px = xoffset * scale;  		float py = (lineHeight - yoffset) * scale;  		thisChar.p0 = new Vector3 (px' py' 0);  		thisChar.p1 = new Vector3 (px + width * scale' py - height * scale' 0);  		if (flipTextureY) {  			thisChar.uv0 = new Vector2 (x / texWidth' y / texHeight);  			thisChar.uv1 = new Vector2 (thisChar.uv0.x + width / texWidth' thisChar.uv0.y + height / texHeight);  		}  		else {  			thisChar.uv0 = new Vector2 (x / texWidth' 1.0f - y / texHeight);  			thisChar.uv1 = new Vector2 (thisChar.uv0.x + width / texWidth' thisChar.uv0.y - height / texHeight);  		}  		thisChar.flipped = false;  	}  	thisChar.advance = xadvance * scale;  	thisChar.channel = theChar.channel;  	largestWidth = Mathf.Max (thisChar.advance' largestWidth);  	// Needs gradient data  	if (gradientTexture != null) {  		// build it up assuming the first gradient  		float x0 = (float)(0.0f / gradientCount);  		float x1 = (float)(1.0f / gradientCount);  		float y0 = 1.0f;  		float y1 = 0.0f;  		// align to glyph if necessary  		thisChar.gradientUv = new Vector2[4];  		thisChar.gradientUv [0] = new Vector2 (x0' y0);  		thisChar.gradientUv [1] = new Vector2 (x1' y0);  		thisChar.gradientUv [2] = new Vector2 (x0' y1);  		thisChar.gradientUv [3] = new Vector2 (x1' y1);  	}  	if (id <= maxCharId) {  		maxCharWithinBounds = (id > maxCharWithinBounds) ? id : maxCharWithinBounds;  		minChar = (id < minChar) ? id : minChar;  		if (useDictionary)  			charDict [id] = thisChar;  		else  			chars [id] = thisChar;  		++numLocalChars;  	}  }  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: if (gradientTexture != null) {  	// build it up assuming the first gradient  	float x0 = (float)(0.0f / gradientCount);  	float x1 = (float)(1.0f / gradientCount);  	float y0 = 1.0f;  	float y1 = 0.0f;  	// align to glyph if necessary  	thisChar.gradientUv = new Vector2[4];  	thisChar.gradientUv [0] = new Vector2 (x0' y0);  	thisChar.gradientUv [1] = new Vector2 (x1' y0);  	thisChar.gradientUv [2] = new Vector2 (x0' y1);  	thisChar.gradientUv [3] = new Vector2 (x1' y1);  }  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: if (gradientTexture != null) {  	// build it up assuming the first gradient  	float x0 = (float)(0.0f / gradientCount);  	float x1 = (float)(1.0f / gradientCount);  	float y0 = 1.0f;  	float y1 = 0.0f;  	// align to glyph if necessary  	thisChar.gradientUv = new Vector2[4];  	thisChar.gradientUv [0] = new Vector2 (x0' y0);  	thisChar.gradientUv [1] = new Vector2 (x1' y0);  	thisChar.gradientUv [2] = new Vector2 (x0' y1);  	thisChar.gradientUv [3] = new Vector2 (x1' y1);  }  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: if (gradientTexture != null) {  	// build it up assuming the first gradient  	float x0 = (float)(0.0f / gradientCount);  	float x1 = (float)(1.0f / gradientCount);  	float y0 = 1.0f;  	float y1 = 0.0f;  	// align to glyph if necessary  	thisChar.gradientUv = new Vector2[4];  	thisChar.gradientUv [0] = new Vector2 (x0' y0);  	thisChar.gradientUv [1] = new Vector2 (x1' y0);  	thisChar.gradientUv [2] = new Vector2 (x0' y1);  	thisChar.gradientUv [3] = new Vector2 (x1' y1);  }  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: thisChar.gradientUv = new Vector2[4];  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: thisChar.gradientUv [2] = new Vector2 (x0' y1);  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: thisChar.gradientUv [3] = new Vector2 (x1' y1);  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: nullChar.gradientUv = new Vector2[4];  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: if (useDictionary) {  	// guarantee at least the first 256 characters  	for (int i = 0; i < 256; ++i) {  		if (!charDict.ContainsKey (i))  			charDict [i] = nullChar;  	}  	target.chars = null;  	target.SetDictionary (charDict);  	target.useDictionary = true;  }  else {  	target.chars = new tk2dFontChar[maxCharId + 1];  	for (int i = 0; i <= maxCharId; ++i) {  		target.chars [i] = chars [i];  		if (target.chars [i] == null) {  			target.chars [i] = nullChar;  			// zero everything' null char  		}  	}  	target.charDict = null;  	target.useDictionary = false;  }  
Magic Number,tk2dEditor.Font,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Fonts\tk2dFontBuilder.cs,BuildFont,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	if (!charDict.ContainsKey (i))  		charDict [i] = nullChar;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  			List<Entry> atlasEntries = new List<Entry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedWidth = 0;  				int matchedHeight = 0;  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.width && height == t.height) {  						matchedId = i;  						matchedWidth = sourceRects [i].width;  						matchedHeight = sourceRects [i].height;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						int width = (sourceRects [i].width + align) >> alignShift;  						int height = (sourceRects [i].height + align) >> alignShift;  						if (!usedRect [i] && width == t.height && height == t.width) {  							matchedId = i;  							flipped = true;  							matchedWidth = sourceRects [i].height;  							matchedHeight = sourceRects [i].width;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				Entry newEntry = new Entry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x << alignShift;  				newEntry.y = t.y << alignShift;  				newEntry.w = matchedWidth;  				newEntry.h = matchedHeight;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			Data currAtlas = new Data ();  			currAtlas.width = thisCellW << alignShift;  			currAtlas.height = thisCellH << alignShift;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				if (forceSquare) {  					thisCellW *= 2;  					thisCellH *= 2;  				}  				else {  					// Can only try another size when it already has been scaled down for the first time  					if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  						// Tried to scale down' but the texture doesn't fit' so revert previous change' and   						// iterate over the data again forcing a pass even though there is wastage  						if (thisCellW < thisCellH)  							thisCellW *= 2;  						else  							thisCellH *= 2;  					}  				}  				reverted = true;  			}  			else {  				if (forceSquare) {  					thisCellH /= 2;  					thisCellW /= 2;  				}  				else {  					// More than half the texture was unused' scale down by one of the dimensions  					if (thisCellW < thisCellH)  						thisCellH /= 2;  					else  						thisCellW /= 2;  				}  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  			List<Entry> atlasEntries = new List<Entry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedWidth = 0;  				int matchedHeight = 0;  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.width && height == t.height) {  						matchedId = i;  						matchedWidth = sourceRects [i].width;  						matchedHeight = sourceRects [i].height;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						int width = (sourceRects [i].width + align) >> alignShift;  						int height = (sourceRects [i].height + align) >> alignShift;  						if (!usedRect [i] && width == t.height && height == t.width) {  							matchedId = i;  							flipped = true;  							matchedWidth = sourceRects [i].height;  							matchedHeight = sourceRects [i].width;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				Entry newEntry = new Entry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x << alignShift;  				newEntry.y = t.y << alignShift;  				newEntry.w = matchedWidth;  				newEntry.h = matchedHeight;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			Data currAtlas = new Data ();  			currAtlas.width = thisCellW << alignShift;  			currAtlas.height = thisCellH << alignShift;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				if (forceSquare) {  					thisCellW *= 2;  					thisCellH *= 2;  				}  				else {  					// Can only try another size when it already has been scaled down for the first time  					if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  						// Tried to scale down' but the texture doesn't fit' so revert previous change' and   						// iterate over the data again forcing a pass even though there is wastage  						if (thisCellW < thisCellH)  							thisCellW *= 2;  						else  							thisCellH *= 2;  					}  				}  				reverted = true;  			}  			else {  				if (forceSquare) {  					thisCellH /= 2;  					thisCellW /= 2;  				}  				else {  					// More than half the texture was unused' scale down by one of the dimensions  					if (thisCellW < thisCellH)  						thisCellH /= 2;  					else  						thisCellW /= 2;  				}  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  			List<Entry> atlasEntries = new List<Entry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedWidth = 0;  				int matchedHeight = 0;  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.width && height == t.height) {  						matchedId = i;  						matchedWidth = sourceRects [i].width;  						matchedHeight = sourceRects [i].height;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						int width = (sourceRects [i].width + align) >> alignShift;  						int height = (sourceRects [i].height + align) >> alignShift;  						if (!usedRect [i] && width == t.height && height == t.width) {  							matchedId = i;  							flipped = true;  							matchedWidth = sourceRects [i].height;  							matchedHeight = sourceRects [i].width;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				Entry newEntry = new Entry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x << alignShift;  				newEntry.y = t.y << alignShift;  				newEntry.w = matchedWidth;  				newEntry.h = matchedHeight;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			Data currAtlas = new Data ();  			currAtlas.width = thisCellW << alignShift;  			currAtlas.height = thisCellH << alignShift;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				if (forceSquare) {  					thisCellW *= 2;  					thisCellH *= 2;  				}  				else {  					// Can only try another size when it already has been scaled down for the first time  					if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  						// Tried to scale down' but the texture doesn't fit' so revert previous change' and   						// iterate over the data again forcing a pass even though there is wastage  						if (thisCellW < thisCellH)  							thisCellW *= 2;  						else  							thisCellH *= 2;  					}  				}  				reverted = true;  			}  			else {  				if (forceSquare) {  					thisCellH /= 2;  					thisCellW /= 2;  				}  				else {  					// More than half the texture was unused' scale down by one of the dimensions  					if (thisCellW < thisCellH)  						thisCellH /= 2;  					else  						thisCellW /= 2;  				}  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  			List<Entry> atlasEntries = new List<Entry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedWidth = 0;  				int matchedHeight = 0;  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.width && height == t.height) {  						matchedId = i;  						matchedWidth = sourceRects [i].width;  						matchedHeight = sourceRects [i].height;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						int width = (sourceRects [i].width + align) >> alignShift;  						int height = (sourceRects [i].height + align) >> alignShift;  						if (!usedRect [i] && width == t.height && height == t.width) {  							matchedId = i;  							flipped = true;  							matchedWidth = sourceRects [i].height;  							matchedHeight = sourceRects [i].width;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				Entry newEntry = new Entry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x << alignShift;  				newEntry.y = t.y << alignShift;  				newEntry.w = matchedWidth;  				newEntry.h = matchedHeight;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			Data currAtlas = new Data ();  			currAtlas.width = thisCellW << alignShift;  			currAtlas.height = thisCellH << alignShift;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				if (forceSquare) {  					thisCellW *= 2;  					thisCellH *= 2;  				}  				else {  					// Can only try another size when it already has been scaled down for the first time  					if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  						// Tried to scale down' but the texture doesn't fit' so revert previous change' and   						// iterate over the data again forcing a pass even though there is wastage  						if (thisCellW < thisCellH)  							thisCellW *= 2;  						else  							thisCellH *= 2;  					}  				}  				reverted = true;  			}  			else {  				if (forceSquare) {  					thisCellH /= 2;  					thisCellW /= 2;  				}  				else {  					// More than half the texture was unused' scale down by one of the dimensions  					if (thisCellW < thisCellH)  						thisCellH /= 2;  					else  						thisCellW /= 2;  				}  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  			List<Entry> atlasEntries = new List<Entry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedWidth = 0;  				int matchedHeight = 0;  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.width && height == t.height) {  						matchedId = i;  						matchedWidth = sourceRects [i].width;  						matchedHeight = sourceRects [i].height;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						int width = (sourceRects [i].width + align) >> alignShift;  						int height = (sourceRects [i].height + align) >> alignShift;  						if (!usedRect [i] && width == t.height && height == t.width) {  							matchedId = i;  							flipped = true;  							matchedWidth = sourceRects [i].height;  							matchedHeight = sourceRects [i].width;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				Entry newEntry = new Entry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x << alignShift;  				newEntry.y = t.y << alignShift;  				newEntry.w = matchedWidth;  				newEntry.h = matchedHeight;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			Data currAtlas = new Data ();  			currAtlas.width = thisCellW << alignShift;  			currAtlas.height = thisCellH << alignShift;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				if (forceSquare) {  					thisCellW *= 2;  					thisCellH *= 2;  				}  				else {  					// Can only try another size when it already has been scaled down for the first time  					if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  						// Tried to scale down' but the texture doesn't fit' so revert previous change' and   						// iterate over the data again forcing a pass even though there is wastage  						if (thisCellW < thisCellH)  							thisCellW *= 2;  						else  							thisCellH *= 2;  					}  				}  				reverted = true;  			}  			else {  				if (forceSquare) {  					thisCellH /= 2;  					thisCellW /= 2;  				}  				else {  					// More than half the texture was unused' scale down by one of the dimensions  					if (thisCellW < thisCellH)  						thisCellH /= 2;  					else  						thisCellW /= 2;  				}  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  			List<Entry> atlasEntries = new List<Entry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedWidth = 0;  				int matchedHeight = 0;  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.width && height == t.height) {  						matchedId = i;  						matchedWidth = sourceRects [i].width;  						matchedHeight = sourceRects [i].height;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						int width = (sourceRects [i].width + align) >> alignShift;  						int height = (sourceRects [i].height + align) >> alignShift;  						if (!usedRect [i] && width == t.height && height == t.width) {  							matchedId = i;  							flipped = true;  							matchedWidth = sourceRects [i].height;  							matchedHeight = sourceRects [i].width;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				Entry newEntry = new Entry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x << alignShift;  				newEntry.y = t.y << alignShift;  				newEntry.w = matchedWidth;  				newEntry.h = matchedHeight;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			Data currAtlas = new Data ();  			currAtlas.width = thisCellW << alignShift;  			currAtlas.height = thisCellH << alignShift;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				if (forceSquare) {  					thisCellW *= 2;  					thisCellH *= 2;  				}  				else {  					// Can only try another size when it already has been scaled down for the first time  					if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  						// Tried to scale down' but the texture doesn't fit' so revert previous change' and   						// iterate over the data again forcing a pass even though there is wastage  						if (thisCellW < thisCellH)  							thisCellW *= 2;  						else  							thisCellH *= 2;  					}  				}  				reverted = true;  			}  			else {  				if (forceSquare) {  					thisCellH /= 2;  					thisCellW /= 2;  				}  				else {  					// More than half the texture was unused' scale down by one of the dimensions  					if (thisCellW < thisCellH)  						thisCellH /= 2;  					else  						thisCellW /= 2;  				}  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  			List<Entry> atlasEntries = new List<Entry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedWidth = 0;  				int matchedHeight = 0;  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.width && height == t.height) {  						matchedId = i;  						matchedWidth = sourceRects [i].width;  						matchedHeight = sourceRects [i].height;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						int width = (sourceRects [i].width + align) >> alignShift;  						int height = (sourceRects [i].height + align) >> alignShift;  						if (!usedRect [i] && width == t.height && height == t.width) {  							matchedId = i;  							flipped = true;  							matchedWidth = sourceRects [i].height;  							matchedHeight = sourceRects [i].width;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				Entry newEntry = new Entry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x << alignShift;  				newEntry.y = t.y << alignShift;  				newEntry.w = matchedWidth;  				newEntry.h = matchedHeight;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			Data currAtlas = new Data ();  			currAtlas.width = thisCellW << alignShift;  			currAtlas.height = thisCellH << alignShift;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				if (forceSquare) {  					thisCellW *= 2;  					thisCellH *= 2;  				}  				else {  					// Can only try another size when it already has been scaled down for the first time  					if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  						// Tried to scale down' but the texture doesn't fit' so revert previous change' and   						// iterate over the data again forcing a pass even though there is wastage  						if (thisCellW < thisCellH)  							thisCellW *= 2;  						else  							thisCellH *= 2;  					}  				}  				reverted = true;  			}  			else {  				if (forceSquare) {  					thisCellH /= 2;  					thisCellW /= 2;  				}  				else {  					// More than half the texture was unused' scale down by one of the dimensions  					if (thisCellW < thisCellH)  						thisCellH /= 2;  					else  						thisCellW /= 2;  				}  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (allUsed == false && atlases.Count < maxAllowedAtlasCount) {  	int numPasses = 1;  	int thisCellW = atlasWidth' thisCellH = atlasHeight;  	bool reverted = false;  	while (numPasses > 0) {  		// Create copy to make sure we can scale textures down when necessary  		List<RectSize> currRects = new List<RectSize> (rects);  		//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  		//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  		MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  		float occupancy = binPacker.Occupancy ();  		// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  		// down by half to maintain PO2 requirements means this is as good as it gets  		bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  		// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  		// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  		if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  			List<Entry> atlasEntries = new List<Entry> ();  			foreach (var t in binPacker.GetMapped ()) {  				int matchedWidth = 0;  				int matchedHeight = 0;  				int matchedId = -1;  				bool flipped = false;  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.width && height == t.height) {  						matchedId = i;  						matchedWidth = sourceRects [i].width;  						matchedHeight = sourceRects [i].height;  						break;  					}  				}  				// Not matched anything yet' so look for the same rects rotated  				if (matchedId == -1) {  					for (int i = 0; i < sourceRects.Count; ++i) {  						int width = (sourceRects [i].width + align) >> alignShift;  						int height = (sourceRects [i].height + align) >> alignShift;  						if (!usedRect [i] && width == t.height && height == t.width) {  							matchedId = i;  							flipped = true;  							matchedWidth = sourceRects [i].height;  							matchedHeight = sourceRects [i].width;  							break;  						}  					}  				}  				// If this fails its a catastrophic error  				usedRect [matchedId] = true;  				Entry newEntry = new Entry ();  				newEntry.flipped = flipped;  				newEntry.x = t.x << alignShift;  				newEntry.y = t.y << alignShift;  				newEntry.w = matchedWidth;  				newEntry.h = matchedHeight;  				newEntry.index = matchedId;  				atlasEntries.Add (newEntry);  			}  			Data currAtlas = new Data ();  			currAtlas.width = thisCellW << alignShift;  			currAtlas.height = thisCellH << alignShift;  			currAtlas.occupancy = binPacker.Occupancy ();  			currAtlas.entries = atlasEntries.ToArray ();  			atlases.Add (currAtlas);  			rects = currRects;  			break;  			// done  		}  		else {  			if (!allUsed) {  				if (forceSquare) {  					thisCellW *= 2;  					thisCellH *= 2;  				}  				else {  					// Can only try another size when it already has been scaled down for the first time  					if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  						// Tried to scale down' but the texture doesn't fit' so revert previous change' and   						// iterate over the data again forcing a pass even though there is wastage  						if (thisCellW < thisCellH)  							thisCellW *= 2;  						else  							thisCellH *= 2;  					}  				}  				reverted = true;  			}  			else {  				if (forceSquare) {  					thisCellH /= 2;  					thisCellW /= 2;  				}  				else {  					// More than half the texture was unused' scale down by one of the dimensions  					if (thisCellW < thisCellH)  						thisCellH /= 2;  					else  						thisCellW /= 2;  				}  			}  			numPasses++;  		}  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  		List<Entry> atlasEntries = new List<Entry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedWidth = 0;  			int matchedHeight = 0;  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.width && height == t.height) {  					matchedId = i;  					matchedWidth = sourceRects [i].width;  					matchedHeight = sourceRects [i].height;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.height && height == t.width) {  						matchedId = i;  						flipped = true;  						matchedWidth = sourceRects [i].height;  						matchedHeight = sourceRects [i].width;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			Entry newEntry = new Entry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x << alignShift;  			newEntry.y = t.y << alignShift;  			newEntry.w = matchedWidth;  			newEntry.h = matchedHeight;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		Data currAtlas = new Data ();  		currAtlas.width = thisCellW << alignShift;  		currAtlas.height = thisCellH << alignShift;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			if (forceSquare) {  				thisCellW *= 2;  				thisCellH *= 2;  			}  			else {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  			}  			reverted = true;  		}  		else {  			if (forceSquare) {  				thisCellH /= 2;  				thisCellW /= 2;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  		}  		numPasses++;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  		List<Entry> atlasEntries = new List<Entry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedWidth = 0;  			int matchedHeight = 0;  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.width && height == t.height) {  					matchedId = i;  					matchedWidth = sourceRects [i].width;  					matchedHeight = sourceRects [i].height;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.height && height == t.width) {  						matchedId = i;  						flipped = true;  						matchedWidth = sourceRects [i].height;  						matchedHeight = sourceRects [i].width;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			Entry newEntry = new Entry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x << alignShift;  			newEntry.y = t.y << alignShift;  			newEntry.w = matchedWidth;  			newEntry.h = matchedHeight;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		Data currAtlas = new Data ();  		currAtlas.width = thisCellW << alignShift;  		currAtlas.height = thisCellH << alignShift;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			if (forceSquare) {  				thisCellW *= 2;  				thisCellH *= 2;  			}  			else {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  			}  			reverted = true;  		}  		else {  			if (forceSquare) {  				thisCellH /= 2;  				thisCellW /= 2;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  		}  		numPasses++;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  		List<Entry> atlasEntries = new List<Entry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedWidth = 0;  			int matchedHeight = 0;  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.width && height == t.height) {  					matchedId = i;  					matchedWidth = sourceRects [i].width;  					matchedHeight = sourceRects [i].height;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.height && height == t.width) {  						matchedId = i;  						flipped = true;  						matchedWidth = sourceRects [i].height;  						matchedHeight = sourceRects [i].width;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			Entry newEntry = new Entry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x << alignShift;  			newEntry.y = t.y << alignShift;  			newEntry.w = matchedWidth;  			newEntry.h = matchedHeight;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		Data currAtlas = new Data ();  		currAtlas.width = thisCellW << alignShift;  		currAtlas.height = thisCellH << alignShift;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			if (forceSquare) {  				thisCellW *= 2;  				thisCellH *= 2;  			}  			else {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  			}  			reverted = true;  		}  		else {  			if (forceSquare) {  				thisCellH /= 2;  				thisCellW /= 2;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  		}  		numPasses++;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  		List<Entry> atlasEntries = new List<Entry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedWidth = 0;  			int matchedHeight = 0;  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.width && height == t.height) {  					matchedId = i;  					matchedWidth = sourceRects [i].width;  					matchedHeight = sourceRects [i].height;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.height && height == t.width) {  						matchedId = i;  						flipped = true;  						matchedWidth = sourceRects [i].height;  						matchedHeight = sourceRects [i].width;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			Entry newEntry = new Entry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x << alignShift;  			newEntry.y = t.y << alignShift;  			newEntry.w = matchedWidth;  			newEntry.h = matchedHeight;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		Data currAtlas = new Data ();  		currAtlas.width = thisCellW << alignShift;  		currAtlas.height = thisCellH << alignShift;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			if (forceSquare) {  				thisCellW *= 2;  				thisCellH *= 2;  			}  			else {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  			}  			reverted = true;  		}  		else {  			if (forceSquare) {  				thisCellH /= 2;  				thisCellW /= 2;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  		}  		numPasses++;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  		List<Entry> atlasEntries = new List<Entry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedWidth = 0;  			int matchedHeight = 0;  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.width && height == t.height) {  					matchedId = i;  					matchedWidth = sourceRects [i].width;  					matchedHeight = sourceRects [i].height;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.height && height == t.width) {  						matchedId = i;  						flipped = true;  						matchedWidth = sourceRects [i].height;  						matchedHeight = sourceRects [i].width;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			Entry newEntry = new Entry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x << alignShift;  			newEntry.y = t.y << alignShift;  			newEntry.w = matchedWidth;  			newEntry.h = matchedHeight;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		Data currAtlas = new Data ();  		currAtlas.width = thisCellW << alignShift;  		currAtlas.height = thisCellH << alignShift;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			if (forceSquare) {  				thisCellW *= 2;  				thisCellH *= 2;  			}  			else {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  			}  			reverted = true;  		}  		else {  			if (forceSquare) {  				thisCellH /= 2;  				thisCellW /= 2;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  		}  		numPasses++;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  		List<Entry> atlasEntries = new List<Entry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedWidth = 0;  			int matchedHeight = 0;  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.width && height == t.height) {  					matchedId = i;  					matchedWidth = sourceRects [i].width;  					matchedHeight = sourceRects [i].height;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.height && height == t.width) {  						matchedId = i;  						flipped = true;  						matchedWidth = sourceRects [i].height;  						matchedHeight = sourceRects [i].width;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			Entry newEntry = new Entry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x << alignShift;  			newEntry.y = t.y << alignShift;  			newEntry.w = matchedWidth;  			newEntry.h = matchedHeight;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		Data currAtlas = new Data ();  		currAtlas.width = thisCellW << alignShift;  		currAtlas.height = thisCellH << alignShift;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			if (forceSquare) {  				thisCellW *= 2;  				thisCellH *= 2;  			}  			else {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  			}  			reverted = true;  		}  		else {  			if (forceSquare) {  				thisCellH /= 2;  				thisCellW /= 2;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  		}  		numPasses++;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  		List<Entry> atlasEntries = new List<Entry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedWidth = 0;  			int matchedHeight = 0;  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.width && height == t.height) {  					matchedId = i;  					matchedWidth = sourceRects [i].width;  					matchedHeight = sourceRects [i].height;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.height && height == t.width) {  						matchedId = i;  						flipped = true;  						matchedWidth = sourceRects [i].height;  						matchedHeight = sourceRects [i].width;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			Entry newEntry = new Entry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x << alignShift;  			newEntry.y = t.y << alignShift;  			newEntry.w = matchedWidth;  			newEntry.h = matchedHeight;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		Data currAtlas = new Data ();  		currAtlas.width = thisCellW << alignShift;  		currAtlas.height = thisCellH << alignShift;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			if (forceSquare) {  				thisCellW *= 2;  				thisCellH *= 2;  			}  			else {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  			}  			reverted = true;  		}  		else {  			if (forceSquare) {  				thisCellH /= 2;  				thisCellW /= 2;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  		}  		numPasses++;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: while (numPasses > 0) {  	// Create copy to make sure we can scale textures down when necessary  	List<RectSize> currRects = new List<RectSize> (rects);  	//					MaxRectsBinPack binPacker = new MaxRectsBinPack(thisCellW' thisCellH);  	//					allUsed = binPacker.Insert(currRects' MaxRectsBinPack.FreeRectChoiceHeuristic.RectBestAreaFit);  	MaxRectsBinPack binPacker = FindBestBinPacker (thisCellW' thisCellH' ref currRects' ref allUsed);  	float occupancy = binPacker.Occupancy ();  	// Consider the atlas resolved when after the first pass' all textures are used' and the occupancy > 0.5f' scaling  	// down by half to maintain PO2 requirements means this is as good as it gets  	bool firstPassFull = numPasses == 1 && occupancy > 0.5f;  	// Reverted copes with the case when halving the atlas size when occupancy < 0.5f' the textures don't fit in the  	// atlas anymore. At this point' size is reverted to the previous value' and the loop should accept this as the final value  	if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  		List<Entry> atlasEntries = new List<Entry> ();  		foreach (var t in binPacker.GetMapped ()) {  			int matchedWidth = 0;  			int matchedHeight = 0;  			int matchedId = -1;  			bool flipped = false;  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.width && height == t.height) {  					matchedId = i;  					matchedWidth = sourceRects [i].width;  					matchedHeight = sourceRects [i].height;  					break;  				}  			}  			// Not matched anything yet' so look for the same rects rotated  			if (matchedId == -1) {  				for (int i = 0; i < sourceRects.Count; ++i) {  					int width = (sourceRects [i].width + align) >> alignShift;  					int height = (sourceRects [i].height + align) >> alignShift;  					if (!usedRect [i] && width == t.height && height == t.width) {  						matchedId = i;  						flipped = true;  						matchedWidth = sourceRects [i].height;  						matchedHeight = sourceRects [i].width;  						break;  					}  				}  			}  			// If this fails its a catastrophic error  			usedRect [matchedId] = true;  			Entry newEntry = new Entry ();  			newEntry.flipped = flipped;  			newEntry.x = t.x << alignShift;  			newEntry.y = t.y << alignShift;  			newEntry.w = matchedWidth;  			newEntry.h = matchedHeight;  			newEntry.index = matchedId;  			atlasEntries.Add (newEntry);  		}  		Data currAtlas = new Data ();  		currAtlas.width = thisCellW << alignShift;  		currAtlas.height = thisCellH << alignShift;  		currAtlas.occupancy = binPacker.Occupancy ();  		currAtlas.entries = atlasEntries.ToArray ();  		atlases.Add (currAtlas);  		rects = currRects;  		break;  		// done  	}  	else {  		if (!allUsed) {  			if (forceSquare) {  				thisCellW *= 2;  				thisCellH *= 2;  			}  			else {  				// Can only try another size when it already has been scaled down for the first time  				if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  					// Tried to scale down' but the texture doesn't fit' so revert previous change' and   					// iterate over the data again forcing a pass even though there is wastage  					if (thisCellW < thisCellH)  						thisCellW *= 2;  					else  						thisCellH *= 2;  				}  			}  			reverted = true;  		}  		else {  			if (forceSquare) {  				thisCellH /= 2;  				thisCellW /= 2;  			}  			else {  				// More than half the texture was unused' scale down by one of the dimensions  				if (thisCellW < thisCellH)  					thisCellH /= 2;  				else  					thisCellW /= 2;  			}  		}  		numPasses++;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  	List<Entry> atlasEntries = new List<Entry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedWidth = 0;  		int matchedHeight = 0;  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			int width = (sourceRects [i].width + align) >> alignShift;  			int height = (sourceRects [i].height + align) >> alignShift;  			if (!usedRect [i] && width == t.width && height == t.height) {  				matchedId = i;  				matchedWidth = sourceRects [i].width;  				matchedHeight = sourceRects [i].height;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.height && height == t.width) {  					matchedId = i;  					flipped = true;  					matchedWidth = sourceRects [i].height;  					matchedHeight = sourceRects [i].width;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		Entry newEntry = new Entry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x << alignShift;  		newEntry.y = t.y << alignShift;  		newEntry.w = matchedWidth;  		newEntry.h = matchedHeight;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	Data currAtlas = new Data ();  	currAtlas.width = thisCellW << alignShift;  	currAtlas.height = thisCellH << alignShift;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		if (forceSquare) {  			thisCellW *= 2;  			thisCellH *= 2;  		}  		else {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  		}  		reverted = true;  	}  	else {  		if (forceSquare) {  			thisCellH /= 2;  			thisCellW /= 2;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  	}  	numPasses++;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  	List<Entry> atlasEntries = new List<Entry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedWidth = 0;  		int matchedHeight = 0;  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			int width = (sourceRects [i].width + align) >> alignShift;  			int height = (sourceRects [i].height + align) >> alignShift;  			if (!usedRect [i] && width == t.width && height == t.height) {  				matchedId = i;  				matchedWidth = sourceRects [i].width;  				matchedHeight = sourceRects [i].height;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.height && height == t.width) {  					matchedId = i;  					flipped = true;  					matchedWidth = sourceRects [i].height;  					matchedHeight = sourceRects [i].width;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		Entry newEntry = new Entry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x << alignShift;  		newEntry.y = t.y << alignShift;  		newEntry.w = matchedWidth;  		newEntry.h = matchedHeight;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	Data currAtlas = new Data ();  	currAtlas.width = thisCellW << alignShift;  	currAtlas.height = thisCellH << alignShift;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		if (forceSquare) {  			thisCellW *= 2;  			thisCellH *= 2;  		}  		else {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  		}  		reverted = true;  	}  	else {  		if (forceSquare) {  			thisCellH /= 2;  			thisCellW /= 2;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  	}  	numPasses++;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  	List<Entry> atlasEntries = new List<Entry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedWidth = 0;  		int matchedHeight = 0;  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			int width = (sourceRects [i].width + align) >> alignShift;  			int height = (sourceRects [i].height + align) >> alignShift;  			if (!usedRect [i] && width == t.width && height == t.height) {  				matchedId = i;  				matchedWidth = sourceRects [i].width;  				matchedHeight = sourceRects [i].height;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.height && height == t.width) {  					matchedId = i;  					flipped = true;  					matchedWidth = sourceRects [i].height;  					matchedHeight = sourceRects [i].width;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		Entry newEntry = new Entry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x << alignShift;  		newEntry.y = t.y << alignShift;  		newEntry.w = matchedWidth;  		newEntry.h = matchedHeight;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	Data currAtlas = new Data ();  	currAtlas.width = thisCellW << alignShift;  	currAtlas.height = thisCellH << alignShift;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		if (forceSquare) {  			thisCellW *= 2;  			thisCellH *= 2;  		}  		else {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  		}  		reverted = true;  	}  	else {  		if (forceSquare) {  			thisCellH /= 2;  			thisCellW /= 2;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  	}  	numPasses++;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  	List<Entry> atlasEntries = new List<Entry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedWidth = 0;  		int matchedHeight = 0;  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			int width = (sourceRects [i].width + align) >> alignShift;  			int height = (sourceRects [i].height + align) >> alignShift;  			if (!usedRect [i] && width == t.width && height == t.height) {  				matchedId = i;  				matchedWidth = sourceRects [i].width;  				matchedHeight = sourceRects [i].height;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.height && height == t.width) {  					matchedId = i;  					flipped = true;  					matchedWidth = sourceRects [i].height;  					matchedHeight = sourceRects [i].width;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		Entry newEntry = new Entry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x << alignShift;  		newEntry.y = t.y << alignShift;  		newEntry.w = matchedWidth;  		newEntry.h = matchedHeight;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	Data currAtlas = new Data ();  	currAtlas.width = thisCellW << alignShift;  	currAtlas.height = thisCellH << alignShift;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		if (forceSquare) {  			thisCellW *= 2;  			thisCellH *= 2;  		}  		else {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  		}  		reverted = true;  	}  	else {  		if (forceSquare) {  			thisCellH /= 2;  			thisCellW /= 2;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  	}  	numPasses++;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  	List<Entry> atlasEntries = new List<Entry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedWidth = 0;  		int matchedHeight = 0;  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			int width = (sourceRects [i].width + align) >> alignShift;  			int height = (sourceRects [i].height + align) >> alignShift;  			if (!usedRect [i] && width == t.width && height == t.height) {  				matchedId = i;  				matchedWidth = sourceRects [i].width;  				matchedHeight = sourceRects [i].height;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.height && height == t.width) {  					matchedId = i;  					flipped = true;  					matchedWidth = sourceRects [i].height;  					matchedHeight = sourceRects [i].width;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		Entry newEntry = new Entry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x << alignShift;  		newEntry.y = t.y << alignShift;  		newEntry.w = matchedWidth;  		newEntry.h = matchedHeight;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	Data currAtlas = new Data ();  	currAtlas.width = thisCellW << alignShift;  	currAtlas.height = thisCellH << alignShift;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		if (forceSquare) {  			thisCellW *= 2;  			thisCellH *= 2;  		}  		else {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  		}  		reverted = true;  	}  	else {  		if (forceSquare) {  			thisCellH /= 2;  			thisCellW /= 2;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  	}  	numPasses++;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  	List<Entry> atlasEntries = new List<Entry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedWidth = 0;  		int matchedHeight = 0;  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			int width = (sourceRects [i].width + align) >> alignShift;  			int height = (sourceRects [i].height + align) >> alignShift;  			if (!usedRect [i] && width == t.width && height == t.height) {  				matchedId = i;  				matchedWidth = sourceRects [i].width;  				matchedHeight = sourceRects [i].height;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.height && height == t.width) {  					matchedId = i;  					flipped = true;  					matchedWidth = sourceRects [i].height;  					matchedHeight = sourceRects [i].width;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		Entry newEntry = new Entry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x << alignShift;  		newEntry.y = t.y << alignShift;  		newEntry.w = matchedWidth;  		newEntry.h = matchedHeight;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	Data currAtlas = new Data ();  	currAtlas.width = thisCellW << alignShift;  	currAtlas.height = thisCellH << alignShift;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		if (forceSquare) {  			thisCellW *= 2;  			thisCellH *= 2;  		}  		else {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  		}  		reverted = true;  	}  	else {  		if (forceSquare) {  			thisCellH /= 2;  			thisCellW /= 2;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  	}  	numPasses++;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  	List<Entry> atlasEntries = new List<Entry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedWidth = 0;  		int matchedHeight = 0;  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			int width = (sourceRects [i].width + align) >> alignShift;  			int height = (sourceRects [i].height + align) >> alignShift;  			if (!usedRect [i] && width == t.width && height == t.height) {  				matchedId = i;  				matchedWidth = sourceRects [i].width;  				matchedHeight = sourceRects [i].height;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.height && height == t.width) {  					matchedId = i;  					flipped = true;  					matchedWidth = sourceRects [i].height;  					matchedHeight = sourceRects [i].width;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		Entry newEntry = new Entry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x << alignShift;  		newEntry.y = t.y << alignShift;  		newEntry.w = matchedWidth;  		newEntry.h = matchedHeight;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	Data currAtlas = new Data ();  	currAtlas.width = thisCellW << alignShift;  	currAtlas.height = thisCellH << alignShift;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		if (forceSquare) {  			thisCellW *= 2;  			thisCellH *= 2;  		}  		else {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  		}  		reverted = true;  	}  	else {  		if (forceSquare) {  			thisCellH /= 2;  			thisCellW /= 2;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  	}  	numPasses++;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (firstPassFull || (numPasses > 1 && occupancy > 0.5f && allUsed) || reverted || !allowOptimizeSize) {  	List<Entry> atlasEntries = new List<Entry> ();  	foreach (var t in binPacker.GetMapped ()) {  		int matchedWidth = 0;  		int matchedHeight = 0;  		int matchedId = -1;  		bool flipped = false;  		for (int i = 0; i < sourceRects.Count; ++i) {  			int width = (sourceRects [i].width + align) >> alignShift;  			int height = (sourceRects [i].height + align) >> alignShift;  			if (!usedRect [i] && width == t.width && height == t.height) {  				matchedId = i;  				matchedWidth = sourceRects [i].width;  				matchedHeight = sourceRects [i].height;  				break;  			}  		}  		// Not matched anything yet' so look for the same rects rotated  		if (matchedId == -1) {  			for (int i = 0; i < sourceRects.Count; ++i) {  				int width = (sourceRects [i].width + align) >> alignShift;  				int height = (sourceRects [i].height + align) >> alignShift;  				if (!usedRect [i] && width == t.height && height == t.width) {  					matchedId = i;  					flipped = true;  					matchedWidth = sourceRects [i].height;  					matchedHeight = sourceRects [i].width;  					break;  				}  			}  		}  		// If this fails its a catastrophic error  		usedRect [matchedId] = true;  		Entry newEntry = new Entry ();  		newEntry.flipped = flipped;  		newEntry.x = t.x << alignShift;  		newEntry.y = t.y << alignShift;  		newEntry.w = matchedWidth;  		newEntry.h = matchedHeight;  		newEntry.index = matchedId;  		atlasEntries.Add (newEntry);  	}  	Data currAtlas = new Data ();  	currAtlas.width = thisCellW << alignShift;  	currAtlas.height = thisCellH << alignShift;  	currAtlas.occupancy = binPacker.Occupancy ();  	currAtlas.entries = atlasEntries.ToArray ();  	atlases.Add (currAtlas);  	rects = currRects;  	break;  	// done  }  else {  	if (!allUsed) {  		if (forceSquare) {  			thisCellW *= 2;  			thisCellH *= 2;  		}  		else {  			// Can only try another size when it already has been scaled down for the first time  			if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  				// Tried to scale down' but the texture doesn't fit' so revert previous change' and   				// iterate over the data again forcing a pass even though there is wastage  				if (thisCellW < thisCellH)  					thisCellW *= 2;  				else  					thisCellH *= 2;  			}  		}  		reverted = true;  	}  	else {  		if (forceSquare) {  			thisCellH /= 2;  			thisCellW /= 2;  		}  		else {  			// More than half the texture was unused' scale down by one of the dimensions  			if (thisCellW < thisCellH)  				thisCellH /= 2;  			else  				thisCellW /= 2;  		}  	}  	numPasses++;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	if (forceSquare) {  		thisCellW *= 2;  		thisCellH *= 2;  	}  	else {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  	}  	reverted = true;  }  else {  	if (forceSquare) {  		thisCellH /= 2;  		thisCellW /= 2;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	if (forceSquare) {  		thisCellW *= 2;  		thisCellH *= 2;  	}  	else {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  	}  	reverted = true;  }  else {  	if (forceSquare) {  		thisCellH /= 2;  		thisCellW /= 2;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	if (forceSquare) {  		thisCellW *= 2;  		thisCellH *= 2;  	}  	else {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  	}  	reverted = true;  }  else {  	if (forceSquare) {  		thisCellH /= 2;  		thisCellW /= 2;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	if (forceSquare) {  		thisCellW *= 2;  		thisCellH *= 2;  	}  	else {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  	}  	reverted = true;  }  else {  	if (forceSquare) {  		thisCellH /= 2;  		thisCellW /= 2;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	if (forceSquare) {  		thisCellW *= 2;  		thisCellH *= 2;  	}  	else {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  	}  	reverted = true;  }  else {  	if (forceSquare) {  		thisCellH /= 2;  		thisCellW /= 2;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	if (forceSquare) {  		thisCellW *= 2;  		thisCellH *= 2;  	}  	else {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  	}  	reverted = true;  }  else {  	if (forceSquare) {  		thisCellH /= 2;  		thisCellW /= 2;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	if (forceSquare) {  		thisCellW *= 2;  		thisCellH *= 2;  	}  	else {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  	}  	reverted = true;  }  else {  	if (forceSquare) {  		thisCellH /= 2;  		thisCellW /= 2;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (!allUsed) {  	if (forceSquare) {  		thisCellW *= 2;  		thisCellH *= 2;  	}  	else {  		// Can only try another size when it already has been scaled down for the first time  		if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  			// Tried to scale down' but the texture doesn't fit' so revert previous change' and   			// iterate over the data again forcing a pass even though there is wastage  			if (thisCellW < thisCellH)  				thisCellW *= 2;  			else  				thisCellH *= 2;  		}  	}  	reverted = true;  }  else {  	if (forceSquare) {  		thisCellH /= 2;  		thisCellW /= 2;  	}  	else {  		// More than half the texture was unused' scale down by one of the dimensions  		if (thisCellW < thisCellH)  			thisCellH /= 2;  		else  			thisCellW /= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (forceSquare) {  	thisCellW *= 2;  	thisCellH *= 2;  }  else {  	// Can only try another size when it already has been scaled down for the first time  	if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  		// Tried to scale down' but the texture doesn't fit' so revert previous change' and   		// iterate over the data again forcing a pass even though there is wastage  		if (thisCellW < thisCellH)  			thisCellW *= 2;  		else  			thisCellH *= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (forceSquare) {  	thisCellW *= 2;  	thisCellH *= 2;  }  else {  	// Can only try another size when it already has been scaled down for the first time  	if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  		// Tried to scale down' but the texture doesn't fit' so revert previous change' and   		// iterate over the data again forcing a pass even though there is wastage  		if (thisCellW < thisCellH)  			thisCellW *= 2;  		else  			thisCellH *= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (forceSquare) {  	thisCellW *= 2;  	thisCellH *= 2;  }  else {  	// Can only try another size when it already has been scaled down for the first time  	if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  		// Tried to scale down' but the texture doesn't fit' so revert previous change' and   		// iterate over the data again forcing a pass even though there is wastage  		if (thisCellW < thisCellH)  			thisCellW *= 2;  		else  			thisCellH *= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (forceSquare) {  	thisCellW *= 2;  	thisCellH *= 2;  }  else {  	// Can only try another size when it already has been scaled down for the first time  	if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  		// Tried to scale down' but the texture doesn't fit' so revert previous change' and   		// iterate over the data again forcing a pass even though there is wastage  		if (thisCellW < thisCellH)  			thisCellW *= 2;  		else  			thisCellH *= 2;  	}  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: thisCellW *= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: thisCellH *= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  	// Tried to scale down' but the texture doesn't fit' so revert previous change' and   	// iterate over the data again forcing a pass even though there is wastage  	if (thisCellW < thisCellH)  		thisCellW *= 2;  	else  		thisCellH *= 2;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < atlasWidth || thisCellH < atlasHeight) {  	// Tried to scale down' but the texture doesn't fit' so revert previous change' and   	// iterate over the data again forcing a pass even though there is wastage  	if (thisCellW < thisCellH)  		thisCellW *= 2;  	else  		thisCellH *= 2;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < thisCellH)  	thisCellW *= 2;  else  	thisCellH *= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < thisCellH)  	thisCellW *= 2;  else  	thisCellH *= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: thisCellW *= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: thisCellH *= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (forceSquare) {  	thisCellH /= 2;  	thisCellW /= 2;  }  else {  	// More than half the texture was unused' scale down by one of the dimensions  	if (thisCellW < thisCellH)  		thisCellH /= 2;  	else  		thisCellW /= 2;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (forceSquare) {  	thisCellH /= 2;  	thisCellW /= 2;  }  else {  	// More than half the texture was unused' scale down by one of the dimensions  	if (thisCellW < thisCellH)  		thisCellH /= 2;  	else  		thisCellW /= 2;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (forceSquare) {  	thisCellH /= 2;  	thisCellW /= 2;  }  else {  	// More than half the texture was unused' scale down by one of the dimensions  	if (thisCellW < thisCellH)  		thisCellH /= 2;  	else  		thisCellW /= 2;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (forceSquare) {  	thisCellH /= 2;  	thisCellW /= 2;  }  else {  	// More than half the texture was unused' scale down by one of the dimensions  	if (thisCellW < thisCellH)  		thisCellH /= 2;  	else  		thisCellW /= 2;  }  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: thisCellH /= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: thisCellW /= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < thisCellH)  	thisCellH /= 2;  else  	thisCellW /= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: if (thisCellW < thisCellH)  	thisCellH /= 2;  else  	thisCellW /= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: thisCellH /= 2;  
Magic Number,tk2dEditor.Atlas,Builder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dAtlasBuilder.cs,Build,The following statement contains a magic number: thisCellW /= 2;  
Magic Number,tk2dEditor.SpriteAnimationEditor,ClipTools,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,ClipTools,The following statement contains a magic number: sortId = -1000;  
Magic Number,tk2dEditor.SpriteAnimationEditor,DeleteFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,DeleteFrames,The following statement contains a magic number: sortId = -50;  
Magic Number,tk2dEditor.SpriteAnimationEditor,DeleteFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,OnFrameGroupInspectorGUI,The following statement contains a magic number: if (frameGroups.Count > 1) {  	GUILayout.Space (16);  	if (GUILayout.Button ("Delete"' EditorStyles.miniButton)) {  		frameGroups.RemoveAt (state.selectedFrame);  		state.selectedFrame = -1;  		changed = true;  	}  	GUILayout.BeginHorizontal ();  	if (GUILayout.Button ("Delete <"' EditorStyles.miniButton)) {  		frameGroups.RemoveRange (0' state.selectedFrame);  		changed = true;  		state.selectedFrame = 0;  	}  	if (GUILayout.Button ("Delete >"' EditorStyles.miniButton)) {  		frameGroups.RemoveRange (state.selectedFrame + 1' frameGroups.Count - 1 - state.selectedFrame);  		changed = true;  		state.selectedFrame = frameGroups.Count - 1;  	}  	GUILayout.EndHorizontal ();  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,DeleteFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,OnFrameGroupInspectorGUI,The following statement contains a magic number: GUILayout.Space (16);  
Magic Number,tk2dEditor.SpriteAnimationEditor,InsertFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,InsertFrames,The following statement contains a magic number: sortId = -100;  
Magic Number,tk2dEditor.SpriteAnimationEditor,AutoFillFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,AutoFillFrames,The following statement contains a magic number: sortId = -110;  
Magic Number,tk2dEditor.SpriteAnimationEditor,AutoFillFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,AutoFill,The following statement contains a magic number: if (selectedFrameGroup.spriteCollection != null && selectedFrameGroup.spriteId >= 0 && selectedFrameGroup.spriteId < selectedFrameGroup.spriteCollection.inst.Count) {  	string na = selectedFrameGroup.spriteCollection.inst.spriteDefinitions [selectedFrameGroup.spriteId].name;  	int numStartA = na.Length - 1;  	if (na [numStartA] >= '0' && na [numStartA] <= '9') {  		while (numStartA > 0 && na [numStartA - 1] >= '0' && na [numStartA - 1] <= '9')  			numStartA--;  		string baseName = na.Substring (0' numStartA).ToLower ();  		int baseNo = System.Convert.ToInt32 (na.Substring (numStartA));  		int maxAllowedMissing = 10;  		int allowedMissing = maxAllowedMissing;  		List<int> pendingFrames = new List<int> ();  		int startOffset = reverse ? -1 : 1;  		int frameInc = reverse ? -1 : 1;  		for (int frameNo = baseNo + startOffset; frameNo >= 0; frameNo += frameInc) {  			int frameIdx = FindFrameIndex (selectedFrameGroup.spriteCollection.inst.spriteDefinitions' baseName' frameNo);  			if (frameIdx == -1) {  				if (--allowedMissing <= 0)  					break;  			}  			else {  				pendingFrames.Add (frameIdx);  				allowedMissing = maxAllowedMissing;  				// reset  			}  		}  		int numInserted = 0;  		int insertIndex = selectedFrame + 1;  		ClipEditor.FrameGroup nextFrameGroup = (insertIndex >= frameGroups.Count) ? null : frameGroups [insertIndex];  		while (pendingFrames.Count > 0) {  			int frameToInsert = pendingFrames [0];  			pendingFrames.RemoveAt (0);  			if (nextFrameGroup != null && nextFrameGroup.spriteCollection == selectedFrameGroup.spriteCollection && nextFrameGroup.spriteId == frameToInsert)  				break;  			ClipEditor.FrameGroup fg = AnimOperatorUtil.NewFrameGroup (frameGroups' selectedFrame);  			fg.spriteId = frameToInsert;  			fg.Update ();  			frameGroups.Insert (insertIndex++' fg);  			numInserted++;  		}  		return numInserted > 0;  	}  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,AutoFillFrames,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationAnimOp.cs,AutoFill,The following statement contains a magic number: if (na [numStartA] >= '0' && na [numStartA] <= '9') {  	while (numStartA > 0 && na [numStartA - 1] >= '0' && na [numStartA - 1] <= '9')  		numStartA--;  	string baseName = na.Substring (0' numStartA).ToLower ();  	int baseNo = System.Convert.ToInt32 (na.Substring (numStartA));  	int maxAllowedMissing = 10;  	int allowedMissing = maxAllowedMissing;  	List<int> pendingFrames = new List<int> ();  	int startOffset = reverse ? -1 : 1;  	int frameInc = reverse ? -1 : 1;  	for (int frameNo = baseNo + startOffset; frameNo >= 0; frameNo += frameInc) {  		int frameIdx = FindFrameIndex (selectedFrameGroup.spriteCollection.inst.spriteDefinitions' baseName' frameNo);  		if (frameIdx == -1) {  			if (--allowedMissing <= 0)  				break;  		}  		else {  			pendingFrames.Add (frameIdx);  			allowedMissing = maxAllowedMissing;  			// reset  		}  	}  	int numInserted = 0;  	int insertIndex = selectedFrame + 1;  	ClipEditor.FrameGroup nextFrameGroup = (insertIndex >= frameGroups.Count) ? null : frameGroups [insertIndex];  	while (pendingFrames.Count > 0) {  		int frameToInsert = pendingFrames [0];  		pendingFrames.RemoveAt (0);  		if (nextFrameGroup != null && nextFrameGroup.spriteCollection == selectedFrameGroup.spriteCollection && nextFrameGroup.spriteId == frameToInsert)  			break;  		ClipEditor.FrameGroup fg = AnimOperatorUtil.NewFrameGroup (frameGroups' selectedFrame);  		fg.spriteId = frameToInsert;  		fg.Update ();  		frameGroups.Insert (insertIndex++' fg);  		numInserted++;  	}  	return numInserted > 0;  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,The following statement contains a magic number: if (GUILayout.Button ("Delete"' GUILayout.Width (46)) && EditorUtility.DisplayDialog ("Delete clip"' "Are you sure you want to delete the selected clip?"' "Yes"' "No")) {  	OnClipDeleted ();  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,The following statement contains a magic number: GUILayout.Space (8);  
Magic Number,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawClipInspector,The following statement contains a magic number: GUILayout.Space (8);  
Magic Number,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawFrameInspector,The following statement contains a magic number: GUILayout.Space (8);  
Magic Number,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawTransportToolbar,The following statement contains a magic number: tk2dPreferences.inst.gridType = (tk2dGrid.Type)EditorGUILayout.EnumPopup (tk2dPreferences.inst.gridType' EditorStyles.toolbarDropDown' GUILayout.Width (95));  
Magic Number,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawTriggerInspector,The following statement contains a magic number: GUILayout.Space (8);  
Magic Number,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,DrawInspector,The following statement contains a magic number: inspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819518' viewRect' 0' tk2dGuiUtility.DragDirection.Horizontal);  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,GetRectForTrigger,The following statement contains a magic number: return new Rect (triggerRect.x + clipLeftHeaderSpace + frameWidth * frame - 3' triggerRect.y + 1' 15' 14);  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,GetRectForTrigger,The following statement contains a magic number: return new Rect (triggerRect.x + clipLeftHeaderSpace + frameWidth * frame - 3' triggerRect.y + 1' 15' 14);  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,GetRectForTrigger,The following statement contains a magic number: return new Rect (triggerRect.x + clipLeftHeaderSpace + frameWidth * frame - 3' triggerRect.y + 1' 15' 14);  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,Draw,The following statement contains a magic number: GUILayout.Box (""' tk2dEditorSkin.Anim_BG' GUILayout.ExpandWidth (true)' GUILayout.Height (16));  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,Draw,The following statement contains a magic number: if (GUIUtility.hotControl == 0 && triggerHelpBox.Contains (Event.current.mousePosition))  	GUI.Label (new Rect (triggerHelpBox.x' triggerHelpBox.y' 150' triggerHelpBox.height)' "Double click to add triggers"' EditorStyles.whiteMiniLabel);  else  	GUI.Label (triggerHelpBox' "?"' EditorStyles.whiteMiniLabel);  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,Draw,The following statement contains a magic number: GUI.Label (new Rect (triggerHelpBox.x' triggerHelpBox.y' 150' triggerHelpBox.height)' "Double click to add triggers"' EditorStyles.whiteMiniLabel);  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawAxis,The following statement contains a magic number: if (Event.current.type == EventType.Repaint) {  	float minWidthPerTick = 50;  	int ticksPerStep = (int)Mathf.Ceil (minWidthPerTick / widthPerTick);  	float t = 0.0f;  	float x = r.x;  	while (x < r.x + r.width) {  		GUI.Label (new Rect (x' r.y' r.width' r.height)' t.ToString ("0.00")' EditorStyles.miniLabel);  		x += widthPerTick * ticksPerStep;  		t += ticksPerStep / clip.fps;  	}  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The following statement contains a magic number: if (GUIUtility.hotControl == controlId && state.type == State.Type.Move && state.activeFrame != -1 && state.insertMarker != -1) {  	Vector2 v = GetInsertMarkerPositionForFrameGroup (frameGroupRect' state.insertMarker' frameGroups);  	GUI.color = Color.green;  	GUI.Box (new Rect (v.x' v.y' 2' frameGroupRect.height)' ""' tk2dEditorSkin.WhiteBox);  	GUI.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The following statement contains a magic number: GUI.Box (new Rect (v.x' v.y' 2' frameGroupRect.height)' ""' tk2dEditorSkin.WhiteBox);  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The following statement contains a magic number: if (clipTimeMarker >= 0.0f) {  	float x = clipLeftHeaderSpace + frameWidth * clipTimeMarker;  	GUI.color = Color.red;  	GUI.Box (new Rect (frameGroupRect.x + x' frameGroupRect.y' 2' frameGroupRect.height)' ""' tk2dEditorSkin.WhiteBox);  	GUI.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The following statement contains a magic number: GUI.Box (new Rect (frameGroupRect.x + x' frameGroupRect.y' 2' frameGroupRect.height)' ""' tk2dEditorSkin.WhiteBox);  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The following statement contains a magic number: if (ev.type == EventType.MouseDown || GUIUtility.hotControl == controlId) {  	switch (ev.GetTypeForControl (controlId)) {  	case EventType.MouseDown:  		if (triggerRect.Contains (ev.mousePosition) && ev.button == 0) {  			int selectedTrigger = GetSelectedTrigger (triggerRect' ev.mousePosition);  			int selectedTriggerRegion = GetRoundedSelectedTrigger (triggerRect' ev.mousePosition);  			bool startDrag = state.selectedTrigger == selectedTriggerRegion;  			if (ev.clickCount == 1) {  				if (startDrag && selectedTriggerRegion == state.selectedTrigger) {  					GUIUtility.hotControl = controlId;  				}  				else if (selectedTrigger >= 0 && selectedTrigger < clip.frames.Length && clip.frames [selectedTrigger].triggerEvent) {  					state.selectedTrigger = selectedTrigger;  					Repaint ();  					GUIUtility.hotControl = controlId;  				}  			}  			// Double click on an empty area  			if (GUIUtility.hotControl == 0 && ev.clickCount == 2 && selectedTriggerRegion >= 0 && selectedTriggerRegion < clip.frames.Length && !clip.frames [selectedTriggerRegion].triggerEvent) {  				clip.frames [selectedTriggerRegion].triggerEvent = true;  				state.selectedTrigger = selectedTriggerRegion;  				Repaint ();  			}  			GUIUtility.keyboardControl = 0;  		}  		break;  	case EventType.MouseDrag:  		{  			int selectedTrigger = Mathf.Clamp (GetRoundedSelectedTrigger (triggerRect' ev.mousePosition)' 0' clip.frames.Length - 1);  			if (state.movingTrigger != selectedTrigger) {  				state.movingTrigger = selectedTrigger;  				Repaint ();  			}  		}  		break;  	case EventType.MouseUp:  		if (state.movingTrigger != -1 && state.movingTrigger != state.selectedTrigger) {  			tk2dSpriteAnimationFrame source = clip.frames [state.selectedTrigger];  			tk2dSpriteAnimationFrame dest = clip.frames [state.movingTrigger];  			dest.CopyTriggerFrom (source);  			source.ClearTrigger ();  			state.selectedTrigger = state.movingTrigger;  		}  		Repaint ();  		state.ResetState ();  		GUIUtility.hotControl = 0;  		break;  	}  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The following statement contains a magic number: switch (ev.GetTypeForControl (controlId)) {  case EventType.MouseDown:  	if (triggerRect.Contains (ev.mousePosition) && ev.button == 0) {  		int selectedTrigger = GetSelectedTrigger (triggerRect' ev.mousePosition);  		int selectedTriggerRegion = GetRoundedSelectedTrigger (triggerRect' ev.mousePosition);  		bool startDrag = state.selectedTrigger == selectedTriggerRegion;  		if (ev.clickCount == 1) {  			if (startDrag && selectedTriggerRegion == state.selectedTrigger) {  				GUIUtility.hotControl = controlId;  			}  			else if (selectedTrigger >= 0 && selectedTrigger < clip.frames.Length && clip.frames [selectedTrigger].triggerEvent) {  				state.selectedTrigger = selectedTrigger;  				Repaint ();  				GUIUtility.hotControl = controlId;  			}  		}  		// Double click on an empty area  		if (GUIUtility.hotControl == 0 && ev.clickCount == 2 && selectedTriggerRegion >= 0 && selectedTriggerRegion < clip.frames.Length && !clip.frames [selectedTriggerRegion].triggerEvent) {  			clip.frames [selectedTriggerRegion].triggerEvent = true;  			state.selectedTrigger = selectedTriggerRegion;  			Repaint ();  		}  		GUIUtility.keyboardControl = 0;  	}  	break;  case EventType.MouseDrag:  	{  		int selectedTrigger = Mathf.Clamp (GetRoundedSelectedTrigger (triggerRect' ev.mousePosition)' 0' clip.frames.Length - 1);  		if (state.movingTrigger != selectedTrigger) {  			state.movingTrigger = selectedTrigger;  			Repaint ();  		}  	}  	break;  case EventType.MouseUp:  	if (state.movingTrigger != -1 && state.movingTrigger != state.selectedTrigger) {  		tk2dSpriteAnimationFrame source = clip.frames [state.selectedTrigger];  		tk2dSpriteAnimationFrame dest = clip.frames [state.movingTrigger];  		dest.CopyTriggerFrom (source);  		source.ClearTrigger ();  		state.selectedTrigger = state.movingTrigger;  	}  	Repaint ();  	state.ResetState ();  	GUIUtility.hotControl = 0;  	break;  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The following statement contains a magic number: if (triggerRect.Contains (ev.mousePosition) && ev.button == 0) {  	int selectedTrigger = GetSelectedTrigger (triggerRect' ev.mousePosition);  	int selectedTriggerRegion = GetRoundedSelectedTrigger (triggerRect' ev.mousePosition);  	bool startDrag = state.selectedTrigger == selectedTriggerRegion;  	if (ev.clickCount == 1) {  		if (startDrag && selectedTriggerRegion == state.selectedTrigger) {  			GUIUtility.hotControl = controlId;  		}  		else if (selectedTrigger >= 0 && selectedTrigger < clip.frames.Length && clip.frames [selectedTrigger].triggerEvent) {  			state.selectedTrigger = selectedTrigger;  			Repaint ();  			GUIUtility.hotControl = controlId;  		}  	}  	// Double click on an empty area  	if (GUIUtility.hotControl == 0 && ev.clickCount == 2 && selectedTriggerRegion >= 0 && selectedTriggerRegion < clip.frames.Length && !clip.frames [selectedTriggerRegion].triggerEvent) {  		clip.frames [selectedTriggerRegion].triggerEvent = true;  		state.selectedTrigger = selectedTriggerRegion;  		Repaint ();  	}  	GUIUtility.keyboardControl = 0;  }  
Magic Number,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The following statement contains a magic number: if (GUIUtility.hotControl == 0 && ev.clickCount == 2 && selectedTriggerRegion >= 0 && selectedTriggerRegion < clip.frames.Length && !clip.frames [selectedTriggerRegion].triggerEvent) {  	clip.frames [selectedTriggerRegion].triggerEvent = true;  	state.selectedTrigger = selectedTriggerRegion;  	Repaint ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The following statement contains a magic number: if (font.texture != null) {  	font.texture.filterMode = FilterMode.Point;  	int border = 16;  	Rect rect = GUILayoutUtility.GetRect (border + font.texture.width' border + font.texture.height' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	GUI.Label (new Rect (border + rect.x' border + rect.y' font.texture.width' font.texture.height)' font.texture);  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,FontView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorFontView.cs,Draw,The following statement contains a magic number: tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteCollectionProxy,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorProxy.cs,FindUniqueTextureName,The following statement contains a magic number: do {  	string currName = name + " " + count.ToString ();  	if (textureNames.IndexOf (currName) == -1)  		return currName;  	++count;  }  while (count < 1024);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,BeginHeader,The following statement contains a magic number: GUILayout.Space (2);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,EndHeader,The following statement contains a magic number: GUILayout.Space (8);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawPlatforms,The following statement contains a magic number: if (system) {  	int toDelete = -1;  	for (int i = 0; i < SpriteCollection.platforms.Count; ++i) {  		tk2dSpriteCollectionPlatform currentPlatform = SpriteCollection.platforms [i];  		GUILayout.BeginHorizontal ();  		string label = (i == 0) ? "Current platform" : "Platform";  		currentPlatform.name = tk2dGuiUtility.PlatformPopup (system' label' currentPlatform.name);  		bool displayDelete = ((SpriteCollection.platforms.Count == 1 && SpriteCollection.platforms [0].name.Length > 0) || (SpriteCollection.platforms.Count > 1 && i > 0));  		if (displayDelete && GUILayout.Button ("Delete"' EditorStyles.miniButton' GUILayout.MaxWidth (50)))  			toDelete = i;  		GUILayout.EndHorizontal ();  	}  	if (toDelete != -1) {  		tk2dSpriteCollection deletedSpriteCollection = null;  		if (SpriteCollection.platforms.Count == 1) {  			if (SpriteCollection.platforms [0].spriteCollection != null && SpriteCollection.platforms [0].spriteCollection.spriteCollection != null)  				deletedSpriteCollection = SpriteCollection.platforms [0].spriteCollection;  			SpriteCollection.platforms [0].name = "";  			SpriteCollection.platforms [0].spriteCollection = null;  		}  		else {  			if (SpriteCollection.platforms [toDelete].spriteCollection != null && SpriteCollection.platforms [toDelete].spriteCollection.spriteCollection != null)  				deletedSpriteCollection = SpriteCollection.platforms [toDelete].spriteCollection;  			SpriteCollection.platforms.RemoveAt (toDelete);  		}  		if (deletedSpriteCollection != null) {  			foreach (tk2dSpriteCollectionFont f in deletedSpriteCollection.fonts)  				tk2dSystemUtility.UnmakeLoadableAsset (f.data);  			tk2dSystemUtility.UnmakeLoadableAsset (deletedSpriteCollection.spriteCollection);  		}  	}  	if (SpriteCollection.platforms.Count > 1 || (SpriteCollection.platforms.Count == 1 && SpriteCollection.platforms [0].name.Length > 0)) {  		GUILayout.BeginHorizontal ();  		EditorGUILayout.PrefixLabel (" ");  		if (GUILayout.Button ("Add new platform"' EditorStyles.miniButton))  			SpriteCollection.platforms.Add (new tk2dSpriteCollectionPlatform ());  		GUILayout.EndHorizontal ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawPlatforms,The following statement contains a magic number: for (int i = 0; i < SpriteCollection.platforms.Count; ++i) {  	tk2dSpriteCollectionPlatform currentPlatform = SpriteCollection.platforms [i];  	GUILayout.BeginHorizontal ();  	string label = (i == 0) ? "Current platform" : "Platform";  	currentPlatform.name = tk2dGuiUtility.PlatformPopup (system' label' currentPlatform.name);  	bool displayDelete = ((SpriteCollection.platforms.Count == 1 && SpriteCollection.platforms [0].name.Length > 0) || (SpriteCollection.platforms.Count > 1 && i > 0));  	if (displayDelete && GUILayout.Button ("Delete"' EditorStyles.miniButton' GUILayout.MaxWidth (50)))  		toDelete = i;  	GUILayout.EndHorizontal ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawPlatforms,The following statement contains a magic number: if (displayDelete && GUILayout.Button ("Delete"' EditorStyles.miniButton' GUILayout.MaxWidth (50)))  	toDelete = i;  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following statement contains a magic number: SpriteCollection.anisoLevel = (int)EditorGUILayout.IntSlider ("Aniso Level"' SpriteCollection.anisoLevel' 0' 9);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following statement contains a magic number: if (SpriteCollection.globalTextureRescale > 0.4 && SpriteCollection.globalTextureRescale < 0.6)  	curRescaleSelection = 1;  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following statement contains a magic number: if (SpriteCollection.globalTextureRescale > 0.4 && SpriteCollection.globalTextureRescale < 0.6)  	curRescaleSelection = 1;  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following statement contains a magic number: if (SpriteCollection.globalTextureRescale > 0.2 && SpriteCollection.globalTextureRescale < 0.3)  	curRescaleSelection = 2;  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following statement contains a magic number: if (SpriteCollection.globalTextureRescale > 0.2 && SpriteCollection.globalTextureRescale < 0.3)  	curRescaleSelection = 2;  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following statement contains a magic number: if (SpriteCollection.globalTextureRescale > 0.2 && SpriteCollection.globalTextureRescale < 0.3)  	curRescaleSelection = 2;  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following statement contains a magic number: curRescaleSelection = 2;  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following statement contains a magic number: switch (newRescaleSelection) {  case 0:  	SpriteCollection.globalTextureRescale = 1.0f;  	break;  case 1:  	SpriteCollection.globalTextureRescale = 0.5f;  	break;  case 2:  	SpriteCollection.globalTextureRescale = 0.25f;  	break;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawSpriteCollectionSettings,The following statement contains a magic number: GUILayout.Space (4);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,Draw,The following statement contains a magic number: if (padAmountValues == null || padAmountValues.Length == 0) {  	int MAX_PAD_AMOUNT = 18;  	padAmountValues = new int[MAX_PAD_AMOUNT];  	padAmountLabels = new string[MAX_PAD_AMOUNT];  	for (int i = 0; i < MAX_PAD_AMOUNT; ++i) {  		padAmountValues [i] = -1 + i;  		padAmountLabels [i] = (i == 0) ? "Default" : ((i - 1).ToString ());  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,Draw,The following statement contains a magic number: GUILayout.Space (8);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,Draw,The following statement contains a magic number: tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,GetSpriteCoordinateHash,The following statement contains a magic number: return (y << 16) + x;  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The following statement contains a magic number: if (textureReady) {  	GUILayout.BeginVertical (tk2dEditorSkin.SC_InspectorBG' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (false));  	selectedMode = (EditMode)GUILayout.Toolbar ((int)selectedMode' new string[] {  		"Edit"'  		"Config"  	});  	EditorGUILayout.Space ();  	GUILayout.EndVertical ();  	if (selectedMode == EditMode.Edit) {  		if (Event.current.type == EventType.Layout)  			activeSelectedSprites = new List<SpriteCollectionEditorEntry> (selectedSprites);  		if (activeSelectedSprites.Count > 0)  			host.SpriteView.DrawSpriteEditorInspector (activeSelectedSprites' true' true);  	}  	else {  		GUILayout.BeginVertical (tk2dEditorSkin.SC_InspectorBG' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (false));  		spriteSheet.tileWidth = EditorGUILayout.IntField ("Tile Width"' spriteSheet.tileWidth);  		spriteSheet.tileHeight = EditorGUILayout.IntField ("Tile Height"' spriteSheet.tileHeight);  		spriteSheet.tileMarginX = EditorGUILayout.IntField ("Tile Margin X"' spriteSheet.tileMarginX);  		spriteSheet.tileMarginY = EditorGUILayout.IntField ("Tile Margin Y"' spriteSheet.tileMarginY);  		spriteSheet.tileSpacingX = EditorGUILayout.IntField ("Tile Spacing X"' spriteSheet.tileSpacingX);  		spriteSheet.tileSpacingY = EditorGUILayout.IntField ("Tile Spacing Y"' spriteSheet.tileSpacingY);  		spriteSheet.pad = (tk2dSpriteCollectionDefinition.Pad)EditorGUILayout.EnumPopup ("Pad"' spriteSheet.pad);  		if (spriteSheet.pad == tk2dSpriteCollectionDefinition.Pad.Default) {  			tk2dGuiUtility.InfoBox ("The sprite sheet is configured to use default padding mode. " + "It is advised to select an explicit padding mode depending on the usage of the " + "sprites within the sprite sheet.\n\n" + "BlackZeroAlpha - Recommended for animations\n" + "Extend - Recommended for tilemaps"' tk2dGuiUtility.WarningLevel.Warning);  		}  		// Apply button  		GUILayout.Space (8);  		GUILayout.BeginHorizontal ();  		GUILayout.FlexibleSpace ();  		if (spriteSheet.texture != null && spriteSheet.tileWidth > 0 && spriteSheet.tileWidth <= spriteSheet.texture.width && spriteSheet.tileHeight > 0 && spriteSheet.tileHeight <= spriteSheet.texture.height && GUILayout.Button ("Apply"' EditorStyles.miniButton)) {  			AddSprites (spriteSheet);  			selectedMode = EditMode.Edit;  		}  		GUILayout.EndHorizontal ();  		GUILayout.EndVertical ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The following statement contains a magic number: if (selectedMode == EditMode.Edit) {  	if (Event.current.type == EventType.Layout)  		activeSelectedSprites = new List<SpriteCollectionEditorEntry> (selectedSprites);  	if (activeSelectedSprites.Count > 0)  		host.SpriteView.DrawSpriteEditorInspector (activeSelectedSprites' true' true);  }  else {  	GUILayout.BeginVertical (tk2dEditorSkin.SC_InspectorBG' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (false));  	spriteSheet.tileWidth = EditorGUILayout.IntField ("Tile Width"' spriteSheet.tileWidth);  	spriteSheet.tileHeight = EditorGUILayout.IntField ("Tile Height"' spriteSheet.tileHeight);  	spriteSheet.tileMarginX = EditorGUILayout.IntField ("Tile Margin X"' spriteSheet.tileMarginX);  	spriteSheet.tileMarginY = EditorGUILayout.IntField ("Tile Margin Y"' spriteSheet.tileMarginY);  	spriteSheet.tileSpacingX = EditorGUILayout.IntField ("Tile Spacing X"' spriteSheet.tileSpacingX);  	spriteSheet.tileSpacingY = EditorGUILayout.IntField ("Tile Spacing Y"' spriteSheet.tileSpacingY);  	spriteSheet.pad = (tk2dSpriteCollectionDefinition.Pad)EditorGUILayout.EnumPopup ("Pad"' spriteSheet.pad);  	if (spriteSheet.pad == tk2dSpriteCollectionDefinition.Pad.Default) {  		tk2dGuiUtility.InfoBox ("The sprite sheet is configured to use default padding mode. " + "It is advised to select an explicit padding mode depending on the usage of the " + "sprites within the sprite sheet.\n\n" + "BlackZeroAlpha - Recommended for animations\n" + "Extend - Recommended for tilemaps"' tk2dGuiUtility.WarningLevel.Warning);  	}  	// Apply button  	GUILayout.Space (8);  	GUILayout.BeginHorizontal ();  	GUILayout.FlexibleSpace ();  	if (spriteSheet.texture != null && spriteSheet.tileWidth > 0 && spriteSheet.tileWidth <= spriteSheet.texture.width && spriteSheet.tileHeight > 0 && spriteSheet.tileHeight <= spriteSheet.texture.height && GUILayout.Button ("Apply"' EditorStyles.miniButton)) {  		AddSprites (spriteSheet);  		selectedMode = EditMode.Edit;  	}  	GUILayout.EndHorizontal ();  	GUILayout.EndVertical ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The following statement contains a magic number: GUILayout.Space (8);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteSheetView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteSheetView.cs,Draw,The following statement contains a magic number: tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorMultiView,The following statement contains a magic number: EditorGUILayout.BeginVertical (tk2dEditorSkin.SC_InspectorBG' GUILayout.MaxWidth (260)' GUILayout.ExpandHeight (true));  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The following statement contains a magic number: if (entries.Count > 1) {  	EditorGUILayout.TextField ("Name"' param.name);  }  else {  	string name = EditorGUILayout.TextField ("Name"' param.name);  	if (name != param.name) {  		param.name = name;  		entry.name = name;  		host.OnSpriteCollectionSortChanged ();  	}  	EditorGUILayout.BeginHorizontal ();  	EditorGUILayout.PrefixLabel ("Sprite Id");  	EditorGUILayout.SelectableLabel (entry.index.ToString ()' EditorStyles.textField' GUILayout.ExpandWidth (true)' GUILayout.Height (16));  	EditorGUILayout.EndHorizontal ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The following statement contains a magic number: EditorGUILayout.SelectableLabel (entry.index.ToString ()' EditorStyles.textField' GUILayout.ExpandWidth (true)' GUILayout.Height (16));  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The following statement contains a magic number: tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal);  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The following statement contains a magic number: if (param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom) {  	EditorGUI.indentLevel++;  	EditorGUILayout.BeginHorizontal ();  	param.anchorX = EditorGUILayout.FloatField ("X"' param.anchorX);  	bool roundAnchorX = GUILayout.Button ("R"' EditorStyles.miniButton' GUILayout.MaxWidth (24));  	EditorGUILayout.EndHorizontal ();  	EditorGUILayout.BeginHorizontal ();  	param.anchorY = EditorGUILayout.FloatField ("Y"' param.anchorY);  	bool roundAnchorY = GUILayout.Button ("R"' EditorStyles.miniButton' GUILayout.MaxWidth (24));  	EditorGUILayout.EndHorizontal ();  	if (roundAnchorX)  		param.anchorX = Mathf.Round (param.anchorX);  	if (roundAnchorY)  		param.anchorY = Mathf.Round (param.anchorY);  	EditorGUI.indentLevel--;  	EditorGUILayout.Separator ();  	HandleMultiSelection (entries' (a' b) => (a.anchor == b.anchor && a.anchorX == b.anchorX && a.anchorY == b.anchorY)' delegate (tk2dSpriteCollectionDefinition a' tk2dSpriteCollectionDefinition b) {  		b.anchor = a.anchor;  		b.anchorX = a.anchorX;  		b.anchorY = a.anchorY;  	});  }  else {  	HandleMultiSelection (entries' (a' b) => a.anchor == b.anchor' (a' b) => b.anchor = a.anchor);  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The following statement contains a magic number: if (param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom) {  	EditorGUI.indentLevel++;  	EditorGUILayout.BeginHorizontal ();  	param.anchorX = EditorGUILayout.FloatField ("X"' param.anchorX);  	bool roundAnchorX = GUILayout.Button ("R"' EditorStyles.miniButton' GUILayout.MaxWidth (24));  	EditorGUILayout.EndHorizontal ();  	EditorGUILayout.BeginHorizontal ();  	param.anchorY = EditorGUILayout.FloatField ("Y"' param.anchorY);  	bool roundAnchorY = GUILayout.Button ("R"' EditorStyles.miniButton' GUILayout.MaxWidth (24));  	EditorGUILayout.EndHorizontal ();  	if (roundAnchorX)  		param.anchorX = Mathf.Round (param.anchorX);  	if (roundAnchorY)  		param.anchorY = Mathf.Round (param.anchorY);  	EditorGUI.indentLevel--;  	EditorGUILayout.Separator ();  	HandleMultiSelection (entries' (a' b) => (a.anchor == b.anchor && a.anchorX == b.anchorX && a.anchorY == b.anchorY)' delegate (tk2dSpriteCollectionDefinition a' tk2dSpriteCollectionDefinition b) {  		b.anchor = a.anchor;  		b.anchorX = a.anchorX;  		b.anchorY = a.anchorY;  	});  }  else {  	HandleMultiSelection (entries' (a' b) => a.anchor == b.anchor' (a' b) => b.anchor = a.anchor);  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The following statement contains a magic number: tk2dPreferences.inst.spriteCollectionInspectorWidth -= (int)tk2dGuiUtility.DragableHandle (4819284' GUILayoutUtility.GetLastRect ()' 0' tk2dGuiUtility.DragDirection.Horizontal);  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (islands == null || islands.Length == 0 || !islands [0].IsValid ()) {  	islands = new tk2dSpriteColliderIsland[1];  	islands [0] = new tk2dSpriteColliderIsland ();  	islands [0].connected = true;  	int w = tex.width;  	int h = tex.height;  	Vector2[] p = new Vector2[4];  	p [0] = new Vector2 (0' 0);  	p [1] = new Vector2 (0' h);  	p [2] = new Vector2 (w' h);  	p [3] = new Vector2 (w' 0);  	islands [0].points = p;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (islands == null || islands.Length == 0 || !islands [0].IsValid ()) {  	islands = new tk2dSpriteColliderIsland[1];  	islands [0] = new tk2dSpriteColliderIsland ();  	islands [0].connected = true;  	int w = tex.width;  	int h = tex.height;  	Vector2[] p = new Vector2[4];  	p [0] = new Vector2 (0' 0);  	p [1] = new Vector2 (0' h);  	p [2] = new Vector2 (w' h);  	p [3] = new Vector2 (w' 0);  	islands [0].points = p;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (islands == null || islands.Length == 0 || !islands [0].IsValid ()) {  	islands = new tk2dSpriteColliderIsland[1];  	islands [0] = new tk2dSpriteColliderIsland ();  	islands [0].connected = true;  	int w = tex.width;  	int h = tex.height;  	Vector2[] p = new Vector2[4];  	p [0] = new Vector2 (0' 0);  	p [1] = new Vector2 (0' h);  	p [2] = new Vector2 (w' h);  	p [3] = new Vector2 (w' 0);  	islands [0].points = p;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: p [2] = new Vector2 (w' h);  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: p [3] = new Vector2 (w' 0);  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (Event.current.clickCount == 2 && Event.current.type == EventType.MouseDown) {  	insertPoint = true;  	Event.current.Use ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (r.Contains (Event.current.mousePosition) && Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.C) {  	Vector2 min = Event.current.mousePosition / editorDisplayScale - new Vector2 (16.0f' 16.0f);  	Vector3 max = Event.current.mousePosition / editorDisplayScale + new Vector2 (16.0f' 16.0f);  	min.x = Mathf.Clamp (min.x' 0' tex.width * editorDisplayScale);  	min.y = Mathf.Clamp (min.y' 0' tex.height * editorDisplayScale);  	max.x = Mathf.Clamp (max.x' 0' tex.width * editorDisplayScale);  	max.y = Mathf.Clamp (max.y' 0' tex.height * editorDisplayScale);  	tk2dSpriteColliderIsland island = new tk2dSpriteColliderIsland ();  	island.connected = true;  	Vector2[] p = new Vector2[4];  	p [0] = new Vector2 (min.x' min.y);  	p [1] = new Vector2 (min.x' max.y);  	p [2] = new Vector2 (max.x' max.y);  	p [3] = new Vector2 (max.x' min.y);  	island.points = p;  	System.Array.Resize (ref islands' islands.Length + 1);  	islands [islands.Length - 1] = island;  	Event.current.Use ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (r.Contains (Event.current.mousePosition) && Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.C) {  	Vector2 min = Event.current.mousePosition / editorDisplayScale - new Vector2 (16.0f' 16.0f);  	Vector3 max = Event.current.mousePosition / editorDisplayScale + new Vector2 (16.0f' 16.0f);  	min.x = Mathf.Clamp (min.x' 0' tex.width * editorDisplayScale);  	min.y = Mathf.Clamp (min.y' 0' tex.height * editorDisplayScale);  	max.x = Mathf.Clamp (max.x' 0' tex.width * editorDisplayScale);  	max.y = Mathf.Clamp (max.y' 0' tex.height * editorDisplayScale);  	tk2dSpriteColliderIsland island = new tk2dSpriteColliderIsland ();  	island.connected = true;  	Vector2[] p = new Vector2[4];  	p [0] = new Vector2 (min.x' min.y);  	p [1] = new Vector2 (min.x' max.y);  	p [2] = new Vector2 (max.x' max.y);  	p [3] = new Vector2 (max.x' min.y);  	island.points = p;  	System.Array.Resize (ref islands' islands.Length + 1);  	islands [islands.Length - 1] = island;  	Event.current.Use ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (r.Contains (Event.current.mousePosition) && Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.C) {  	Vector2 min = Event.current.mousePosition / editorDisplayScale - new Vector2 (16.0f' 16.0f);  	Vector3 max = Event.current.mousePosition / editorDisplayScale + new Vector2 (16.0f' 16.0f);  	min.x = Mathf.Clamp (min.x' 0' tex.width * editorDisplayScale);  	min.y = Mathf.Clamp (min.y' 0' tex.height * editorDisplayScale);  	max.x = Mathf.Clamp (max.x' 0' tex.width * editorDisplayScale);  	max.y = Mathf.Clamp (max.y' 0' tex.height * editorDisplayScale);  	tk2dSpriteColliderIsland island = new tk2dSpriteColliderIsland ();  	island.connected = true;  	Vector2[] p = new Vector2[4];  	p [0] = new Vector2 (min.x' min.y);  	p [1] = new Vector2 (min.x' max.y);  	p [2] = new Vector2 (max.x' max.y);  	p [3] = new Vector2 (max.x' min.y);  	island.points = p;  	System.Array.Resize (ref islands' islands.Length + 1);  	islands [islands.Length - 1] = island;  	Event.current.Use ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: p [2] = new Vector2 (max.x' max.y);  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: p [3] = new Vector2 (max.x' min.y);  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int islandId = 0; islandId < islands.Length; ++islandId) {  	float closestDistanceSq = 1.0e32f;  	Vector2 closestPoint = Vector2.zero;  	int closestPreviousPoint = 0;  	var island = islands [islandId];  	Handles.color = handleInactiveColor;  	Vector2 ov = (island.points.Length > 0) ? island.points [island.points.Length - 1] : Vector2.zero;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector2 v = island.points [i];  		// Don't draw last connection if its not connected  		if (!island.connected && i == 0) {  			ov = v;  			continue;  		}  		if (insertPoint) {  			Vector2 localMousePosition = (Event.current.mousePosition - origin) / editorDisplayScale;  			Vector2 closestPointToCursor = ClosestPointOnLine (localMousePosition' ov' v);  			float lengthSq = (closestPointToCursor - localMousePosition).sqrMagnitude;  			if (lengthSq < closestDistanceSq) {  				closestDistanceSq = lengthSq;  				closestPoint = closestPointToCursor;  				closestPreviousPoint = i;  			}  		}  		if (drawColliderNormals) {  			Vector2 l = (ov - v).normalized;  			Vector2 n = new Vector2 (l.y' -l.x);  			Vector2 c = (v + ov) * 0.5f * editorDisplayScale + origin;  			Handles.DrawLine (c' c + n * 16.0f);  		}  		Handles.DrawLine (v * editorDisplayScale + origin' ov * editorDisplayScale + origin);  		ov = v;  	}  	Handles.color = previousHandleColor;  	if (insertPoint && closestDistanceSq < 16.0f) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.Insert (closestPreviousPoint' closestPoint);  		island.points = tmpList.ToArray ();  		HandleUtility.Repaint ();  	}  	int deletedIndex = -1;  	bool flipIsland = false;  	bool disconnectIsland = false;  	Event ev = Event.current;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector3 cp = island.points [i];  		int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  		cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  		if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  			switch (ev.keyCode) {  			case KeyCode.Backspace:  			case KeyCode.Delete: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIndex = i;  				ev.Use ();  				break;  			}  			case KeyCode.X: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIsland = islandId;  				ev.Use ();  				break;  			}  			case KeyCode.T: {  				if (!forceClosed) {  					GUIUtility.keyboardControl = 0;  					GUIUtility.hotControl = 0;  					disconnectIsland = true;  					ev.Use ();  				}  				break;  			}  			case KeyCode.F: {  				flipIsland = true;  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				ev.Use ();  				break;  			}  			case KeyCode.Escape: {  				GUIUtility.hotControl = 0;  				GUIUtility.keyboardControl = 0;  				ev.Use ();  				break;  			}  			}  		}  		cp.x = Mathf.Round (cp.x * 2) / 2.0f;  		// allow placing point at half texel  		cp.y = Mathf.Round (cp.y * 2) / 2.0f;  		// constrain  		cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  		cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  		island.points [i] = cp;  	}  	if (flipIsland) {  		System.Array.Reverse (island.points);  	}  	if (disconnectIsland) {  		island.connected = !island.connected;  		if (island.connected && island.points.Length < 3) {  			Vector2 pp = (island.points [1] - island.points [0]);  			float l = pp.magnitude;  			pp.Normalize ();  			Vector2 nn = new Vector2 (pp.y' -pp.x);  			nn.y = Mathf.Clamp (nn.y' 0' tex.height);  			nn.x = Mathf.Clamp (nn.x' 0' tex.width);  			System.Array.Resize (ref island.points' island.points.Length + 1);  			island.points [island.points.Length - 1] = (island.points [0] + island.points [1]) * 0.5f + nn * l * 0.5f;  		}  	}  	if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.RemoveAt (deletedIndex);  		island.points = tmpList.ToArray ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int islandId = 0; islandId < islands.Length; ++islandId) {  	float closestDistanceSq = 1.0e32f;  	Vector2 closestPoint = Vector2.zero;  	int closestPreviousPoint = 0;  	var island = islands [islandId];  	Handles.color = handleInactiveColor;  	Vector2 ov = (island.points.Length > 0) ? island.points [island.points.Length - 1] : Vector2.zero;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector2 v = island.points [i];  		// Don't draw last connection if its not connected  		if (!island.connected && i == 0) {  			ov = v;  			continue;  		}  		if (insertPoint) {  			Vector2 localMousePosition = (Event.current.mousePosition - origin) / editorDisplayScale;  			Vector2 closestPointToCursor = ClosestPointOnLine (localMousePosition' ov' v);  			float lengthSq = (closestPointToCursor - localMousePosition).sqrMagnitude;  			if (lengthSq < closestDistanceSq) {  				closestDistanceSq = lengthSq;  				closestPoint = closestPointToCursor;  				closestPreviousPoint = i;  			}  		}  		if (drawColliderNormals) {  			Vector2 l = (ov - v).normalized;  			Vector2 n = new Vector2 (l.y' -l.x);  			Vector2 c = (v + ov) * 0.5f * editorDisplayScale + origin;  			Handles.DrawLine (c' c + n * 16.0f);  		}  		Handles.DrawLine (v * editorDisplayScale + origin' ov * editorDisplayScale + origin);  		ov = v;  	}  	Handles.color = previousHandleColor;  	if (insertPoint && closestDistanceSq < 16.0f) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.Insert (closestPreviousPoint' closestPoint);  		island.points = tmpList.ToArray ();  		HandleUtility.Repaint ();  	}  	int deletedIndex = -1;  	bool flipIsland = false;  	bool disconnectIsland = false;  	Event ev = Event.current;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector3 cp = island.points [i];  		int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  		cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  		if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  			switch (ev.keyCode) {  			case KeyCode.Backspace:  			case KeyCode.Delete: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIndex = i;  				ev.Use ();  				break;  			}  			case KeyCode.X: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIsland = islandId;  				ev.Use ();  				break;  			}  			case KeyCode.T: {  				if (!forceClosed) {  					GUIUtility.keyboardControl = 0;  					GUIUtility.hotControl = 0;  					disconnectIsland = true;  					ev.Use ();  				}  				break;  			}  			case KeyCode.F: {  				flipIsland = true;  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				ev.Use ();  				break;  			}  			case KeyCode.Escape: {  				GUIUtility.hotControl = 0;  				GUIUtility.keyboardControl = 0;  				ev.Use ();  				break;  			}  			}  		}  		cp.x = Mathf.Round (cp.x * 2) / 2.0f;  		// allow placing point at half texel  		cp.y = Mathf.Round (cp.y * 2) / 2.0f;  		// constrain  		cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  		cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  		island.points [i] = cp;  	}  	if (flipIsland) {  		System.Array.Reverse (island.points);  	}  	if (disconnectIsland) {  		island.connected = !island.connected;  		if (island.connected && island.points.Length < 3) {  			Vector2 pp = (island.points [1] - island.points [0]);  			float l = pp.magnitude;  			pp.Normalize ();  			Vector2 nn = new Vector2 (pp.y' -pp.x);  			nn.y = Mathf.Clamp (nn.y' 0' tex.height);  			nn.x = Mathf.Clamp (nn.x' 0' tex.width);  			System.Array.Resize (ref island.points' island.points.Length + 1);  			island.points [island.points.Length - 1] = (island.points [0] + island.points [1]) * 0.5f + nn * l * 0.5f;  		}  	}  	if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.RemoveAt (deletedIndex);  		island.points = tmpList.ToArray ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int islandId = 0; islandId < islands.Length; ++islandId) {  	float closestDistanceSq = 1.0e32f;  	Vector2 closestPoint = Vector2.zero;  	int closestPreviousPoint = 0;  	var island = islands [islandId];  	Handles.color = handleInactiveColor;  	Vector2 ov = (island.points.Length > 0) ? island.points [island.points.Length - 1] : Vector2.zero;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector2 v = island.points [i];  		// Don't draw last connection if its not connected  		if (!island.connected && i == 0) {  			ov = v;  			continue;  		}  		if (insertPoint) {  			Vector2 localMousePosition = (Event.current.mousePosition - origin) / editorDisplayScale;  			Vector2 closestPointToCursor = ClosestPointOnLine (localMousePosition' ov' v);  			float lengthSq = (closestPointToCursor - localMousePosition).sqrMagnitude;  			if (lengthSq < closestDistanceSq) {  				closestDistanceSq = lengthSq;  				closestPoint = closestPointToCursor;  				closestPreviousPoint = i;  			}  		}  		if (drawColliderNormals) {  			Vector2 l = (ov - v).normalized;  			Vector2 n = new Vector2 (l.y' -l.x);  			Vector2 c = (v + ov) * 0.5f * editorDisplayScale + origin;  			Handles.DrawLine (c' c + n * 16.0f);  		}  		Handles.DrawLine (v * editorDisplayScale + origin' ov * editorDisplayScale + origin);  		ov = v;  	}  	Handles.color = previousHandleColor;  	if (insertPoint && closestDistanceSq < 16.0f) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.Insert (closestPreviousPoint' closestPoint);  		island.points = tmpList.ToArray ();  		HandleUtility.Repaint ();  	}  	int deletedIndex = -1;  	bool flipIsland = false;  	bool disconnectIsland = false;  	Event ev = Event.current;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector3 cp = island.points [i];  		int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  		cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  		if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  			switch (ev.keyCode) {  			case KeyCode.Backspace:  			case KeyCode.Delete: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIndex = i;  				ev.Use ();  				break;  			}  			case KeyCode.X: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIsland = islandId;  				ev.Use ();  				break;  			}  			case KeyCode.T: {  				if (!forceClosed) {  					GUIUtility.keyboardControl = 0;  					GUIUtility.hotControl = 0;  					disconnectIsland = true;  					ev.Use ();  				}  				break;  			}  			case KeyCode.F: {  				flipIsland = true;  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				ev.Use ();  				break;  			}  			case KeyCode.Escape: {  				GUIUtility.hotControl = 0;  				GUIUtility.keyboardControl = 0;  				ev.Use ();  				break;  			}  			}  		}  		cp.x = Mathf.Round (cp.x * 2) / 2.0f;  		// allow placing point at half texel  		cp.y = Mathf.Round (cp.y * 2) / 2.0f;  		// constrain  		cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  		cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  		island.points [i] = cp;  	}  	if (flipIsland) {  		System.Array.Reverse (island.points);  	}  	if (disconnectIsland) {  		island.connected = !island.connected;  		if (island.connected && island.points.Length < 3) {  			Vector2 pp = (island.points [1] - island.points [0]);  			float l = pp.magnitude;  			pp.Normalize ();  			Vector2 nn = new Vector2 (pp.y' -pp.x);  			nn.y = Mathf.Clamp (nn.y' 0' tex.height);  			nn.x = Mathf.Clamp (nn.x' 0' tex.width);  			System.Array.Resize (ref island.points' island.points.Length + 1);  			island.points [island.points.Length - 1] = (island.points [0] + island.points [1]) * 0.5f + nn * l * 0.5f;  		}  	}  	if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.RemoveAt (deletedIndex);  		island.points = tmpList.ToArray ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int islandId = 0; islandId < islands.Length; ++islandId) {  	float closestDistanceSq = 1.0e32f;  	Vector2 closestPoint = Vector2.zero;  	int closestPreviousPoint = 0;  	var island = islands [islandId];  	Handles.color = handleInactiveColor;  	Vector2 ov = (island.points.Length > 0) ? island.points [island.points.Length - 1] : Vector2.zero;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector2 v = island.points [i];  		// Don't draw last connection if its not connected  		if (!island.connected && i == 0) {  			ov = v;  			continue;  		}  		if (insertPoint) {  			Vector2 localMousePosition = (Event.current.mousePosition - origin) / editorDisplayScale;  			Vector2 closestPointToCursor = ClosestPointOnLine (localMousePosition' ov' v);  			float lengthSq = (closestPointToCursor - localMousePosition).sqrMagnitude;  			if (lengthSq < closestDistanceSq) {  				closestDistanceSq = lengthSq;  				closestPoint = closestPointToCursor;  				closestPreviousPoint = i;  			}  		}  		if (drawColliderNormals) {  			Vector2 l = (ov - v).normalized;  			Vector2 n = new Vector2 (l.y' -l.x);  			Vector2 c = (v + ov) * 0.5f * editorDisplayScale + origin;  			Handles.DrawLine (c' c + n * 16.0f);  		}  		Handles.DrawLine (v * editorDisplayScale + origin' ov * editorDisplayScale + origin);  		ov = v;  	}  	Handles.color = previousHandleColor;  	if (insertPoint && closestDistanceSq < 16.0f) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.Insert (closestPreviousPoint' closestPoint);  		island.points = tmpList.ToArray ();  		HandleUtility.Repaint ();  	}  	int deletedIndex = -1;  	bool flipIsland = false;  	bool disconnectIsland = false;  	Event ev = Event.current;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector3 cp = island.points [i];  		int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  		cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  		if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  			switch (ev.keyCode) {  			case KeyCode.Backspace:  			case KeyCode.Delete: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIndex = i;  				ev.Use ();  				break;  			}  			case KeyCode.X: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIsland = islandId;  				ev.Use ();  				break;  			}  			case KeyCode.T: {  				if (!forceClosed) {  					GUIUtility.keyboardControl = 0;  					GUIUtility.hotControl = 0;  					disconnectIsland = true;  					ev.Use ();  				}  				break;  			}  			case KeyCode.F: {  				flipIsland = true;  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				ev.Use ();  				break;  			}  			case KeyCode.Escape: {  				GUIUtility.hotControl = 0;  				GUIUtility.keyboardControl = 0;  				ev.Use ();  				break;  			}  			}  		}  		cp.x = Mathf.Round (cp.x * 2) / 2.0f;  		// allow placing point at half texel  		cp.y = Mathf.Round (cp.y * 2) / 2.0f;  		// constrain  		cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  		cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  		island.points [i] = cp;  	}  	if (flipIsland) {  		System.Array.Reverse (island.points);  	}  	if (disconnectIsland) {  		island.connected = !island.connected;  		if (island.connected && island.points.Length < 3) {  			Vector2 pp = (island.points [1] - island.points [0]);  			float l = pp.magnitude;  			pp.Normalize ();  			Vector2 nn = new Vector2 (pp.y' -pp.x);  			nn.y = Mathf.Clamp (nn.y' 0' tex.height);  			nn.x = Mathf.Clamp (nn.x' 0' tex.width);  			System.Array.Resize (ref island.points' island.points.Length + 1);  			island.points [island.points.Length - 1] = (island.points [0] + island.points [1]) * 0.5f + nn * l * 0.5f;  		}  	}  	if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.RemoveAt (deletedIndex);  		island.points = tmpList.ToArray ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int islandId = 0; islandId < islands.Length; ++islandId) {  	float closestDistanceSq = 1.0e32f;  	Vector2 closestPoint = Vector2.zero;  	int closestPreviousPoint = 0;  	var island = islands [islandId];  	Handles.color = handleInactiveColor;  	Vector2 ov = (island.points.Length > 0) ? island.points [island.points.Length - 1] : Vector2.zero;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector2 v = island.points [i];  		// Don't draw last connection if its not connected  		if (!island.connected && i == 0) {  			ov = v;  			continue;  		}  		if (insertPoint) {  			Vector2 localMousePosition = (Event.current.mousePosition - origin) / editorDisplayScale;  			Vector2 closestPointToCursor = ClosestPointOnLine (localMousePosition' ov' v);  			float lengthSq = (closestPointToCursor - localMousePosition).sqrMagnitude;  			if (lengthSq < closestDistanceSq) {  				closestDistanceSq = lengthSq;  				closestPoint = closestPointToCursor;  				closestPreviousPoint = i;  			}  		}  		if (drawColliderNormals) {  			Vector2 l = (ov - v).normalized;  			Vector2 n = new Vector2 (l.y' -l.x);  			Vector2 c = (v + ov) * 0.5f * editorDisplayScale + origin;  			Handles.DrawLine (c' c + n * 16.0f);  		}  		Handles.DrawLine (v * editorDisplayScale + origin' ov * editorDisplayScale + origin);  		ov = v;  	}  	Handles.color = previousHandleColor;  	if (insertPoint && closestDistanceSq < 16.0f) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.Insert (closestPreviousPoint' closestPoint);  		island.points = tmpList.ToArray ();  		HandleUtility.Repaint ();  	}  	int deletedIndex = -1;  	bool flipIsland = false;  	bool disconnectIsland = false;  	Event ev = Event.current;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector3 cp = island.points [i];  		int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  		cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  		if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  			switch (ev.keyCode) {  			case KeyCode.Backspace:  			case KeyCode.Delete: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIndex = i;  				ev.Use ();  				break;  			}  			case KeyCode.X: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIsland = islandId;  				ev.Use ();  				break;  			}  			case KeyCode.T: {  				if (!forceClosed) {  					GUIUtility.keyboardControl = 0;  					GUIUtility.hotControl = 0;  					disconnectIsland = true;  					ev.Use ();  				}  				break;  			}  			case KeyCode.F: {  				flipIsland = true;  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				ev.Use ();  				break;  			}  			case KeyCode.Escape: {  				GUIUtility.hotControl = 0;  				GUIUtility.keyboardControl = 0;  				ev.Use ();  				break;  			}  			}  		}  		cp.x = Mathf.Round (cp.x * 2) / 2.0f;  		// allow placing point at half texel  		cp.y = Mathf.Round (cp.y * 2) / 2.0f;  		// constrain  		cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  		cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  		island.points [i] = cp;  	}  	if (flipIsland) {  		System.Array.Reverse (island.points);  	}  	if (disconnectIsland) {  		island.connected = !island.connected;  		if (island.connected && island.points.Length < 3) {  			Vector2 pp = (island.points [1] - island.points [0]);  			float l = pp.magnitude;  			pp.Normalize ();  			Vector2 nn = new Vector2 (pp.y' -pp.x);  			nn.y = Mathf.Clamp (nn.y' 0' tex.height);  			nn.x = Mathf.Clamp (nn.x' 0' tex.width);  			System.Array.Resize (ref island.points' island.points.Length + 1);  			island.points [island.points.Length - 1] = (island.points [0] + island.points [1]) * 0.5f + nn * l * 0.5f;  		}  	}  	if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.RemoveAt (deletedIndex);  		island.points = tmpList.ToArray ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int islandId = 0; islandId < islands.Length; ++islandId) {  	float closestDistanceSq = 1.0e32f;  	Vector2 closestPoint = Vector2.zero;  	int closestPreviousPoint = 0;  	var island = islands [islandId];  	Handles.color = handleInactiveColor;  	Vector2 ov = (island.points.Length > 0) ? island.points [island.points.Length - 1] : Vector2.zero;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector2 v = island.points [i];  		// Don't draw last connection if its not connected  		if (!island.connected && i == 0) {  			ov = v;  			continue;  		}  		if (insertPoint) {  			Vector2 localMousePosition = (Event.current.mousePosition - origin) / editorDisplayScale;  			Vector2 closestPointToCursor = ClosestPointOnLine (localMousePosition' ov' v);  			float lengthSq = (closestPointToCursor - localMousePosition).sqrMagnitude;  			if (lengthSq < closestDistanceSq) {  				closestDistanceSq = lengthSq;  				closestPoint = closestPointToCursor;  				closestPreviousPoint = i;  			}  		}  		if (drawColliderNormals) {  			Vector2 l = (ov - v).normalized;  			Vector2 n = new Vector2 (l.y' -l.x);  			Vector2 c = (v + ov) * 0.5f * editorDisplayScale + origin;  			Handles.DrawLine (c' c + n * 16.0f);  		}  		Handles.DrawLine (v * editorDisplayScale + origin' ov * editorDisplayScale + origin);  		ov = v;  	}  	Handles.color = previousHandleColor;  	if (insertPoint && closestDistanceSq < 16.0f) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.Insert (closestPreviousPoint' closestPoint);  		island.points = tmpList.ToArray ();  		HandleUtility.Repaint ();  	}  	int deletedIndex = -1;  	bool flipIsland = false;  	bool disconnectIsland = false;  	Event ev = Event.current;  	for (int i = 0; i < island.points.Length; ++i) {  		Vector3 cp = island.points [i];  		int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  		cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  		if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  			switch (ev.keyCode) {  			case KeyCode.Backspace:  			case KeyCode.Delete: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIndex = i;  				ev.Use ();  				break;  			}  			case KeyCode.X: {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				deletedIsland = islandId;  				ev.Use ();  				break;  			}  			case KeyCode.T: {  				if (!forceClosed) {  					GUIUtility.keyboardControl = 0;  					GUIUtility.hotControl = 0;  					disconnectIsland = true;  					ev.Use ();  				}  				break;  			}  			case KeyCode.F: {  				flipIsland = true;  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				ev.Use ();  				break;  			}  			case KeyCode.Escape: {  				GUIUtility.hotControl = 0;  				GUIUtility.keyboardControl = 0;  				ev.Use ();  				break;  			}  			}  		}  		cp.x = Mathf.Round (cp.x * 2) / 2.0f;  		// allow placing point at half texel  		cp.y = Mathf.Round (cp.y * 2) / 2.0f;  		// constrain  		cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  		cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  		island.points [i] = cp;  	}  	if (flipIsland) {  		System.Array.Reverse (island.points);  	}  	if (disconnectIsland) {  		island.connected = !island.connected;  		if (island.connected && island.points.Length < 3) {  			Vector2 pp = (island.points [1] - island.points [0]);  			float l = pp.magnitude;  			pp.Normalize ();  			Vector2 nn = new Vector2 (pp.y' -pp.x);  			nn.y = Mathf.Clamp (nn.y' 0' tex.height);  			nn.x = Mathf.Clamp (nn.x' 0' tex.width);  			System.Array.Resize (ref island.points' island.points.Length + 1);  			island.points [island.points.Length - 1] = (island.points [0] + island.points [1]) * 0.5f + nn * l * 0.5f;  		}  	}  	if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) {  		var tmpList = new List<Vector2> (island.points);  		tmpList.RemoveAt (deletedIndex);  		island.points = tmpList.ToArray ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int i = 0; i < island.points.Length; ++i) {  	Vector3 cp = island.points [i];  	int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  	cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  	if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  		switch (ev.keyCode) {  		case KeyCode.Backspace:  		case KeyCode.Delete: {  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			deletedIndex = i;  			ev.Use ();  			break;  		}  		case KeyCode.X: {  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			deletedIsland = islandId;  			ev.Use ();  			break;  		}  		case KeyCode.T: {  			if (!forceClosed) {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				disconnectIsland = true;  				ev.Use ();  			}  			break;  		}  		case KeyCode.F: {  			flipIsland = true;  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			ev.Use ();  			break;  		}  		case KeyCode.Escape: {  			GUIUtility.hotControl = 0;  			GUIUtility.keyboardControl = 0;  			ev.Use ();  			break;  		}  		}  	}  	cp.x = Mathf.Round (cp.x * 2) / 2.0f;  	// allow placing point at half texel  	cp.y = Mathf.Round (cp.y * 2) / 2.0f;  	// constrain  	cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  	cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  	island.points [i] = cp;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int i = 0; i < island.points.Length; ++i) {  	Vector3 cp = island.points [i];  	int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  	cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  	if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  		switch (ev.keyCode) {  		case KeyCode.Backspace:  		case KeyCode.Delete: {  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			deletedIndex = i;  			ev.Use ();  			break;  		}  		case KeyCode.X: {  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			deletedIsland = islandId;  			ev.Use ();  			break;  		}  		case KeyCode.T: {  			if (!forceClosed) {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				disconnectIsland = true;  				ev.Use ();  			}  			break;  		}  		case KeyCode.F: {  			flipIsland = true;  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			ev.Use ();  			break;  		}  		case KeyCode.Escape: {  			GUIUtility.hotControl = 0;  			GUIUtility.keyboardControl = 0;  			ev.Use ();  			break;  		}  		}  	}  	cp.x = Mathf.Round (cp.x * 2) / 2.0f;  	// allow placing point at half texel  	cp.y = Mathf.Round (cp.y * 2) / 2.0f;  	// constrain  	cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  	cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  	island.points [i] = cp;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: for (int i = 0; i < island.points.Length; ++i) {  	Vector3 cp = island.points [i];  	int id = "tk2dPolyEditor".GetHashCode () + islandId * 10000 + i;  	cp = (tk2dGuiUtility.Handle (tk2dEditorSkin.MoveHandle' id' cp * editorDisplayScale + origin3' true) - origin) / editorDisplayScale;  	if (GUIUtility.keyboardControl == id && ev.type == EventType.KeyDown) {  		switch (ev.keyCode) {  		case KeyCode.Backspace:  		case KeyCode.Delete: {  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			deletedIndex = i;  			ev.Use ();  			break;  		}  		case KeyCode.X: {  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			deletedIsland = islandId;  			ev.Use ();  			break;  		}  		case KeyCode.T: {  			if (!forceClosed) {  				GUIUtility.keyboardControl = 0;  				GUIUtility.hotControl = 0;  				disconnectIsland = true;  				ev.Use ();  			}  			break;  		}  		case KeyCode.F: {  			flipIsland = true;  			GUIUtility.keyboardControl = 0;  			GUIUtility.hotControl = 0;  			ev.Use ();  			break;  		}  		case KeyCode.Escape: {  			GUIUtility.hotControl = 0;  			GUIUtility.keyboardControl = 0;  			ev.Use ();  			break;  		}  		}  	}  	cp.x = Mathf.Round (cp.x * 2) / 2.0f;  	// allow placing point at half texel  	cp.y = Mathf.Round (cp.y * 2) / 2.0f;  	// constrain  	cp.x = Mathf.Clamp (cp.x' 0.0f' tex.width);  	cp.y = Mathf.Clamp (cp.y' 0.0f' tex.height);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (cp.x' cp.y));  	island.points [i] = cp;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: cp.x = Mathf.Round (cp.x * 2) / 2.0f;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: cp.y = Mathf.Round (cp.y * 2) / 2.0f;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (disconnectIsland) {  	island.connected = !island.connected;  	if (island.connected && island.points.Length < 3) {  		Vector2 pp = (island.points [1] - island.points [0]);  		float l = pp.magnitude;  		pp.Normalize ();  		Vector2 nn = new Vector2 (pp.y' -pp.x);  		nn.y = Mathf.Clamp (nn.y' 0' tex.height);  		nn.x = Mathf.Clamp (nn.x' 0' tex.width);  		System.Array.Resize (ref island.points' island.points.Length + 1);  		island.points [island.points.Length - 1] = (island.points [0] + island.points [1]) * 0.5f + nn * l * 0.5f;  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (island.connected && island.points.Length < 3) {  	Vector2 pp = (island.points [1] - island.points [0]);  	float l = pp.magnitude;  	pp.Normalize ();  	Vector2 nn = new Vector2 (pp.y' -pp.x);  	nn.y = Mathf.Clamp (nn.y' 0' tex.height);  	nn.x = Mathf.Clamp (nn.x' 0' tex.width);  	System.Array.Resize (ref island.points' island.points.Length + 1);  	island.points [island.points.Length - 1] = (island.points [0] + island.points [1]) * 0.5f + nn * l * 0.5f;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) {  	var tmpList = new List<Vector2> (island.points);  	tmpList.RemoveAt (deletedIndex);  	island.points = tmpList.ToArray ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following statement contains a magic number: if (deletedIndex != -1 && ((island.connected && island.points.Length > 3) || (!island.connected && island.points.Length > 2))) {  	var tmpList = new List<Vector2> (island.points);  	tmpList.RemoveAt (deletedIndex);  	island.points = tmpList.ToArray ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: transparentColor.a = 10;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: handlePos = (pt [2] + pt [3]) * 0.5f;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: handlePos = (pt [2] + pt [3]) * 0.5f;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: handlePos = (pt [0] + pt [3]) * 0.5f;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: handlePos = (tk2dGuiUtility.PositionHandle (id + 2' handlePos) - origin) / editorDisplayScale;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: handlePos = (pt [1] + pt [2]) * 0.5f;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: handlePos = (tk2dGuiUtility.PositionHandle (id + 3' handlePos) - origin) / editorDisplayScale;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: tk2dGuiUtility.SetPositionHandleValue (id + 2' new Vector2 (param.boxColliderMin.x' 0));  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawCustomBoxColliderEditor,The following statement contains a magic number: tk2dGuiUtility.SetPositionHandleValue (id + 3' new Vector2 (param.boxColliderMax.x' 0));  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (texture == null) {  	// Get somewhere to put the texture...  	GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  }  else {  	bool allowAnchor = param.anchor == tk2dSpriteCollectionDefinition.Anchor.Custom;  	bool allowCollider = (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon || param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom);  	if (mode == Mode.Anchor && !allowAnchor)  		mode = Mode.Texture;  	if (mode == Mode.Collider && !allowCollider)  		mode = Mode.Texture;  	Rect rect = GUILayoutUtility.GetRect (128.0f' 128.0f' GUILayout.ExpandWidth (true)' GUILayout.ExpandHeight (true));  	tk2dGrid.Draw (rect);  	// middle mouse drag and scroll zoom  	if (rect.Contains (Event.current.mousePosition)) {  		if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  			textureScrollPos -= Event.current.delta * editorDisplayScale;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  		if (Event.current.type == EventType.ScrollWheel) {  			editorDisplayScale -= Event.current.delta.y * 0.03f;  			Event.current.Use ();  			HandleUtility.Repaint ();  		}  	}  	bool alphaBlend = true;  	textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  	Rect textureRect = new Rect (textureBorderPixels' textureBorderPixels' texture.width * editorDisplayScale' texture.height * editorDisplayScale);  	texture.filterMode = FilterMode.Point;  	GUI.DrawTexture (textureRect' texture' ScaleMode.ScaleAndCrop' alphaBlend);  	if (mode == Mode.Collider) {  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.BoxCustom)  			DrawCustomBoxColliderEditor (textureRect' param' texture);  		if (param.colliderType == tk2dSpriteCollectionDefinition.ColliderType.Polygon)  			DrawPolygonColliderEditor (textureRect' ref param.polyColliderIslands' texture' false);  	}  	if (mode == Mode.Texture && param.customSpriteGeometry) {  		DrawPolygonColliderEditor (textureRect' ref param.geometryIslands' texture' true);  	}  	// Anchor  	if (mode == Mode.Anchor) {  		Color lineColor = Color.white;  		Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = 99999;  		anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  		Color oldColor = Handles.color;  		Handles.color = lineColor;  		float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  		float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  		Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  		Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  		Handles.color = oldColor;  		// constrain  		param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  		param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  		HandleUtility.Repaint ();  	}  	if (mode == Mode.AttachPoint) {  		Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  		int id = "Mode.AttachPoint".GetHashCode ();  		foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  			Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  			if (showAttachPointSprites) {  				tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  				if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  					tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  					tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  				}  			}  			Vector2 pos = apPosition * editorDisplayScale + origin;  			GUI.color = Color.clear;  			// don't actually draw the move handle center  			apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  			GUI.color = Color.white;  			float handleSize = 30;  			Handles.color = Color.green;  			Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  			Handles.color = Color.red;  			Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  			Handles.color = Color.white;  			Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  			// rotation handle  			Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  			Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  			if (newRotHandlePos != rotHandlePos) {  				Vector2 deltaRot = newRotHandlePos - pos;  				float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  				if (Event.current.control) {  					float snapAmount = Event.current.shift ? 15 : 5;  					angle = Mathf.Floor (angle / snapAmount) * snapAmount;  				}  				else if (!Event.current.shift) {  					angle = Mathf.Floor (angle);  				}  				ap.angle = angle;  			}  			Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  			GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  			ap.position.x = Mathf.Round (apPosition.x);  			ap.position.y = Mathf.Round (apPosition.y);  			tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  			id += 2;  		}  		Handles.color = Color.white;  	}  	if (mode == Mode.Texture) {  		if (param.dice) {  			Handles.color = Color.red;  			Vector3 p1' p2;  			int q' dq;  			p1 = new Vector3 (textureRect.x' textureRect.y' 0);  			p2 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitX;  			if (dq > 0) {  				while (q <= texture.width) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.width && (q + dq) > texture.width)  						q = texture.width;  					else  						q += dq;  					p1.x += (float)(q - q0) * editorDisplayScale;  					p2.x += (float)(q - q0) * editorDisplayScale;  				}  			}  			p1 = new Vector3 (textureRect.x' textureRect.y + textureRect.height' 0);  			p2 = new Vector3 (textureRect.x + textureRect.width' textureRect.y + textureRect.height' 0);  			q = 0;  			dq = param.diceUnitY;  			if (dq > 0) {  				while (q <= texture.height) {  					Handles.DrawLine (p1' p2);  					int q0 = q;  					if (q < texture.height && (q + dq) > texture.height)  						q = texture.height;  					else  						q += dq;  					p1.y -= (float)(q - q0) * editorDisplayScale;  					p2.y -= (float)(q - q0) * editorDisplayScale;  				}  			}  			Handles.color = Color.white;  		}  	}  	GUI.EndScrollView ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (rect.Contains (Event.current.mousePosition)) {  	if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  		textureScrollPos -= Event.current.delta * editorDisplayScale;  		Event.current.Use ();  		HandleUtility.Repaint ();  	}  	if (Event.current.type == EventType.ScrollWheel) {  		editorDisplayScale -= Event.current.delta.y * 0.03f;  		Event.current.Use ();  		HandleUtility.Repaint ();  	}  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (Event.current.type == EventType.MouseDrag && Event.current.button == 2) {  	textureScrollPos -= Event.current.delta * editorDisplayScale;  	Event.current.Use ();  	HandleUtility.Repaint ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: textureScrollPos = GUI.BeginScrollView (rect' textureScrollPos' new Rect (0' 0' textureBorderPixels * 2 + (texture.width) * editorDisplayScale' textureBorderPixels * 2 + (texture.height) * editorDisplayScale));  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.Anchor) {  	Color lineColor = Color.white;  	Vector2 anchor = new Vector2 (param.anchorX' param.anchorY);  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = 99999;  	anchor = (tk2dGuiUtility.PositionHandle (id' anchor * editorDisplayScale + origin) - origin) / editorDisplayScale;  	Color oldColor = Handles.color;  	Handles.color = lineColor;  	float w = Mathf.Max (rect.width' texture.width * editorDisplayScale);  	float h = Mathf.Max (rect.height' texture.height * editorDisplayScale);  	Handles.DrawLine (new Vector3 (textureRect.x' textureRect.y + anchor.y * editorDisplayScale' 0)' new Vector3 (textureRect.x + w' textureRect.y + anchor.y * editorDisplayScale' 0));  	Handles.DrawLine (new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + 0' 0)' new Vector3 (textureRect.x + anchor.x * editorDisplayScale' textureRect.y + h' 0));  	Handles.color = oldColor;  	// constrain  	param.anchorX = Mathf.Clamp (Mathf.Round (anchor.x)' 0.0f' texture.width);  	param.anchorY = Mathf.Clamp (Mathf.Round (anchor.y)' 0.0f' texture.height);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (param.anchorX' param.anchorY));  	HandleUtility.Repaint ();  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.AttachPoint) {  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = "Mode.AttachPoint".GetHashCode ();  	foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  		Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  		if (showAttachPointSprites) {  			tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  			if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  				tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  				tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  			}  		}  		Vector2 pos = apPosition * editorDisplayScale + origin;  		GUI.color = Color.clear;  		// don't actually draw the move handle center  		apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  		GUI.color = Color.white;  		float handleSize = 30;  		Handles.color = Color.green;  		Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  		Handles.color = Color.red;  		Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  		Handles.color = Color.white;  		Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  		// rotation handle  		Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  		Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  		if (newRotHandlePos != rotHandlePos) {  			Vector2 deltaRot = newRotHandlePos - pos;  			float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  			if (Event.current.control) {  				float snapAmount = Event.current.shift ? 15 : 5;  				angle = Mathf.Floor (angle / snapAmount) * snapAmount;  			}  			else if (!Event.current.shift) {  				angle = Mathf.Floor (angle);  			}  			ap.angle = angle;  		}  		Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  		GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  		ap.position.x = Mathf.Round (apPosition.x);  		ap.position.y = Mathf.Round (apPosition.y);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  		id += 2;  	}  	Handles.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.AttachPoint) {  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = "Mode.AttachPoint".GetHashCode ();  	foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  		Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  		if (showAttachPointSprites) {  			tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  			if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  				tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  				tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  			}  		}  		Vector2 pos = apPosition * editorDisplayScale + origin;  		GUI.color = Color.clear;  		// don't actually draw the move handle center  		apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  		GUI.color = Color.white;  		float handleSize = 30;  		Handles.color = Color.green;  		Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  		Handles.color = Color.red;  		Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  		Handles.color = Color.white;  		Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  		// rotation handle  		Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  		Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  		if (newRotHandlePos != rotHandlePos) {  			Vector2 deltaRot = newRotHandlePos - pos;  			float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  			if (Event.current.control) {  				float snapAmount = Event.current.shift ? 15 : 5;  				angle = Mathf.Floor (angle / snapAmount) * snapAmount;  			}  			else if (!Event.current.shift) {  				angle = Mathf.Floor (angle);  			}  			ap.angle = angle;  		}  		Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  		GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  		ap.position.x = Mathf.Round (apPosition.x);  		ap.position.y = Mathf.Round (apPosition.y);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  		id += 2;  	}  	Handles.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.AttachPoint) {  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = "Mode.AttachPoint".GetHashCode ();  	foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  		Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  		if (showAttachPointSprites) {  			tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  			if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  				tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  				tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  			}  		}  		Vector2 pos = apPosition * editorDisplayScale + origin;  		GUI.color = Color.clear;  		// don't actually draw the move handle center  		apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  		GUI.color = Color.white;  		float handleSize = 30;  		Handles.color = Color.green;  		Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  		Handles.color = Color.red;  		Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  		Handles.color = Color.white;  		Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  		// rotation handle  		Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  		Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  		if (newRotHandlePos != rotHandlePos) {  			Vector2 deltaRot = newRotHandlePos - pos;  			float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  			if (Event.current.control) {  				float snapAmount = Event.current.shift ? 15 : 5;  				angle = Mathf.Floor (angle / snapAmount) * snapAmount;  			}  			else if (!Event.current.shift) {  				angle = Mathf.Floor (angle);  			}  			ap.angle = angle;  		}  		Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  		GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  		ap.position.x = Mathf.Round (apPosition.x);  		ap.position.y = Mathf.Round (apPosition.y);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  		id += 2;  	}  	Handles.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.AttachPoint) {  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = "Mode.AttachPoint".GetHashCode ();  	foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  		Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  		if (showAttachPointSprites) {  			tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  			if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  				tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  				tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  			}  		}  		Vector2 pos = apPosition * editorDisplayScale + origin;  		GUI.color = Color.clear;  		// don't actually draw the move handle center  		apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  		GUI.color = Color.white;  		float handleSize = 30;  		Handles.color = Color.green;  		Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  		Handles.color = Color.red;  		Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  		Handles.color = Color.white;  		Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  		// rotation handle  		Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  		Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  		if (newRotHandlePos != rotHandlePos) {  			Vector2 deltaRot = newRotHandlePos - pos;  			float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  			if (Event.current.control) {  				float snapAmount = Event.current.shift ? 15 : 5;  				angle = Mathf.Floor (angle / snapAmount) * snapAmount;  			}  			else if (!Event.current.shift) {  				angle = Mathf.Floor (angle);  			}  			ap.angle = angle;  		}  		Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  		GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  		ap.position.x = Mathf.Round (apPosition.x);  		ap.position.y = Mathf.Round (apPosition.y);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  		id += 2;  	}  	Handles.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.AttachPoint) {  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = "Mode.AttachPoint".GetHashCode ();  	foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  		Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  		if (showAttachPointSprites) {  			tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  			if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  				tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  				tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  			}  		}  		Vector2 pos = apPosition * editorDisplayScale + origin;  		GUI.color = Color.clear;  		// don't actually draw the move handle center  		apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  		GUI.color = Color.white;  		float handleSize = 30;  		Handles.color = Color.green;  		Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  		Handles.color = Color.red;  		Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  		Handles.color = Color.white;  		Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  		// rotation handle  		Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  		Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  		if (newRotHandlePos != rotHandlePos) {  			Vector2 deltaRot = newRotHandlePos - pos;  			float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  			if (Event.current.control) {  				float snapAmount = Event.current.shift ? 15 : 5;  				angle = Mathf.Floor (angle / snapAmount) * snapAmount;  			}  			else if (!Event.current.shift) {  				angle = Mathf.Floor (angle);  			}  			ap.angle = angle;  		}  		Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  		GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  		ap.position.x = Mathf.Round (apPosition.x);  		ap.position.y = Mathf.Round (apPosition.y);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  		id += 2;  	}  	Handles.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.AttachPoint) {  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = "Mode.AttachPoint".GetHashCode ();  	foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  		Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  		if (showAttachPointSprites) {  			tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  			if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  				tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  				tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  			}  		}  		Vector2 pos = apPosition * editorDisplayScale + origin;  		GUI.color = Color.clear;  		// don't actually draw the move handle center  		apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  		GUI.color = Color.white;  		float handleSize = 30;  		Handles.color = Color.green;  		Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  		Handles.color = Color.red;  		Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  		Handles.color = Color.white;  		Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  		// rotation handle  		Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  		Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  		if (newRotHandlePos != rotHandlePos) {  			Vector2 deltaRot = newRotHandlePos - pos;  			float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  			if (Event.current.control) {  				float snapAmount = Event.current.shift ? 15 : 5;  				angle = Mathf.Floor (angle / snapAmount) * snapAmount;  			}  			else if (!Event.current.shift) {  				angle = Mathf.Floor (angle);  			}  			ap.angle = angle;  		}  		Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  		GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  		ap.position.x = Mathf.Round (apPosition.x);  		ap.position.y = Mathf.Round (apPosition.y);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  		id += 2;  	}  	Handles.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.AttachPoint) {  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = "Mode.AttachPoint".GetHashCode ();  	foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  		Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  		if (showAttachPointSprites) {  			tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  			if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  				tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  				tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  			}  		}  		Vector2 pos = apPosition * editorDisplayScale + origin;  		GUI.color = Color.clear;  		// don't actually draw the move handle center  		apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  		GUI.color = Color.white;  		float handleSize = 30;  		Handles.color = Color.green;  		Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  		Handles.color = Color.red;  		Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  		Handles.color = Color.white;  		Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  		// rotation handle  		Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  		Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  		if (newRotHandlePos != rotHandlePos) {  			Vector2 deltaRot = newRotHandlePos - pos;  			float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  			if (Event.current.control) {  				float snapAmount = Event.current.shift ? 15 : 5;  				angle = Mathf.Floor (angle / snapAmount) * snapAmount;  			}  			else if (!Event.current.shift) {  				angle = Mathf.Floor (angle);  			}  			ap.angle = angle;  		}  		Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  		GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  		ap.position.x = Mathf.Round (apPosition.x);  		ap.position.y = Mathf.Round (apPosition.y);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  		id += 2;  	}  	Handles.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (mode == Mode.AttachPoint) {  	Vector2 origin = new Vector2 (textureRect.x' textureRect.y);  	int id = "Mode.AttachPoint".GetHashCode ();  	foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  		Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  		if (showAttachPointSprites) {  			tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  			if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  				tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  				tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  			}  		}  		Vector2 pos = apPosition * editorDisplayScale + origin;  		GUI.color = Color.clear;  		// don't actually draw the move handle center  		apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  		GUI.color = Color.white;  		float handleSize = 30;  		Handles.color = Color.green;  		Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  		Handles.color = Color.red;  		Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  		Handles.color = Color.white;  		Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  		// rotation handle  		Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  		Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  		if (newRotHandlePos != rotHandlePos) {  			Vector2 deltaRot = newRotHandlePos - pos;  			float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  			if (Event.current.control) {  				float snapAmount = Event.current.shift ? 15 : 5;  				angle = Mathf.Floor (angle / snapAmount) * snapAmount;  			}  			else if (!Event.current.shift) {  				angle = Mathf.Floor (angle);  			}  			ap.angle = angle;  		}  		Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  		GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  		ap.position.x = Mathf.Round (apPosition.x);  		ap.position.y = Mathf.Round (apPosition.y);  		tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  		id += 2;  	}  	Handles.color = Color.white;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  	Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  	if (showAttachPointSprites) {  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  			tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  			tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  		}  	}  	Vector2 pos = apPosition * editorDisplayScale + origin;  	GUI.color = Color.clear;  	// don't actually draw the move handle center  	apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  	GUI.color = Color.white;  	float handleSize = 30;  	Handles.color = Color.green;  	Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  	Handles.color = Color.red;  	Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  	Handles.color = Color.white;  	Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  	// rotation handle  	Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  	Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  	if (newRotHandlePos != rotHandlePos) {  		Vector2 deltaRot = newRotHandlePos - pos;  		float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  		if (Event.current.control) {  			float snapAmount = Event.current.shift ? 15 : 5;  			angle = Mathf.Floor (angle / snapAmount) * snapAmount;  		}  		else if (!Event.current.shift) {  			angle = Mathf.Floor (angle);  		}  		ap.angle = angle;  	}  	Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  	GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  	ap.position.x = Mathf.Round (apPosition.x);  	ap.position.y = Mathf.Round (apPosition.y);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  	id += 2;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  	Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  	if (showAttachPointSprites) {  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  			tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  			tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  		}  	}  	Vector2 pos = apPosition * editorDisplayScale + origin;  	GUI.color = Color.clear;  	// don't actually draw the move handle center  	apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  	GUI.color = Color.white;  	float handleSize = 30;  	Handles.color = Color.green;  	Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  	Handles.color = Color.red;  	Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  	Handles.color = Color.white;  	Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  	// rotation handle  	Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  	Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  	if (newRotHandlePos != rotHandlePos) {  		Vector2 deltaRot = newRotHandlePos - pos;  		float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  		if (Event.current.control) {  			float snapAmount = Event.current.shift ? 15 : 5;  			angle = Mathf.Floor (angle / snapAmount) * snapAmount;  		}  		else if (!Event.current.shift) {  			angle = Mathf.Floor (angle);  		}  		ap.angle = angle;  	}  	Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  	GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  	ap.position.x = Mathf.Round (apPosition.x);  	ap.position.y = Mathf.Round (apPosition.y);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  	id += 2;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  	Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  	if (showAttachPointSprites) {  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  			tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  			tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  		}  	}  	Vector2 pos = apPosition * editorDisplayScale + origin;  	GUI.color = Color.clear;  	// don't actually draw the move handle center  	apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  	GUI.color = Color.white;  	float handleSize = 30;  	Handles.color = Color.green;  	Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  	Handles.color = Color.red;  	Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  	Handles.color = Color.white;  	Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  	// rotation handle  	Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  	Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  	if (newRotHandlePos != rotHandlePos) {  		Vector2 deltaRot = newRotHandlePos - pos;  		float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  		if (Event.current.control) {  			float snapAmount = Event.current.shift ? 15 : 5;  			angle = Mathf.Floor (angle / snapAmount) * snapAmount;  		}  		else if (!Event.current.shift) {  			angle = Mathf.Floor (angle);  		}  		ap.angle = angle;  	}  	Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  	GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  	ap.position.x = Mathf.Round (apPosition.x);  	ap.position.y = Mathf.Round (apPosition.y);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  	id += 2;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  	Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  	if (showAttachPointSprites) {  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  			tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  			tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  		}  	}  	Vector2 pos = apPosition * editorDisplayScale + origin;  	GUI.color = Color.clear;  	// don't actually draw the move handle center  	apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  	GUI.color = Color.white;  	float handleSize = 30;  	Handles.color = Color.green;  	Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  	Handles.color = Color.red;  	Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  	Handles.color = Color.white;  	Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  	// rotation handle  	Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  	Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  	if (newRotHandlePos != rotHandlePos) {  		Vector2 deltaRot = newRotHandlePos - pos;  		float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  		if (Event.current.control) {  			float snapAmount = Event.current.shift ? 15 : 5;  			angle = Mathf.Floor (angle / snapAmount) * snapAmount;  		}  		else if (!Event.current.shift) {  			angle = Mathf.Floor (angle);  		}  		ap.angle = angle;  	}  	Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  	GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  	ap.position.x = Mathf.Round (apPosition.x);  	ap.position.y = Mathf.Round (apPosition.y);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  	id += 2;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  	Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  	if (showAttachPointSprites) {  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  			tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  			tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  		}  	}  	Vector2 pos = apPosition * editorDisplayScale + origin;  	GUI.color = Color.clear;  	// don't actually draw the move handle center  	apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  	GUI.color = Color.white;  	float handleSize = 30;  	Handles.color = Color.green;  	Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  	Handles.color = Color.red;  	Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  	Handles.color = Color.white;  	Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  	// rotation handle  	Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  	Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  	if (newRotHandlePos != rotHandlePos) {  		Vector2 deltaRot = newRotHandlePos - pos;  		float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  		if (Event.current.control) {  			float snapAmount = Event.current.shift ? 15 : 5;  			angle = Mathf.Floor (angle / snapAmount) * snapAmount;  		}  		else if (!Event.current.shift) {  			angle = Mathf.Floor (angle);  		}  		ap.angle = angle;  	}  	Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  	GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  	ap.position.x = Mathf.Round (apPosition.x);  	ap.position.y = Mathf.Round (apPosition.y);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  	id += 2;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  	Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  	if (showAttachPointSprites) {  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  			tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  			tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  		}  	}  	Vector2 pos = apPosition * editorDisplayScale + origin;  	GUI.color = Color.clear;  	// don't actually draw the move handle center  	apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  	GUI.color = Color.white;  	float handleSize = 30;  	Handles.color = Color.green;  	Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  	Handles.color = Color.red;  	Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  	Handles.color = Color.white;  	Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  	// rotation handle  	Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  	Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  	if (newRotHandlePos != rotHandlePos) {  		Vector2 deltaRot = newRotHandlePos - pos;  		float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  		if (Event.current.control) {  			float snapAmount = Event.current.shift ? 15 : 5;  			angle = Mathf.Floor (angle / snapAmount) * snapAmount;  		}  		else if (!Event.current.shift) {  			angle = Mathf.Floor (angle);  		}  		ap.angle = angle;  	}  	Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  	GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  	ap.position.x = Mathf.Round (apPosition.x);  	ap.position.y = Mathf.Round (apPosition.y);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  	id += 2;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  	Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  	if (showAttachPointSprites) {  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  			tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  			tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  		}  	}  	Vector2 pos = apPosition * editorDisplayScale + origin;  	GUI.color = Color.clear;  	// don't actually draw the move handle center  	apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  	GUI.color = Color.white;  	float handleSize = 30;  	Handles.color = Color.green;  	Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  	Handles.color = Color.red;  	Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  	Handles.color = Color.white;  	Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  	// rotation handle  	Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  	Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  	if (newRotHandlePos != rotHandlePos) {  		Vector2 deltaRot = newRotHandlePos - pos;  		float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  		if (Event.current.control) {  			float snapAmount = Event.current.shift ? 15 : 5;  			angle = Mathf.Floor (angle / snapAmount) * snapAmount;  		}  		else if (!Event.current.shift) {  			angle = Mathf.Floor (angle);  		}  		ap.angle = angle;  	}  	Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  	GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  	ap.position.x = Mathf.Round (apPosition.x);  	ap.position.y = Mathf.Round (apPosition.y);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  	id += 2;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: foreach (tk2dSpriteDefinition.AttachPoint ap in param.attachPoints) {  	Vector2 apPosition = new Vector2 (ap.position.x' ap.position.y);  	if (showAttachPointSprites) {  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (SpriteCollection.attachPointTestSprites.TryGetValue (ap.name' out spriteProxy) && spriteProxy.spriteCollection != null && spriteProxy.spriteCollection.IsValidSpriteId (spriteProxy.spriteId)) {  			tk2dSpriteDefinition def = spriteProxy.spriteCollection.inst.spriteDefinitions [spriteProxy.spriteId];  			tk2dSpriteThumbnailCache.DrawSpriteTextureInRect (textureRect' def' Color.white' ap.position' ap.angle' new Vector2 (editorDisplayScale' editorDisplayScale));  		}  	}  	Vector2 pos = apPosition * editorDisplayScale + origin;  	GUI.color = Color.clear;  	// don't actually draw the move handle center  	apPosition = (tk2dGuiUtility.PositionHandle (id' pos) - origin) / editorDisplayScale;  	GUI.color = Color.white;  	float handleSize = 30;  	Handles.color = Color.green;  	Handles.DrawLine (pos' pos - Rotate (Vector2.up' ap.angle) * handleSize);  	Handles.color = Color.red;  	Handles.DrawLine (pos' pos + Rotate (Vector2.right' ap.angle) * handleSize);  	Handles.color = Color.white;  	Handles.DrawWireDisc (pos' Vector3.forward' handleSize);  	// rotation handle  	Vector2 rotHandlePos = pos + Rotate (Vector2.right' ap.angle) * handleSize;  	Vector2 newRotHandlePos = tk2dGuiUtility.Handle (tk2dEditorSkin.RotateHandle' id + 1' rotHandlePos' false);  	if (newRotHandlePos != rotHandlePos) {  		Vector2 deltaRot = newRotHandlePos - pos;  		float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  		if (Event.current.control) {  			float snapAmount = Event.current.shift ? 15 : 5;  			angle = Mathf.Floor (angle / snapAmount) * snapAmount;  		}  		else if (!Event.current.shift) {  			angle = Mathf.Floor (angle);  		}  		ap.angle = angle;  	}  	Rect r = new Rect (pos.x + 8' pos.y + 6' 1000' 50);  	GUI.Label (r' ap.name' EditorStyles.whiteMiniLabel);  	ap.position.x = Mathf.Round (apPosition.x);  	ap.position.y = Mathf.Round (apPosition.y);  	tk2dGuiUtility.SetPositionHandleValue (id' new Vector2 (ap.position.x' ap.position.y));  	id += 2;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (newRotHandlePos != rotHandlePos) {  	Vector2 deltaRot = newRotHandlePos - pos;  	float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  	if (Event.current.control) {  		float snapAmount = Event.current.shift ? 15 : 5;  		angle = Mathf.Floor (angle / snapAmount) * snapAmount;  	}  	else if (!Event.current.shift) {  		angle = Mathf.Floor (angle);  	}  	ap.angle = angle;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (newRotHandlePos != rotHandlePos) {  	Vector2 deltaRot = newRotHandlePos - pos;  	float angle = -Mathf.Atan2 (deltaRot.y' deltaRot.x) * Mathf.Rad2Deg;  	if (Event.current.control) {  		float snapAmount = Event.current.shift ? 15 : 5;  		angle = Mathf.Floor (angle / snapAmount) * snapAmount;  	}  	else if (!Event.current.shift) {  		angle = Mathf.Floor (angle);  	}  	ap.angle = angle;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (Event.current.control) {  	float snapAmount = Event.current.shift ? 15 : 5;  	angle = Mathf.Floor (angle / snapAmount) * snapAmount;  }  else if (!Event.current.shift) {  	angle = Mathf.Floor (angle);  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: if (Event.current.control) {  	float snapAmount = Event.current.shift ? 15 : 5;  	angle = Mathf.Floor (angle / snapAmount) * snapAmount;  }  else if (!Event.current.shift) {  	angle = Mathf.Floor (angle);  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawTextureView,The following statement contains a magic number: id += 2;  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawAttachPointInspector,The following statement contains a magic number: foreach (var ap in param.attachPoints) {  	GUILayout.BeginHorizontal ();  	if (editingAttachPointName == ap) {  		if (Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.Return) {  			newEditingAttachPointName = null;  			HandleUtility.Repaint ();  			GUIUtility.keyboardControl = 0;  		}  		ap.name = GUILayout.TextField (ap.name);  	}  	else {  		int sel = EditorGUILayout.Popup (apNameLookup [ap.name]' apNames.ToArray ());  		if (sel == apNames.Count - 1) {  			newEditingAttachPointName = ap;  			HandleUtility.Repaint ();  		}  		else {  			ap.name = apNames [sel];  		}  	}  	ap.angle = EditorGUILayout.FloatField (ap.angle' GUILayout.Width (45));  	if (GUILayout.Button ("x"' GUILayout.Width (22))) {  		toDelete = apIdx;  	}  	GUILayout.EndHorizontal ();  	if (showAttachPointSprites) {  		bool pushGUIEnabled = GUI.enabled;  		string tmpName;  		if (editingAttachPointName != ap) {  			tmpName = ap.name;  		}  		else {  			tmpName = "";  			GUI.enabled = false;  		}  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (!SpriteCollection.attachPointTestSprites.TryGetValue (tmpName' out spriteProxy)) {  			spriteProxy = new tk2dSpriteCollection.AttachPointTestSprite ();  			SpriteCollection.attachPointTestSprites.Add (tmpName' spriteProxy);  		}  		tk2dSpriteGuiUtility.SpriteSelector (spriteProxy.spriteCollection' spriteProxy.spriteId' AttachPointSpriteHandler' tmpName);  		GUI.enabled = pushGUIEnabled;  	}  	editingAttachPointName = newEditingAttachPointName;  	++apIdx;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawAttachPointInspector,The following statement contains a magic number: foreach (var ap in param.attachPoints) {  	GUILayout.BeginHorizontal ();  	if (editingAttachPointName == ap) {  		if (Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.Return) {  			newEditingAttachPointName = null;  			HandleUtility.Repaint ();  			GUIUtility.keyboardControl = 0;  		}  		ap.name = GUILayout.TextField (ap.name);  	}  	else {  		int sel = EditorGUILayout.Popup (apNameLookup [ap.name]' apNames.ToArray ());  		if (sel == apNames.Count - 1) {  			newEditingAttachPointName = ap;  			HandleUtility.Repaint ();  		}  		else {  			ap.name = apNames [sel];  		}  	}  	ap.angle = EditorGUILayout.FloatField (ap.angle' GUILayout.Width (45));  	if (GUILayout.Button ("x"' GUILayout.Width (22))) {  		toDelete = apIdx;  	}  	GUILayout.EndHorizontal ();  	if (showAttachPointSprites) {  		bool pushGUIEnabled = GUI.enabled;  		string tmpName;  		if (editingAttachPointName != ap) {  			tmpName = ap.name;  		}  		else {  			tmpName = "";  			GUI.enabled = false;  		}  		tk2dSpriteCollection.AttachPointTestSprite spriteProxy = null;  		if (!SpriteCollection.attachPointTestSprites.TryGetValue (tmpName' out spriteProxy)) {  			spriteProxy = new tk2dSpriteCollection.AttachPointTestSprite ();  			SpriteCollection.attachPointTestSprites.Add (tmpName' spriteProxy);  		}  		tk2dSpriteGuiUtility.SpriteSelector (spriteProxy.spriteCollection' spriteProxy.spriteId' AttachPointSpriteHandler' tmpName);  		GUI.enabled = pushGUIEnabled;  	}  	editingAttachPointName = newEditingAttachPointName;  	++apIdx;  }  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawAttachPointInspector,The following statement contains a magic number: ap.angle = EditorGUILayout.FloatField (ap.angle' GUILayout.Width (45));  
Magic Number,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawAttachPointInspector,The following statement contains a magic number: if (GUILayout.Button ("x"' GUILayout.Width (22))) {  	toDelete = apIdx;  }  
Magic Number,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following statement contains a magic number: switch (targetTextureFormat) {  case TextureFormat.ARGB4444:  	quantShiftR = quantShiftG = quantShiftB = quantShiftA = 4;  	break;  case TextureFormat.RGB565:  	quantShiftR = 5;  	quantShiftB = 6;  	quantShiftG = 5;  	quantShiftA = 0;  	break;  }  
Magic Number,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following statement contains a magic number: switch (targetTextureFormat) {  case TextureFormat.ARGB4444:  	quantShiftR = quantShiftG = quantShiftB = quantShiftA = 4;  	break;  case TextureFormat.RGB565:  	quantShiftR = 5;  	quantShiftB = 6;  	quantShiftG = 5;  	quantShiftA = 0;  	break;  }  
Magic Number,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following statement contains a magic number: switch (targetTextureFormat) {  case TextureFormat.ARGB4444:  	quantShiftR = quantShiftG = quantShiftB = quantShiftA = 4;  	break;  case TextureFormat.RGB565:  	quantShiftR = 5;  	quantShiftB = 6;  	quantShiftG = 5;  	quantShiftA = 0;  	break;  }  
Magic Number,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following statement contains a magic number: switch (targetTextureFormat) {  case TextureFormat.ARGB4444:  	quantShiftR = quantShiftG = quantShiftB = quantShiftA = 4;  	break;  case TextureFormat.RGB565:  	quantShiftR = 5;  	quantShiftB = 6;  	quantShiftG = 5;  	quantShiftA = 0;  	break;  }  
Magic Number,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following statement contains a magic number: quantShiftR = quantShiftG = quantShiftB = quantShiftA = 4;  
Magic Number,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following statement contains a magic number: quantShiftR = 5;  
Magic Number,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following statement contains a magic number: quantShiftB = 6;  
Magic Number,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following statement contains a magic number: quantShiftG = 5;  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: for (int i = 0' j = 0; i < ints.Length; ++i' j += 4) {  	ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  }  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: for (int i = 0' j = 0; i < ints.Length; ++i' j += 4) {  	ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  }  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: for (int i = 0' j = 0; i < ints.Length; ++i' j += 4) {  	ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  }  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: for (int i = 0' j = 0; i < ints.Length; ++i' j += 4) {  	ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  }  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: for (int i = 0' j = 0; i < ints.Length; ++i' j += 4) {  	ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  }  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: for (int i = 0' j = 0; i < ints.Length; ++i' j += 4) {  	ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  }  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: j += 4
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  
Magic Number,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,BytesToInts,The following statement contains a magic number: ints [i] = (uint)bytes [j] | ((uint)bytes [j + 1] << 8) | ((uint)bytes [j + 2] << 16) | ((uint)bytes [j + 3] << 24);  
Missing Default,tk2dEditor,tk2dCameraSceneGUI,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Camera\tk2dCameraEditor.cs,PreviewWindowFunc,The following switch statement is missing a default case: switch (Event.current.type) {  case EventType.Repaint: {  	int heightTweak = 19;  	Rect r = new Rect (previewWindowRect.x + rs.x' Camera.current.pixelHeight - (previewWindowRect.y + rs.y)' rs.width' rs.height);  	Vector2 v = new Vector2 (previewWindowRect.x + rs.x' (Camera.current.pixelHeight - previewWindowRect.y - rs.height - heightTweak) + rs.y);  	previewCamera.CopyFrom (target.camera);  	previewCamera.projectionMatrix = target.Editor__GetFinalProjectionMatrix ();  	// Work around a Unity bug  	previewCamera.pixelRect = new Rect (v.x' v.y' r.width' r.height);  	previewCamera.Render ();  	break;  }  }  
Missing Default,tk2dEditor,BrushBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\tk2dTileMapBrushBuilder.cs,HandleGUI,The following switch statement is missing a default case: switch (Event.current.GetTypeForControl (controlID)) {  case EventType.MouseDown:  	bool multiSelectKeyDown = (Application.platform == RuntimePlatform.OSXEditor) ? Event.current.command : Event.current.control;  	if (multiSelectKeyDown) {  		multiSelect = true;  		rectSelect = false;  		// Only add to selection when changing from single selection to multiselect  		if (tileSelection.Count == 0) {  			AddToSelection (tilesPerRow);  		}  	}  	else {  		Reset ();  	}  	tileSelection_x0 = tx;  	tileSelection_y0 = ty;  	tileSelection_x1 = tx;  	tileSelection_y1 = ty;  	HandleUtility.Repaint ();  	GUIUtility.hotControl = controlID;  	break;  case EventType.MouseDrag:  	if (GUIUtility.hotControl == controlID) {  		tileSelection_x1 = tx;  		tileSelection_y1 = ty;  		HandleUtility.Repaint ();  	}  	break;  case EventType.MouseUp:  	if (GUIUtility.hotControl == controlID) {  		if (multiSelect) {  			AddToSelection (tilesPerRow);  		}  		// Build brush  		GUIUtility.hotControl = 0;  		BuildBrush (spriteCollection' brush' tilesPerRow);  		HandleUtility.Repaint ();  	}  	break;  }  
Missing Default,tk2dEditor.Atlas,MaxRectsBinPack,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dMaxRectsBinPack.cs,Insert,The following switch statement is missing a default case: switch (method) {  case FreeRectChoiceHeuristic.RectBestShortSideFit:  	newNode = FindPositionForNewNodeBestShortSideFit (width' height' ref score1' ref score2);  	break;  case FreeRectChoiceHeuristic.RectBottomLeftRule:  	newNode = FindPositionForNewNodeBottomLeft (width' height' ref score1' ref score2);  	break;  case FreeRectChoiceHeuristic.RectContactPointRule:  	newNode = FindPositionForNewNodeContactPoint (width' height' ref score1);  	break;  case FreeRectChoiceHeuristic.RectBestLongSideFit:  	newNode = FindPositionForNewNodeBestLongSideFit (width' height' ref score2' ref score1);  	break;  case FreeRectChoiceHeuristic.RectBestAreaFit:  	newNode = FindPositionForNewNodeBestAreaFit (width' height' ref score1' ref score2);  	break;  }  
Missing Default,tk2dEditor.Atlas,MaxRectsBinPack,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\Atlas\tk2dMaxRectsBinPack.cs,ScoreRect,The following switch statement is missing a default case: switch (method) {  case FreeRectChoiceHeuristic.RectBestShortSideFit:  	newNode = FindPositionForNewNodeBestShortSideFit (width' height' ref score1' ref score2);  	break;  case FreeRectChoiceHeuristic.RectBottomLeftRule:  	newNode = FindPositionForNewNodeBottomLeft (width' height' ref score1' ref score2);  	break;  case FreeRectChoiceHeuristic.RectContactPointRule:  	newNode = FindPositionForNewNodeContactPoint (width' height' ref score1);  	score1 = -score1;  	// Reverse since we are minimizing' but for contact point score bigger is better.  	break;  case FreeRectChoiceHeuristic.RectBestLongSideFit:  	newNode = FindPositionForNewNodeBestLongSideFit (width' height' ref score2' ref score1);  	break;  case FreeRectChoiceHeuristic.RectBestAreaFit:  	newNode = FindPositionForNewNodeBestAreaFit (width' height' ref score1' ref score2);  	break;  }  
Missing Default,tk2dEditor.SpriteAnimationEditor,ClipEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipEditor.cs,HandleKeyboardShortcuts,The following switch statement is missing a default case: switch (ev.keyCode) {  case KeyCode.UpArrow:  	if (OnClipSelectionChanged (-1))  		ev.Use ();  	break;  case KeyCode.DownArrow:  	if (OnClipSelectionChanged (1))  		ev.Use ();  	break;  case KeyCode.Return:  	TogglePlayAnimation ();  	ev.Use ();  	break;  case KeyCode.F:  	if (preview != null)  		preview.ResetTransform ();  	ev.Use ();  	break;  }  
Missing Default,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The following switch statement is missing a default case: switch (ev.keyCode) {  case KeyCode.LeftArrow:  case KeyCode.Comma:  	newFrame--;  	break;  case KeyCode.RightArrow:  case KeyCode.Period:  	newFrame++;  	break;  case KeyCode.Home:  	newFrame = 0;  	break;  case KeyCode.End:  	newFrame = frameGroups.Count - 1;  	break;  case KeyCode.Escape:  	state.selectedFrame = -1;  	Repaint ();  	ev.Use ();  	break;  }  
Missing Default,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The following switch statement is missing a default case: switch (ev.GetTypeForControl (controlId)) {  case EventType.MouseDown:  	if (frameGroupRect.Contains (ev.mousePosition)) {  		int frameGroup = GetSelectedFrameGroup (frameGroupRect' ev.mousePosition' frameGroups' false);  		if (frameGroup != state.selectedFrame) {  			Repaint ();  			state.selectedFrame = frameGroup;  		}  		if (frameGroup != -1) {  			Rect r = GetRectForFrameGroup (frameGroupRect' frameGroups [frameGroup]);  			Rect resizeRect = GetResizeRectFromFrameRect (r);  			state.frameSelectionOffset = ev.mousePosition - new Vector2 (r.x' 0);  			state.type = resizeRect.Contains (ev.mousePosition) ? State.Type.Resize : State.Type.MoveHandle;  			if (state.type == State.Type.Resize) {  				if (singleFrameMode) {  					state.ResetState ();  					// disallow resize in single frame mode  				}  				else {  					state.backupFrames = new List<tk2dSpriteAnimationFrame> (frameGroups [frameGroup].frames);  					// make a backup of frames for triggers  					state.activeFrame = frameGroup;  					state.insertMarker = state.activeFrame;  				}  			}  			else {  				state.activeFrame = frameGroup;  				state.insertMarker = state.activeFrame;  			}  		}  		GUIUtility.hotControl = controlId;  	}  	GUIUtility.keyboardControl = 0;  	break;  case EventType.MouseDrag:  	{  		switch (state.type) {  		case State.Type.MoveHandle:  		case State.Type.Move:  			{  				state.type = State.Type.Move;  				state.insertMarker = GetSelectedFrameGroup (frameGroupRect' ev.mousePosition' frameGroups' true);  			}  			break;  		case State.Type.Resize:  			{  				int frame = GetSelectedFrame (frameGroupRect' ev.mousePosition + new Vector2 (frameWidth * 0.5f' 0.0f));  				ClipEditor.FrameGroup fg = frameGroups [state.activeFrame];  				int frameCount = Mathf.Max (1' frame - fg.startFrame);  				bool changed = frameCount != fg.frames.Count;  				if (changed) {  					fg.frames = new List<tk2dSpriteAnimationFrame> (state.backupFrames);  					fg.SetFrameCount (frameCount);  					Repaint ();  					ClipEditor.RecalculateFrames (clip' frameGroups);  				}  			}  			break;  		}  	}  	break;  case EventType.MouseUp:  	switch (state.type) {  	case State.Type.Move:  		{  			int finalInsertMarker = (state.insertMarker > state.activeFrame) ? (state.insertMarker - 1) : state.insertMarker;  			if (state.activeFrame != finalInsertMarker) {  				ClipEditor.FrameGroup tmpFrameGroup = frameGroups [state.activeFrame];  				frameGroups.RemoveAt (state.activeFrame);  				frameGroups.Insert (finalInsertMarker' tmpFrameGroup);  				state.selectedFrame = finalInsertMarker;  				ClipEditor.RecalculateFrames (clip' frameGroups);  				Repaint ();  			}  		}  		break;  	}  	if (state.type != State.Type.None)  		Repaint ();  	state.ResetState ();  	GUIUtility.keyboardControl = 0;  	GUIUtility.hotControl = 0;  	break;  }  
Missing Default,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The following switch statement is missing a default case: switch (state.type) {  case State.Type.MoveHandle:  case State.Type.Move:  	{  		state.type = State.Type.Move;  		state.insertMarker = GetSelectedFrameGroup (frameGroupRect' ev.mousePosition' frameGroups' true);  	}  	break;  case State.Type.Resize:  	{  		int frame = GetSelectedFrame (frameGroupRect' ev.mousePosition + new Vector2 (frameWidth * 0.5f' 0.0f));  		ClipEditor.FrameGroup fg = frameGroups [state.activeFrame];  		int frameCount = Mathf.Max (1' frame - fg.startFrame);  		bool changed = frameCount != fg.frames.Count;  		if (changed) {  			fg.frames = new List<tk2dSpriteAnimationFrame> (state.backupFrames);  			fg.SetFrameCount (frameCount);  			Repaint ();  			ClipEditor.RecalculateFrames (clip' frameGroups);  		}  	}  	break;  }  
Missing Default,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawFrameGroups,The following switch statement is missing a default case: switch (state.type) {  case State.Type.Move:  	{  		int finalInsertMarker = (state.insertMarker > state.activeFrame) ? (state.insertMarker - 1) : state.insertMarker;  		if (state.activeFrame != finalInsertMarker) {  			ClipEditor.FrameGroup tmpFrameGroup = frameGroups [state.activeFrame];  			frameGroups.RemoveAt (state.activeFrame);  			frameGroups.Insert (finalInsertMarker' tmpFrameGroup);  			state.selectedFrame = finalInsertMarker;  			ClipEditor.RecalculateFrames (clip' frameGroups);  			Repaint ();  		}  	}  	break;  }  
Missing Default,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The following switch statement is missing a default case: switch (ev.keyCode) {  case KeyCode.Escape:  	GUIUtility.hotControl = 0;  	state.Reset ();  	Repaint ();  	ev.Use ();  	break;  case KeyCode.Delete:  case KeyCode.Backspace:  	clip.frames [state.selectedTrigger].ClearTrigger ();  	GUIUtility.hotControl = 0;  	state.Reset ();  	Repaint ();  	ev.Use ();  	break;  }  
Missing Default,tk2dEditor.SpriteAnimationEditor,TimelineEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteAnimationEditor\tk2dSpriteAnimationClipTimelineEditor.cs,DrawTriggers,The following switch statement is missing a default case: switch (ev.GetTypeForControl (controlId)) {  case EventType.MouseDown:  	if (triggerRect.Contains (ev.mousePosition) && ev.button == 0) {  		int selectedTrigger = GetSelectedTrigger (triggerRect' ev.mousePosition);  		int selectedTriggerRegion = GetRoundedSelectedTrigger (triggerRect' ev.mousePosition);  		bool startDrag = state.selectedTrigger == selectedTriggerRegion;  		if (ev.clickCount == 1) {  			if (startDrag && selectedTriggerRegion == state.selectedTrigger) {  				GUIUtility.hotControl = controlId;  			}  			else if (selectedTrigger >= 0 && selectedTrigger < clip.frames.Length && clip.frames [selectedTrigger].triggerEvent) {  				state.selectedTrigger = selectedTrigger;  				Repaint ();  				GUIUtility.hotControl = controlId;  			}  		}  		// Double click on an empty area  		if (GUIUtility.hotControl == 0 && ev.clickCount == 2 && selectedTriggerRegion >= 0 && selectedTriggerRegion < clip.frames.Length && !clip.frames [selectedTriggerRegion].triggerEvent) {  			clip.frames [selectedTriggerRegion].triggerEvent = true;  			state.selectedTrigger = selectedTriggerRegion;  			Repaint ();  		}  		GUIUtility.keyboardControl = 0;  	}  	break;  case EventType.MouseDrag:  	{  		int selectedTrigger = Mathf.Clamp (GetRoundedSelectedTrigger (triggerRect' ev.mousePosition)' 0' clip.frames.Length - 1);  		if (state.movingTrigger != selectedTrigger) {  			state.movingTrigger = selectedTrigger;  			Repaint ();  		}  	}  	break;  case EventType.MouseUp:  	if (state.movingTrigger != -1 && state.movingTrigger != state.selectedTrigger) {  		tk2dSpriteAnimationFrame source = clip.frames [state.selectedTrigger];  		tk2dSpriteAnimationFrame dest = clip.frames [state.movingTrigger];  		dest.CopyTriggerFrom (source);  		source.ClearTrigger ();  		state.selectedTrigger = state.movingTrigger;  	}  	Repaint ();  	state.ResetState ();  	GUIUtility.hotControl = 0;  	break;  }  
Missing Default,tk2dEditor.SpriteCollectionEditor,SettingsView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSettingsView.cs,DrawTextureSettings,The following switch statement is missing a default case: switch (newRescaleSelection) {  case 0:  	SpriteCollection.globalTextureRescale = 1.0f;  	break;  case 1:  	SpriteCollection.globalTextureRescale = 0.5f;  	break;  case 2:  	SpriteCollection.globalTextureRescale = 0.25f;  	break;  }  
Missing Default,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,DrawSpriteEditorInspector,The following switch statement is missing a default case: switch (newMeshType) {  case CustomMeshType.Custom:  	param.customSpriteGeometry = true;  	break;  case CustomMeshType.Diced:  	param.dice = true;  	break;  case CustomMeshType.Default:  	break;  case CustomMeshType.DoubleSided:  	param.doubleSidedSprite = true;  	break;  }  
Missing Default,tk2dEditor.SpriteCollectionEditor,SpriteView,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorSpriteView.cs,Draw,The following switch statement is missing a default case: switch (entryType) {  case SpriteCollectionEditorEntry.Type.Sprite:  	DrawSpriteEditorView (entries);  	break;  case SpriteCollectionEditorEntry.Type.SpriteSheet:  	DrawSpriteSheetView (entries);  	break;  }  
Missing Default,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,DrawPolygonColliderEditor,The following switch statement is missing a default case: switch (ev.keyCode) {  case KeyCode.Backspace:  case KeyCode.Delete: {  	GUIUtility.keyboardControl = 0;  	GUIUtility.hotControl = 0;  	deletedIndex = i;  	ev.Use ();  	break;  }  case KeyCode.X: {  	GUIUtility.keyboardControl = 0;  	GUIUtility.hotControl = 0;  	deletedIsland = islandId;  	ev.Use ();  	break;  }  case KeyCode.T: {  	if (!forceClosed) {  		GUIUtility.keyboardControl = 0;  		GUIUtility.hotControl = 0;  		disconnectIsland = true;  		ev.Use ();  	}  	break;  }  case KeyCode.F: {  	flipIsland = true;  	GUIUtility.keyboardControl = 0;  	GUIUtility.hotControl = 0;  	ev.Use ();  	break;  }  case KeyCode.Escape: {  	GUIUtility.hotControl = 0;  	GUIUtility.keyboardControl = 0;  	ev.Use ();  	break;  }  }  
Missing Default,tk2dEditor.SpriteCollectionEditor,TextureEditor,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\SpriteCollectionEditor\tk2dSpriteCollectionEditorTextureView.cs,HandleKeys,The following switch statement is missing a default case: switch (evt.keyCode) {  case KeyCode.Q:  	newMode = Mode.Texture;  	break;  case KeyCode.W:  	newMode = Mode.Anchor;  	break;  case KeyCode.E:  	newMode = Mode.Collider;  	break;  case KeyCode.R:  	newMode = Mode.AttachPoint;  	break;  case KeyCode.N:  	drawColliderNormals = !drawColliderNormals;  	HandleUtility.Repaint ();  	break;  }  
Missing Default,tk2dEditor.TextureProcessing,FloydSteinbergDithering,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Editor\Sprites\TextureProcessing\tk2dFloydSteinbergDithering.cs,DitherTexture,The following switch statement is missing a default case: switch (targetTextureFormat) {  case TextureFormat.ARGB4444:  	quantShiftR = quantShiftG = quantShiftB = quantShiftA = 4;  	break;  case TextureFormat.RGB565:  	quantShiftR = 5;  	quantShiftB = 6;  	quantShiftG = 5;  	quantShiftA = 0;  	break;  }  
Missing Default,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,Import,The following switch statement is missing a default case: switch (format) {  case Format.TMX:  	if (!importer.CheckZlib ())  		return false;  	ext = "tmx";  	break;  }  
Missing Default,tk2dEditor.TileMap,Importer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Editor\Importer\tk2dTileMapImporter.cs,Import,The following switch statement is missing a default case: switch (format) {  case Format.TMX:  	message = importer.ImportTMX (path);  	break;  }  
