Implementation smell,Namespace,Class,File,Method,Description
Long Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The method has 100 lines of code.
Long Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 100 lines of code.
Complex Method,UGR.Mahjong,ButtonController,C:\repos\justdude_SpinTheBall\Assets\Code\Utils\ButtonController.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,Cyclomatic complexity of the method is 34
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,Cyclomatic complexity of the method is 10
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,HideTileMapPrefabs,Cyclomatic complexity of the method is 11
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,Cyclomatic complexity of the method is 16
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,Cyclomatic complexity of the method is 35
Complex Method,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,Cyclomatic complexity of the method is 19
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,Build,Cyclomatic complexity of the method is 10
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 5 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 8 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 9 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The method has 7 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,The method has 9 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,ApplySpriteVertexTileFlags,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Layer,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Init,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 7 parameters.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "			UnityEditor.EditorUtility.DisplayDialog ("tk2dRuntimeSpriteCollection Error"' "The tk2d/BlendVertexColor shader needs to be in a resources folder for this to work.\n\n" + "Create a subdirectory named 'resources' where the shaders are' and move the BlendVertexColor shader into this directory.\n\n" + "eg. TK2DROOT/tk2d/Shaders/Resources/BlendVertexColor\n\n" + "Be sure to do this from within Unity and not from Explorer/Finder."' "Ok"); " is 437.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "		sc.spriteDefinitions [i] = CreateDefinitionForRegionInTexture (names [i]' textureDimensions' scale' regions [i]' trimRect' anchors [i]' defRotated); " is 148.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v0 = new Vector2 ((uvRegion.x + uvOffset.x) / fwidth' 1.0f - (uvRegion.y + uvRegion.height + uvOffset.y) / fheight); " is 124.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v1 = new Vector2 ((uvRegion.x + uvRegion.width - uvOffset.x) / fwidth' 1.0f - (uvRegion.y - uvOffset.y) / fheight); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "							entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4])); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "	return CreateFromTexture (texture' spriteCollectionSize' textureDimensions' names.ToArray ()' rects.ToArray ()' trimRects.ToArray ()' anchors.ToArray ()' rotated.ToArray ()); " is 174.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "			tileMap.Layers [i] = new Layer (tileMap.data.Layers [i].hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 141.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "				newLayers [i] = new Layer (layerInfo.hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 122.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "		tileMap.ColorChannel = new ColorChannel (tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 120.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "			#if UNITY_3_0 || UNITY_3_1 || UNITY_3_2 || UNITY_3_3 || UNITY_3_4 || UNITY_3_5 || UNITY_3_6 || UNITY_3_7 || UNITY_3_8 || UNITY_3_9 " is 130.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "			layer.gameObject.transform.localPosition = new Vector3 (0' 0' tileMap.data.layersFixedZ ? (-layerInfoZ) : accumulatedLayerZ); " is 125.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "		BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' layer.numColumns' layer.numRows' out x0' out x1' out dx' out y0' out y1' out dy); " is 132.
Long Statement,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The length of the statement  "					Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90); " is 136.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "	BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' tileMap.partitionSizeX' tileMap.partitionSizeY' out x0' out x1' out dx' out y0' out y1' out dy); " is 147.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' sprite' sprite.positions [v]' flipH' flipV' rot90); " is 121.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "					Color color = Color.Lerp (Color.Lerp (tileColorx0y0' tileColorx1y0' tileColorX)' Color.Lerp (tileColorx0y1' tileColorx1y1' tileColorX)' tileColorY); " is 148.
Complex Conditional,tk2dRuntime.TileMap,ColorChannel,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Optimize,The conditional expression  "c.r != clearColor32.r || c.g != clearColor32.g || c.b != clearColor32.b || c.a != clearColor32.a"  is complex.
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.boundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.untrimmedBoundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.x = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.y = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryName = line.Substring (2);  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRotated = Int32.Parse (line.Substring (2)) == 1;  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildForChunk,The following statement contains a magic number: if (localMeshIndices.Length > 6) {  	// Remove duplicate verts  	localMeshVertices = WeldVertices (localMeshVertices' ref localMeshIndices);  	// Remove duplicate and back-to-back faces  	// Removes inside faces  	localMeshIndices = RemoveDuplicateFaces (localMeshIndices);  	// Merge coplanar faces  	// Optimize (remove unused vertices' reindex)  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [2] = new Vector3 (max.x' min.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [3] = new Vector3 (max.x' min.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [4] = new Vector3 (min.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [5] = new Vector3 (min.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [6] = new Vector3 (max.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [7] = new Vector3 (max.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  	vertexList.Add (flippedPos + currentPos);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,CompareDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {  	int d = indices [face0index + i] - indices [face1index + i];  	if (d != 0)  		return d;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortIndex [i / 3] = i;  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < sortIndex.Length; ++i) {  	if (i != sortIndex.Length - 1 && CompareDuplicateFaces (sortedFaceIndices' sortIndex [i]' sortIndex [i + 1]) == 0) {  		// skip both faces  		// this will fail in the case where there are 3 coplanar faces  		// but that is probably likely user error / intentional  		i++;  		continue;  	}  	for (int j = 0; j < 3; ++j)  		newIndices.Add (indices [sortIndex [i] + j]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int j = 0; j < 3; ++j)  	newIndices.Add (indices [sortIndex [i] + j]);  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\justdude_SpinTheBall\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
