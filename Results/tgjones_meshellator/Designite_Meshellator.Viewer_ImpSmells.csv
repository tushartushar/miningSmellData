Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Meshellator.Viewer.Framework.Rendering,ModelMesh,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\ModelMesh.cs,ModelMesh,The method has 8 parameters. Parameters: sourceMesh' device' vertexBuffer' numVertices' indexBuffer' primitiveCount' world' material
Long Parameter List,Meshellator.Viewer.Framework.Rendering,Renderer,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Renderer.cs,Renderer,The method has 5 parameters. Parameters: device' model' width' height' cameraTransform
Long Statement,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,DrawFullscreenQuad,The length of the statement  "			vertices[0] = new VertexTransformedPositionTexture(new Point4D(dest.Left - 0.5f' dest.Top - 0.5f' 0' 1)' new Point2D(0' 0)); " is 124.
Long Statement,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,DrawFullscreenQuad,The length of the statement  "			vertices[1] = new VertexTransformedPositionTexture(new Point4D(dest.Right - 0.5f' dest.Top - 0.5f' 0' 1)' new Point2D(1' 0)); " is 125.
Long Statement,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,DrawFullscreenQuad,The length of the statement  "			vertices[2] = new VertexTransformedPositionTexture(new Point4D(dest.Right - 0.5f' dest.Bottom - 0.5f' 0' 1)' new Point2D(0' 1)); " is 128.
Long Statement,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,DrawFullscreenQuad,The length of the statement  "			vertices[3] = new VertexTransformedPositionTexture(new Point4D(dest.Right - 0.5f' dest.Bottom - 0.5f' 0' 1)' new Point2D(1' 1)); " is 128.
Long Statement,Meshellator.Viewer.Modules.ModelEditor.Views,ModelEditorView,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\ModelEditor\Views\ModelEditorView.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Meshellator.Viewer;component/modules/modeleditor/views/modeleditorview.xaml"' System.UriKind.Relative); " is 149.
Long Statement,Meshellator.Viewer.Modules.ModelExplorer.Views,ExplorerView,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\ModelExplorer\Views\ModelExplorerView.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Meshellator.Viewer;component/modules/modelexplorer/views/modelexplorerview.xaml"' System.UriKind.Relative); " is 153.
Long Statement,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,NewSphere,The length of the statement  "			yield return Show.Document(new ModelEditorViewModel(new SceneViewModel(MeshellatorLoader.CreateFromSphere(10' 10))' "[New Sphere]")); " is 133.
Long Statement,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,NewTeapot,The length of the statement  "			yield return Show.Document(new ModelEditorViewModel(new SceneViewModel(MeshellatorLoader.CreateFromTeapot(10' 10))' "[New Teapot]")); " is 133.
Long Statement,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,ToggleFillModeWireframe,The length of the statement  "			yield return new RenderSettingsResult(e => e.RenderParameters.FillMode = (isChecked) ? FillMode.Wireframe : FillMode.Solid); " is 124.
Magic Number,Meshellator.Viewer.Framework.Rendering,Renderer,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Renderer.cs,Renderer,The following statement contains a magic number: _projection = Matrix3D.CreatePerspectiveFieldOfView(  				fov'  				width / (float) height'  				1.0f' radius * 10);
Magic Number,Meshellator.Viewer.Framework.Rendering,Renderer,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Renderer.cs,Renderer,The following statement contains a magic number: float dist = radius / MathUtility.Sin(fov / 2);
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,BlurComponent,The following statement contains a magic number: int width = Dims - 5;
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,BlurComponent,The following statement contains a magic number: int height = Dims - 5;
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < SampleCount / 2; i++)  			{  				// Store weights for the positive and negative taps.  				float weight = ComputeGaussian(i + 1);    				weights[i * 2 + 1] = weight;  				weights[i * 2 + 2] = weight;    				totalWeights += weight * 2;    				// To get the maximum amount of blurring from a limited number of  				// pixel shader samples' we take advantage of the bilinear filtering  				// hardware inside the texture fetch unit. If we position our texture  				// coordinates exactly halfway between two texels' the filtering unit  				// will average them for us' giving two samples for the price of one.  				// This allows us to step in units of two texels per sample' rather  				// than just one at a time. The 1.5 offset kicks things off by  				// positioning us nicely in between two texels.  				float sampleOffset = i * 2 + 1.5f;    				Vector4D delta = new Vector4D(dx' dy' 1.0f' 1.0f) * sampleOffset;    				// Store texture coordinate offsets for the positive and negative taps.  				offsets[i * 2 + 1] = delta;  				offsets[i * 2 + 2] = -delta;  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,ComputeGaussian,The following statement contains a magic number: return ((1.0f / MathUtility.Sqrt(2 * MathUtility.PI * theta)) *  										 MathUtility.Exp(-(n * n) / (2 * theta * theta)));
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,BlurComponent,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\BlurComponent.cs,ComputeGaussian,The following statement contains a magic number: return ((1.0f / MathUtility.Sqrt(2 * MathUtility.PI * theta)) *  										 MathUtility.Exp(-(n * n) / (2 * theta * theta)));
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,NormalsDecorator,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\NormalsDecorator.cs,GetNormalBuffers,The following statement contains a magic number: if (!_normals.ContainsKey(mesh))  			{  				NormalBuffers normalBuffers = new NormalBuffers();    				Line3D[] normalLines = NormalLinesGenerator.Generate(mesh.SourceMesh);  				normalBuffers.PrimitiveCount = normalLines.Length;  				normalBuffers.VertexCount = normalLines.Length * 2;    				VertexBuffer vertexBuffer = new VertexBuffer(_device'  					normalBuffers.VertexCount * VertexPositionColor.SizeInBytes'  					Usage.WriteOnly' VertexFormat.None' Pool.Default);  				DataStream vertexDataStream = vertexBuffer.Lock(0'  					normalBuffers.VertexCount * VertexPositionColor.SizeInBytes'  					LockFlags.None);  				VertexPositionColor[] vertices = new VertexPositionColor[normalBuffers.VertexCount];  				int counter = 0;  				for (int i = 0; i < normalLines.Length; ++i)  				{  					Vector3D normalColor = Vector3D.Normalize(normalLines[i].Direction);  					normalColor += Vector3D.One;  					normalColor *= 0.5f;  					vertices[counter++] = new VertexPositionColor(normalLines[i].Start' normalColor);  					vertices[counter++] = new VertexPositionColor(normalLines[i].End' normalColor);  				}  				vertexDataStream.WriteRange(vertices);  				vertexBuffer.Unlock();  				normalBuffers.Vertices = vertexBuffer;    				IndexBuffer indexBuffer = new IndexBuffer(_device' normalBuffers.VertexCount * sizeof(int)'  					Usage.WriteOnly' Pool.Default' false);  				DataStream indexDataStream = indexBuffer.Lock(0' normalBuffers.VertexCount * sizeof(int)' LockFlags.None);  				indexDataStream.WriteRange(Enumerable.Range(0' normalBuffers.VertexCount).ToArray());  				indexBuffer.Unlock();  				normalBuffers.Indices = indexBuffer;    				_normals.Add(mesh' normalBuffers);  			}
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,ShadowDecorator,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\ShadowDecorator.cs,CreateLightViewProjectionMatrix,The following statement contains a magic number: Matrix3D lightProjection = Matrix3D.CreateOrthographic(boxSize.X * 2' boxSize.Y * 2' -boxSize.Z' boxSize.Z);
Magic Number,Meshellator.Viewer.Framework.Rendering.Decorators,ShadowDecorator,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Framework\Rendering\Decorators\ShadowDecorator.cs,CreateLightViewProjectionMatrix,The following statement contains a magic number: Matrix3D lightProjection = Matrix3D.CreateOrthographic(boxSize.X * 2' boxSize.Y * 2' -boxSize.Z' boxSize.Z);
Magic Number,Meshellator.Viewer.Modules.ModelEditor.Views,ModelEditorView,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\ModelEditor\Views\ModelEditorView.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.D3DImage = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.D3DImageSource = ((System.Windows.Interop.D3DImage)(target));              return;              }
Magic Number,Meshellator.Viewer.Modules.ModelEditor.Views,Trackball,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\ModelEditor\Views\Trackball.cs,ProjectToTrackball,The following statement contains a magic number: double x = point.X / (width / 2);
Magic Number,Meshellator.Viewer.Modules.ModelEditor.Views,Trackball,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\ModelEditor\Views\Trackball.cs,ProjectToTrackball,The following statement contains a magic number: double y = point.Y / (height / 2);
Magic Number,Meshellator.Viewer.Modules.ModelEditor.Views,Trackball,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\ModelEditor\Views\Trackball.cs,Zoom,The following statement contains a magic number: double scale = Math.Exp(yDelta / 100);
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,Initialize,The following statement contains a magic number: Scene torusScene = MeshellatorLoader.CreateFromTorus(10' 1' 20);
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,Initialize,The following statement contains a magic number: Scene torusScene = MeshellatorLoader.CreateFromTorus(10' 1' 20);
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,Initialize,The following statement contains a magic number: Scene teapotScene = MeshellatorLoader.CreateFromTeapot(15' 20);
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,Initialize,The following statement contains a magic number: Scene teapotScene = MeshellatorLoader.CreateFromTeapot(15' 20);
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,Initialize,The following statement contains a magic number: Scene planeScene = MeshellatorLoader.CreateFromPlane(40' 40);
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,Initialize,The following statement contains a magic number: Scene planeScene = MeshellatorLoader.CreateFromPlane(40' 40);
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,Initialize,The following statement contains a magic number: fileMenuItem.Children.Insert(2' new MenuItemSeparator());
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,NewSphere,The following statement contains a magic number: yield return Show.Document(new ModelEditorViewModel(new SceneViewModel(MeshellatorLoader.CreateFromSphere(10' 10))' "[New Sphere]"));
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,NewSphere,The following statement contains a magic number: yield return Show.Document(new ModelEditorViewModel(new SceneViewModel(MeshellatorLoader.CreateFromSphere(10' 10))' "[New Sphere]"));
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,NewTeapot,The following statement contains a magic number: yield return Show.Document(new ModelEditorViewModel(new SceneViewModel(MeshellatorLoader.CreateFromTeapot(10' 10))' "[New Teapot]"));
Magic Number,Meshellator.Viewer.Modules.Startup,Module,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\Startup\Module.cs,NewTeapot,The following statement contains a magic number: yield return Show.Document(new ModelEditorViewModel(new SceneViewModel(MeshellatorLoader.CreateFromTeapot(10' 10))' "[New Teapot]"));
Missing Default,Meshellator.Viewer.Modules.ModelEditor.Views,ModelEditorView,C:\repos\tgjones_meshellator\src\Meshellator.Viewer\Modules\ModelEditor\Views\ModelEditorView.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.D3DImage = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.D3DImageSource = ((System.Windows.Interop.D3DImage)(target));              return;              }
