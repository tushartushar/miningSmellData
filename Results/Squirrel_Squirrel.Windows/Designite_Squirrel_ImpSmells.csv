Implementation smell,Namespace,Class,File,Method,Description
Long Method,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The method has 156 lines of code.
Long Method,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The method has 113 lines of code.
Long Method,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,GetBlockPattern,The method has 119 lines of code.
Long Method,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The method has 125 lines of code.
Long Method,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The method has 125 lines of code.
Long Method,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The method has 125 lines of code.
Complex Method,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Split,Cyclomatic complexity of the method is 8
Complex Method,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,SuffixSort,Cyclomatic complexity of the method is 13
Complex Method,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,ParseReleaseEntry,Cyclomatic complexity of the method is 9
Complex Method,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,fixPinnedExecutables,Cyclomatic complexity of the method is 8
Complex Method,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,cleanDeadVersions,Cyclomatic complexity of the method is 8
Complex Method,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,handleTrailingParens,Cyclomatic complexity of the method is 9
Complex Method,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,Cyclomatic complexity of the method is 16
Complex Method,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,Cyclomatic complexity of the method is 16
Complex Method,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,Cyclomatic complexity of the method is 16
Long Parameter List,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Search,The method has 7 parameters. Parameters: I' oldData' newData' newOffset' start' end' pos
Long Parameter List,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Split,The method has 5 parameters. Parameters: I' v' start' len' h
Long Parameter List,Squirrel.Bsdiff,WrappingStream,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Squirrel.Bsdiff,WrappingStream,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Squirrel,IUpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\IUpdateManager.cs,CreateShortcutsForExecutable,The method has 5 parameters. Parameters: exeName' locations' updateOnly' programArguments' icon
Long Parameter List,Squirrel,NativeMethods,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\NativeMethods.cs,NtQueryInformationProcess,The method has 5 parameters. Parameters: hProcess' pic' pbi' cb' pSize
Long Parameter List,Squirrel,NativeMethods,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\NativeMethods.cs,UpdateResource,The method has 6 parameters. Parameters: handle' pType' pName' language' pData' dwSize
Long Parameter List,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,ReleaseEntry,The method has 7 parameters. Parameters: sha1' filename' filesize' isDelta' baseUrl' query' stagingPercentage
Long Parameter List,Squirrel,SquirrelAwareApp,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SquirrelAwareApp.cs,HandleEvents,The method has 6 parameters. Parameters: onInitialInstall' onAppUpdate' onAppObsoleted' onAppUninstall' onFirstRun' arguments
Long Parameter List,Squirrel,UpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,CreateShortcutsForExecutable,The method has 5 parameters. Parameters: exeName' locations' updateOnly' programArguments' icon
Long Parameter List,Squirrel,UpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,GitHubUpdateManager,The method has 6 parameters. Parameters: repoUrl' applicationName' rootDirectory' urlDownloader' prerelease' accessToken
Long Parameter List,Squirrel,CheckForUpdateImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,CheckForUpdate,The method has 5 parameters. Parameters: localReleaseFile' updateUrlOrPath' ignoreDeltaUpdates' progress' urlDownloader
Long Parameter List,Squirrel,DownloadReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.DownloadReleases.cs,downloadRelease,The method has 5 parameters. Parameters: updateBaseUrl' releaseEntry' urlDownloader' targetFile' progress
Long Parameter List,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,CreateShortcutsForExecutable,The method has 5 parameters. Parameters: exeName' locations' updateOnly' programArguments' icon
Long Parameter List,Squirrel.Shell,UnManagedMethods,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,ExtractIconEx,The method has 5 parameters. Parameters: lpszFile' nIconIndex' phIconLarge' phIconSmall' nIcons
Long Parameter List,Squirrel.Shell,FileIcon,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pszPath' dwFileAttributes' psfi' cbFileInfo' uFlags
Long Parameter List,Squirrel.Shell,FileIcon,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,FormatMessage,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' argumentsLong
Long Identifier,Squirrel.Shell,FileIcon,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,,The length of the parameter FORMAT_MESSAGE_ALLOCATE_BUFFER is 30.
Long Identifier,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter _currentJsonSerializerStrategy is 30.
Long Identifier,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter _dataContractJsonSerializerStrategy is 35.
Long Identifier,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter _currentJsonSerializerStrategy is 30.
Long Identifier,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter _dataContractJsonSerializerStrategy is 35.
Long Identifier,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter ArrayConstructorParameterTypes is 30.
Long Identifier,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter ArrayConstructorParameterTypes is 30.
Long Identifier,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter _currentJsonSerializerStrategy is 30.
Long Identifier,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter _dataContractJsonSerializerStrategy is 35.
Long Identifier,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,,The length of the parameter ArrayConstructorParameterTypes is 30.
Long Statement,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,GetReleaseNotes,The length of the statement  "                throw new Exception(String.Format("Invalid 'ReleaseNotes' value in nuspec file at '{0}'"' Path.Combine(packageDirectory' Filename))); " is 133.
Long Statement,Squirrel,ReleasePackage,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleasePackage.cs,CreateReleasePackage,The length of the statement  "                    "The input package file {0} targets multiple platforms - {1} - and cannot be transformed into a release package."' InputPackageFile' platforms)); " is 145.
Long Statement,Squirrel,ReleasePackage,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleasePackage.cs,removeDependenciesFromPackageSpec,The length of the statement  "            var dependenciesNode = metadata.ChildNodes.OfType<XmlElement>().FirstOrDefault(x => x.Name.ToLowerInvariant() == "dependencies"); " is 129.
Long Statement,Squirrel,ReleasePackage,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleasePackage.cs,findAllDependentPackages,The length of the statement  "                return findAllDependentPackages(ret' packageRepository' packageCache' frameworkName).StartWith(ret).Distinct(y => y.GetFullName()); " is 131.
Long Statement,Squirrel,SquirrelAwareExecutableDetector,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SquirrelAwareExecutableDetector.cs,GetAssemblySquirrelAwareVersion,The length of the statement  "                if (!Int32.TryParse(attribute.ConstructorArguments[1].Value.ToString()' NumberStyles.Integer' CultureInfo.CurrentCulture' out result)) { " is 136.
Long Statement,Squirrel,SquirrelAwareExecutableDetector,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SquirrelAwareExecutableDetector.cs,GetVersionBlockSquirrelAwareValue,The length of the statement  "            if (!NativeMethods.VerQueryValue(buf' "\\StringFileInfo\\040904B0\\SquirrelAwareVersion"' out result' out resultSize)) { " is 120.
Long Statement,Squirrel,TrayStateChanger,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\TrayHelper.cs,RemoveDeadEntries,The length of the statement  "                iconStreamData = (byte[])Registry.GetValue("HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify"' "IconStreams"' new byte[] { 00 }); " is 191.
Long Statement,Squirrel,TrayStateChanger,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\TrayHelper.cs,RemoveDeadEntries,The length of the statement  "                Registry.SetValue("HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify"' "IconStreams"' toSave); " is 155.
Long Statement,Squirrel,UpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,CheckForUpdate,The length of the statement  "            return await checkForUpdate.CheckForUpdate(Utility.LocalReleaseFileForAppDir(rootAppDirectory)' updateUrlOrPath' ignoreDeltaUpdates' progress' urlDownloader); " is 158.
Long Statement,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateWebClient,The length of the statement  "            System.Net.ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls; " is 133.
Long Statement,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,InvokeProcessAsync,The length of the statement  "            if (Environment.OSVersion.Platform != PlatformID.Win32NT && fileName.EndsWith (".exe"' StringComparison.OrdinalIgnoreCase)) { " is 125.
Long Statement,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,tempNameForIndex,The length of the statement  "            return prefix + directoryChars.Value[index % directoryChars.Value.Length] + tempNameForIndex(index / directoryChars.Value.Length' ""); " is 134.
Long Statement,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,GetTempDirectory,The length of the statement  "            tempDir = tempDir ?? Path.Combine(localAppDirectory ?? Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)' "SquirrelTemp"); " is 146.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The length of the statement  "                this.ErrorIfThrows(() => trayFixer.RemoveDeadEntries(allExes' rootAppDirectory' updateInfo.FutureReleaseEntry.Version.ToString())); " is 131.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The length of the statement  "                        if (isAppFolderDead(currentRelease.FullName)) throw new Exception("App folder is dead' but we're trying to uninstall it?"); " is 123.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The length of the statement  "                            .Where(x => !x.Name.StartsWith("squirrel."' StringComparison.OrdinalIgnoreCase) && !x.Name.StartsWith("update."' StringComparison.OrdinalIgnoreCase)) " is 149.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,GetShortcutsForExecutable,The length of the statement  "                    var appUserModelId = String.Format("com.squirrel.{0}.{1}"' zf.Id.Replace(" "' "")' exeName.Replace(".exe"' "").Replace(" "' "")); " is 129.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,CreateShortcutsForExecutable,The length of the statement  "                        var appUserModelId = String.Format("com.squirrel.{0}.{1}"' zf.Id.Replace(" "' "")' exeName.Replace(".exe"' "").Replace(" "' "")); " is 129.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,CreateShortcutsForExecutable,The length of the statement  "                        this.Log().Info("About to save shortcut: {0} (target {1}' workingDir {2}' args {3}' toastActivatorCSLID {4})"' file' sl.Target' sl.WorkingDirectory' sl.Arguments' toastActivatorCLSID); " is 184.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,createFullPackagesFromDeltas,The length of the statement  "                        Regex.Replace(deltaPkg.InputPackageFile' @"-delta.nupkg$"' ".nupkg"' RegexOptions.IgnoreCase | RegexOptions.CultureInvariant)); " is 127.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,invokePostInstall,The length of the statement  "                    squirrelApps.ForEach(x => CreateShortcutsForExecutable(Path.GetFileName(x)' ShortcutLocation.Desktop | ShortcutLocation.StartMenu' isInitialInstall == false' null' null)); " is 171.
Long Statement,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,cleanDeadVersions,The length of the statement  "                        if (runningProcesses.All(p => p.Item1 == null || !p.Item1.StartsWith(x.FullName' StringComparison.OrdinalIgnoreCase))) { " is 120.
Long Statement,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AnchorRefShortcutEvaluator,The length of the statement  "            string linkID = Regex.Replace(linkText.ToLowerInvariant()' @"[ ]*\n[ ]*"' " ");  // lower case and remove newlines / extra spaces " is 129.
Long Statement,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,ProcessListItems,The length of the statement  "                    if (!isInsideParagraphlessListItem) // only the outer-most item should run this' otherwise it's run multiple times for the inner ones " is 133.
Long Statement,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,BlockQuoteEvaluator,The length of the statement  "            bq = Regex.Replace(bq' @"(\s*<pre>.+?</pre>)"' new MatchEvaluator(BlockQuoteEvaluator2)' RegexOptions.IgnorePatternWhitespace | RegexOptions.Singleline); " is 153.
Long Statement,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,handleTrailingParens,The length of the statement  "            // We're not using a *real* lookbehind' because of links with in links' like <a href="http://web.archive.org/web/20121130000728/http://www.google.com/"> " is 152.
Long Statement,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,DoAutoLinks,The length of the statement  "                text = Regex.Replace(text' pattern' new MatchEvaluator(EmailEvaluator)' RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace); " is 136.
Long Statement,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,EscapeSpecialCharsWithinTagAttributes,The length of the statement  "                    if (_autoHyperlink && value.StartsWith("<!")) // escape slashes in comments to prevent autolinking there -- http://meta.stackoverflow.com/questions/95987/html-comment-containing-url-breaks-if-followed-by-another-html-comment " is 224.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The length of the statement  "                            if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint))) " is 130.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The length of the statement  "                                    if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint)) " is 163.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The length of the statement  "                if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e') " is 127.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The length of the statement  "                            if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint))) " is 130.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The length of the statement  "                                    if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint)) " is 163.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The length of the statement  "                if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e') " is 127.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[MapClrMemberNameToJsonFieldName(propertyInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 184.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                result[MapClrMemberNameToJsonFieldName(fieldInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 172.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 144.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTimeOffset) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset))) " is 139.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTimeOffset.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 150.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                obj = type == typeof(int) || type == typeof(long) || type == typeof(double) || type == typeof(float) || type == typeof(bool) || type == typeof(decimal) || type == typeof(byte) || type == typeof(short) " is 200.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        else if (ReflectionUtils.IsTypeGenericeCollectionInterface(type) || ReflectionUtils.IsAssignableFrom(typeof(IList)' type)) " is 122.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                            list = (IList)(ConstructorCache[type] ?? ConstructorCache[typeof(List<>).MakeGenericType(innerType)])(jsonObject.Count); " is 120.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[MapClrMemberNameToJsonFieldName(propertyInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 184.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                result[MapClrMemberNameToJsonFieldName(fieldInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 172.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 144.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTimeOffset) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset))) " is 139.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTimeOffset.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 150.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                obj = type == typeof(int) || type == typeof(long) || type == typeof(double) || type == typeof(float) || type == typeof(bool) || type == typeof(decimal) || type == typeof(byte) || type == typeof(short) " is 200.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        else if (ReflectionUtils.IsTypeGenericeCollectionInterface(type) || ReflectionUtils.IsAssignableFrom(typeof(IList)' type)) " is 122.
Long Statement,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                            list = (IList)(ConstructorCache[type] ?? ConstructorCache[typeof(List<>).MakeGenericType(innerType)])(jsonObject.Count); " is 120.
Long Statement,Squirrel.Json,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,Squirrel.Json,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                        result[jsonKey] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 141.
Long Statement,Squirrel.Json,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[jsonKey] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 132.
Long Statement,Squirrel.Json,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,CanAdd,The length of the statement  "            DataMemberAttribute dataMemberAttribute = (DataMemberAttribute)ReflectionUtils.GetAttribute(info' typeof(DataMemberAttribute)); " is 127.
Long Statement,Squirrel.Json,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,Squirrel.Json,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                        result[jsonKey] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 141.
Long Statement,Squirrel.Json,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[jsonKey] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 132.
Long Statement,Squirrel.Json,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,CanAdd,The length of the statement  "            DataMemberAttribute dataMemberAttribute = (DataMemberAttribute)ReflectionUtils.GetAttribute(info' typeof(DataMemberAttribute)); " is 127.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                Func<object' object> compiled = Expression.Lambda<Func<object' object>>(Expression.TypeAs(Expression.Call(instanceCast' getMethodInfo)' typeof(object))' instance).Compile(); " is 173.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression valueCast = (!IsValueType(propertyInfo.PropertyType)) ? Expression.TypeAs(value' propertyInfo.PropertyType) : Expression.Convert(value' propertyInfo.PropertyType); " is 179.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                Action<object' object> compiled = Expression.Lambda<Action<object' object>>(Expression.Call(instanceCast' setMethodInfo' valueCast)' new ParameterExpression[] { instance' value }).Compile(); " is 190.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                    Assign(Expression.Field(Expression.Convert(instance' fieldInfo.DeclaringType)' fieldInfo)' Expression.Convert(value' fieldInfo.FieldType))' instance' value).Compile(); " is 167.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                Func<object' object> compiled = Expression.Lambda<Func<object' object>>(Expression.TypeAs(Expression.Call(instanceCast' getMethodInfo)' typeof(object))' instance).Compile(); " is 173.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression valueCast = (!IsValueType(propertyInfo.PropertyType)) ? Expression.TypeAs(value' propertyInfo.PropertyType) : Expression.Convert(value' propertyInfo.PropertyType); " is 179.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                Action<object' object> compiled = Expression.Lambda<Action<object' object>>(Expression.Call(instanceCast' setMethodInfo' valueCast)' new ParameterExpression[] { instance' value }).Compile(); " is 190.
Long Statement,Squirrel.Json,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                    Assign(Expression.Field(Expression.Convert(instance' fieldInfo.DeclaringType)' fieldInfo)' Expression.Convert(value' fieldInfo.FieldType))' instance' value).Compile(); " is 167.
Long Statement,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The length of the statement  "                            if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint))) " is 130.
Long Statement,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The length of the statement  "                                    if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint)) " is 163.
Long Statement,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The length of the statement  "                if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e') " is 127.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[MapClrMemberNameToJsonFieldName(propertyInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 184.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                result[MapClrMemberNameToJsonFieldName(fieldInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 172.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 144.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTimeOffset) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset))) " is 139.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTimeOffset.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 150.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                obj = type == typeof(int) || type == typeof(long) || type == typeof(double) || type == typeof(float) || type == typeof(bool) || type == typeof(decimal) || type == typeof(byte) || type == typeof(short) " is 200.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        else if (ReflectionUtils.IsTypeGenericeCollectionInterface(type) || ReflectionUtils.IsAssignableFrom(typeof(IList)' type)) " is 122.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                            list = (IList)(ConstructorCache[type] ?? ConstructorCache[typeof(List<>).MakeGenericType(innerType)])(jsonObject.Count); " is 120.
Long Statement,Reflection,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,Reflection,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                        result[jsonKey] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 141.
Long Statement,Reflection,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[jsonKey] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 132.
Long Statement,Reflection,DataContractJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,CanAdd,The length of the statement  "            DataMemberAttribute dataMemberAttribute = (DataMemberAttribute)ReflectionUtils.GetAttribute(info' typeof(DataMemberAttribute)); " is 127.
Long Statement,Reflection,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,Reflection,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,Reflection,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                Func<object' object> compiled = Expression.Lambda<Func<object' object>>(Expression.TypeAs(Expression.Call(instanceCast' getMethodInfo)' typeof(object))' instance).Compile(); " is 173.
Long Statement,Reflection,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,Reflection,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression valueCast = (!IsValueType(propertyInfo.PropertyType)) ? Expression.TypeAs(value' propertyInfo.PropertyType) : Expression.Convert(value' propertyInfo.PropertyType); " is 179.
Long Statement,Reflection,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                Action<object' object> compiled = Expression.Lambda<Action<object' object>>(Expression.Call(instanceCast' setMethodInfo' valueCast)' new ParameterExpression[] { instance' value }).Compile(); " is 190.
Long Statement,Reflection,ReflectionUtils,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                    Assign(Expression.Field(Expression.Convert(instance' fieldInfo.DeclaringType)' fieldInfo)' Expression.Convert(value' fieldInfo.FieldType))' instance' value).Compile(); " is 167.
Complex Conditional,Squirrel,UpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,getUpdateExe,The conditional expression  "assembly != null &&                  Path.GetFileName(assembly.Location).Equals("update.exe"' StringComparison.OrdinalIgnoreCase) &&                  assembly.Location.IndexOf("app-"' StringComparison.OrdinalIgnoreCase) == -1 &&                  assembly.Location.IndexOf("SquirrelTemp"' StringComparison.OrdinalIgnoreCase) == -1"  is complex.
Complex Conditional,Squirrel.Json,JsonObject,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,TryConvert,The conditional expression  "(targetType == typeof(IEnumerable)) ||                  (targetType == typeof(IEnumerable<KeyValuePair<string' object>>)) ||                  (targetType == typeof(IDictionary<string' object>)) ||                  (targetType == typeof(IDictionary))"  is complex.
Complex Conditional,Squirrel.Json,JsonObject,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,TryConvert,The conditional expression  "(targetType == typeof(IEnumerable)) ||                  (targetType == typeof(IEnumerable<KeyValuePair<string' object>>)) ||                  (targetType == typeof(IDictionary<string' object>)) ||                  (targetType == typeof(IDictionary))"  is complex.
Complex Conditional,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e'"  is complex.
Complex Conditional,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e'"  is complex.
Complex Conditional,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l'"  is complex.
Complex Conditional,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e'"  is complex.
Complex Conditional,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e'"  is complex.
Complex Conditional,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l'"  is complex.
Complex Conditional,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsLong && type == typeof(long)) || (valueIsDouble && type == typeof(double))"  is complex.
Complex Conditional,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsDouble && type != typeof(double)) || (valueIsLong && type != typeof(long))"  is complex.
Complex Conditional,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsLong && type == typeof(long)) || (valueIsDouble && type == typeof(double))"  is complex.
Complex Conditional,Squirrel.Json,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsDouble && type != typeof(double)) || (valueIsLong && type != typeof(long))"  is complex.
Complex Conditional,Reflection,JsonObject,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,TryConvert,The conditional expression  "(targetType == typeof(IEnumerable)) ||                  (targetType == typeof(IEnumerable<KeyValuePair<string' object>>)) ||                  (targetType == typeof(IDictionary<string' object>)) ||                  (targetType == typeof(IDictionary))"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e'"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e'"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l'"  is complex.
Complex Conditional,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsLong && type == typeof(long)) || (valueIsDouble && type == typeof(double))"  is complex.
Complex Conditional,Reflection,PocoJsonSerializerStrategy,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsDouble && type != typeof(double)) || (valueIsLong && type != typeof(long))"  is complex.
Empty Catch Block,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The method has an empty catch block.
Empty Catch Block,Squirrel,InstallHelperImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.InstallHelpers.cs,KillAllProcessesBelongingToPackage,The method has an empty catch block.
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Create,The following statement contains a magic number: var t = new Thread(() =>              {                  try                  {                      CreateInternal(oldData' newData' output);                  }                  catch (Exception exc)                  {                      ex = exc;                  }              }' 40 * 1048576);
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Create,The following statement contains a magic number: var t = new Thread(() =>              {                  try                  {                      CreateInternal(oldData' newData' output);                  }                  catch (Exception exc)                  {                      ex = exc;                  }              }' 40 * 1048576);
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: WriteInt64(0' header' 8);
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: WriteInt64(0' header' 16);
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: WriteInt64(newData.Length' header' 24);
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: using (WrappingStream wrappingStream = new WrappingStream(output' Ownership.None))              using (var bz2Stream = new BZip2Stream(wrappingStream' CompressionMode.Compress))              {                  // compute the differences' writing ctrl as we go                  int scan = 0;                  int pos = 0;                  int len = 0;                  int lastscan = 0;                  int lastpos = 0;                  int lastoffset = 0;                  while (scan < newData.Length)                  {                      int oldscore = 0;                        for (int scsc = scan += len; scan < newData.Length; scan++)                      {                          len = Search(I' oldData' newData' scan' 0' oldData.Length' out pos);                            for (; scsc < scan + len; scsc++)                          {                              if ((scsc + lastoffset < oldData.Length) && (oldData[scsc + lastoffset] == newData[scsc]))                                  oldscore++;                          }                            if ((len == oldscore && len != 0) || (len > oldscore + 8))                              break;                            if ((scan + lastoffset < oldData.Length) && (oldData[scan + lastoffset] == newData[scan]))                              oldscore--;                      }                        if (len != oldscore || scan == newData.Length)                      {                          int s = 0;                          int sf = 0;                          int lenf = 0;                          for (int i = 0; (lastscan + i < scan) && (lastpos + i < oldData.Length); )                          {                              if (oldData[lastpos + i] == newData[lastscan + i])                                  s++;                              i++;                              if (s * 2 - i > sf * 2 - lenf)                              {                                  sf = s;                                  lenf = i;                              }                          }                            int lenb = 0;                          if (scan < newData.Length)                          {                              s = 0;                              int sb = 0;                              for (int i = 1; (scan >= lastscan + i) && (pos >= i); i++)                              {                                  if (oldData[pos - i] == newData[scan - i])                                      s++;                                  if (s * 2 - i > sb * 2 - lenb)                                  {                                      sb = s;                                      lenb = i;                                  }                              }                          }                            if (lastscan + lenf > scan - lenb)                          {                              int overlap = (lastscan + lenf) - (scan - lenb);                              s = 0;                              int ss = 0;                              int lens = 0;                              for (int i = 0; i < overlap; i++)                              {                                  if (newData[lastscan + lenf - overlap + i] == oldData[lastpos + lenf - overlap + i])                                      s++;                                  if (newData[scan - lenb + i] == oldData[pos - lenb + i])                                      s--;                                  if (s > ss)                                  {                                      ss = s;                                      lens = i + 1;                                  }                              }                                lenf += lens - overlap;                              lenb -= lens;                          }                            for (int i = 0; i < lenf; i++)                              db[dblen + i] = (byte)(newData[lastscan + i] - oldData[lastpos + i]);                          for (int i = 0; i < (scan - lenb) - (lastscan + lenf); i++)                              eb[eblen + i] = newData[lastscan + lenf + i];                            dblen += lenf;                          eblen += (scan - lenb) - (lastscan + lenf);                            byte[] buf = new byte[8];                          WriteInt64(lenf' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((scan - lenb) - (lastscan + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            WriteInt64((pos - lenb) - (lastpos + lenf)' buf' 0);                          bz2Stream.Write(buf' 0' 8);                            lastscan = scan - lenb;                          lastpos = pos - lenb;                          lastoffset = pos - scan;                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: WriteInt64(controlEndPosition - startPosition - c_headerSize' header' 8);
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,CreateInternal,The following statement contains a magic number: WriteInt64(diffEndPosition - controlEndPosition' header' 16);
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: using (Stream patchStream = openPatchStream())              {                  // check patch stream capabilities                  if (!patchStream.CanRead)                      throw new ArgumentException("Patch stream must be readable."' "openPatchStream");                  if (!patchStream.CanSeek)                      throw new ArgumentException("Patch stream must be seekable."' "openPatchStream");                    byte[] header = patchStream.ReadExactly(c_headerSize);                    // check for appropriate magic                  long signature = ReadInt64(header' 0);                  if (signature != c_fileSignature)                      throw new InvalidOperationException("Corrupt patch.");                    // read lengths from header                  controlLength = ReadInt64(header' 8);                  diffLength = ReadInt64(header' 16);                  newSize = ReadInt64(header' 24);                  if (controlLength < 0 || diffLength < 0 || newSize < 0)                      throw new InvalidOperationException("Corrupt patch.");              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: using (Stream patchStream = openPatchStream())              {                  // check patch stream capabilities                  if (!patchStream.CanRead)                      throw new ArgumentException("Patch stream must be readable."' "openPatchStream");                  if (!patchStream.CanSeek)                      throw new ArgumentException("Patch stream must be seekable."' "openPatchStream");                    byte[] header = patchStream.ReadExactly(c_headerSize);                    // check for appropriate magic                  long signature = ReadInt64(header' 0);                  if (signature != c_fileSignature)                      throw new InvalidOperationException("Corrupt patch.");                    // read lengths from header                  controlLength = ReadInt64(header' 8);                  diffLength = ReadInt64(header' 16);                  newSize = ReadInt64(header' 24);                  if (controlLength < 0 || diffLength < 0 || newSize < 0)                      throw new InvalidOperationException("Corrupt patch.");              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: using (Stream patchStream = openPatchStream())              {                  // check patch stream capabilities                  if (!patchStream.CanRead)                      throw new ArgumentException("Patch stream must be readable."' "openPatchStream");                  if (!patchStream.CanSeek)                      throw new ArgumentException("Patch stream must be seekable."' "openPatchStream");                    byte[] header = patchStream.ReadExactly(c_headerSize);                    // check for appropriate magic                  long signature = ReadInt64(header' 0);                  if (signature != c_fileSignature)                      throw new InvalidOperationException("Corrupt patch.");                    // read lengths from header                  controlLength = ReadInt64(header' 8);                  diffLength = ReadInt64(header' 16);                  newSize = ReadInt64(header' 24);                  if (controlLength < 0 || diffLength < 0 || newSize < 0)                      throw new InvalidOperationException("Corrupt patch.");              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: const int c_bufferSize = 1048576;
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: using (Stream compressedControlStream = openPatchStream())              using (Stream compressedDiffStream = openPatchStream())              using (Stream compressedExtraStream = openPatchStream())              {                  // seek to the start of each part                  compressedControlStream.Seek(c_headerSize' SeekOrigin.Current);                  compressedDiffStream.Seek(c_headerSize + controlLength' SeekOrigin.Current);                  compressedExtraStream.Seek(c_headerSize + controlLength + diffLength' SeekOrigin.Current);                    // decompress each part (to read it)                  using (var controlStream = new BZip2Stream(compressedControlStream' CompressionMode.Decompress))                  using (var diffStream = new BZip2Stream(compressedDiffStream' CompressionMode.Decompress))                  using (var extraStream = new BZip2Stream(compressedExtraStream' CompressionMode.Decompress))                  {                      long[] control = new long[3];                      byte[] buffer = new byte[8];                        int oldPosition = 0;                      int newPosition = 0;                      while (newPosition < newSize)                      {                          // read control data                          for (int i = 0; i < 3; i++)                          {                              controlStream.ReadExactly(buffer' 0' 8);                              control[i] = ReadInt64(buffer' 0);                          }                            // sanity-check                          if (newPosition + control[0] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // seek old file to the position that the new data is diffed against                          input.Position = oldPosition;                            int bytesToCopy = (int)control[0];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                // read diff string                              diffStream.ReadExactly(newData' 0' actualBytesToCopy);                                // add old data to diff string                              int availableInputBytes = Math.Min(actualBytesToCopy' (int)(input.Length - input.Position));                              input.ReadExactly(oldData' 0' availableInputBytes);                                for (int index = 0; index < availableInputBytes; index++)                                  newData[index] += oldData[index];                                output.Write(newData' 0' actualBytesToCopy);                                // adjust counters                              newPosition += actualBytesToCopy;                              oldPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // sanity-check                          if (newPosition + control[1] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // read extra string                          bytesToCopy = (int)control[1];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                extraStream.ReadExactly(newData' 0' actualBytesToCopy);                              output.Write(newData' 0' actualBytesToCopy);                                newPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // adjust position                          oldPosition = (int)(oldPosition + control[2]);                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: using (Stream compressedControlStream = openPatchStream())              using (Stream compressedDiffStream = openPatchStream())              using (Stream compressedExtraStream = openPatchStream())              {                  // seek to the start of each part                  compressedControlStream.Seek(c_headerSize' SeekOrigin.Current);                  compressedDiffStream.Seek(c_headerSize + controlLength' SeekOrigin.Current);                  compressedExtraStream.Seek(c_headerSize + controlLength + diffLength' SeekOrigin.Current);                    // decompress each part (to read it)                  using (var controlStream = new BZip2Stream(compressedControlStream' CompressionMode.Decompress))                  using (var diffStream = new BZip2Stream(compressedDiffStream' CompressionMode.Decompress))                  using (var extraStream = new BZip2Stream(compressedExtraStream' CompressionMode.Decompress))                  {                      long[] control = new long[3];                      byte[] buffer = new byte[8];                        int oldPosition = 0;                      int newPosition = 0;                      while (newPosition < newSize)                      {                          // read control data                          for (int i = 0; i < 3; i++)                          {                              controlStream.ReadExactly(buffer' 0' 8);                              control[i] = ReadInt64(buffer' 0);                          }                            // sanity-check                          if (newPosition + control[0] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // seek old file to the position that the new data is diffed against                          input.Position = oldPosition;                            int bytesToCopy = (int)control[0];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                // read diff string                              diffStream.ReadExactly(newData' 0' actualBytesToCopy);                                // add old data to diff string                              int availableInputBytes = Math.Min(actualBytesToCopy' (int)(input.Length - input.Position));                              input.ReadExactly(oldData' 0' availableInputBytes);                                for (int index = 0; index < availableInputBytes; index++)                                  newData[index] += oldData[index];                                output.Write(newData' 0' actualBytesToCopy);                                // adjust counters                              newPosition += actualBytesToCopy;                              oldPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // sanity-check                          if (newPosition + control[1] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // read extra string                          bytesToCopy = (int)control[1];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                extraStream.ReadExactly(newData' 0' actualBytesToCopy);                              output.Write(newData' 0' actualBytesToCopy);                                newPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // adjust position                          oldPosition = (int)(oldPosition + control[2]);                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: using (Stream compressedControlStream = openPatchStream())              using (Stream compressedDiffStream = openPatchStream())              using (Stream compressedExtraStream = openPatchStream())              {                  // seek to the start of each part                  compressedControlStream.Seek(c_headerSize' SeekOrigin.Current);                  compressedDiffStream.Seek(c_headerSize + controlLength' SeekOrigin.Current);                  compressedExtraStream.Seek(c_headerSize + controlLength + diffLength' SeekOrigin.Current);                    // decompress each part (to read it)                  using (var controlStream = new BZip2Stream(compressedControlStream' CompressionMode.Decompress))                  using (var diffStream = new BZip2Stream(compressedDiffStream' CompressionMode.Decompress))                  using (var extraStream = new BZip2Stream(compressedExtraStream' CompressionMode.Decompress))                  {                      long[] control = new long[3];                      byte[] buffer = new byte[8];                        int oldPosition = 0;                      int newPosition = 0;                      while (newPosition < newSize)                      {                          // read control data                          for (int i = 0; i < 3; i++)                          {                              controlStream.ReadExactly(buffer' 0' 8);                              control[i] = ReadInt64(buffer' 0);                          }                            // sanity-check                          if (newPosition + control[0] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // seek old file to the position that the new data is diffed against                          input.Position = oldPosition;                            int bytesToCopy = (int)control[0];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                // read diff string                              diffStream.ReadExactly(newData' 0' actualBytesToCopy);                                // add old data to diff string                              int availableInputBytes = Math.Min(actualBytesToCopy' (int)(input.Length - input.Position));                              input.ReadExactly(oldData' 0' availableInputBytes);                                for (int index = 0; index < availableInputBytes; index++)                                  newData[index] += oldData[index];                                output.Write(newData' 0' actualBytesToCopy);                                // adjust counters                              newPosition += actualBytesToCopy;                              oldPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // sanity-check                          if (newPosition + control[1] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // read extra string                          bytesToCopy = (int)control[1];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                extraStream.ReadExactly(newData' 0' actualBytesToCopy);                              output.Write(newData' 0' actualBytesToCopy);                                newPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // adjust position                          oldPosition = (int)(oldPosition + control[2]);                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: using (Stream compressedControlStream = openPatchStream())              using (Stream compressedDiffStream = openPatchStream())              using (Stream compressedExtraStream = openPatchStream())              {                  // seek to the start of each part                  compressedControlStream.Seek(c_headerSize' SeekOrigin.Current);                  compressedDiffStream.Seek(c_headerSize + controlLength' SeekOrigin.Current);                  compressedExtraStream.Seek(c_headerSize + controlLength + diffLength' SeekOrigin.Current);                    // decompress each part (to read it)                  using (var controlStream = new BZip2Stream(compressedControlStream' CompressionMode.Decompress))                  using (var diffStream = new BZip2Stream(compressedDiffStream' CompressionMode.Decompress))                  using (var extraStream = new BZip2Stream(compressedExtraStream' CompressionMode.Decompress))                  {                      long[] control = new long[3];                      byte[] buffer = new byte[8];                        int oldPosition = 0;                      int newPosition = 0;                      while (newPosition < newSize)                      {                          // read control data                          for (int i = 0; i < 3; i++)                          {                              controlStream.ReadExactly(buffer' 0' 8);                              control[i] = ReadInt64(buffer' 0);                          }                            // sanity-check                          if (newPosition + control[0] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // seek old file to the position that the new data is diffed against                          input.Position = oldPosition;                            int bytesToCopy = (int)control[0];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                // read diff string                              diffStream.ReadExactly(newData' 0' actualBytesToCopy);                                // add old data to diff string                              int availableInputBytes = Math.Min(actualBytesToCopy' (int)(input.Length - input.Position));                              input.ReadExactly(oldData' 0' availableInputBytes);                                for (int index = 0; index < availableInputBytes; index++)                                  newData[index] += oldData[index];                                output.Write(newData' 0' actualBytesToCopy);                                // adjust counters                              newPosition += actualBytesToCopy;                              oldPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // sanity-check                          if (newPosition + control[1] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // read extra string                          bytesToCopy = (int)control[1];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                extraStream.ReadExactly(newData' 0' actualBytesToCopy);                              output.Write(newData' 0' actualBytesToCopy);                                newPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // adjust position                          oldPosition = (int)(oldPosition + control[2]);                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Apply,The following statement contains a magic number: using (Stream compressedControlStream = openPatchStream())              using (Stream compressedDiffStream = openPatchStream())              using (Stream compressedExtraStream = openPatchStream())              {                  // seek to the start of each part                  compressedControlStream.Seek(c_headerSize' SeekOrigin.Current);                  compressedDiffStream.Seek(c_headerSize + controlLength' SeekOrigin.Current);                  compressedExtraStream.Seek(c_headerSize + controlLength + diffLength' SeekOrigin.Current);                    // decompress each part (to read it)                  using (var controlStream = new BZip2Stream(compressedControlStream' CompressionMode.Decompress))                  using (var diffStream = new BZip2Stream(compressedDiffStream' CompressionMode.Decompress))                  using (var extraStream = new BZip2Stream(compressedExtraStream' CompressionMode.Decompress))                  {                      long[] control = new long[3];                      byte[] buffer = new byte[8];                        int oldPosition = 0;                      int newPosition = 0;                      while (newPosition < newSize)                      {                          // read control data                          for (int i = 0; i < 3; i++)                          {                              controlStream.ReadExactly(buffer' 0' 8);                              control[i] = ReadInt64(buffer' 0);                          }                            // sanity-check                          if (newPosition + control[0] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // seek old file to the position that the new data is diffed against                          input.Position = oldPosition;                            int bytesToCopy = (int)control[0];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                // read diff string                              diffStream.ReadExactly(newData' 0' actualBytesToCopy);                                // add old data to diff string                              int availableInputBytes = Math.Min(actualBytesToCopy' (int)(input.Length - input.Position));                              input.ReadExactly(oldData' 0' availableInputBytes);                                for (int index = 0; index < availableInputBytes; index++)                                  newData[index] += oldData[index];                                output.Write(newData' 0' actualBytesToCopy);                                // adjust counters                              newPosition += actualBytesToCopy;                              oldPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // sanity-check                          if (newPosition + control[1] > newSize)                              throw new InvalidOperationException("Corrupt patch.");                            // read extra string                          bytesToCopy = (int)control[1];                          while (bytesToCopy > 0)                          {                              int actualBytesToCopy = Math.Min(bytesToCopy' c_bufferSize);                                extraStream.ReadExactly(newData' 0' actualBytesToCopy);                              output.Write(newData' 0' actualBytesToCopy);                                newPosition += actualBytesToCopy;                              bytesToCopy -= actualBytesToCopy;                          }                            // adjust position                          oldPosition = (int)(oldPosition + control[2]);                      }                  }              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Search,The following statement contains a magic number: if (end - start < 2)              {                  int startLength = MatchLength(oldData' I[start]' newData' newOffset);                  int endLength = MatchLength(oldData' I[end]' newData' newOffset);                    if (startLength > endLength)                  {                      pos = I[start];                      return startLength;                  }                  else                  {                      pos = I[end];                      return endLength;                  }              }              else              {                  int midPoint = start + (end - start) / 2;                  return CompareBytes(oldData' I[midPoint]' newData' newOffset) < 0 ?                      Search(I' oldData' newData' newOffset' midPoint' end' out pos) :                      Search(I' oldData' newData' newOffset' start' midPoint' out pos);              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Search,The following statement contains a magic number: if (end - start < 2)              {                  int startLength = MatchLength(oldData' I[start]' newData' newOffset);                  int endLength = MatchLength(oldData' I[end]' newData' newOffset);                    if (startLength > endLength)                  {                      pos = I[start];                      return startLength;                  }                  else                  {                      pos = I[end];                      return endLength;                  }              }              else              {                  int midPoint = start + (end - start) / 2;                  return CompareBytes(oldData' I[midPoint]' newData' newOffset) < 0 ?                      Search(I' oldData' newData' newOffset' midPoint' end' out pos) :                      Search(I' oldData' newData' newOffset' start' midPoint' out pos);              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Split,The following statement contains a magic number: if (len < 16)              {                  int j;                  for (int k = start; k < start + len; k += j)                  {                      j = 1;                      int x = v[I[k] + h];                      for (int i = 1; k + i < start + len; i++)                      {                          if (v[I[k + i] + h] < x)                          {                              x = v[I[k + i] + h];                              j = 0;                          }                          if (v[I[k + i] + h] == x)                          {                              Swap(ref I[k + j]' ref I[k + i]);                              j++;                          }                      }                      for (int i = 0; i < j; i++)                          v[I[k + i]] = k + j - 1;                      if (j == 1)                          I[k] = -1;                  }              }              else              {                  int x = v[I[start + len / 2] + h];                  int jj = 0;                  int kk = 0;                  for (int i2 = start; i2 < start + len; i2++)                  {                      if (v[I[i2] + h] < x)                          jj++;                      if (v[I[i2] + h] == x)                          kk++;                  }                  jj += start;                  kk += jj;                    int i = start;                  int j = 0;                  int k = 0;                  while (i < jj)                  {                      if (v[I[i] + h] < x)                      {                          i++;                      }                      else if (v[I[i] + h] == x)                      {                          Swap(ref I[i]' ref I[jj + j]);                          j++;                      }                      else                      {                          Swap(ref I[i]' ref I[kk + k]);                          k++;                      }                  }                    while (jj + j < kk)                  {                      if (v[I[jj + j] + h] == x)                      {                          j++;                      }                      else                      {                          Swap(ref I[jj + j]' ref I[kk + k]);                          k++;                      }                  }                    if (jj > start)                      Split(I' v' start' jj - start' h);                    for (i = 0; i < kk - jj; i++)                      v[I[jj + i]] = kk - 1;                  if (jj == kk - 1)                      I[jj] = -1;                    if (start + len > kk)                      Split(I' v' kk' start + len - kk' h);              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,Split,The following statement contains a magic number: if (len < 16)              {                  int j;                  for (int k = start; k < start + len; k += j)                  {                      j = 1;                      int x = v[I[k] + h];                      for (int i = 1; k + i < start + len; i++)                      {                          if (v[I[k + i] + h] < x)                          {                              x = v[I[k + i] + h];                              j = 0;                          }                          if (v[I[k + i] + h] == x)                          {                              Swap(ref I[k + j]' ref I[k + i]);                              j++;                          }                      }                      for (int i = 0; i < j; i++)                          v[I[k + i]] = k + j - 1;                      if (j == 1)                          I[k] = -1;                  }              }              else              {                  int x = v[I[start + len / 2] + h];                  int jj = 0;                  int kk = 0;                  for (int i2 = start; i2 < start + len; i2++)                  {                      if (v[I[i2] + h] < x)                          jj++;                      if (v[I[i2] + h] == x)                          kk++;                  }                  jj += start;                  kk += jj;                    int i = start;                  int j = 0;                  int k = 0;                  while (i < jj)                  {                      if (v[I[i] + h] < x)                      {                          i++;                      }                      else if (v[I[i] + h] == x)                      {                          Swap(ref I[i]' ref I[jj + j]);                          j++;                      }                      else                      {                          Swap(ref I[i]' ref I[kk + k]);                          k++;                      }                  }                    while (jj + j < kk)                  {                      if (v[I[jj + j] + h] == x)                      {                          j++;                      }                      else                      {                          Swap(ref I[jj + j]' ref I[kk + k]);                          k++;                      }                  }                    if (jj > start)                      Split(I' v' start' jj - start' h);                    for (i = 0; i < kk - jj; i++)                      v[I[jj + i]] = kk - 1;                  if (jj == kk - 1)                      I[jj] = -1;                    if (start + len > kk)                      Split(I' v' kk' start + len - kk' h);              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,SuffixSort,The following statement contains a magic number: int[] buckets = new int[256];
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,SuffixSort,The following statement contains a magic number: for (int i = 1; i < 256; i++)                  buckets[i] += buckets[i - 1];
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,SuffixSort,The following statement contains a magic number: for (int i = 255; i > 0; i--)                  buckets[i] = buckets[i - 1];
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,SuffixSort,The following statement contains a magic number: for (int i = 1; i < 256; i++)              {                  if (buckets[i] == buckets[i - 1] + 1)                      I[buckets[i]] = -1;              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,ReadInt64,The following statement contains a magic number: long value = buf[offset + 7] & 0x7F;
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,ReadInt64,The following statement contains a magic number: for (int index = 6; index >= 0; index--)              {                  value *= 256;                  value += buf[offset + index];              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,ReadInt64,The following statement contains a magic number: for (int index = 6; index >= 0; index--)              {                  value *= 256;                  value += buf[offset + index];              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,ReadInt64,The following statement contains a magic number: if ((buf[offset + 7] & 0x80) != 0)                  value = -value;
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,WriteInt64,The following statement contains a magic number: for (int byteIndex = 0; byteIndex < 8; byteIndex++)              {                  buf[offset + byteIndex] = (byte)(valueToWrite % 256);                  valueToWrite -= buf[offset + byteIndex];                  valueToWrite /= 256;              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,WriteInt64,The following statement contains a magic number: for (int byteIndex = 0; byteIndex < 8; byteIndex++)              {                  buf[offset + byteIndex] = (byte)(valueToWrite % 256);                  valueToWrite -= buf[offset + byteIndex];                  valueToWrite /= 256;              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,WriteInt64,The following statement contains a magic number: for (int byteIndex = 0; byteIndex < 8; byteIndex++)              {                  buf[offset + byteIndex] = (byte)(valueToWrite % 256);                  valueToWrite -= buf[offset + byteIndex];                  valueToWrite /= 256;              }
Magic Number,Squirrel.Bsdiff,BinaryPatchUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\BinaryPatchUtility.cs,WriteInt64,The following statement contains a magic number: if (value < 0)                  buf[offset + 7] |= 0x80;
Magic Number,Squirrel,FileDownloader,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\FileDownloader.cs,DownloadFile,The following statement contains a magic number: using (var wc = _providedClient ?? Utility.CreateWebClient()) {                  var failedUrl = default(string);                    var lastSignalled = DateTime.MinValue;                  wc.DownloadProgressChanged += (sender' args) => {                      var now = DateTime.Now;                        if (now - lastSignalled > TimeSpan.FromMilliseconds(500)) {                          lastSignalled = now;                          progress(args.ProgressPercentage);                      }                  };                retry:                  try {                      this.Log().Info("Downloading file: " + (failedUrl ?? url));                        await this.WarnIfThrows(                          async () => {                              await wc.DownloadFileTaskAsync(failedUrl ?? url' targetFile);                              progress(100);                          }'                          "Failed downloading URL: " + (failedUrl ?? url));                  } catch (Exception) {                      // NB: Some super brain-dead services are case-sensitive yet                       // corrupt case on upload. I can't even.                      if (failedUrl != null) throw;                        failedUrl = url.ToLower();                      progress(0);                      goto retry;                  }              }
Magic Number,Squirrel,FileDownloader,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\FileDownloader.cs,DownloadFile,The following statement contains a magic number: using (var wc = _providedClient ?? Utility.CreateWebClient()) {                  var failedUrl = default(string);                    var lastSignalled = DateTime.MinValue;                  wc.DownloadProgressChanged += (sender' args) => {                      var now = DateTime.Now;                        if (now - lastSignalled > TimeSpan.FromMilliseconds(500)) {                          lastSignalled = now;                          progress(args.ProgressPercentage);                      }                  };                retry:                  try {                      this.Log().Info("Downloading file: " + (failedUrl ?? url));                        await this.WarnIfThrows(                          async () => {                              await wc.DownloadFileTaskAsync(failedUrl ?? url' targetFile);                              progress(100);                          }'                          "Failed downloading URL: " + (failedUrl ?? url));                  } catch (Exception) {                      // NB: Some super brain-dead services are case-sensitive yet                       // corrupt case on upload. I can't even.                      if (failedUrl != null) throw;                        failedUrl = url.ToLower();                      progress(0);                      goto retry;                  }              }
Magic Number,Squirrel,EasyModeMixin,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\IUpdateManager.cs,UpdateApp,The following statement contains a magic number: try {                  updateInfo = await This.ErrorIfThrows(() => This.CheckForUpdate(ignoreDeltaUpdates' x => progress(x / 3))'                      "Failed to check for updates");                    await This.ErrorIfThrows(() =>                      This.DownloadReleases(updateInfo.ReleasesToApply' x => progress(x / 3 + 33))'                      "Failed to download updates");                    await This.ErrorIfThrows(() =>                      This.ApplyReleases(updateInfo' x => progress(x / 3 + 66))'                      "Failed to apply updates");                    await This.ErrorIfThrows(() =>                       This.CreateUninstallerRegistryEntry()'                      "Failed to set up uninstaller");              } catch {                  if (ignoreDeltaUpdates == false) {                      ignoreDeltaUpdates = true;                      goto retry;                  }                    throw;              }
Magic Number,Squirrel,EasyModeMixin,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\IUpdateManager.cs,UpdateApp,The following statement contains a magic number: try {                  updateInfo = await This.ErrorIfThrows(() => This.CheckForUpdate(ignoreDeltaUpdates' x => progress(x / 3))'                      "Failed to check for updates");                    await This.ErrorIfThrows(() =>                      This.DownloadReleases(updateInfo.ReleasesToApply' x => progress(x / 3 + 33))'                      "Failed to download updates");                    await This.ErrorIfThrows(() =>                      This.ApplyReleases(updateInfo' x => progress(x / 3 + 66))'                      "Failed to apply updates");                    await This.ErrorIfThrows(() =>                       This.CreateUninstallerRegistryEntry()'                      "Failed to set up uninstaller");              } catch {                  if (ignoreDeltaUpdates == false) {                      ignoreDeltaUpdates = true;                      goto retry;                  }                    throw;              }
Magic Number,Squirrel,EasyModeMixin,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\IUpdateManager.cs,UpdateApp,The following statement contains a magic number: try {                  updateInfo = await This.ErrorIfThrows(() => This.CheckForUpdate(ignoreDeltaUpdates' x => progress(x / 3))'                      "Failed to check for updates");                    await This.ErrorIfThrows(() =>                      This.DownloadReleases(updateInfo.ReleasesToApply' x => progress(x / 3 + 33))'                      "Failed to download updates");                    await This.ErrorIfThrows(() =>                      This.ApplyReleases(updateInfo' x => progress(x / 3 + 66))'                      "Failed to apply updates");                    await This.ErrorIfThrows(() =>                       This.CreateUninstallerRegistryEntry()'                      "Failed to set up uninstaller");              } catch {                  if (ignoreDeltaUpdates == false) {                      ignoreDeltaUpdates = true;                      goto retry;                  }                    throw;              }
Magic Number,Squirrel,EasyModeMixin,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\IUpdateManager.cs,UpdateApp,The following statement contains a magic number: try {                  updateInfo = await This.ErrorIfThrows(() => This.CheckForUpdate(ignoreDeltaUpdates' x => progress(x / 3))'                      "Failed to check for updates");                    await This.ErrorIfThrows(() =>                      This.DownloadReleases(updateInfo.ReleasesToApply' x => progress(x / 3 + 33))'                      "Failed to download updates");                    await This.ErrorIfThrows(() =>                      This.ApplyReleases(updateInfo' x => progress(x / 3 + 66))'                      "Failed to apply updates");                    await This.ErrorIfThrows(() =>                       This.CreateUninstallerRegistryEntry()'                      "Failed to set up uninstaller");              } catch {                  if (ignoreDeltaUpdates == false) {                      ignoreDeltaUpdates = true;                      goto retry;                  }                    throw;              }
Magic Number,Squirrel,EasyModeMixin,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\IUpdateManager.cs,UpdateApp,The following statement contains a magic number: try {                  updateInfo = await This.ErrorIfThrows(() => This.CheckForUpdate(ignoreDeltaUpdates' x => progress(x / 3))'                      "Failed to check for updates");                    await This.ErrorIfThrows(() =>                      This.DownloadReleases(updateInfo.ReleasesToApply' x => progress(x / 3 + 33))'                      "Failed to download updates");                    await This.ErrorIfThrows(() =>                      This.ApplyReleases(updateInfo' x => progress(x / 3 + 66))'                      "Failed to apply updates");                    await This.ErrorIfThrows(() =>                       This.CreateUninstallerRegistryEntry()'                      "Failed to set up uninstaller");              } catch {                  if (ignoreDeltaUpdates == false) {                      ignoreDeltaUpdates = true;                      goto retry;                  }                    throw;              }
Magic Number,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,ReleaseEntry,The following statement contains a magic number: Contract.Requires(sha1 != null && sha1.Length == 40);
Magic Number,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,ParseReleaseEntry,The following statement contains a magic number: if (m.Groups.Count != 4) {                  throw new Exception("Invalid release entry: " + entry);              }
Magic Number,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,ParseReleaseEntry,The following statement contains a magic number: string filename = m.Groups[2].Value;
Magic Number,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,ParseReleaseEntry,The following statement contains a magic number: long size = Int64.Parse(m.Groups[3].Value);
Magic Number,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,IsStagingMatch,The following statement contains a magic number: uint val = BitConverter.ToUInt32(userId.Value.ToByteArray()' 12);
Magic Number,Squirrel,ReleaseEntry,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleaseEntry.cs,stagingPercentageAsString,The following statement contains a magic number: return String.Format("{0:F0}%"' percentage * 100.0);
Magic Number,Squirrel,ReleasePackage,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleasePackage.cs,extractZipWithEscaping,The following statement contains a magic number: return Task.Run(() => {                  using (var za = ZipArchive.Open(zipFilePath))                  using (var reader = za.ExtractAllEntries()) {                      while (reader.MoveToNextEntry()) {                          var parts = reader.Entry.Key.Split('\\'' '/').Select(x => Uri.UnescapeDataString(x));                          var decoded = String.Join(Path.DirectorySeparatorChar.ToString()' parts);                            var fullTargetFile = Path.Combine(outFolder' decoded);                          var fullTargetDir = Path.GetDirectoryName(fullTargetFile);                          Directory.CreateDirectory(fullTargetDir);                            Utility.Retry(() => {                              if (reader.Entry.IsDirectory) {                                  Directory.CreateDirectory(Path.Combine(outFolder' decoded));                              } else {                                  reader.WriteEntryToFile(Path.Combine(outFolder' decoded));                              }                          }' 5);                      }                  }              });
Magic Number,Squirrel,ReleasePackage,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ReleasePackage.cs,ExtractZipForInstall,The following statement contains a magic number: return Task.Run(() => {                  using (var za = ZipArchive.Open(zipFilePath))                  using (var reader = za.ExtractAllEntries()) {                      while (reader.MoveToNextEntry()) {                          var parts = reader.Entry.Key.Split('\\'' '/');                          var decoded = String.Join(Path.DirectorySeparatorChar.ToString()' parts);                            if (!re.IsMatch(decoded)) continue;                          decoded = re.Replace(decoded' ""' 1);                            var fullTargetFile = Path.Combine(outFolder' decoded);                          var fullTargetDir = Path.GetDirectoryName(fullTargetFile);                          Directory.CreateDirectory(fullTargetDir);                            var failureIsOkay = false;                          if (!reader.Entry.IsDirectory && decoded.Contains("_ExecutionStub.exe")) {                              // NB: On upgrade' many of these stubs will be in-use' nbd tho.                              failureIsOkay = true;                                fullTargetFile = Path.Combine(                                  rootPackageFolder'                                  Path.GetFileName(decoded).Replace("_ExecutionStub.exe"' ".exe"));                                LogHost.Default.Info("Rigging execution stub for {0} to {1}"' decoded' fullTargetFile);                          }                            try {                              Utility.Retry(() => {                                  if (reader.Entry.IsDirectory) {                                      Directory.CreateDirectory(fullTargetFile);                                  } else {                                      reader.WriteEntryToFile(fullTargetFile);                                  }                              }' 5);                          } catch (Exception e) {                              if (!failureIsOkay) throw;                              LogHost.Default.WarnException("Can't write execution stub' probably in use"' e);                          }                      }                  }              });
Magic Number,Squirrel,SquirrelAwareApp,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SquirrelAwareApp.cs,HandleEvents,The following statement contains a magic number: if (args.Length != 2) return;
Magic Number,Squirrel,SquirrelAwareExecutableDetector,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SquirrelAwareExecutableDetector.cs,GetAssemblySquirrelAwareVersion,The following statement contains a magic number: try {                  var assembly = AssemblyDefinition.ReadAssembly(executable);                  if (!assembly.HasCustomAttributes) return null;                    var attrs = assembly.CustomAttributes;                  var attribute = attrs.FirstOrDefault(x => {                      if (x.AttributeType.FullName != typeof(AssemblyMetadataAttribute).FullName) return false;                      if (x.ConstructorArguments.Count != 2) return false;                      return x.ConstructorArguments[0].Value.ToString() == "SquirrelAwareVersion";                  });                    if (attribute == null) return null;                    int result;                  if (!Int32.TryParse(attribute.ConstructorArguments[1].Value.ToString()' NumberStyles.Integer' CultureInfo.CurrentCulture' out result)) {                      return null;                  }                    return result;              }               catch (FileLoadException) { return null; }              catch (BadImageFormatException) { return null; }
Magic Number,Squirrel,SquirrelAwareExecutableDetector,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SquirrelAwareExecutableDetector.cs,GetVersionBlockSquirrelAwareValue,The following statement contains a magic number: if (size <= 0 || size > 4096) return null;
Magic Number,Squirrel,TrayStateChanger,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\TrayHelper.cs,RemoveDeadEntries,The following statement contains a magic number: if (iconStreamData == null || iconStreamData.Length < 20) return;
Magic Number,Squirrel,TrayStateChanger,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\TrayHelper.cs,useLegacyInterface,The following statement contains a magic number: if (ver.Major < 6) return true;
Magic Number,Squirrel,TrayStateChanger,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\TrayHelper.cs,useLegacyInterface,The following statement contains a magic number: if (ver.Major > 6) return false;
Magic Number,Squirrel,UpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,RestartApp,The following statement contains a magic number: Thread.Sleep(500);
Magic Number,Squirrel,UpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,RestartAppWhenExited,The following statement contains a magic number: await Task.Delay(500);
Magic Number,Squirrel,UpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,acquireUpdateLock,The following statement contains a magic number: return Task.Run(() => {                  var key = Utility.CalculateStreamSHA1(new MemoryStream(Encoding.UTF8.GetBytes(rootAppDirectory)));                    IDisposable theLock;                  try {                      theLock = ModeDetector.InUnitTestRunner() ?                          Disposable.Create(() => {}) : new SingleGlobalInstance(key' TimeSpan.FromMilliseconds(2000));                  } catch (TimeoutException) {                      throw new TimeoutException("Couldn't acquire update lock' another instance may be running updates");                  }                    var ret = Disposable.Create(() => {                      theLock.Dispose();                      updateLock = null;                  });                    updateLock = ret;                  return ret;              });
Magic Number,Squirrel,UpdateManager,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,GitHubUpdateManager,The following statement contains a magic number: if (repoUri.Segments.Length != 3) {                  throw new Exception("Repo URL must be to the root URL of the repo e.g. https://github.com/myuser/myrepo");              }
Magic Number,Squirrel,CheckForUpdateImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,CheckForUpdate,The following statement contains a magic number: if (Utility.IsHttpUrl(updateUrlOrPath)) {                      if (updateUrlOrPath.EndsWith("/")) {                          updateUrlOrPath = updateUrlOrPath.Substring(0' updateUrlOrPath.Length - 1);                      }                        this.Log().Info("Downloading RELEASES file from {0}"' updateUrlOrPath);                        int retries = 3;                    retry:                        try {                          var uri = Utility.AppendPathToUri(new Uri(updateUrlOrPath)' "RELEASES");                            if (latestLocalRelease != null) {                              uri = Utility.AddQueryParamsToUri(uri' new Dictionary<string' string> {                                  { "id"' latestLocalRelease.PackageName }'                                  { "localVersion"' latestLocalRelease.Version.ToString() }'                                  { "arch"' Environment.Is64BitOperatingSystem ? "amd64" : "x86" }                              });                          }                            var data = await urlDownloader.DownloadUrl(uri.ToString());                          releaseFile = Encoding.UTF8.GetString(data);                      } catch (WebException ex) {                          this.Log().InfoException("Download resulted in WebException (returning blank release list)"' ex);                            if (retries <= 0) throw;                          retries--;                          goto retry;                      }                        progress(33);                  } else {                      this.Log().Info("Reading RELEASES file from {0}"' updateUrlOrPath);                        if (!Directory.Exists(updateUrlOrPath)) {                          var message = String.Format(                              "The directory {0} does not exist' something is probably broken with your application"'                              updateUrlOrPath);                            throw new Exception(message);                      }                        var fi = new FileInfo(Path.Combine(updateUrlOrPath' "RELEASES"));                      if (!fi.Exists) {                          var message = String.Format(                              "The file {0} does not exist' something is probably broken with your application"'                              fi.FullName);                            this.Log().Warn(message);                            var packages = (new DirectoryInfo(updateUrlOrPath)).GetFiles("*.nupkg");                          if (packages.Length == 0) {                              throw new Exception(message);                          }                            // NB: Create a new RELEASES file since we've got a directory of packages                          ReleaseEntry.WriteReleaseFile(                              packages.Select(x => ReleaseEntry.GenerateFromFile(x.FullName))' fi.FullName);                      }                        releaseFile = File.ReadAllText(fi.FullName' Encoding.UTF8);                      progress(33);                  }
Magic Number,Squirrel,CheckForUpdateImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,CheckForUpdate,The following statement contains a magic number: if (Utility.IsHttpUrl(updateUrlOrPath)) {                      if (updateUrlOrPath.EndsWith("/")) {                          updateUrlOrPath = updateUrlOrPath.Substring(0' updateUrlOrPath.Length - 1);                      }                        this.Log().Info("Downloading RELEASES file from {0}"' updateUrlOrPath);                        int retries = 3;                    retry:                        try {                          var uri = Utility.AppendPathToUri(new Uri(updateUrlOrPath)' "RELEASES");                            if (latestLocalRelease != null) {                              uri = Utility.AddQueryParamsToUri(uri' new Dictionary<string' string> {                                  { "id"' latestLocalRelease.PackageName }'                                  { "localVersion"' latestLocalRelease.Version.ToString() }'                                  { "arch"' Environment.Is64BitOperatingSystem ? "amd64" : "x86" }                              });                          }                            var data = await urlDownloader.DownloadUrl(uri.ToString());                          releaseFile = Encoding.UTF8.GetString(data);                      } catch (WebException ex) {                          this.Log().InfoException("Download resulted in WebException (returning blank release list)"' ex);                            if (retries <= 0) throw;                          retries--;                          goto retry;                      }                        progress(33);                  } else {                      this.Log().Info("Reading RELEASES file from {0}"' updateUrlOrPath);                        if (!Directory.Exists(updateUrlOrPath)) {                          var message = String.Format(                              "The directory {0} does not exist' something is probably broken with your application"'                              updateUrlOrPath);                            throw new Exception(message);                      }                        var fi = new FileInfo(Path.Combine(updateUrlOrPath' "RELEASES"));                      if (!fi.Exists) {                          var message = String.Format(                              "The file {0} does not exist' something is probably broken with your application"'                              fi.FullName);                            this.Log().Warn(message);                            var packages = (new DirectoryInfo(updateUrlOrPath)).GetFiles("*.nupkg");                          if (packages.Length == 0) {                              throw new Exception(message);                          }                            // NB: Create a new RELEASES file since we've got a directory of packages                          ReleaseEntry.WriteReleaseFile(                              packages.Select(x => ReleaseEntry.GenerateFromFile(x.FullName))' fi.FullName);                      }                        releaseFile = File.ReadAllText(fi.FullName' Encoding.UTF8);                      progress(33);                  }
Magic Number,Squirrel,CheckForUpdateImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,CheckForUpdate,The following statement contains a magic number: if (Utility.IsHttpUrl(updateUrlOrPath)) {                      if (updateUrlOrPath.EndsWith("/")) {                          updateUrlOrPath = updateUrlOrPath.Substring(0' updateUrlOrPath.Length - 1);                      }                        this.Log().Info("Downloading RELEASES file from {0}"' updateUrlOrPath);                        int retries = 3;                    retry:                        try {                          var uri = Utility.AppendPathToUri(new Uri(updateUrlOrPath)' "RELEASES");                            if (latestLocalRelease != null) {                              uri = Utility.AddQueryParamsToUri(uri' new Dictionary<string' string> {                                  { "id"' latestLocalRelease.PackageName }'                                  { "localVersion"' latestLocalRelease.Version.ToString() }'                                  { "arch"' Environment.Is64BitOperatingSystem ? "amd64" : "x86" }                              });                          }                            var data = await urlDownloader.DownloadUrl(uri.ToString());                          releaseFile = Encoding.UTF8.GetString(data);                      } catch (WebException ex) {                          this.Log().InfoException("Download resulted in WebException (returning blank release list)"' ex);                            if (retries <= 0) throw;                          retries--;                          goto retry;                      }                        progress(33);                  } else {                      this.Log().Info("Reading RELEASES file from {0}"' updateUrlOrPath);                        if (!Directory.Exists(updateUrlOrPath)) {                          var message = String.Format(                              "The directory {0} does not exist' something is probably broken with your application"'                              updateUrlOrPath);                            throw new Exception(message);                      }                        var fi = new FileInfo(Path.Combine(updateUrlOrPath' "RELEASES"));                      if (!fi.Exists) {                          var message = String.Format(                              "The file {0} does not exist' something is probably broken with your application"'                              fi.FullName);                            this.Log().Warn(message);                            var packages = (new DirectoryInfo(updateUrlOrPath)).GetFiles("*.nupkg");                          if (packages.Length == 0) {                              throw new Exception(message);                          }                            // NB: Create a new RELEASES file since we've got a directory of packages                          ReleaseEntry.WriteReleaseFile(                              packages.Select(x => ReleaseEntry.GenerateFromFile(x.FullName))' fi.FullName);                      }                        releaseFile = File.ReadAllText(fi.FullName' Encoding.UTF8);                      progress(33);                  }
Magic Number,Squirrel,CheckForUpdateImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,CheckForUpdate,The following statement contains a magic number: progress(66);
Magic Number,Squirrel,CheckForUpdateImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,CheckForUpdate,The following statement contains a magic number: progress(100);
Magic Number,Squirrel,CheckForUpdateImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.CheckForUpdates.cs,getOrCreateStagedUserId,The following statement contains a magic number: var buf = new byte[4096];
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,Retry,The following statement contains a magic number: while (true) {                  try {                      T ret = block();                      return ret;                  } catch (Exception) {                      if (retries == 0) {                          throw;                      }                        retries--;                      Thread.Sleep(250);                  }              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,InvokeProcessAsync,The following statement contains a magic number: await Task.Run(() => {                  while (!ct.IsCancellationRequested) {                      if (pi.WaitForExit(2000)) return;                  }                    if (ct.IsCancellationRequested) {                      pi.Kill();                      ct.ThrowIfCancellationRequested();                  }              });
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,WithTempDirectory,The following statement contains a magic number: var names = Enumerable.Range(0' 1<<20).Select(x => tempNameForIndex(x' "temp"));
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,WithTempFile,The following statement contains a magic number: var names = Enumerable.Range(0' 1<<20).Select(x => tempNameForIndex(x' "temp"));
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,DeleteFileHarder,The following statement contains a magic number: try {                  Retry(() => File.Delete(path)' 2);              } catch (Exception ex) {                  if (ignoreIfFails) return;                    LogHost.Default.ErrorException("Really couldn't delete file: " + path' ex);                  throw;              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,ExecutableUsesWin32Subsystem,The following statement contains a magic number: using (var s = new FileStream(peImage' FileMode.Open' FileAccess.Read)) {                  var rawPeSignatureOffset = new byte[4];                  s.Seek(0x3c' SeekOrigin.Begin);                  s.Read(rawPeSignatureOffset' 0' 4);                    int peSignatureOffset = rawPeSignatureOffset[0];                  peSignatureOffset |= rawPeSignatureOffset[1] << 8;                  peSignatureOffset |= rawPeSignatureOffset[2] << 16;                  peSignatureOffset |= rawPeSignatureOffset[3] << 24;                    var coffHeader = new byte[24];                  s.Seek(peSignatureOffset' SeekOrigin.Begin);                  s.Read(coffHeader' 0' 24);                    byte[] signature = { (byte)'P'' (byte)'E'' (byte)'\0'' (byte)'\0' };                  for (int index = 0; index < 4; index++) {                      if (coffHeader[index] != signature[index]) throw new Exception("File is not a PE image");                  }                    var subsystemBytes = new byte[2];                  s.Seek(68' SeekOrigin.Current);                  s.Read(subsystemBytes' 0' 2);                    int subSystem = subsystemBytes[0] | subsystemBytes[1] << 8;                  return subSystem == 2; /*IMAGE_SUBSYSTEM_WINDOWS_GUI*/              }
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,IsFileTopLevelInPackage,The following statement contains a magic number: return relativePath.Split(Path.DirectorySeparatorChar).Length == 4;
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateGuidFromHash,The following statement contains a magic number: var newGuid = new byte[16];
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateGuidFromHash,The following statement contains a magic number: Array.Copy(hash' 0' newGuid' 0' 16);
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateGuidFromHash,The following statement contains a magic number: newGuid[6] = (byte)((newGuid[6] & 0x0F) | (5 << 4));
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateGuidFromHash,The following statement contains a magic number: newGuid[6] = (byte)((newGuid[6] & 0x0F) | (5 << 4));
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateGuidFromHash,The following statement contains a magic number: newGuid[6] = (byte)((newGuid[6] & 0x0F) | (5 << 4));
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateGuidFromHash,The following statement contains a magic number: newGuid[6] = (byte)((newGuid[6] & 0x0F) | (5 << 4));
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateGuidFromHash,The following statement contains a magic number: newGuid[8] = (byte)((newGuid[8] & 0x3F) | 0x80);
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,CreateGuidFromHash,The following statement contains a magic number: newGuid[8] = (byte)((newGuid[8] & 0x3F) | 0x80);
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,SwapByteOrder,The following statement contains a magic number: SwapBytes(guid' 0' 3);
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,SwapByteOrder,The following statement contains a magic number: SwapBytes(guid' 1' 2);
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,SwapByteOrder,The following statement contains a magic number: SwapBytes(guid' 4' 5);
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,SwapByteOrder,The following statement contains a magic number: SwapBytes(guid' 4' 5);
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,SwapByteOrder,The following statement contains a magic number: SwapBytes(guid' 6' 7);
Magic Number,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,SwapByteOrder,The following statement contains a magic number: SwapBytes(guid' 6' 7);
Magic Number,Squirrel,UnsafeUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,EnumerateProcesses,The following statement contains a magic number: var pids = new int[2048];
Magic Number,Squirrel,UnsafeUtility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,EnumerateProcesses,The following statement contains a magic number: return Enumerable.Range(0' bytesReturned / sizeof(int))                  .Where(i => pids[i] > 0)                  .Select(i => {                      try {                          var hProcess = NativeMethods.OpenProcess(ProcessAccess.QueryLimitedInformation' false' pids[i]);                          if (hProcess == IntPtr.Zero) throw new Win32Exception();                            var sb = new StringBuilder(256);                          var capacity = sb.Capacity;                          if (!NativeMethods.QueryFullProcessImageName(hProcess' 0' sb' ref capacity)) {                              throw new Win32Exception();                          }                            NativeMethods.CloseHandle(hProcess);                          return Tuple.Create(sb.ToString()' pids[i]);                      } catch (Exception) {                          return Tuple.Create(default(string)' pids[i]);                      }                  })                  .ToList();
Magic Number,Squirrel,SingleGlobalInstance,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,SingleGlobalInstance,The following statement contains a magic number: while (st.Elapsed < timeOut) {                  try {                      fh = new FileStream(path' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.Delete);                      fh.Write(new byte[] { 0xba' 0xad' 0xf0' 0x0d' }' 0' 4);                      break;                  } catch (Exception ex) {                      this.Log().WarnException("Failed to grab lockfile' will retry: " + path' ex);                      Thread.Sleep(250);                  }              }
Magic Number,Squirrel,SingleGlobalInstance,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,SingleGlobalInstance,The following statement contains a magic number: while (st.Elapsed < timeOut) {                  try {                      fh = new FileStream(path' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.Delete);                      fh.Write(new byte[] { 0xba' 0xad' 0xf0' 0x0d' }' 0' 4);                      break;                  } catch (Exception ex) {                      this.Log().WarnException("Failed to grab lockfile' will retry: " + path' ex);                      Thread.Sleep(250);                  }              }
Magic Number,Squirrel,DownloadReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.DownloadReleases.cs,DownloadReleases,The following statement contains a magic number: double toIncrement = 100.0 / releasesToDownload.Count();
Magic Number,Squirrel,DownloadReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.DownloadReleases.cs,DownloadReleases,The following statement contains a magic number: if (Utility.IsHttpUrl(updateUrlOrPath)) {                      // From Internet                      await releasesToDownload.ForEachAsync(async x => {                          var targetFile = Path.Combine(packagesDirectory' x.Filename);                          double component = 0;                          await downloadRelease(updateUrlOrPath' x' urlDownloader' targetFile' p => {                              lock (progress) {                                  current -= component;                                  component = toIncrement / 100.0 * p;                                  progress((int)Math.Round(current += component));                              }                          });                            checksumPackage(x);                      });                  } else {                      // From Disk                      await releasesToDownload.ForEachAsync(x => {                          var targetFile = Path.Combine(packagesDirectory' x.Filename);                            File.Copy(                              Path.Combine(updateUrlOrPath' x.Filename)'                              targetFile'                              true);                            lock (progress) progress((int)Math.Round(current += toIncrement));                          checksumPackage(x);                      });                  }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The following statement contains a magic number: progress(10);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The following statement contains a magic number: if (release == null) {                      if (attemptingFullInstall) {                          this.Log().Info("No release to install' running the app");                          await invokePostInstall(updateInfo.CurrentlyInstalledVersion.Version' false' true' silentInstall);                      }                        progress(100);                      return getDirectoryForRelease(updateInfo.CurrentlyInstalledVersion.Version).FullName;                  }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The following statement contains a magic number: progress(30);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The following statement contains a magic number: progress(50);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The following statement contains a magic number: progress(75);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The following statement contains a magic number: progress(80);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The following statement contains a magic number: progress(85);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,ApplyReleases,The following statement contains a magic number: progress(100);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The following statement contains a magic number: if (currentRelease.Exists) {                      var version = currentRelease.Name.ToSemanticVersion();                        try {                          var squirrelAwareApps = SquirrelAwareExecutableDetector.GetAllSquirrelAwareApps(currentRelease.FullName);                            if (isAppFolderDead(currentRelease.FullName)) throw new Exception("App folder is dead' but we're trying to uninstall it?");                            var allApps = currentRelease.EnumerateFiles()                              .Where(x => x.Name.EndsWith(".exe"' StringComparison.OrdinalIgnoreCase))                              .Where(x => !x.Name.StartsWith("squirrel."' StringComparison.OrdinalIgnoreCase) && !x.Name.StartsWith("update."' StringComparison.OrdinalIgnoreCase))                              .ToList();                            if (squirrelAwareApps.Count > 0) {                              await squirrelAwareApps.ForEachAsync(async exe => {                                  using (var cts = new CancellationTokenSource()) {                                       cts.CancelAfter(10 * 1000);                                        try {                                          await Utility.InvokeProcessAsync(exe' String.Format("--squirrel-uninstall {0}"' version)' cts.Token);                                      } catch (Exception ex) {                                          this.Log().ErrorException("Failed to run cleanup hook' continuing: " + exe' ex);                                      }                                  }                              }' 1 /*at a time*/);                          } else {                              allApps.ForEach(x => RemoveShortcutsForExecutable(x.Name' ShortcutLocation.StartMenu | ShortcutLocation.Desktop));                          }                      } catch (Exception ex) {                          this.Log().WarnException("Failed to run pre-uninstall hooks' uninstalling anyways"' ex);                      }                  }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The following statement contains a magic number: if (currentRelease.Exists) {                      var version = currentRelease.Name.ToSemanticVersion();                        try {                          var squirrelAwareApps = SquirrelAwareExecutableDetector.GetAllSquirrelAwareApps(currentRelease.FullName);                            if (isAppFolderDead(currentRelease.FullName)) throw new Exception("App folder is dead' but we're trying to uninstall it?");                            var allApps = currentRelease.EnumerateFiles()                              .Where(x => x.Name.EndsWith(".exe"' StringComparison.OrdinalIgnoreCase))                              .Where(x => !x.Name.StartsWith("squirrel."' StringComparison.OrdinalIgnoreCase) && !x.Name.StartsWith("update."' StringComparison.OrdinalIgnoreCase))                              .ToList();                            if (squirrelAwareApps.Count > 0) {                              await squirrelAwareApps.ForEachAsync(async exe => {                                  using (var cts = new CancellationTokenSource()) {                                       cts.CancelAfter(10 * 1000);                                        try {                                          await Utility.InvokeProcessAsync(exe' String.Format("--squirrel-uninstall {0}"' version)' cts.Token);                                      } catch (Exception ex) {                                          this.Log().ErrorException("Failed to run cleanup hook' continuing: " + exe' ex);                                      }                                  }                              }' 1 /*at a time*/);                          } else {                              allApps.ForEach(x => RemoveShortcutsForExecutable(x.Name' ShortcutLocation.StartMenu | ShortcutLocation.Desktop));                          }                      } catch (Exception ex) {                          this.Log().WarnException("Failed to run pre-uninstall hooks' uninstalling anyways"' ex);                      }                  }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The following statement contains a magic number: try {                      this.ErrorIfThrows(() => fixPinnedExecutables(new SemanticVersion(255' 255' 255' 255)' true));                  } catch { }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The following statement contains a magic number: try {                      this.ErrorIfThrows(() => fixPinnedExecutables(new SemanticVersion(255' 255' 255' 255)' true));                  } catch { }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The following statement contains a magic number: try {                      this.ErrorIfThrows(() => fixPinnedExecutables(new SemanticVersion(255' 255' 255' 255)' true));                  } catch { }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,FullUninstall,The following statement contains a magic number: try {                      this.ErrorIfThrows(() => fixPinnedExecutables(new SemanticVersion(255' 255' 255' 255)' true));                  } catch { }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,CreateShortcutsForExecutable,The following statement contains a magic number: foreach (var f in (ShortcutLocation[]) Enum.GetValues(typeof(ShortcutLocation))) {                      if (!locations.HasFlag(f)) continue;                        var file = linkTargetForVersionInfo(f' zf' fileVerInfo);                      var fileExists = File.Exists(file);                        // NB: If we've already installed the app' but the shortcut                      // is no longer there' we have to assume that the user didn't                      // want it there and explicitly deleted it' so we shouldn't                      // annoy them by recreating it.                      if (!fileExists && updateOnly) {                          this.Log().Warn("Wanted to update shortcut {0} but it appears user deleted it"' file);                          continue;                      }                        this.Log().Info("Creating shortcut for {0} => {1}"' exeName' file);                        ShellLink sl;                      this.ErrorIfThrows(() => Utility.Retry(() => {                          File.Delete(file);                            var target = Path.Combine(rootAppDirectory' exeName);                          sl = new ShellLink {                              Target = target'                              IconPath = icon ?? target'                              IconIndex = 0'                              WorkingDirectory = Path.GetDirectoryName(exePath)'                              Description = zf.Description'                          };                            if (!String.IsNullOrWhiteSpace(programArguments)) {                              sl.Arguments += String.Format(" -a \"{0}\""' programArguments);                          }                            var appUserModelId = String.Format("com.squirrel.{0}.{1}"' zf.Id.Replace(" "' "")' exeName.Replace(".exe"' "").Replace(" "' ""));                          var toastActivatorCLSID = Utility.CreateGuidFromHash(appUserModelId).ToString();                            sl.SetAppUserModelId(appUserModelId);                          sl.SetToastActivatorCLSID(toastActivatorCLSID);                            this.Log().Info("About to save shortcut: {0} (target {1}' workingDir {2}' args {3}' toastActivatorCSLID {4})"' file' sl.Target' sl.WorkingDirectory' sl.Arguments' toastActivatorCLSID);                          if (ModeDetector.InUnitTestRunner() == false) sl.Save(file);                      }' 4)' "Can't write shortcut: " + file);                  }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,invokePostInstall,The following statement contains a magic number: if (!firstRunOnly) await squirrelApps.ForEachAsync(async exe => {                      using (var cts = new CancellationTokenSource()) {                           cts.CancelAfter(15 * 1000);                            try {                              await Utility.InvokeProcessAsync(exe' args' cts.Token);                          } catch (Exception ex) {                              this.Log().ErrorException("Couldn't run Squirrel hook' continuing: " + exe' ex);                          }                      }                  }' 1 /* at a time */);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,invokePostInstall,The following statement contains a magic number: if (!firstRunOnly) await squirrelApps.ForEachAsync(async exe => {                      using (var cts = new CancellationTokenSource()) {                           cts.CancelAfter(15 * 1000);                            try {                              await Utility.InvokeProcessAsync(exe' args' cts.Token);                          } catch (Exception ex) {                              this.Log().ErrorException("Couldn't run Squirrel hook' continuing: " + exe' ex);                          }                      }                  }' 1 /* at a time */);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,fixPinnedExecutables,The following statement contains a magic number: if (Environment.OSVersion.Version < new Version(6' 1)) {                      this.Log().Warn("fixPinnedExecutables: Found OS Version '{0}'' exiting..."' Environment.OSVersion.VersionString);                      return;                  }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,updateLink,The following statement contains a magic number: this.ErrorIfThrows(() => Utility.Retry(() => shortcut.Save()' 2)' "Couldn't write shortcut " + shortcut.ShortCutFile);
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,cleanDeadVersions,The following statement contains a magic number: if (forceUninstall == false) {                      await toCleanup.ForEachAsync(async x => {                          var squirrelApps = SquirrelAwareExecutableDetector.GetAllSquirrelAwareApps(x.FullName);                          var args = String.Format("--squirrel-obsolete {0}"' x.Name.Replace("app-"' ""));                            if (squirrelApps.Count > 0) {                              // For each app' run the install command in-order and wait                              await squirrelApps.ForEachAsync(async exe => {                                  using (var cts = new CancellationTokenSource()) {                                       cts.CancelAfter(10 * 1000);                                        try {                                          await Utility.InvokeProcessAsync(exe' args' cts.Token);                                      } catch (Exception ex) {                                          this.Log().ErrorException("Coudln't run Squirrel hook' continuing: " + exe' ex);                                      }                                  }                              }' 1 /* at a time */);                          }                      });                  }
Magic Number,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,cleanDeadVersions,The following statement contains a magic number: if (forceUninstall == false) {                      await toCleanup.ForEachAsync(async x => {                          var squirrelApps = SquirrelAwareExecutableDetector.GetAllSquirrelAwareApps(x.FullName);                          var args = String.Format("--squirrel-obsolete {0}"' x.Name.Replace("app-"' ""));                            if (squirrelApps.Count > 0) {                              // For each app' run the install command in-order and wait                              await squirrelApps.ForEachAsync(async exe => {                                  using (var cts = new CancellationTokenSource()) {                                       cts.CancelAfter(10 * 1000);                                        try {                                          await Utility.InvokeProcessAsync(exe' args' cts.Token);                                      } catch (Exception ex) {                                          this.Log().ErrorException("Coudln't run Squirrel hook' continuing: " + exe' ex);                                      }                                  }                              }' 1 /* at a time */);                          }                      });                  }
Magic Number,Squirrel,InstallHelperImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.InstallHelpers.cs,CreateUninstallerRegistryEntry,The following statement contains a magic number: var dwordsToWrite = new[] {                      new { Key = "EstimatedSize"' Value = (int)((new FileInfo(pkgPath)).Length / 1024) }'                      new { Key = "NoModify"' Value = 1 }'                      new { Key = "NoRepair"' Value = 1 }'                      new { Key = "Language"' Value = 0x0409 }'                  };
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,FormParagraphs,The following statement contains a magic number: for (int i = 0; i < grafs.Length; i++)              {                  if (grafs[i].StartsWith("\x1AH"))                  {                      // unhashify HTML blocks                      if (unhash)                      {                          int sanityCheck = 50; // just for safety' guard against an infinite loop                          bool keepGoing = true; // as long as replacements where made' keep going                          while (keepGoing && sanityCheck > 0)                          {                              keepGoing = false;                              grafs[i] = _htmlBlockHash.Replace(grafs[i]' match =>                              {                                  keepGoing = true;                                  return _htmlBlocks[match.Value];                              });                              sanityCheck--;                          }                          /* if (keepGoing)                          {                              // Logging of an infinite loop goes here.                              // If such a thing should happen' please open a new issue on http://code.google.com/p/markdownsharp/                              // with the input that caused it.                          }*/                      }                  }                  else                  {                      // do span level processing inside the block' then wrap result in <p> tags                      grafs[i] = _leadingWhitespace.Replace(RunSpanGamut(grafs[i])' "<p>") + "</p>";                  }              }
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,LinkEvaluator,The following statement contains a magic number: _urls[linkID] = EncodeAmpsAndAngles(match.Groups[2].Value);
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,LinkEvaluator,The following statement contains a magic number: if (match.Groups[3] != null && match.Groups[3].Length > 0)                  _titles[linkID] = match.Groups[3].Value.Replace("\""' "&quot;");
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,LinkEvaluator,The following statement contains a magic number: if (match.Groups[3] != null && match.Groups[3].Length > 0)                  _titles[linkID] = match.Groups[3].Value.Replace("\""' "&quot;");
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,LinkEvaluator,The following statement contains a magic number: if (match.Groups[3] != null && match.Groups[3].Length > 0)                  _titles[linkID] = match.Groups[3].Value.Replace("\""' "&quot;");
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AnchorRefEvaluator,The following statement contains a magic number: string linkText = SaveFromAutoLinking(match.Groups[2].Value);
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AnchorRefEvaluator,The following statement contains a magic number: string linkID = match.Groups[3].Value.ToLowerInvariant();
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AnchorRefShortcutEvaluator,The following statement contains a magic number: string linkText = SaveFromAutoLinking(match.Groups[2].Value);
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AnchorInlineEvaluator,The following statement contains a magic number: string linkText = SaveFromAutoLinking(match.Groups[2].Value);
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AnchorInlineEvaluator,The following statement contains a magic number: string url = match.Groups[3].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AnchorInlineEvaluator,The following statement contains a magic number: string title = match.Groups[6].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AnchorInlineEvaluator,The following statement contains a magic number: if (url.StartsWith("<") && url.EndsWith(">"))                  url = url.Substring(1' url.Length - 2);
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,ImageReferenceEvaluator,The following statement contains a magic number: string altText = match.Groups[2].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,ImageReferenceEvaluator,The following statement contains a magic number: string linkID = match.Groups[3].Value.ToLowerInvariant();
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,ImageInlineEvaluator,The following statement contains a magic number: string alt = match.Groups[2].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,ImageInlineEvaluator,The following statement contains a magic number: string url = match.Groups[3].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,ImageInlineEvaluator,The following statement contains a magic number: string title = match.Groups[6].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,ImageInlineEvaluator,The following statement contains a magic number: if (url.StartsWith("<") && url.EndsWith(">"))                  url = url.Substring(1' url.Length - 2);
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,SetextHeaderEvaluator,The following statement contains a magic number: int level = match.Groups[2].Value.StartsWith("=") ? 1 : 2;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,SetextHeaderEvaluator,The following statement contains a magic number: int level = match.Groups[2].Value.StartsWith("=") ? 1 : 2;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,AtxHeaderEvaluator,The following statement contains a magic number: string header = match.Groups[2].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,GetListEvaluator,The following statement contains a magic number: return new MatchEvaluator(match =>                  {                      string list = match.Groups[1].Value;                      string listType = Regex.IsMatch(match.Groups[3].Value' _markerUL) ? "ul" : "ol";                      string result;                        result = ProcessListItems(list' listType == "ul" ? _markerUL : _markerOL' isInsideParagraphlessListItem);                        result = string.Format("<{0}>\n{1}</{0}>\n"' listType' result);                      return result;                  });
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,ProcessListItems,The following statement contains a magic number: MatchEvaluator ListItemEvaluator = (Match match) =>              {                  string item = match.Groups[3].Value;                    bool endsWithDoubleNewline = item.EndsWith("\n\n");                  bool containsDoubleNewline = endsWithDoubleNewline || item.Contains("\n\n");                    if (containsDoubleNewline || lastItemHadADoubleNewline)                      // we could correct any bad indentation here..                      item = RunBlockGamut(Outdent(item) + "\n"' unhash: false);                  else                  {                      // recursion for sub-lists                      item = DoLists(Outdent(item)' isInsideParagraphlessListItem: true);                      item = item.TrimEnd('\n');                      if (!isInsideParagraphlessListItem) // only the outer-most item should run this' otherwise it's run multiple times for the inner ones                          item = RunSpanGamut(item);                  }                  lastItemHadADoubleNewline = endsWithDoubleNewline;                  return string.Format("<li>{0}</li>\n"' item);              };
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,CodeSpanEvaluator,The following statement contains a magic number: string span = match.Groups[2].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,handleTrailingParens,The following statement contains a magic number: var protocol = match.Groups[2].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,handleTrailingParens,The following statement contains a magic number: var link = match.Groups[3].Value;
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,EncodeEmailAddress,The following statement contains a magic number: var sb = new StringBuilder(addr.Length * 5);
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,EncodeEmailAddress,The following statement contains a magic number: foreach (char c in addr)              {                  r = rand.Next(1' 100);                  if ((r > 90 || c == ':') && c != '@')                      sb.Append(c);                         // m                  else if (r < 45)                      sb.AppendFormat("&#x{0:x};"' (int)c); // &#x6D                  else                      sb.AppendFormat("&#{0};"' (int)c);    // &#109              }
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,EncodeEmailAddress,The following statement contains a magic number: foreach (char c in addr)              {                  r = rand.Next(1' 100);                  if ((r > 90 || c == ':') && c != '@')                      sb.Append(c);                         // m                  else if (r < 45)                      sb.AppendFormat("&#x{0:x};"' (int)c); // &#x6D                  else                      sb.AppendFormat("&#{0};"' (int)c);    // &#109              }
Magic Number,MarkdownSharp,Markdown,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\MarkdownSharp.cs,EncodeEmailAddress,The following statement contains a magic number: foreach (char c in addr)              {                  r = rand.Next(1' 100);                  if ((r > 90 || c == ':') && c != '@')                      sb.Append(c);                         // m                  else if (r < 45)                      sb.AppendFormat("&#x{0:x};"' (int)c); // &#x6D                  else                      sb.AppendFormat("&#{0};"' (int)c);    // &#109              }
Magic Number,Squirrel.Shell,ShellLink,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,getIcon,The following statement contains a magic number: StringBuilder iconPath = new StringBuilder(260' 260);
Magic Number,Squirrel.Shell,ShellLink,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,getIcon,The following statement contains a magic number: StringBuilder iconPath = new StringBuilder(260' 260);
Magic Number,Squirrel.Shell,ShellLink,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,Open,The following statement contains a magic number: if ((resolveFlags & EShellLinkResolveFlags.SLR_NO_UI)                  == EShellLinkResolveFlags.SLR_NO_UI)              {                  flags = (uint)((int)resolveFlags | (timeOut << 16));              }              else              {                  flags = (uint)resolveFlags;              }
Magic Number,Squirrel.Shell,PropVariant,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,FromString,The following statement contains a magic number: var pv = new PropVariant() {                      variantType = 31'  // VT_LPWSTR                      pointerValue = Marshal.StringToCoTaskMemUni(str)'                  };
Magic Number,Squirrel.Shell,FileIcon,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,GetInfo,The following statement contains a magic number: if (ret != IntPtr.Zero)              {                  if (shfi.hIcon != IntPtr.Zero)                  {                      fileIcon = System.Drawing.Icon.FromHandle(shfi.hIcon);                      // Now owned by the GDI+ object                      //DestroyIcon(shfi.hIcon);                  }                  typeName = shfi.szTypeName;                  displayName = shfi.szDisplayName;              }              else              {                  int err = GetLastError();                  Console.WriteLine("Error {0}"' err);                  string txtS = new string('\0'' 256);                  int len = FormatMessage(                      FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS'                      IntPtr.Zero' err' 0' txtS' 256' IntPtr.Zero);                  Console.WriteLine("Len {0} text {1}"' len' txtS);                    // throw exception              }
Magic Number,Squirrel.Shell,FileIcon,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\ShellFile.cs,GetInfo,The following statement contains a magic number: if (ret != IntPtr.Zero)              {                  if (shfi.hIcon != IntPtr.Zero)                  {                      fileIcon = System.Drawing.Icon.FromHandle(shfi.hIcon);                      // Now owned by the GDI+ object                      //DestroyIcon(shfi.hIcon);                  }                  typeName = shfi.szTypeName;                  displayName = shfi.szDisplayName;              }              else              {                  int err = GetLastError();                  Console.WriteLine("Error {0}"' err);                  string txtS = new string('\0'' 256);                  int len = FormatMessage(                      FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS'                      IntPtr.Zero' err' 0' txtS' 256' IntPtr.Zero);                  Console.WriteLine("Len {0} text {1}"' len' txtS);                    // throw exception              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SimpleJson,The following statement contains a magic number: EscapeTable = new char[93];
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ConvertFromUtf32,The following statement contains a magic number: return new string(new char[] { (char)((utf32 >> 10) + 0xD800)' (char)(utf32 % 0x0400 + 0xDC00) });
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SimpleJson,The following statement contains a magic number: EscapeTable = new char[93];
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ConvertFromUtf32,The following statement contains a magic number: return new string(new char[] { (char)((utf32 >> 10) + 0xD800)' (char)(utf32 % 0x0400 + 0xDC00) });
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,SimpleJson,The following statement contains a magic number: EscapeTable = new char[93];
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ConvertFromUtf32,The following statement contains a magic number: return new string(new char[] { (char)((utf32 >> 10) + 0xD800)' (char)(utf32 % 0x0400 + 0xDC00) });
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Missing Default,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,LogIfThrows,The following switch statement is missing a default case: switch (level) {                  case LogLevel.Debug:                      This.DebugException(message ?? ""' ex);                      break;                  case LogLevel.Info:                      This.InfoException(message ?? ""' ex);                      break;                  case LogLevel.Warn:                      This.WarnException(message ?? ""' ex);                      break;                  case LogLevel.Error:                      This.ErrorException(message ?? ""' ex);                      break;                  }
Missing Default,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,LogIfThrows,The following switch statement is missing a default case: switch (level) {                  case LogLevel.Debug:                      This.DebugException(message ?? ""' ex);                      break;                  case LogLevel.Info:                      This.InfoException(message ?? ""' ex);                      break;                  case LogLevel.Warn:                      This.WarnException(message ?? ""' ex);                      break;                  case LogLevel.Error:                      This.ErrorException(message ?? ""' ex);                      break;                  }
Missing Default,Squirrel,Utility,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\Utility.cs,LogIfThrows,The following switch statement is missing a default case: switch (level) {                  case LogLevel.Debug:                      This.DebugException(message ?? ""' ex);                      break;                  case LogLevel.Info:                      This.InfoException(message ?? ""' ex);                      break;                  case LogLevel.Warn:                      This.WarnException(message ?? ""' ex);                      break;                  case LogLevel.Error:                      This.ErrorException(message ?? ""' ex);                      break;                  }
Missing Default,Squirrel,ApplyReleasesImpl,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\UpdateManager.ApplyReleases.cs,getLinkTarget,The following switch statement is missing a default case: switch (location) {                  case ShortcutLocation.Desktop:                      dir = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);                      break;                  case ShortcutLocation.StartMenu:                      dir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.StartMenu)' "Programs"' applicationName);                      break;                  case ShortcutLocation.Startup:                      dir = Environment.GetFolderPath (Environment.SpecialFolder.Startup);                      break;                  case ShortcutLocation.AppRoot:                      dir = rootAppDirectory;                      break;                  }
Missing Default,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
Missing Default,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,Squirrel.Json,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
Missing Default,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,Reflection,SimpleJson,C:\repos\Squirrel_Squirrel.Windows\src\Squirrel\SimpleJson\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
