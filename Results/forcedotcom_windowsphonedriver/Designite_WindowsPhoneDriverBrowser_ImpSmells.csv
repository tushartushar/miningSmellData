Implementation smell,Namespace,Class,File,Method,Description
Long Method,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The method has 124 lines of code.
Long Method,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The method has 180 lines of code.
Complex Method,WindowsPhoneDriverBrowser.CommandHandlers,AddCookieCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\AddCookieCommandHandler.cs,Execute,Cyclomatic complexity of the method is 8
Complex Method,WindowsPhoneDriverBrowser.CommandHandlers,SetTimeoutCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\SetTimeoutCommandHandler.cs,Execute,Cyclomatic complexity of the method is 12
Complex Method,WindowsPhoneDriverBrowser.CommandHandlers,FindChildElementsCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindChildElementsCommandHandler.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,WindowsPhoneDriverBrowser.CommandHandlers,FindChildElementCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindChildElementCommandHandler.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,WindowsPhoneDriverBrowser.CommandHandlers,FindElementsCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindElementsCommandHandler.cs,Execute,Cyclomatic complexity of the method is 8
Complex Method,WindowsPhoneDriverBrowser.CommandHandlers,FindElementCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindElementCommandHandler.cs,Execute,Cyclomatic complexity of the method is 8
Complex Method,WindowsPhoneDriverBrowser.CommandHandlers,GoToUrlCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GoToUrlCommandHandler.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,Cyclomatic complexity of the method is 20
Complex Method,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,Cyclomatic complexity of the method is 10
Long Statement,WindowsPhoneDriverBrowser,Command,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\Command.cs,Execute,The length of the statement  "		string errorMessage = string.Format (CultureInfo.InvariantCulture' "Unexpected exception for command {0} [{1}]: {2}"' this.commandName' ex.GetType ().ToString ()' ex.Message); " is 175.
Long Statement,WindowsPhoneDriverBrowser,CommandDispatcher,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandDispatcher.cs,GetIPAddress,The length of the statement  "		if (hostName.IPInformation != null && (hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 71 || hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 6)) { " is 168.
Long Statement,WindowsPhoneDriverBrowser,CommandHandlerFactory,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlerFactory.cs,PopulateCommandHandlers,The length of the statement  "	this.handlers.Add (DriverCommand.GetElementLocationOnceScrolledIntoView' new GetElementLocationInViewCommandHandler ()); " is 120.
Long Statement,WindowsPhoneDriverBrowser,MainPage,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\MainPage.xaml.cs,DispatcherDataReceived,The length of the statement  "		string memoryUsage = string.Format (CultureInfo.InvariantCulture' "Mem: {0}/{1}"' FormatMemoryValue (DeviceStatus.ApplicationPeakMemoryUsage)' FormatMemoryValue (DeviceStatus.ApplicationMemoryUsageLimit)); " is 205.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,GetElementLocationInViewCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GetElementLocationInViewCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.GetTopLeftCoordinates' element' environment.CreateFrameObject ()); " is 129.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,MouseButtonUpCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\MouseButtonUpCommandHandler.cs,Execute,The length of the statement  "	// string result = this.EvaluateAtom(environment' WebDriverAtoms.MouseUp' button' environment.MouseState' environment.CreateFrameObject()); " is 139.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,MouseButtonUpCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\MouseButtonUpCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.MouseUp' environment.MouseState' environment.CreateFrameObject ()); " is 130.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,MouseButtonDownCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\MouseButtonDownCommandHandler.cs,Execute,The length of the statement  "	// string result = this.EvaluateAtom(environment' WebDriverAtoms.MouseDown' button' environment.MouseState' environment.CreateFrameObject()); " is 141.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,MouseButtonDownCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\MouseButtonDownCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.MouseDown' environment.MouseState' environment.CreateFrameObject ()); " is 132.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,MouseDoubleClickCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\MouseDoubleClickCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.MouseDoubleClick' environment.MouseState' environment.CreateFrameObject ()); " is 139.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,MouseMoveCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\MouseMoveCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.MouseMove' element' offsetX' offsetY' environment.MouseState' environment.CreateFrameObject ()); " is 159.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,MouseClickCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\MouseClickCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.MouseClick' button' environment.MouseState' environment.CreateFrameObject ()); " is 141.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,ExecuteAsyncScriptCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\ExecuteAsyncScriptCommandHandler.cs,Execute,The length of the statement  "	argumentString = string.Format (CultureInfo.InvariantCulture' "{0}' {1}' {2}"' argumentString' callback' JsonConvert.SerializeObject (environment.CreateFrameObject ())); " is 169.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,ExecuteAsyncScriptCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\ExecuteAsyncScriptCommandHandler.cs,Execute,The length of the statement  "			result = string.Format (CultureInfo.InvariantCulture' "{{ \"status\": {2}' \"value\": {{ \"message\": \"Unexpected exception ({0}) - '{1}'\" }} }}"' ex.GetType ().ToString ()' ex.Message' WebDriverStatusCode.UnhandledError); " is 224.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,ExecuteAsyncScriptCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\ExecuteAsyncScriptCommandHandler.cs,Execute,The length of the statement  "		return Response.CreateErrorResponse (WebDriverStatusCode.UnhandledError' "Page load detected during asynchronous script execution"); " is 132.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,ExecuteAsyncScriptCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\ExecuteAsyncScriptCommandHandler.cs,WaitForAsyncScriptResult,The length of the statement  "				result = string.Format (CultureInfo.InvariantCulture' "{{ \"status\": {2}' \"value\": {{ \"message\": \"Unexpected exception ({0}) - '{1}'\" }} }}"' ex.GetType ().ToString ()' ex.Message' WebDriverStatusCode.UnhandledError); " is 224.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,CommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\CommandHandler.cs,EvaluateAtom,The length of the statement  "			result = string.Format (CultureInfo.InvariantCulture' "{{ \"status\": {2}' \"value\": {{ \"message\": \"Unexpected exception ({0}) - '{1}'\" }} }}"' ex.GetType ().ToString ()' ex.Message' WebDriverStatusCode.UnhandledError); " is 224.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,SendKeysToActiveElementCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\SendKeysToActiveElementCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.SendKeysToActiveElement' keysAsString' environment.KeyboardState' environment.CreateFrameObject ()); " is 163.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,SetTimeoutCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\SetTimeoutCommandHandler.cs,Execute,The length of the statement  "		return Response.CreateErrorResponse (WebDriverStatusCode.UnhandledError' string.Format (CultureInfo.InvariantCulture' "'{0}' is not a valid timeout type"' timeoutType.ToString ())); " is 181.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,ExecuteScriptCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\ExecuteScriptCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.ExecuteScript' script' args' environment.CreateFrameObject ()); " is 126.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,SwitchToFrameCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\SwitchToFrameCommandHandler.cs,Execute,The length of the statement  "			string errorMessage = string.Format (CultureInfo.InvariantCulture' "No frame found for criteria {0}"' frameIdentifier.ToString ()); " is 131.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,GetTitleCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GetTitleCommandHandler.cs,Execute,The length of the statement  "	string title = this.EvaluateAtom (environment' "function() { if(window && window.top && window.top.document) { return window.top.document.title; } return ''; }"); " is 162.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,FindChildElementsCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindChildElementsCommandHandler.cs,Execute,The length of the statement  "		result = this.EvaluateAtom (environment' WebDriverAtoms.FindElements' mechanism' criteria' element' environment.CreateFrameObject ()); " is 134.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,FindChildElementCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindChildElementCommandHandler.cs,Execute,The length of the statement  "		string result = this.EvaluateAtom (environment' WebDriverAtoms.FindElement' mechanism' criteria' element' environment.CreateFrameObject ()); " is 140.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,FindChildElementCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindChildElementCommandHandler.cs,Execute,The length of the statement  "	string errorMessage = string.Format (CultureInfo.InvariantCulture' "No element found for {0} == '{1}'"' mechanism.ToString ()' criteria.ToString ()); " is 149.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,FindElementsCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindElementsCommandHandler.cs,Execute,The length of the statement  "		string result = this.EvaluateAtom (environment' WebDriverAtoms.FindElements' mechanism' criteria' null' environment.CreateFrameObject ()); " is 138.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,GetElementCssPropertyValueCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GetElementCssPropertyValueCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.GetValueOfCssProperty' element' propertyName' environment.CreateFrameObject ()); " is 143.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,GetElementLocationCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GetElementLocationCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.GetTopLeftCoordinates' element' environment.CreateFrameObject ()); " is 129.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,GetElementAttributeValueCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GetElementAttributeValueCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.GetAttributeValue' element' attributeName' environment.CreateFrameObject ()); " is 140.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,SendKeysCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\SendKeysCommandHandler.cs,Execute,The length of the statement  "	string result = this.EvaluateAtom (environment' WebDriverAtoms.Type' element' keysAsString' environment.CreateFrameObject ()); " is 126.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,FindElementCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindElementCommandHandler.cs,Execute,The length of the statement  "		string result = this.EvaluateAtom (environment' WebDriverAtoms.FindElement' mechanism' criteria' null' environment.CreateFrameObject ()); " is 137.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,FindElementCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\FindElementCommandHandler.cs,Execute,The length of the statement  "	string errorMessage = string.Format (CultureInfo.InvariantCulture' "No element found for {0} == '{1}'"' mechanism.ToString ()' criteria.ToString ()); " is 149.
Long Statement,WindowsPhoneDriverBrowser.CommandHandlers,GoToUrlCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GoToUrlCommandHandler.cs,Execute,The length of the statement  "		return Response.CreateErrorResponse (WebDriverStatusCode.UnhandledError' string.Format (CultureInfo.InvariantCulture' "Could not create valie URL from {0}"' url.ToString ())); " is 175.
Long Statement,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The length of the statement  "		// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it. " is 124.
Long Statement,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The length of the statement  "		// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different. " is 121.
Complex Conditional,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The conditional expression  "red == 4 || green == 4 || blue == 4 || trans == 4"  is complex.
Magic Number,WindowsPhoneDriverBrowser,CommandDispatcher,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandDispatcher.cs,GetIPAddress,The following statement contains a magic number: foreach (var hostName in hostNames) {  	if (hostName.IPInformation != null && (hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 71 || hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 6)) {  		string hostDisplayName = hostName.DisplayName;  		addresses.Add (hostDisplayName);  	}  }  
Magic Number,WindowsPhoneDriverBrowser,CommandDispatcher,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandDispatcher.cs,GetIPAddress,The following statement contains a magic number: foreach (var hostName in hostNames) {  	if (hostName.IPInformation != null && (hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 71 || hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 6)) {  		string hostDisplayName = hostName.DisplayName;  		addresses.Add (hostDisplayName);  	}  }  
Magic Number,WindowsPhoneDriverBrowser,CommandDispatcher,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandDispatcher.cs,GetIPAddress,The following statement contains a magic number: if (hostName.IPInformation != null && (hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 71 || hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 6)) {  	string hostDisplayName = hostName.DisplayName;  	addresses.Add (hostDisplayName);  }  
Magic Number,WindowsPhoneDriverBrowser,CommandDispatcher,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandDispatcher.cs,GetIPAddress,The following statement contains a magic number: if (hostName.IPInformation != null && (hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 71 || hostName.IPInformation.NetworkAdapter.IanaInterfaceType == 6)) {  	string hostDisplayName = hostName.DisplayName;  	addresses.Add (hostDisplayName);  }  
Magic Number,WindowsPhoneDriverBrowser,CommandEnvironment,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandEnvironment.cs,BrowserScriptNotifyEventHandler,The following statement contains a magic number: if (!this.isBlocked) {  	string[] valueParts = e.Value.Split (new char[] {  		':'  	}' 2);  	this.alertType = valueParts [0];  	this.alertText = valueParts [1];  	this.isBlocked = true;  }  else {  	this.ClearAlertStatus ();  }  
Magic Number,WindowsPhoneDriverBrowser,MainPage,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\MainPage.xaml.cs,FormatMemoryValue,The following statement contains a magic number: if (valueInBytes >= 1024 * 1024) {  	double valueInMb = valueInBytes / (1024.0 * 1024.0);  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} MB"' valueInMb);  }  else {  	double valueInKb = valueInBytes / 1024.0;  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} KB"' valueInKb);  }  
Magic Number,WindowsPhoneDriverBrowser,MainPage,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\MainPage.xaml.cs,FormatMemoryValue,The following statement contains a magic number: if (valueInBytes >= 1024 * 1024) {  	double valueInMb = valueInBytes / (1024.0 * 1024.0);  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} MB"' valueInMb);  }  else {  	double valueInKb = valueInBytes / 1024.0;  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} KB"' valueInKb);  }  
Magic Number,WindowsPhoneDriverBrowser,MainPage,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\MainPage.xaml.cs,FormatMemoryValue,The following statement contains a magic number: if (valueInBytes >= 1024 * 1024) {  	double valueInMb = valueInBytes / (1024.0 * 1024.0);  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} MB"' valueInMb);  }  else {  	double valueInKb = valueInBytes / 1024.0;  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} KB"' valueInKb);  }  
Magic Number,WindowsPhoneDriverBrowser,MainPage,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\MainPage.xaml.cs,FormatMemoryValue,The following statement contains a magic number: if (valueInBytes >= 1024 * 1024) {  	double valueInMb = valueInBytes / (1024.0 * 1024.0);  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} MB"' valueInMb);  }  else {  	double valueInKb = valueInBytes / 1024.0;  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} KB"' valueInKb);  }  
Magic Number,WindowsPhoneDriverBrowser,MainPage,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\MainPage.xaml.cs,FormatMemoryValue,The following statement contains a magic number: if (valueInBytes >= 1024 * 1024) {  	double valueInMb = valueInBytes / (1024.0 * 1024.0);  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} MB"' valueInMb);  }  else {  	double valueInKb = valueInBytes / 1024.0;  	valueString = string.Format (CultureInfo.InvariantCulture' "{0:F2} KB"' valueInKb);  }  
Magic Number,WindowsPhoneDriverBrowser,Response,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\Response.cs,CreateMissingParametersResponse,The following statement contains a magic number: response.Status = 400;  
Magic Number,WindowsPhoneDriverBrowser,WebBrowserNavigationMonitor,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\WebBrowserNavigationMonitor.cs,MonitorNavigation,The following statement contains a magic number: while (ignoreTimeout || DateTime.Now < endTime) {  	if ((this.isNavigated && this.isLoadCompleted) || this.isNavigationError) {  		timedOut = false;  		break;  	}  	System.Threading.Thread.Sleep (100);  }  
Magic Number,WindowsPhoneDriverBrowser,WebBrowserNavigationMonitor,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\WebBrowserNavigationMonitor.cs,MonitorNavigation,The following statement contains a magic number: System.Threading.Thread.Sleep (100);  
Magic Number,WindowsPhoneDriverBrowser.CommandHandlers,ClickElementCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\ClickElementCommandHandler.cs,Execute,The following statement contains a magic number: this.SetAtomExecutionTimeout (TimeSpan.FromMilliseconds (100));  
Magic Number,WindowsPhoneDriverBrowser.CommandHandlers,AddCookieCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\AddCookieCommandHandler.cs,Execute,The following statement contains a magic number: if (cookie != null) {  	StringBuilder cookieBuilder = new StringBuilder ();  	cookieBuilder.AppendFormat (CultureInfo.InvariantCulture' "{0}={1}; "' cookie ["name"]' cookie ["value"]);  	if (cookie.ContainsKey ("secure")) {  		bool isSecure = Convert.ToBoolean (cookie ["secure"]' CultureInfo.InvariantCulture);  		if (isSecure) {  			cookieBuilder.Append ("secure; ");  		}  	}  	if (cookie.ContainsKey ("expiry")) {  		double expirationOffset = Convert.ToDouble (cookie ["expiry"]' CultureInfo.InvariantCulture);  		DateTime expires = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (expirationOffset);  		cookieBuilder.AppendFormat (CultureInfo.InvariantCulture' "expires={0:ddd' d MMM yyyy HH:mm:ss} GMT; "' expires);  	}  	if (cookie.ContainsKey ("path")) {  		cookieBuilder.AppendFormat (CultureInfo.InvariantCulture' "path={0}; "' cookie ["path"].ToString ());  	}  	if (cookie.ContainsKey ("domain")) {  		cookieBuilder.AppendFormat (CultureInfo.InvariantCulture' "domain={0}; "' cookie ["domain"].ToString ());  	}  	this.EvaluateAtom (environment' "function() { document.cookie = '" + cookieBuilder.ToString () + "'; }");  }  
Magic Number,WindowsPhoneDriverBrowser.CommandHandlers,AddCookieCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\AddCookieCommandHandler.cs,Execute,The following statement contains a magic number: if (cookie.ContainsKey ("expiry")) {  	double expirationOffset = Convert.ToDouble (cookie ["expiry"]' CultureInfo.InvariantCulture);  	DateTime expires = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds (expirationOffset);  	cookieBuilder.AppendFormat (CultureInfo.InvariantCulture' "expires={0:ddd' d MMM yyyy HH:mm:ss} GMT; "' expires);  }  
Magic Number,WindowsPhoneDriverBrowser.CommandHandlers,GetAllCookiesCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GetAllCookiesCommandHandler.cs,Execute,The following statement contains a magic number: if (cookies != null) {  	foreach (Cookie currentCookie in cookies) {  		Dictionary<string' object> cookie = new Dictionary<string' object> ();  		cookie ["name"] = currentCookie.Name;  		cookie ["value"] = currentCookie.Value;  		cookie ["secure"] = currentCookie.Secure;  		if (!string.IsNullOrEmpty (currentCookie.Path)) {  			cookie ["path"] = currentCookie.Path;  		}  		if (!string.IsNullOrEmpty (currentCookie.Domain)) {  			cookie ["domain"] = currentCookie.Domain;  		}  		DateTime referenceDate = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  		double expirationSeconds = currentCookie.Expires.Subtract (referenceDate).TotalSeconds;  		if (expirationSeconds > 0) {  			cookie ["expiry"] = expirationSeconds;  		}  		cookieList.Add (cookie);  	}  }  
Magic Number,WindowsPhoneDriverBrowser.CommandHandlers,GetAllCookiesCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GetAllCookiesCommandHandler.cs,Execute,The following statement contains a magic number: foreach (Cookie currentCookie in cookies) {  	Dictionary<string' object> cookie = new Dictionary<string' object> ();  	cookie ["name"] = currentCookie.Name;  	cookie ["value"] = currentCookie.Value;  	cookie ["secure"] = currentCookie.Secure;  	if (!string.IsNullOrEmpty (currentCookie.Path)) {  		cookie ["path"] = currentCookie.Path;  	}  	if (!string.IsNullOrEmpty (currentCookie.Domain)) {  		cookie ["domain"] = currentCookie.Domain;  	}  	DateTime referenceDate = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  	double expirationSeconds = currentCookie.Expires.Subtract (referenceDate).TotalSeconds;  	if (expirationSeconds > 0) {  		cookie ["expiry"] = expirationSeconds;  	}  	cookieList.Add (cookie);  }  
Magic Number,WindowsPhoneDriverBrowser.CommandHandlers,GoToUrlCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GoToUrlCommandHandler.cs,Execute,The following statement contains a magic number: if (timeoutInMilliseconds < 0) {  	timeoutInMilliseconds = 15000;  }  else {  	// If a page load timeout has been set' don't retry the page load.  	this.retryCount = 1;  }  
Magic Number,WindowsPhoneDriverBrowser.CommandHandlers,GoToUrlCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\GoToUrlCommandHandler.cs,Execute,The following statement contains a magic number: timeoutInMilliseconds = 15000;  
Magic Number,WindowsPhoneDriverBrowser.CommandHandlers,NotImplementedCommandHandler,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\CommandHandlers\NotImplementedCommandHandler.cs,Execute,The following statement contains a magic number: return Response.CreateErrorResponse (501' errorMessage);  
Magic Number,ToolStackCRCLib,CRC32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,makeCRCTable,The following statement contains a magic number: for (n = 0; n < 256; n++) {  	c = n;  	for (k = 0; k < 8; k++) {  		if ((c & (uint)1) == 1)  			c = (uint)0xedb88320L ^ (c >> 1);  		else  			c = c >> 1;  	}  	crcTable [n] = c;  }  
Magic Number,ToolStackCRCLib,CRC32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,makeCRCTable,The following statement contains a magic number: for (n = 0; n < 256; n++) {  	c = n;  	for (k = 0; k < 8; k++) {  		if ((c & (uint)1) == 1)  			c = (uint)0xedb88320L ^ (c >> 1);  		else  			c = c >> 1;  	}  	crcTable [n] = c;  }  
Magic Number,ToolStackCRCLib,CRC32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,makeCRCTable,The following statement contains a magic number: for (k = 0; k < 8; k++) {  	if ((c & (uint)1) == 1)  		c = (uint)0xedb88320L ^ (c >> 1);  	else  		c = c >> 1;  }  
Magic Number,ToolStackCRCLib,CRC32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,crc,The following statement contains a magic number: for (n = offset; n < offset + len; n++) {  	c = crcTable [(c ^ buf [n]) & 0xff] ^ (c >> 8);  }  
Magic Number,ToolStackCRCLib,CRC32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,crc,The following statement contains a magic number: c = crcTable [(c ^ buf [n]) & 0xff] ^ (c >> 8);  
Magic Number,ToolStackCRCLib,CRC32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,addToCRC,The following statement contains a magic number: for (n = offset; n < offset + len; n++) {  	c = crcTable [(c ^ buf [n]) & (uint)0xff] ^ (c >> 8);  }  
Magic Number,ToolStackCRCLib,CRC32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,addToCRC,The following statement contains a magic number: c = crcTable [(c ^ buf [n]) & (uint)0xff] ^ (c >> 8);  
Magic Number,ToolStackCRCLib,Adler32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,adler,The following statement contains a magic number: return (AdlerB << 16) | AdlerA;  
Magic Number,ToolStackCRCLib,Adler32,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackCRCLib.cs,adler,The following statement contains a magic number: return (b << 16) | a;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: TestWB.Render (blueRectangle' new TranslateTransform () {  	X = 2'  	Y = 0  });  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == greenBytes [2] && blueBytes [2] == greenBytes [2]) {  	trans = 2;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == greenBytes [2] && blueBytes [2] == greenBytes [2]) {  	trans = 2;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == greenBytes [2] && blueBytes [2] == greenBytes [2]) {  	trans = 2;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == greenBytes [2] && blueBytes [2] == greenBytes [2]) {  	trans = 2;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == greenBytes [2] && blueBytes [2] == greenBytes [2]) {  	trans = 2;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: trans = 2;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [3] == greenBytes [3] && blueBytes [3] == greenBytes [3]) {  	trans = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [3] == greenBytes [3] && blueBytes [3] == greenBytes [3]) {  	trans = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [3] == greenBytes [3] && blueBytes [3] == greenBytes [3]) {  	trans = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [3] == greenBytes [3] && blueBytes [3] == greenBytes [3]) {  	trans = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [3] == greenBytes [3] && blueBytes [3] == greenBytes [3]) {  	trans = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: trans = 3;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (trans != 4) {  	// now set all the alpha channel's to zero to get them out of the way.  	redBytes [trans] = 0;  	greenBytes [trans] = 0;  	blueBytes [trans] = 0;  	// Find the red channel.  	if (redBytes [0] == 255) {  		red = 0;  	}  	else if (redBytes [1] == 255) {  		red = 1;  	}  	else if (redBytes [2] == 255) {  		red = 2;  	}  	else if (redBytes [3] == 255) {  		red = 3;  	}  	// Find the green channel' note that Colors.Green is not dark green' but light green so use 128 instead of 255 to detect it.  	if (greenBytes [0] == 128) {  		green = 0;  	}  	else if (greenBytes [1] == 128) {  		green = 1;  	}  	else if (greenBytes [2] == 128) {  		green = 2;  	}  	else if (greenBytes [3] == 128) {  		green = 3;  	}  	// Find the blue channel.  	if (blueBytes [0] == 255) {  		blue = 0;  	}  	else if (blueBytes [1] == 255) {  		blue = 1;  	}  	else if (blueBytes [2] == 255) {  		blue = 2;  	}  	else if (blueBytes [3] == 255) {  		blue = 3;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [0] == 255) {  	red = 0;  }  else if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [0] == 255) {  	red = 0;  }  else if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [0] == 255) {  	red = 0;  }  else if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [0] == 255) {  	red = 0;  }  else if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [0] == 255) {  	red = 0;  }  else if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [0] == 255) {  	red = 0;  }  else if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [0] == 255) {  	red = 0;  }  else if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [0] == 255) {  	red = 0;  }  else if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [1] == 255) {  	red = 1;  }  else if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [2] == 255) {  	red = 2;  }  else if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: red = 2;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (redBytes [3] == 255) {  	red = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: red = 3;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [0] == 128) {  	green = 0;  }  else if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [0] == 128) {  	green = 0;  }  else if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [0] == 128) {  	green = 0;  }  else if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [0] == 128) {  	green = 0;  }  else if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [0] == 128) {  	green = 0;  }  else if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [0] == 128) {  	green = 0;  }  else if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [0] == 128) {  	green = 0;  }  else if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [0] == 128) {  	green = 0;  }  else if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [1] == 128) {  	green = 1;  }  else if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [2] == 128) {  	green = 2;  }  else if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: green = 2;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (greenBytes [3] == 128) {  	green = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: green = 3;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [0] == 255) {  	blue = 0;  }  else if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [0] == 255) {  	blue = 0;  }  else if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [0] == 255) {  	blue = 0;  }  else if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [0] == 255) {  	blue = 0;  }  else if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [0] == 255) {  	blue = 0;  }  else if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [0] == 255) {  	blue = 0;  }  else if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [0] == 255) {  	blue = 0;  }  else if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [0] == 255) {  	blue = 0;  }  else if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [1] == 255) {  	blue = 1;  }  else if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [2] == 255) {  	blue = 2;  }  else if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: blue = 2;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (blueBytes [3] == 255) {  	blue = 3;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: blue = 3;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (red == 4 || green == 4 || blue == 4 || trans == 4) {  	WBByteOrder = new int[] {  		2'  		1'  		0'  		3  	};  }  else {  	WBBODetectionRun = true;  	WBByteOrder = new int[] {  		red'  		green'  		blue'  		trans  	};  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (red == 4 || green == 4 || blue == 4 || trans == 4) {  	WBByteOrder = new int[] {  		2'  		1'  		0'  		3  	};  }  else {  	WBBODetectionRun = true;  	WBByteOrder = new int[] {  		red'  		green'  		blue'  		trans  	};  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (red == 4 || green == 4 || blue == 4 || trans == 4) {  	WBByteOrder = new int[] {  		2'  		1'  		0'  		3  	};  }  else {  	WBBODetectionRun = true;  	WBByteOrder = new int[] {  		red'  		green'  		blue'  		trans  	};  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (red == 4 || green == 4 || blue == 4 || trans == 4) {  	WBByteOrder = new int[] {  		2'  		1'  		0'  		3  	};  }  else {  	WBBODetectionRun = true;  	WBByteOrder = new int[] {  		red'  		green'  		blue'  		trans  	};  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (red == 4 || green == 4 || blue == 4 || trans == 4) {  	WBByteOrder = new int[] {  		2'  		1'  		0'  		3  	};  }  else {  	WBBODetectionRun = true;  	WBByteOrder = new int[] {  		red'  		green'  		blue'  		trans  	};  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: if (red == 4 || green == 4 || blue == 4 || trans == 4) {  	WBByteOrder = new int[] {  		2'  		1'  		0'  		3  	};  }  else {  	WBBODetectionRun = true;  	WBByteOrder = new int[] {  		red'  		green'  		blue'  		trans  	};  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: WBByteOrder = new int[] {  	2'  	1'  	0'  	3  };  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,DetectWBByteOrder,The following statement contains a magic number: WBByteOrder = new int[] {  	2'  	1'  	0'  	3  };  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WritePNG,The following statement contains a magic number: stream.Write (new byte[] {  	0x89'  	0x50'  	0x4E'  	0x47'  	0x0D'  	0x0A'  	0x1A'  	0x0A  }' 0' 8);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WritePNG,The following statement contains a magic number: header.ColorType = 6;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WritePNG,The following statement contains a magic number: header.BitDepth = 8;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WritePhysicsChunk,The following statement contains a magic number: WriteInteger (chunkData' 4' dpmY);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WritePhysicsChunk,The following statement contains a magic number: chunkData [8] = 1;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: if (IsWritingGamma) {  	int gammeValue = (int)(Gamma * 100000f);  	byte[] fourByteData = new byte[4];  	byte[] size = BitConverter.GetBytes (gammeValue);  	fourByteData [0] = size [3];  	fourByteData [1] = size [2];  	fourByteData [2] = size [1];  	fourByteData [3] = size [0];  	WriteChunk (PngChunkTypes.Gamma' fourByteData);  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: if (IsWritingGamma) {  	int gammeValue = (int)(Gamma * 100000f);  	byte[] fourByteData = new byte[4];  	byte[] size = BitConverter.GetBytes (gammeValue);  	fourByteData [0] = size [3];  	fourByteData [1] = size [2];  	fourByteData [2] = size [1];  	fourByteData [3] = size [0];  	WriteChunk (PngChunkTypes.Gamma' fourByteData);  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: if (IsWritingGamma) {  	int gammeValue = (int)(Gamma * 100000f);  	byte[] fourByteData = new byte[4];  	byte[] size = BitConverter.GetBytes (gammeValue);  	fourByteData [0] = size [3];  	fourByteData [1] = size [2];  	fourByteData [2] = size [1];  	fourByteData [3] = size [0];  	WriteChunk (PngChunkTypes.Gamma' fourByteData);  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: if (IsWritingGamma) {  	int gammeValue = (int)(Gamma * 100000f);  	byte[] fourByteData = new byte[4];  	byte[] size = BitConverter.GetBytes (gammeValue);  	fourByteData [0] = size [3];  	fourByteData [1] = size [2];  	fourByteData [2] = size [1];  	fourByteData [3] = size [0];  	WriteChunk (PngChunkTypes.Gamma' fourByteData);  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: if (IsWritingGamma) {  	int gammeValue = (int)(Gamma * 100000f);  	byte[] fourByteData = new byte[4];  	byte[] size = BitConverter.GetBytes (gammeValue);  	fourByteData [0] = size [3];  	fourByteData [1] = size [2];  	fourByteData [2] = size [1];  	fourByteData [3] = size [0];  	WriteChunk (PngChunkTypes.Gamma' fourByteData);  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: fourByteData [0] = size [3];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: fourByteData [1] = size [2];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: fourByteData [2] = size [1];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteGammaChunk,The following statement contains a magic number: fourByteData [3] = size [0];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: pngLength = 11 + ((blockCount - 1) * (5 + MaxBlockSize)) + lastBlockSize;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: pngLength = 11 + ((blockCount - 1) * (5 + MaxBlockSize)) + lastBlockSize;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int y = 0; y < _image.PixelHeight; y++) {  	// This code appears twice' once here and once in the pixel byte loop (loop 3).  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.  It get executed on the first time through to setup  	// the first block but is unlikly to get executed again as it would mean the   	// block boundry is at a row boundry' which seems unlikly.  	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Set the filter byte to 0' not really required as C# initalizes the byte array to 0 by default' but here for clarity.  	data [dataPointer] = 0;  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  	// Loop thorough each pixel in the row' you have to do this as the source format and destination format may be different.  	for (int x = 0; x < _image.PixelWidth; x++) {  		// Data is in RGBA format but source may not be  		pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  		// Loop through the 4 bytes of the pixel and 'write' them to the data array.  		for (int z = 0; z < 4; z++) {  			// This is the second appearance of this code code.  			// It checks to see if we're at the boundry for the PNG block and if so writes  			// out a new block header.    			if (blockRemainder == 0) {  				// Setup a temporary byte array to store the block size in.  				byte[] tempBytes = new byte[2];  				// Increment the current block count.  				currentBlock++;  				// Figure out the current block size and if we're at the last block' write  				// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  				int length = MaxBlockSize;  				if (currentBlock == blockCount) {  					length = lastBlockSize;  					data [dataPointer] = 0x01;  				}  				else {  					data [dataPointer] = 0x00;  				}  				// Each and every time we write something to the data array' increment the pointer.  				dataPointer++;  				// Write the block length out.  				tempBytes = BitConverter.GetBytes (length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Write one's compliment of length for error checking.  				tempBytes = BitConverter.GetBytes ((ushort)~length);  				data [dataPointer + 0] = tempBytes [0];  				data [dataPointer + 1] = tempBytes [1];  				dataPointer += 2;  				// Reset the remaining block size to the next block's length.  				blockRemainder = length;  			}  			// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   			// we have the write order of bytes to store in the PNG file.  			if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  				// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    				data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  			}  			else {  				// Alpha channel or no need to unpremultiply    				data [dataPointer] = pixel [WBByteOrder [z]];  			}  			// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  			// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  			crcCode.addToAdler (data' 1' (uint)dataPointer);  			// Increment the data pointer and decrement the remain block value.  			dataPointer++;  			blockRemainder--;  		}  		// Increment where we start writting the next pixel and where we get the next pixel from.  		pixelSource++;  	}  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (blockRemainder == 0) {  	// Setup a temporary byte array to store the block size in.  	byte[] tempBytes = new byte[2];  	// Increment the current block count.  	currentBlock++;  	// Figure out the current block size and if we're at the last block' write  	// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  	int length = MaxBlockSize;  	if (currentBlock == blockCount) {  		length = lastBlockSize;  		data [dataPointer] = 0x01;  	}  	else {  		data [dataPointer] = 0x00;  	}  	// Each and every time we write something to the data array' increment the pointer.  	dataPointer++;  	// Write the block length out.  	tempBytes = BitConverter.GetBytes (length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Write one's compliment of length for error checking.  	tempBytes = BitConverter.GetBytes ((ushort)~length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Reset the remaining block size to the next block's length.  	blockRemainder = length;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (blockRemainder == 0) {  	// Setup a temporary byte array to store the block size in.  	byte[] tempBytes = new byte[2];  	// Increment the current block count.  	currentBlock++;  	// Figure out the current block size and if we're at the last block' write  	// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  	int length = MaxBlockSize;  	if (currentBlock == blockCount) {  		length = lastBlockSize;  		data [dataPointer] = 0x01;  	}  	else {  		data [dataPointer] = 0x00;  	}  	// Each and every time we write something to the data array' increment the pointer.  	dataPointer++;  	// Write the block length out.  	tempBytes = BitConverter.GetBytes (length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Write one's compliment of length for error checking.  	tempBytes = BitConverter.GetBytes ((ushort)~length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Reset the remaining block size to the next block's length.  	blockRemainder = length;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (blockRemainder == 0) {  	// Setup a temporary byte array to store the block size in.  	byte[] tempBytes = new byte[2];  	// Increment the current block count.  	currentBlock++;  	// Figure out the current block size and if we're at the last block' write  	// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  	int length = MaxBlockSize;  	if (currentBlock == blockCount) {  		length = lastBlockSize;  		data [dataPointer] = 0x01;  	}  	else {  		data [dataPointer] = 0x00;  	}  	// Each and every time we write something to the data array' increment the pointer.  	dataPointer++;  	// Write the block length out.  	tempBytes = BitConverter.GetBytes (length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Write one's compliment of length for error checking.  	tempBytes = BitConverter.GetBytes ((ushort)~length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Reset the remaining block size to the next block's length.  	blockRemainder = length;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: dataPointer += 2;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: dataPointer += 2;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int x = 0; x < _image.PixelWidth; x++) {  	// Data is in RGBA format but source may not be  	pixel = BitConverter.GetBytes (_image.Pixels [pixelSource]);  	// Loop through the 4 bytes of the pixel and 'write' them to the data array.  	for (int z = 0; z < 4; z++) {  		// This is the second appearance of this code code.  		// It checks to see if we're at the boundry for the PNG block and if so writes  		// out a new block header.    		if (blockRemainder == 0) {  			// Setup a temporary byte array to store the block size in.  			byte[] tempBytes = new byte[2];  			// Increment the current block count.  			currentBlock++;  			// Figure out the current block size and if we're at the last block' write  			// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  			int length = MaxBlockSize;  			if (currentBlock == blockCount) {  				length = lastBlockSize;  				data [dataPointer] = 0x01;  			}  			else {  				data [dataPointer] = 0x00;  			}  			// Each and every time we write something to the data array' increment the pointer.  			dataPointer++;  			// Write the block length out.  			tempBytes = BitConverter.GetBytes (length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Write one's compliment of length for error checking.  			tempBytes = BitConverter.GetBytes ((ushort)~length);  			data [dataPointer + 0] = tempBytes [0];  			data [dataPointer + 1] = tempBytes [1];  			dataPointer += 2;  			// Reset the remaining block size to the next block's length.  			blockRemainder = length;  		}  		// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   		// we have the write order of bytes to store in the PNG file.  		if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  			// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    			data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  		}  		else {  			// Alpha channel or no need to unpremultiply    			data [dataPointer] = pixel [WBByteOrder [z]];  		}  		// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  		// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  		crcCode.addToAdler (data' 1' (uint)dataPointer);  		// Increment the data pointer and decrement the remain block value.  		dataPointer++;  		blockRemainder--;  	}  	// Increment where we start writting the next pixel and where we get the next pixel from.  	pixelSource++;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: for (int z = 0; z < 4; z++) {  	// This is the second appearance of this code code.  	// It checks to see if we're at the boundry for the PNG block and if so writes  	// out a new block header.    	if (blockRemainder == 0) {  		// Setup a temporary byte array to store the block size in.  		byte[] tempBytes = new byte[2];  		// Increment the current block count.  		currentBlock++;  		// Figure out the current block size and if we're at the last block' write  		// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  		int length = MaxBlockSize;  		if (currentBlock == blockCount) {  			length = lastBlockSize;  			data [dataPointer] = 0x01;  		}  		else {  			data [dataPointer] = 0x00;  		}  		// Each and every time we write something to the data array' increment the pointer.  		dataPointer++;  		// Write the block length out.  		tempBytes = BitConverter.GetBytes (length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Write one's compliment of length for error checking.  		tempBytes = BitConverter.GetBytes ((ushort)~length);  		data [dataPointer + 0] = tempBytes [0];  		data [dataPointer + 1] = tempBytes [1];  		dataPointer += 2;  		// Reset the remaining block size to the next block's length.  		blockRemainder = length;  	}  	// Store the pixel's byte in to the data array. We use the WBByteOrder array to ensure   	// we have the write order of bytes to store in the PNG file.  	if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  		// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    		data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  	}  	else {  		// Alpha channel or no need to unpremultiply    		data [dataPointer] = pixel [WBByteOrder [z]];  	}  	// Add the current byte to the running Adler32 value' note we ONLY add the filter byte and the pixel bytes to the  	// Adler32 CRC' all other header and block header bytes are execluded from the CRC.  	crcCode.addToAdler (data' 1' (uint)dataPointer);  	// Increment the data pointer and decrement the remain block value.  	dataPointer++;  	blockRemainder--;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (blockRemainder == 0) {  	// Setup a temporary byte array to store the block size in.  	byte[] tempBytes = new byte[2];  	// Increment the current block count.  	currentBlock++;  	// Figure out the current block size and if we're at the last block' write  	// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  	int length = MaxBlockSize;  	if (currentBlock == blockCount) {  		length = lastBlockSize;  		data [dataPointer] = 0x01;  	}  	else {  		data [dataPointer] = 0x00;  	}  	// Each and every time we write something to the data array' increment the pointer.  	dataPointer++;  	// Write the block length out.  	tempBytes = BitConverter.GetBytes (length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Write one's compliment of length for error checking.  	tempBytes = BitConverter.GetBytes ((ushort)~length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Reset the remaining block size to the next block's length.  	blockRemainder = length;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (blockRemainder == 0) {  	// Setup a temporary byte array to store the block size in.  	byte[] tempBytes = new byte[2];  	// Increment the current block count.  	currentBlock++;  	// Figure out the current block size and if we're at the last block' write  	// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  	int length = MaxBlockSize;  	if (currentBlock == blockCount) {  		length = lastBlockSize;  		data [dataPointer] = 0x01;  	}  	else {  		data [dataPointer] = 0x00;  	}  	// Each and every time we write something to the data array' increment the pointer.  	dataPointer++;  	// Write the block length out.  	tempBytes = BitConverter.GetBytes (length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Write one's compliment of length for error checking.  	tempBytes = BitConverter.GetBytes ((ushort)~length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Reset the remaining block size to the next block's length.  	blockRemainder = length;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (blockRemainder == 0) {  	// Setup a temporary byte array to store the block size in.  	byte[] tempBytes = new byte[2];  	// Increment the current block count.  	currentBlock++;  	// Figure out the current block size and if we're at the last block' write  	// out and 1 to let the zlib decompressor know.  By default' use the MaxBlockSize.  	int length = MaxBlockSize;  	if (currentBlock == blockCount) {  		length = lastBlockSize;  		data [dataPointer] = 0x01;  	}  	else {  		data [dataPointer] = 0x00;  	}  	// Each and every time we write something to the data array' increment the pointer.  	dataPointer++;  	// Write the block length out.  	tempBytes = BitConverter.GetBytes (length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Write one's compliment of length for error checking.  	tempBytes = BitConverter.GetBytes ((ushort)~length);  	data [dataPointer + 0] = tempBytes [0];  	data [dataPointer + 1] = tempBytes [1];  	dataPointer += 2;  	// Reset the remaining block size to the next block's length.  	blockRemainder = length;  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: dataPointer += 2;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: dataPointer += 2;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  	// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    	data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  }  else {  	// Alpha channel or no need to unpremultiply    	data [dataPointer] = pixel [WBByteOrder [z]];  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  	// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    	data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  }  else {  	// Alpha channel or no need to unpremultiply    	data [dataPointer] = pixel [WBByteOrder [z]];  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  	// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    	data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  }  else {  	// Alpha channel or no need to unpremultiply    	data [dataPointer] = pixel [WBByteOrder [z]];  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  	// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    	data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  }  else {  	// Alpha channel or no need to unpremultiply    	data [dataPointer] = pixel [WBByteOrder [z]];  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  	// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    	data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  }  else {  	// Alpha channel or no need to unpremultiply    	data [dataPointer] = pixel [WBByteOrder [z]];  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: if (z != 3 && pixel [WBByteOrder [3]] != 0 && pixel [WBByteOrder [3]] != 255) {  	// Calculate unmultiplied pixel value from premultiplied value (Windows Phone always uses premultiplied ARGB32)    	data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  }  else {  	// Alpha channel or no need to unpremultiply    	data [dataPointer] = pixel [WBByteOrder [z]];  }  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: data [dataPointer] = (byte)((255 * pixel [WBByteOrder [z]]) / pixel [WBByteOrder [3]]);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: data [dataPointer + 0] = pixel [3];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: data [dataPointer + 1] = pixel [2];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: data [dataPointer + 2] = pixel [1];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The following statement contains a magic number: data [dataPointer + 3] = pixel [0];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteHeaderChunk,The following statement contains a magic number: WriteInteger (chunkData' 4' header.Height);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteHeaderChunk,The following statement contains a magic number: chunkData [8] = header.BitDepth;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteHeaderChunk,The following statement contains a magic number: chunkData [9] = header.ColorType;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteHeaderChunk,The following statement contains a magic number: chunkData [10] = header.CompressionMethod;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteHeaderChunk,The following statement contains a magic number: chunkData [11] = header.FilterMethod;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteHeaderChunk,The following statement contains a magic number: chunkData [12] = header.InterlaceMethod;  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteChunk,The following statement contains a magic number: typeArray [2] = (byte)type [2];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteChunk,The following statement contains a magic number: typeArray [2] = (byte)type [2];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteChunk,The following statement contains a magic number: typeArray [3] = (byte)type [3];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteChunk,The following statement contains a magic number: typeArray [3] = (byte)type [3];  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteChunk,The following statement contains a magic number: _stream.Write (typeArray' 0' 4);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteChunk,The following statement contains a magic number: crcCode.addToCRC (typeArray' 4);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteInteger,The following statement contains a magic number: Array.Copy (buffer' 0' data' offset' 4);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteInteger,The following statement contains a magic number: stream.Write (buffer' 0' 4);  
Magic Number,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteInteger,The following statement contains a magic number: stream.Write (buffer' 0' 4);  
Duplicate Code,ToolStackPNGWriterLib,PNGWriter,C:\repos\forcedotcom_windowsphonedriver\src\WindowsPhoneDriverBrowser\PngWriter\ToolStackPNGWriterLib.cs,WriteDataChunksUncompressed,The method contains a code clone-set at the following line numbers (starting from the method definition): ((71' 100)' (118' 147))
