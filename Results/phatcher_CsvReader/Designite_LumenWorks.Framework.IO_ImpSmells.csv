Implementation smell,Namespace,Class,File,Method,Description
Long Method,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The method has 296 lines of code.
Long Method,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadNextRecord,The method has 141 lines of code.
Complex Method,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,Cyclomatic complexity of the method is 13
Complex Method,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadNextRecord,Cyclomatic complexity of the method is 15
Long Parameter List,LumenWorks.Framework.IO.Csv,CachedCsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CachedCsvReader.cs,CachedCsvReader,The method has 8 parameters. Parameters: reader' hasHeaders' delimiter' quote' escape' comment' trimmingOptions' nullValue
Long Parameter List,LumenWorks.Framework.IO.Csv,CachedCsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CachedCsvReader.cs,CachedCsvReader,The method has 9 parameters. Parameters: reader' hasHeaders' delimiter' quote' escape' comment' trimmingOptions' bufferSize' nullValue
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,CsvReader,The method has 8 parameters. Parameters: reader' hasHeaders' delimiter' quote' escape' comment' trimmingOptions' nullValue
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,CsvReader,The method has 9 parameters. Parameters: reader' hasHeaders' delimiter' quote' escape' comment' trimmingOptions' bufferSize' nullValue
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,CopyFieldToArray,The method has 5 parameters. Parameters: field' fieldOffset' destinationArray' destinationOffset' length
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,LumenWorks.Framework.IO.Csv,MalformedCsvException,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\Exceptions\MalformedCsvException.cs,MalformedCsvException,The method has 5 parameters. Parameters: rawData' currentPosition' currentRecordIndex' currentFieldIndex' innerException
Long Parameter List,LumenWorks.Framework.IO.Csv,MissingFieldCsvException,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\Exceptions\MissingFieldCsvException.cs,MissingFieldCsvException,The method has 5 parameters. Parameters: rawData' currentPosition' currentRecordIndex' currentFieldIndex' innerException
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,EnsureInitialize,The length of the statement  "            Debug.Assert(Columns.Count > 0 || (Columns.Count == 0 && (_fieldHeaderIndexes == null || _fieldHeaderIndexes.Count == 0))); " is 123.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,IsWhiteSpace,The length of the statement  "                    return (System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c) == System.Globalization.UnicodeCategory.SpaceSeparator); " is 123.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The length of the statement  "                    throw new ArgumentOutOfRangeException("field"' field' string.Format(CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' field)); " is 145.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The length of the statement  "                                else if (c == _escape && (_escape != _quote || (pos + 1 < _bufferLength && _buffer[pos + 1] == _quote) || (pos + 1 == _bufferLength && _reader.Peek() == _quote))) " is 162.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The length of the statement  "                                    HandleParseError(new MalformedCsvException(GetCurrentRawData()' _nextFieldStart' Math.Max(0' _currentRecordIndex)' index)' ref _nextFieldStart); " is 144.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The length of the statement  "                                    HandleParseError(new MalformedCsvException(GetCurrentRawData()' _nextFieldStart' Math.Max(0' _currentRecordIndex)' index)' ref _nextFieldStart); " is 144.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The length of the statement  "                                HandleParseError(new MalformedCsvException(GetCurrentRawData()' _nextFieldStart' Math.Max(0' _currentRecordIndex)' index)' ref _nextFieldStart); " is 144.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The length of the statement  "            HandleParseError(new MalformedCsvException(GetCurrentRawData()' _nextFieldStart' Math.Max(0' _currentRecordIndex)' index)' ref _nextFieldStart); " is 144.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,HandleParseError,The length of the statement  "                            throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' ExceptionMessage.ParseErrorActionInvalidInsideParseErrorEvent' e.Action)' e.Error); " is 163.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,HandleParseError,The length of the statement  "                            throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' ExceptionMessage.ParseErrorActionNotSupported' e.Action)' e.Error); " is 143.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,HandleParseError,The length of the statement  "                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' ExceptionMessage.ParseErrorActionNotSupported' _defaultParseErrorAction)' error); " is 157.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,HandleMissingField,The length of the statement  "                throw new ArgumentOutOfRangeException("fieldIndex"' fieldIndex' string.Format(CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' fieldIndex)); " is 160.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,HandleMissingField,The length of the statement  "                        HandleParseError(new MissingFieldCsvException(GetCurrentRawData()' currentPosition' Math.Max(0' _currentRecordIndex)' fieldIndex)' ref currentPosition); " is 152.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,HandleMissingField,The length of the statement  "                        throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' ExceptionMessage.MissingFieldActionNotSupported' _missingFieldAction)); " is 147.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,CopyFieldToArray,The length of the statement  "                throw new ArgumentOutOfRangeException("field"' field' string.Format(CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' field)); " is 145.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,GetFieldType,The length of the statement  "                throw new ArgumentOutOfRangeException("i"' i' string.Format(CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' i)); " is 133.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,GetName,The length of the statement  "                throw new ArgumentOutOfRangeException("i"' i' string.Format(CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' i)); " is 133.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,GetOrdinal,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' ExceptionMessage.FieldHeaderNotFound' name)' "name"); " is 125.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,Dispose,The length of the statement  "                    // Dispose-time code should also set references of all owned objects to null' after disposing them. This will allow the referenced objects to be garbage collected even if not all references to the "parent" are released. It may be a significant memory consumption win if the referenced objects are large' such as big arrays' collections' etc.  " is 341.
Complex Conditional,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The conditional expression  "c == _escape && (_escape != _quote || (pos + 1 < _bufferLength && _buffer[pos + 1] == _quote) || (pos + 1 == _bufferLength && _reader.Peek() == _quote))"  is complex.
Complex Conditional,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The conditional expression  "!_eof && !delimiterSkipped && (initializing || index == _fieldCount - 1)"  is complex.
Complex Conditional,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadField,The conditional expression  "!delimiterSkipped && !_eof && !(_eol || IsNewLine(_nextFieldStart))"  is complex.
Complex Conditional,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,SkipToNewLine,The conditional expression  "(pos < _bufferLength || (ReadBuffer() && ((pos = 0) == 0))) && !ParseNewLine(ref pos)"  is complex.
Empty Catch Block,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,Dispose,The method has an empty catch block.
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadNextRecord,The following statement contains a magic number: if (!_initialized)              {                  _buffer = new char[_bufferSize];                    if (!ReadBuffer())                      return false;                    if (!SkipEmptyAndCommentedLines(ref _nextFieldStart))                      return false;                    // Keep growing _fields array until the last field has been found                  // and then resize it to its final correct size                    _fieldCount = 0;                  _fields = new string[16];                    while (ReadField(_fieldCount' true' false) != null)                  {                      if (_parseErrorFlag)                      {                          _fieldCount = 0;                          Array.Clear(_fields' 0' _fields.Length);                          _parseErrorFlag = false;                          _nextFieldIndex = 0;                      }                      else                      {                          _fieldCount++;                            if (_fieldCount == _fields.Length)                              Array.Resize(ref _fields' (_fieldCount + 1) * 2);                      }                  }                    // _fieldCount contains the last field index' but it must contains the field count'                  // so increment by 1                  _fieldCount++;                    if (_fields.Length != _fieldCount)                      Array.Resize(ref _fields' _fieldCount);                    _fieldHeaderIndexes = new Dictionary<string' int>(_fieldCount' StringComparer.CurrentCultureIgnoreCase);                    _initialized = true;                    // If headers are present' call ReadNextRecord again                  if (_hasHeaders)                  {                      // Don't count first record as it was the headers                      _currentRecordIndex = -1;                        _firstRecordInCache = false;                        for (int i = 0; i < _fields.Length; i++)                      {                          var headerName = _fields[i];                          if (string.IsNullOrEmpty(headerName) || headerName.Trim().Length == 0)                          {                              headerName = DefaultHeaderName + i;                          }                            // Create it if we haven't already set it explicitly                          var col = Columns.Count < i + 1 ? null : Columns[i];                          if (col == null)                          {                              col = new Column                              {                                  Name = headerName'                                  // Default to string if not assigned.                                  Type = typeof(string)                              };                              _fieldHeaderIndexes.Add(headerName' i);                              // Should be correct as we are going in ascending order.                              Columns.Add(col);                          }                      }                        // Proceed to first record                      if (!onlyReadHeaders)                      {                          // Calling again ReadNextRecord() seems to be simpler'                           // but in fact would probably cause many subtle bugs because a derived class does not expect a recursive behavior                          // so simply do what is needed here and no more.                            if (!SkipEmptyAndCommentedLines(ref _nextFieldStart))                              return false;                            Array.Clear(_fields' 0' _fields.Length);                          _nextFieldIndex = 0;                          _eol = false;                            _currentRecordIndex++;                          return true;                      }                  }                  else                  {                      // If we have explicity columne' now build up the reverse dictionary                      for (var i = 0; i < Columns.Count; i++)                      {                          _fieldHeaderIndexes.Add(Columns[i].Name' i);                      }                        if (onlyReadHeaders)                      {                          _firstRecordInCache = true;                          _currentRecordIndex = -1;                      }                      else                      {                          _firstRecordInCache = false;                          _currentRecordIndex = 0;                      }                  }              }              else              {                  if (skipToNextLine)                      SkipToNewLine(ref _nextFieldStart);                  else if (_currentRecordIndex > -1 && !_missingFieldFlag)                  {                      // If not already at end of record' move there                      if (!_eol && !_eof)                      {                          HandleExtraFieldsInCurrentRecord(_nextFieldStart);                      }                  }                    if (!_firstRecordInCache && !SkipEmptyAndCommentedLines(ref _nextFieldStart))                      return false;                    if (_hasHeaders || !_firstRecordInCache)                      _eol = false;                    // Check to see if the first record is in cache.                  // This can happen when initializing a reader with no headers                  // because one record must be read to get the field count automatically                  if (_firstRecordInCache)                      _firstRecordInCache = false;                  else                  {                      Array.Clear(_fields' 0' _fields.Length);                      _nextFieldIndex = 0;                  }                    _missingFieldFlag = false;                  _parseErrorFlag = false;                  _currentRecordIndex++;              }
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,ReadNextRecord,The following statement contains a magic number: if (!_initialized)              {                  _buffer = new char[_bufferSize];                    if (!ReadBuffer())                      return false;                    if (!SkipEmptyAndCommentedLines(ref _nextFieldStart))                      return false;                    // Keep growing _fields array until the last field has been found                  // and then resize it to its final correct size                    _fieldCount = 0;                  _fields = new string[16];                    while (ReadField(_fieldCount' true' false) != null)                  {                      if (_parseErrorFlag)                      {                          _fieldCount = 0;                          Array.Clear(_fields' 0' _fields.Length);                          _parseErrorFlag = false;                          _nextFieldIndex = 0;                      }                      else                      {                          _fieldCount++;                            if (_fieldCount == _fields.Length)                              Array.Resize(ref _fields' (_fieldCount + 1) * 2);                      }                  }                    // _fieldCount contains the last field index' but it must contains the field count'                  // so increment by 1                  _fieldCount++;                    if (_fields.Length != _fieldCount)                      Array.Resize(ref _fields' _fieldCount);                    _fieldHeaderIndexes = new Dictionary<string' int>(_fieldCount' StringComparer.CurrentCultureIgnoreCase);                    _initialized = true;                    // If headers are present' call ReadNextRecord again                  if (_hasHeaders)                  {                      // Don't count first record as it was the headers                      _currentRecordIndex = -1;                        _firstRecordInCache = false;                        for (int i = 0; i < _fields.Length; i++)                      {                          var headerName = _fields[i];                          if (string.IsNullOrEmpty(headerName) || headerName.Trim().Length == 0)                          {                              headerName = DefaultHeaderName + i;                          }                            // Create it if we haven't already set it explicitly                          var col = Columns.Count < i + 1 ? null : Columns[i];                          if (col == null)                          {                              col = new Column                              {                                  Name = headerName'                                  // Default to string if not assigned.                                  Type = typeof(string)                              };                              _fieldHeaderIndexes.Add(headerName' i);                              // Should be correct as we are going in ascending order.                              Columns.Add(col);                          }                      }                        // Proceed to first record                      if (!onlyReadHeaders)                      {                          // Calling again ReadNextRecord() seems to be simpler'                           // but in fact would probably cause many subtle bugs because a derived class does not expect a recursive behavior                          // so simply do what is needed here and no more.                            if (!SkipEmptyAndCommentedLines(ref _nextFieldStart))                              return false;                            Array.Clear(_fields' 0' _fields.Length);                          _nextFieldIndex = 0;                          _eol = false;                            _currentRecordIndex++;                          return true;                      }                  }                  else                  {                      // If we have explicity columne' now build up the reverse dictionary                      for (var i = 0; i < Columns.Count; i++)                      {                          _fieldHeaderIndexes.Add(Columns[i].Name' i);                      }                        if (onlyReadHeaders)                      {                          _firstRecordInCache = true;                          _currentRecordIndex = -1;                      }                      else                      {                          _firstRecordInCache = false;                          _currentRecordIndex = 0;                      }                  }              }              else              {                  if (skipToNextLine)                      SkipToNewLine(ref _nextFieldStart);                  else if (_currentRecordIndex > -1 && !_missingFieldFlag)                  {                      // If not already at end of record' move there                      if (!_eol && !_eof)                      {                          HandleExtraFieldsInCurrentRecord(_nextFieldStart);                      }                  }                    if (!_firstRecordInCache && !SkipEmptyAndCommentedLines(ref _nextFieldStart))                      return false;                    if (_hasHeaders || !_firstRecordInCache)                      _eol = false;                    // Check to see if the first record is in cache.                  // This can happen when initializing a reader with no headers                  // because one record must be read to get the field count automatically                  if (_firstRecordInCache)                      _firstRecordInCache = false;                  else                  {                      Array.Clear(_fields' 0' _fields.Length);                      _nextFieldIndex = 0;                  }                    _missingFieldFlag = false;                  _parseErrorFlag = false;                  _currentRecordIndex++;              }
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,GetSchemaTable,The following statement contains a magic number: for (int i = 0; i < columns.Count; i++)              {                  schemaRow[1] = columns[i].Name; // Base column name                  schemaRow[4] = columns[i].Name; // Column name                  schemaRow[5] = i;               // Column ordinal                  schemaRow[7] = columns[i].Type; // Data type                    schema.Rows.Add(schemaRow);              }
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,GetSchemaTable,The following statement contains a magic number: for (int i = 0; i < columns.Count; i++)              {                  schemaRow[1] = columns[i].Name; // Base column name                  schemaRow[4] = columns[i].Name; // Column name                  schemaRow[5] = i;               // Column ordinal                  schemaRow[7] = columns[i].Type; // Data type                    schema.Rows.Add(schemaRow);              }
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,C:\repos\phatcher_CsvReader\code\LumenWorks.Framework.IO\Csv\CsvReader.cs,GetSchemaTable,The following statement contains a magic number: for (int i = 0; i < columns.Count; i++)              {                  schemaRow[1] = columns[i].Name; // Base column name                  schemaRow[4] = columns[i].Name; // Column name                  schemaRow[5] = i;               // Column ordinal                  schemaRow[7] = columns[i].Type; // Data type                    schema.Rows.Add(schemaRow);              }
