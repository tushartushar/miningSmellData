Implementation smell,Namespace,Class,File,Method,Description
Complex Method,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,GetLength,Cyclomatic complexity of the method is 17
Complex Method,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,ToArray,Cyclomatic complexity of the method is 14
Complex Method,PCSC.Iso7816,FileStructureInfo,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\FileStructureInfo.cs,FileStructureInfo,Cyclomatic complexity of the method is 11
Long Parameter List,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,IsoReader,The method has 5 parameters. Parameters: reader' readerName' mode' protocol' disconnectReaderOnDispose
Long Parameter List,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,IsoReader,The method has 5 parameters. Parameters: context' readerName' mode' protocol' releaseContextOnDispose
Long Parameter List,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,IsoReader,The method has 6 parameters. Parameters: context' readerName' mode' protocol' releaseContextOnDispose' maxReceiveSize
Long Parameter List,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,SimpleTransmit,The method has 7 parameters. Parameters: commandApdu' commandApduLength' isoCase' protocol' receivePci' receiveBuffer' receiveBufferLength
Long Parameter List,PCSC.Iso7816,ResponseApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\ResponseApdu.cs,ResponseApdu,The method has 5 parameters. Parameters: response' length' isoCase' protocol' copy
Long Identifier,PCSC.Iso7816,FileStructureInfo,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\FileStructureInfo.cs,,The length of the parameter FILE_STRUCTURE_LINEAR_FIXED_TLV is 31.
Long Identifier,PCSC.Iso7816,FileStructureInfo,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\FileStructureInfo.cs,,The length of the parameter FILE_STRUCTURE_LINEAR_VARIABLE is 30.
Long Identifier,PCSC.Iso7816,FileStructureInfo,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\FileStructureInfo.cs,,The length of the parameter FILE_STRUCTURE_LINEAR_VARIABLE_TLV is 34.
Long Identifier,PCSC.Iso7816,RecordInfo,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\RecordInfo.cs,,The length of the parameter FILE_STRUCTURE_IS_LINEAR_FIXED is 30.
Long Identifier,PCSC.Iso7816,RecordInfo,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\RecordInfo.cs,,The length of the parameter FILE_STRUCTURE_IS_LINEAR_VARIABLE is 33.
Complex Conditional,PCSC.Iso7816,ResponseApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\ResponseApdu.cs,ResponseApdu,The conditional expression  "length < 0 ||                  (response == null && length > 0) ||                  (response != null && response.Length < length)"  is complex.
Complex Conditional,PCSC.Iso7816,ResponseApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\ResponseApdu.cs,ResponseApdu,The conditional expression  "length < 0 ||                  (response == null && length > 0) ||                  (response != null && response.Length < length)"  is complex.
Virtual Method Call from Constructor,PCSC.Iso7816,InvalidApduException,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\InvalidApduException.cs,InvalidApduException,The constructor "InvalidApduException" calls a virtual method "ToArray".
Virtual Method Call from Constructor,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,IsoReader,The constructor "IsoReader" calls a virtual method "Connect".
Virtual Method Call from Constructor,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,IsoReader,The constructor "IsoReader" calls a virtual method "Connect".
Magic Number,PCSC.Iso7816,ClassByte,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\ClassByte.cs,ClassByte,The following statement contains a magic number: logicalChannelNumber > 3 || logicalChannelNumber < 0
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: var size = 4;
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one extra byte */                      if (Protocol == SCardProtocol.T0) {                          size++;                      }                        break;                    case IsoCase.Case2Short:                      /* 1 byte for Le */                      size++;                      break;                    case IsoCase.Case3Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        /* 1 byte for Lc + Num(Lc) bytes */                      size += 1 + Lc;                      break;                    case IsoCase.Case4Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size += 1; /* 1 byte for Lc.                                       * Regarding to OpenSC: T0 has no byte for Le */                      } else {                          size += 2; /* 1 byte for Lc AND 1 byte for Le */                      }                        break;                    case IsoCase.Case2Extended:                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Le */                      } else {                          size += 3; /* 3 bytes for Le */                      }                        break;                    case IsoCase.Case3Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Lc */                      } else {                          size += 3; /* 3 bytes for Lc */                      }                        break;                    case IsoCase.Case4Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 has only 1 byte for Lc                                       * and no byte for Le */                      } else {                          size += 5; /* 3 bytes for Lc AND 2 bytes for Le */                      }                        break;                    default:                      throw new InvalidOperationException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one extra byte */                      if (Protocol == SCardProtocol.T0) {                          size++;                      }                        break;                    case IsoCase.Case2Short:                      /* 1 byte for Le */                      size++;                      break;                    case IsoCase.Case3Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        /* 1 byte for Lc + Num(Lc) bytes */                      size += 1 + Lc;                      break;                    case IsoCase.Case4Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size += 1; /* 1 byte for Lc.                                       * Regarding to OpenSC: T0 has no byte for Le */                      } else {                          size += 2; /* 1 byte for Lc AND 1 byte for Le */                      }                        break;                    case IsoCase.Case2Extended:                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Le */                      } else {                          size += 3; /* 3 bytes for Le */                      }                        break;                    case IsoCase.Case3Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Lc */                      } else {                          size += 3; /* 3 bytes for Lc */                      }                        break;                    case IsoCase.Case4Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 has only 1 byte for Lc                                       * and no byte for Le */                      } else {                          size += 5; /* 3 bytes for Lc AND 2 bytes for Le */                      }                        break;                    default:                      throw new InvalidOperationException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one extra byte */                      if (Protocol == SCardProtocol.T0) {                          size++;                      }                        break;                    case IsoCase.Case2Short:                      /* 1 byte for Le */                      size++;                      break;                    case IsoCase.Case3Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        /* 1 byte for Lc + Num(Lc) bytes */                      size += 1 + Lc;                      break;                    case IsoCase.Case4Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size += 1; /* 1 byte for Lc.                                       * Regarding to OpenSC: T0 has no byte for Le */                      } else {                          size += 2; /* 1 byte for Lc AND 1 byte for Le */                      }                        break;                    case IsoCase.Case2Extended:                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Le */                      } else {                          size += 3; /* 3 bytes for Le */                      }                        break;                    case IsoCase.Case3Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Lc */                      } else {                          size += 3; /* 3 bytes for Lc */                      }                        break;                    case IsoCase.Case4Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 has only 1 byte for Lc                                       * and no byte for Le */                      } else {                          size += 5; /* 3 bytes for Lc AND 2 bytes for Le */                      }                        break;                    default:                      throw new InvalidOperationException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one extra byte */                      if (Protocol == SCardProtocol.T0) {                          size++;                      }                        break;                    case IsoCase.Case2Short:                      /* 1 byte for Le */                      size++;                      break;                    case IsoCase.Case3Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        /* 1 byte for Lc + Num(Lc) bytes */                      size += 1 + Lc;                      break;                    case IsoCase.Case4Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size += 1; /* 1 byte for Lc.                                       * Regarding to OpenSC: T0 has no byte for Le */                      } else {                          size += 2; /* 1 byte for Lc AND 1 byte for Le */                      }                        break;                    case IsoCase.Case2Extended:                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Le */                      } else {                          size += 3; /* 3 bytes for Le */                      }                        break;                    case IsoCase.Case3Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Lc */                      } else {                          size += 3; /* 3 bytes for Lc */                      }                        break;                    case IsoCase.Case4Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 has only 1 byte for Lc                                       * and no byte for Le */                      } else {                          size += 5; /* 3 bytes for Lc AND 2 bytes for Le */                      }                        break;                    default:                      throw new InvalidOperationException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,ToArray,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one additional                        * byte containing 0x00. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = 0;                      }                        break;                    case IsoCase.Case2Short:                      /* Body contains only Le. */                      apdu[pos] = (byte) _le;                      break;                    case IsoCase.Case3Short:                      /* Body contains Num(Lc) followed by the data. */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Short:                      /* Body contains Num(Lc) followed by the data                       * and Num(Le). */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                      /* Regarding to OpenSC: T0 has no Le */                      if (Protocol != SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      }                        break;                    case IsoCase.Case2Extended:                      /* Body contains only Le. Regarding to OpenSC: T0 has only                       * a short Le (1 byte instead of 3 bytes).*/                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (_le >> 8); // B1 = higher bits                          apdu[pos] = (byte) (_le & 0xFF); // B2 = lower bits                      }                        break;                    case IsoCase.Case3Extended:                      /* Body contains Num(Lc) followed by the data.                        * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * therefore Num(Lc) cannot be greater then 255. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                        Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Extended:                      /* Body contains Num(Lc) followed by the data and Num(Le).                       * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * no Le */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                        Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                        if (Protocol != SCardProtocol.T0) {                          /* Case4Extended uses two bytes to "encode"                           * the Le value. */                          apdu[pos++] = (byte) (_le >> 8); // Bl-1 = higher bits                          apdu[pos] = (byte) (_le & 0xff); // Bl = lower bits                      }                        break;                    default:                      throw new NotSupportedException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,ToArray,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one additional                        * byte containing 0x00. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = 0;                      }                        break;                    case IsoCase.Case2Short:                      /* Body contains only Le. */                      apdu[pos] = (byte) _le;                      break;                    case IsoCase.Case3Short:                      /* Body contains Num(Lc) followed by the data. */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Short:                      /* Body contains Num(Lc) followed by the data                       * and Num(Le). */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                      /* Regarding to OpenSC: T0 has no Le */                      if (Protocol != SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      }                        break;                    case IsoCase.Case2Extended:                      /* Body contains only Le. Regarding to OpenSC: T0 has only                       * a short Le (1 byte instead of 3 bytes).*/                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (_le >> 8); // B1 = higher bits                          apdu[pos] = (byte) (_le & 0xFF); // B2 = lower bits                      }                        break;                    case IsoCase.Case3Extended:                      /* Body contains Num(Lc) followed by the data.                        * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * therefore Num(Lc) cannot be greater then 255. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                        Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Extended:                      /* Body contains Num(Lc) followed by the data and Num(Le).                       * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * no Le */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                        Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                        if (Protocol != SCardProtocol.T0) {                          /* Case4Extended uses two bytes to "encode"                           * the Le value. */                          apdu[pos++] = (byte) (_le >> 8); // Bl-1 = higher bits                          apdu[pos] = (byte) (_le & 0xff); // Bl = lower bits                      }                        break;                    default:                      throw new NotSupportedException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,ToArray,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one additional                        * byte containing 0x00. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = 0;                      }                        break;                    case IsoCase.Case2Short:                      /* Body contains only Le. */                      apdu[pos] = (byte) _le;                      break;                    case IsoCase.Case3Short:                      /* Body contains Num(Lc) followed by the data. */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Short:                      /* Body contains Num(Lc) followed by the data                       * and Num(Le). */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                      /* Regarding to OpenSC: T0 has no Le */                      if (Protocol != SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      }                        break;                    case IsoCase.Case2Extended:                      /* Body contains only Le. Regarding to OpenSC: T0 has only                       * a short Le (1 byte instead of 3 bytes).*/                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (_le >> 8); // B1 = higher bits                          apdu[pos] = (byte) (_le & 0xFF); // B2 = lower bits                      }                        break;                    case IsoCase.Case3Extended:                      /* Body contains Num(Lc) followed by the data.                        * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * therefore Num(Lc) cannot be greater then 255. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                        Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Extended:                      /* Body contains Num(Lc) followed by the data and Num(Le).                       * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * no Le */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                        Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                        if (Protocol != SCardProtocol.T0) {                          /* Case4Extended uses two bytes to "encode"                           * the Le value. */                          apdu[pos++] = (byte) (_le >> 8); // Bl-1 = higher bits                          apdu[pos] = (byte) (_le & 0xff); // Bl = lower bits                      }                        break;                    default:                      throw new NotSupportedException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\CommandApdu.cs,ToArray,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one additional                        * byte containing 0x00. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = 0;                      }                        break;                    case IsoCase.Case2Short:                      /* Body contains only Le. */                      apdu[pos] = (byte) _le;                      break;                    case IsoCase.Case3Short:                      /* Body contains Num(Lc) followed by the data. */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Short:                      /* Body contains Num(Lc) followed by the data                       * and Num(Le). */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                      /* Regarding to OpenSC: T0 has no Le */                      if (Protocol != SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      }                        break;                    case IsoCase.Case2Extended:                      /* Body contains only Le. Regarding to OpenSC: T0 has only                       * a short Le (1 byte instead of 3 bytes).*/                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (_le >> 8); // B1 = higher bits                          apdu[pos] = (byte) (_le & 0xFF); // B2 = lower bits                      }                        break;                    case IsoCase.Case3Extended:                      /* Body contains Num(Lc) followed by the data.                        * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * therefore Num(Lc) cannot be greater then 255. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                        Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Extended:                      /* Body contains Num(Lc) followed by the data and Num(Le).                       * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * no Le */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                        Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                        if (Protocol != SCardProtocol.T0) {                          /* Case4Extended uses two bytes to "encode"                           * the Le value. */                          apdu[pos++] = (byte) (_le >> 8); // Bl-1 = higher bits                          apdu[pos] = (byte) (_le & 0xff); // Bl = lower bits                      }                        break;                    default:                      throw new NotSupportedException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,IssueGetResponseCommand,The following statement contains a magic number: var receiveBufferLength = le == 0                      ? 256 + 2                      : le + 2;
Magic Number,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,IssueGetResponseCommand,The following statement contains a magic number: var receiveBufferLength = le == 0                      ? 256 + 2                      : le + 2;
Magic Number,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,IssueGetResponseCommand,The following statement contains a magic number: var receiveBufferLength = le == 0                      ? 256 + 2                      : le + 2;
Magic Number,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,RetransmitOnInsufficientBuffer,The following statement contains a magic number: receiveBufferLength = 256 + 2;
Magic Number,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,RetransmitOnInsufficientBuffer,The following statement contains a magic number: receiveBufferLength = 256 + 2;
Magic Number,PCSC.Iso7816,IsoReader,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\IsoReader.cs,ConstructGetResponseApdu,The following statement contains a magic number: le > 255 || le < 0
Magic Number,PCSC.Iso7816,ResponseApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\ResponseApdu.cs,GetData,The following statement contains a magic number: FullApdu.Length <= 2 ||                  Length <= 2
Magic Number,PCSC.Iso7816,ResponseApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\ResponseApdu.cs,GetData,The following statement contains a magic number: FullApdu.Length <= 2 ||                  Length <= 2
Magic Number,PCSC.Iso7816,ResponseApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\ResponseApdu.cs,GetData,The following statement contains a magic number: var tmp = new byte[Length - 2];
Magic Number,PCSC.Iso7816,ResponseApdu,D:\research\architectureSmells\repos\danm-de_pcsc-sharp\src\PCSC.Iso7816\ResponseApdu.cs,GetData,The following statement contains a magic number: Array.Copy(FullApdu' tmp' Length - 2);
