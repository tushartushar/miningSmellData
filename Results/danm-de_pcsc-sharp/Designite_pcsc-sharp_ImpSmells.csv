Implementation smell,Namespace,Class,File,Method,Description
Complex Method,PCSC,SCardMonitor,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Monitoring\SCardMonitor.cs,StartMonitor,Cyclomatic complexity of the method is 13
Long Parameter List,PCSC,ISCardReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Reader\ISCardReader.cs,Transmit,The method has 6 parameters. Parameters: sendPci' sendBuffer' sendBufferLength' receivePci' receiveBuffer' receiveBufferLength
Long Parameter List,PCSC,SCardReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Reader\SCardReader.cs,Transmit,The method has 6 parameters. Parameters: sendPci' sendBuffer' sendBufferLength' receivePci' receiveBuffer' receiveBufferLength
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,SCardConnect,The method has 6 parameters. Parameters: hContext' szReader' dwShareMode' dwPreferredProtocols' phCard' pdwActiveProtocol
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,Connect,The method has 6 parameters. Parameters: hContext' szReader' dwShareMode' dwPreferredProtocols' phCard' pdwActiveProtocol
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,SCardReconnect,The method has 5 parameters. Parameters: hCard' dwShareMode' dwPreferredProtocols' dwInitialization' pdwActiveProtocol
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,Reconnect,The method has 5 parameters. Parameters: hCard' dwShareMode' dwPreferredProtocols' dwInitialization' pdwActiveProtocol
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,SCardTransmit,The method has 7 parameters. Parameters: hCard' pioSendPci' pbSendBuffer' cbSendLength' pioRecvPci' pbRecvBuffer' pcbRecvLength
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,Transmit,The method has 6 parameters. Parameters: hCard' pioSendPci' pbSendBuffer' pioRecvPci' pbRecvBuffer' pcbRecvLength
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,Transmit,The method has 7 parameters. Parameters: hCard' pioSendPci' pbSendBuffer' pcbSendLength' pioRecvPci' pbRecvBuffer' pcbRecvLength
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,SCardControl,The method has 7 parameters. Parameters: hCard' dwControlCode' pbSendBuffer' cbSendLength' pbRecvBuffer' pcbRecvLength' lpBytesReturned
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,Control,The method has 5 parameters. Parameters: hCard' dwControlCode' pbSendBuffer' pbRecvBuffer' lpBytesReturned
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,SCardStatus,The method has 7 parameters. Parameters: hCard' szReaderName' pcchReaderLen' pdwState' pdwProtocol' pbAtr' pcbAtrLen
Long Parameter List,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,Status,The method has 5 parameters. Parameters: hCard' szReaderName' pdwState' pdwProtocol' pbAtr
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,SCardConnect,The method has 6 parameters. Parameters: hContext' szReader' dwShareMode' dwPreferredProtocols' phCard' pdwActiveProtocol
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,Connect,The method has 6 parameters. Parameters: hContext' szReader' dwShareMode' dwPreferredProtocols' phCard' pdwActiveProtocol
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,SCardReconnect,The method has 5 parameters. Parameters: hCard' dwShareMode' dwPreferredProtocols' dwInitialization' pdwActiveProtocol
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,Reconnect,The method has 5 parameters. Parameters: hCard' dwShareMode' dwPreferredProtocols' dwInitialization' pdwActiveProtocol
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,SCardTransmit,The method has 7 parameters. Parameters: hCard' pioSendPci' pbSendBuffer' cbSendLength' pioRecvPci' pbRecvBuffer' pcbRecvLength
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,Transmit,The method has 6 parameters. Parameters: hCard' pioSendPci' pbSendBuffer' pioRecvPci' pbRecvBuffer' pcbRecvLength
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,Transmit,The method has 7 parameters. Parameters: hCard' pioSendPci' pbSendBuffer' pcbSendLength' pioRecvPci' pbRecvBuffer' pcbRecvLength
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,SCardControl,The method has 7 parameters. Parameters: hCard' dwControlCode' lpInBuffer' nInBufferSize' lpOutBuffer' nOutBufferSize' lpBytesReturned
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,Control,The method has 5 parameters. Parameters: hCard' dwControlCode' pbSendBuffer' pbRecvBuffer' lpBytesReturned
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,SCardStatus,The method has 7 parameters. Parameters: hCard' szReaderName' pcchReaderLen' pdwState' pdwProtocol' pbAtr' pcbAtrLen
Long Parameter List,PCSC.Interop.Windows,WinSCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Windows\WinSCardAPI.cs,Status,The method has 5 parameters. Parameters: hCard' szReaderName' pdwState' pdwProtocol' pbAtr
Long Parameter List,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,IsoReader,The method has 5 parameters. Parameters: reader' readerName' mode' protocol' disconnectReaderOnDispose
Long Parameter List,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,IsoReader,The method has 5 parameters. Parameters: context' readerName' mode' protocol' releaseContextOnDispose
Long Parameter List,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,SimpleTransmit,The method has 7 parameters. Parameters: commandApdu' commandApduLength' isoCase' protocol' receivePci' receiveBuffer' receiveBufferLength
Long Parameter List,PCSC.Iso7816,ResponseApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\ResponseApdu.cs,ResponseApdu,The method has 5 parameters. Parameters: response' length' isoCase' protocol' copy
Long Parameter List,PCSC.Interop,ISCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\ISCardAPI.cs,Connect,The method has 6 parameters. Parameters: hContext' szReader' dwShareMode' dwPreferredProtocols' phCard' pdwActiveProtocol
Long Parameter List,PCSC.Interop,ISCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\ISCardAPI.cs,Reconnect,The method has 5 parameters. Parameters: hCard' dwShareMode' dwPreferredProtocols' dwInitialization' pdwActiveProtocol
Long Parameter List,PCSC.Interop,ISCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\ISCardAPI.cs,Transmit,The method has 6 parameters. Parameters: hCard' pioSendPci' pbSendBuffer' pioRecvPci' pbRecvBuffer' pcbRecvLength
Long Parameter List,PCSC.Interop,ISCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\ISCardAPI.cs,Transmit,The method has 7 parameters. Parameters: hCard' pioSendPci' pbSendBuffer' pcbSendLength' pioRecvPci' pbRecvBuffer' pcbRecvLength
Long Parameter List,PCSC.Interop,ISCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\ISCardAPI.cs,Control,The method has 5 parameters. Parameters: hCard' dwControlCode' pbSendBuffer' pbRecvBuffer' lpBytesReturned
Long Parameter List,PCSC.Interop,ISCardAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\ISCardAPI.cs,Status,The method has 5 parameters. Parameters: hCard' szReaderName' pdwState' pdwProtocol' pbAtr
Long Identifier,PCSC,PCSCException,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Exceptions\PCSCException.cs,,The length of the parameter SCARD_ERROR_SERIALIZATION_NAME is 30.
Long Identifier,PCSC.Iso7816,FileStructureInfo,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\FileStructureInfo.cs,,The length of the parameter FILE_STRUCTURE_LINEAR_FIXED_TLV is 31.
Long Identifier,PCSC.Iso7816,FileStructureInfo,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\FileStructureInfo.cs,,The length of the parameter FILE_STRUCTURE_LINEAR_VARIABLE is 30.
Long Identifier,PCSC.Iso7816,FileStructureInfo,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\FileStructureInfo.cs,,The length of the parameter FILE_STRUCTURE_LINEAR_VARIABLE_TLV is 34.
Long Identifier,PCSC.Iso7816,RecordInfo,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\RecordInfo.cs,,The length of the parameter FILE_STRUCTURE_IS_LINEAR_FIXED is 30.
Long Identifier,PCSC.Iso7816,RecordInfo,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\RecordInfo.cs,,The length of the parameter FILE_STRUCTURE_IS_LINEAR_VARIABLE is 33.
Complex Conditional,PCSC.Iso7816,ResponseApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\ResponseApdu.cs,ResponseApdu,The conditional expression  "length < 0 ||                  (response == null && length > 0) ||                  (response != null && response.Length < length)"  is complex.
Complex Conditional,PCSC.Iso7816,ResponseApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\ResponseApdu.cs,ResponseApdu,The conditional expression  "length < 0 ||                  (response == null && length > 0) ||                  (response != null && response.Length < length)"  is complex.
Complex Conditional,PCSC.Interop,Platform,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Platform.cs,Platform,The conditional expression  "platform == PlatformID.Win32S ||                  platform == PlatformID.Win32Windows ||                  platform == PlatformID.Win32NT ||                  platform == PlatformID.WinCE"  is complex.
Virtual Method Call from Constructor,PCSC.Iso7816,InvalidApduException,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\Exceptions\InvalidApduException.cs,InvalidApduException,The constructor "InvalidApduException" calls a virtual method "ToArray".
Virtual Method Call from Constructor,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,IsoReader,The constructor "IsoReader" calls a virtual method "Connect".
Virtual Method Call from Constructor,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,IsoReader,The constructor "IsoReader" calls a virtual method "Connect".
Empty Catch Block,PCSC,DeviceMonitor,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Monitoring\DeviceMonitor.cs,Dispose,The method has an empty catch block.
Empty Catch Block,PCSC,SCardContext,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Context\SCardContext.cs,Dispose,The method has an empty catch block.
Magic Number,PCSC,DeviceMonitor,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Monitoring\DeviceMonitor.cs,StartMonitor,The following statement contains a magic number: try {                  var readers = GetReaders(ctx);                  OnInitialized(new DeviceChangeEventArgs(                      readers'                       Enumerable.Empty<string>()'                       Enumerable.Empty<string>()));                    while (true) {                      var scannerStates = new[] {                          new SCardReaderState {                              ReaderName = "\\\\?PnP?\\Notification"'                              CurrentStateValue = (IntPtr) (readers.Count << 16)'                              EventStateValue = (IntPtr) SCRState.Unknown'                          }                      };                        var rc = ctx.GetStatusChange(ctx.Infinite' scannerStates);                      if (rc == SCardError.Cancelled) {                          return;                      }                        if (rc != SCardError.Success) {                          throw new PCSCException(rc);                      }                        var newReaderList = GetReaders(ctx);                      var attached = GetAttachedReaders(readers' newReaderList);                      var detached = GetDetachedReaders(readers' newReaderList);                        OnStatusChanged(new DeviceChangeEventArgs(                          newReaderList.ToList()'                           attached.ToList()'                           detached.ToList()));                        readers = newReaderList;                  }              } catch (Exception exception) {                  OnMonitorException(new DeviceMonitorExceptionEventArgs(exception));              }
Magic Number,PCSC.Interop.Unix,PCSCliteAPI,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Interop\Unix\PCSCliteAPI.cs,GetUnameSysName,The following statement contains a magic number: byte[] utsNameBuffer = new byte[1000];
Magic Number,PCSC.Iso7816,ClassByte,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\ClassByte.cs,ClassByte,The following statement contains a magic number: if (logicalChannelNumber > 3 || logicalChannelNumber < 0) {                  throw new ArgumentOutOfRangeException(                      nameof(logicalChannelNumber)'                      "Logical channels must be in the range between 0 and 3.");              }
Magic Number,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,IssueGetResponseCommand,The following statement contains a magic number: do {                  // add the last ResponseAPDU to the Response object                  response.Add(responseApdu);                  response.Add(receivePci);                    var getResponseApdu = ConstructGetResponseApdu(ref le);                    // +2 bytes for status word                  var receiveBufferLength = le == 0                       ? 256 + 2                       : le + 2;                    var receiveBuffer = new byte[receiveBufferLength];                    try {                      var sendBuffer = getResponseApdu.ToArray();                        // Shall we wait until we re-send we APDU/TPDU?                      if (RetransmitWaitTime > 0) {                          Thread.Sleep(RetransmitWaitTime);                      }                        // send Command APDU again with new Le value                      responseApdu = SimpleTransmit(                          sendBuffer'                          sendBuffer.Length'                          getResponseApdu.Case'                          getResponseApdu.Protocol'                          receivePci'                          receiveBuffer'                          receiveBufferLength);                  } catch (WinErrorInsufficientBufferException ex) {                      throw new InvalidApduException($"GET RESPONSE command failed because of unsufficient buffer (Le={getResponseApdu.Le})"'                           getResponseApdu' ex);                  } catch (InvalidOperationException ex) {                      throw new InvalidApduException(                          "Got SW1=0x61. Retransmission failed because of an invalid GET RESPONSE APDU."'                          getResponseApdu' ex);                  }                    // In case there is more data available.                  le = responseApdu.SW2;              } while (                  // More data available.                  responseApdu.SW1 == (byte) SW1Code.NormalDataResponse ||                  // Warning condition: data may be corrupted. Iso7816-4 7.1.5                  (responseApdu.SW1 == (byte) SW1Code.WarningNVDataNotChanged && responseApdu.SW2 == 0x81));
Magic Number,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,IssueGetResponseCommand,The following statement contains a magic number: do {                  // add the last ResponseAPDU to the Response object                  response.Add(responseApdu);                  response.Add(receivePci);                    var getResponseApdu = ConstructGetResponseApdu(ref le);                    // +2 bytes for status word                  var receiveBufferLength = le == 0                       ? 256 + 2                       : le + 2;                    var receiveBuffer = new byte[receiveBufferLength];                    try {                      var sendBuffer = getResponseApdu.ToArray();                        // Shall we wait until we re-send we APDU/TPDU?                      if (RetransmitWaitTime > 0) {                          Thread.Sleep(RetransmitWaitTime);                      }                        // send Command APDU again with new Le value                      responseApdu = SimpleTransmit(                          sendBuffer'                          sendBuffer.Length'                          getResponseApdu.Case'                          getResponseApdu.Protocol'                          receivePci'                          receiveBuffer'                          receiveBufferLength);                  } catch (WinErrorInsufficientBufferException ex) {                      throw new InvalidApduException($"GET RESPONSE command failed because of unsufficient buffer (Le={getResponseApdu.Le})"'                           getResponseApdu' ex);                  } catch (InvalidOperationException ex) {                      throw new InvalidApduException(                          "Got SW1=0x61. Retransmission failed because of an invalid GET RESPONSE APDU."'                          getResponseApdu' ex);                  }                    // In case there is more data available.                  le = responseApdu.SW2;              } while (                  // More data available.                  responseApdu.SW1 == (byte) SW1Code.NormalDataResponse ||                  // Warning condition: data may be corrupted. Iso7816-4 7.1.5                  (responseApdu.SW1 == (byte) SW1Code.WarningNVDataNotChanged && responseApdu.SW2 == 0x81));
Magic Number,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,IssueGetResponseCommand,The following statement contains a magic number: do {                  // add the last ResponseAPDU to the Response object                  response.Add(responseApdu);                  response.Add(receivePci);                    var getResponseApdu = ConstructGetResponseApdu(ref le);                    // +2 bytes for status word                  var receiveBufferLength = le == 0                       ? 256 + 2                       : le + 2;                    var receiveBuffer = new byte[receiveBufferLength];                    try {                      var sendBuffer = getResponseApdu.ToArray();                        // Shall we wait until we re-send we APDU/TPDU?                      if (RetransmitWaitTime > 0) {                          Thread.Sleep(RetransmitWaitTime);                      }                        // send Command APDU again with new Le value                      responseApdu = SimpleTransmit(                          sendBuffer'                          sendBuffer.Length'                          getResponseApdu.Case'                          getResponseApdu.Protocol'                          receivePci'                          receiveBuffer'                          receiveBufferLength);                  } catch (WinErrorInsufficientBufferException ex) {                      throw new InvalidApduException($"GET RESPONSE command failed because of unsufficient buffer (Le={getResponseApdu.Le})"'                           getResponseApdu' ex);                  } catch (InvalidOperationException ex) {                      throw new InvalidApduException(                          "Got SW1=0x61. Retransmission failed because of an invalid GET RESPONSE APDU."'                          getResponseApdu' ex);                  }                    // In case there is more data available.                  le = responseApdu.SW2;              } while (                  // More data available.                  responseApdu.SW1 == (byte) SW1Code.NormalDataResponse ||                  // Warning condition: data may be corrupted. Iso7816-4 7.1.5                  (responseApdu.SW1 == (byte) SW1Code.WarningNVDataNotChanged && responseApdu.SW2 == 0x81));
Magic Number,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,RetransmitOnInsufficientBuffer,The following statement contains a magic number: if (responseApdu.SW2 == 0) {                  resendCmdApdu.Le = 0; // 256                  receiveBufferLength = 256 + 2; // 2 bytes for status word              } else {                  resendCmdApdu.Le = responseApdu.SW2;                  receiveBufferLength = responseApdu.SW2 + 2; // 2 bytes for status word              }
Magic Number,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,RetransmitOnInsufficientBuffer,The following statement contains a magic number: if (responseApdu.SW2 == 0) {                  resendCmdApdu.Le = 0; // 256                  receiveBufferLength = 256 + 2; // 2 bytes for status word              } else {                  resendCmdApdu.Le = responseApdu.SW2;                  receiveBufferLength = responseApdu.SW2 + 2; // 2 bytes for status word              }
Magic Number,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,RetransmitOnInsufficientBuffer,The following statement contains a magic number: if (responseApdu.SW2 == 0) {                  resendCmdApdu.Le = 0; // 256                  receiveBufferLength = 256 + 2; // 2 bytes for status word              } else {                  resendCmdApdu.Le = responseApdu.SW2;                  receiveBufferLength = responseApdu.SW2 + 2; // 2 bytes for status word              }
Magic Number,PCSC.Iso7816,IsoReader,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\IsoReader.cs,ConstructGetResponseApdu,The following statement contains a magic number: if (le > 255 || le < 0) {                  throw new ArgumentOutOfRangeException(nameof(le));              }
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: var size = 4;
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one extra byte */                      if (Protocol == SCardProtocol.T0) {                          size++;                      }                      break;                    case IsoCase.Case2Short:                      /* 1 byte for Le */                      size++;                      break;                    case IsoCase.Case3Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        /* 1 byte for Lc + Num(Lc) bytes */                      size += 1 + Lc;                      break;                    case IsoCase.Case4Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size += 1; /* 1 byte for Lc.                                       * Regarding to OpenSC: T0 has no byte for Le */                      } else {                          size += 2; /* 1 byte for Lc AND 1 byte for Le */                      }                      break;                    case IsoCase.Case2Extended:                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Le */                      } else {                          size += 3; /* 3 bytes for Le */                      }                      break;                    case IsoCase.Case3Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Lc */                      } else {                          size += 3; /* 3 bytes for Lc */                      }                        break;                    case IsoCase.Case4Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 has only 1 byte for Lc                                       * and no byte for Le */                      } else {                          size += 5; /* 3 bytes for Lc AND 2 bytes for Le */                      }                      break;                    default:                      throw new InvalidOperationException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one extra byte */                      if (Protocol == SCardProtocol.T0) {                          size++;                      }                      break;                    case IsoCase.Case2Short:                      /* 1 byte for Le */                      size++;                      break;                    case IsoCase.Case3Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        /* 1 byte for Lc + Num(Lc) bytes */                      size += 1 + Lc;                      break;                    case IsoCase.Case4Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size += 1; /* 1 byte for Lc.                                       * Regarding to OpenSC: T0 has no byte for Le */                      } else {                          size += 2; /* 1 byte for Lc AND 1 byte for Le */                      }                      break;                    case IsoCase.Case2Extended:                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Le */                      } else {                          size += 3; /* 3 bytes for Le */                      }                      break;                    case IsoCase.Case3Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Lc */                      } else {                          size += 3; /* 3 bytes for Lc */                      }                        break;                    case IsoCase.Case4Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 has only 1 byte for Lc                                       * and no byte for Le */                      } else {                          size += 5; /* 3 bytes for Lc AND 2 bytes for Le */                      }                      break;                    default:                      throw new InvalidOperationException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one extra byte */                      if (Protocol == SCardProtocol.T0) {                          size++;                      }                      break;                    case IsoCase.Case2Short:                      /* 1 byte for Le */                      size++;                      break;                    case IsoCase.Case3Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        /* 1 byte for Lc + Num(Lc) bytes */                      size += 1 + Lc;                      break;                    case IsoCase.Case4Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size += 1; /* 1 byte for Lc.                                       * Regarding to OpenSC: T0 has no byte for Le */                      } else {                          size += 2; /* 1 byte for Lc AND 1 byte for Le */                      }                      break;                    case IsoCase.Case2Extended:                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Le */                      } else {                          size += 3; /* 3 bytes for Le */                      }                      break;                    case IsoCase.Case3Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Lc */                      } else {                          size += 3; /* 3 bytes for Lc */                      }                        break;                    case IsoCase.Case4Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 has only 1 byte for Lc                                       * and no byte for Le */                      } else {                          size += 5; /* 3 bytes for Lc AND 2 bytes for Le */                      }                      break;                    default:                      throw new InvalidOperationException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,GetLength,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one extra byte */                      if (Protocol == SCardProtocol.T0) {                          size++;                      }                      break;                    case IsoCase.Case2Short:                      /* 1 byte for Le */                      size++;                      break;                    case IsoCase.Case3Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        /* 1 byte for Lc + Num(Lc) bytes */                      size += 1 + Lc;                      break;                    case IsoCase.Case4Short:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size += 1; /* 1 byte for Lc.                                       * Regarding to OpenSC: T0 has no byte for Le */                      } else {                          size += 2; /* 1 byte for Lc AND 1 byte for Le */                      }                      break;                    case IsoCase.Case2Extended:                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Le */                      } else {                          size += 3; /* 3 bytes for Le */                      }                      break;                    case IsoCase.Case3Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 needs only one byte for Lc */                      } else {                          size += 3; /* 3 bytes for Lc */                      }                        break;                    case IsoCase.Case4Extended:                      if (_data == null) {                          throw new InvalidOperationException("No data has been set.");                      }                        size += Lc; /* Num(Lc) bytes */                      if (Protocol == SCardProtocol.T0) {                          size++; /* Regarding to OpenSC: T0 has only 1 byte for Lc                                       * and no byte for Le */                      } else {                          size += 5; /* 3 bytes for Lc AND 2 bytes for Le */                      }                      break;                    default:                      throw new InvalidOperationException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,ToArray,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one additional                        * byte containing 0x00. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = 0;                      }                      break;                    case IsoCase.Case2Short:                      /* Body contains only Le. */                      apdu[pos] = (byte) _le;                      break;                    case IsoCase.Case3Short:                      /* Body contains Num(Lc) followed by the data. */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Short:                      /* Body contains Num(Lc) followed by the data                       * and Num(Le). */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                      /* Regarding to OpenSC: T0 has no Le */                      if (Protocol != SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      }                      break;                    case IsoCase.Case2Extended:                      /* Body contains only Le. Regarding to OpenSC: T0 has only                       * a short Le (1 byte instead of 3 bytes).*/                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (_le >> 8); // B1 = higher bits                          apdu[pos] = (byte) (_le & 0xFF); // B2 = lower bits                      }                      break;                    case IsoCase.Case3Extended:                      /* Body contains Num(Lc) followed by the data.                        * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * therefore Num(Lc) cannot be greater then 255. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Extended:                      /* Body contains Num(Lc) followed by the data and Num(Le).                       * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * no Le */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                        if (Protocol != SCardProtocol.T0) {                          /* Case4Extended uses two bytes to "encode"                           * the Le value. */                          apdu[pos++] = (byte) (_le >> 8); // Bl-1 = higher bits                          apdu[pos] = (byte) (_le & 0xff); // Bl = lower bits                      }                      break;                    default:                      throw new NotSupportedException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,ToArray,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one additional                        * byte containing 0x00. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = 0;                      }                      break;                    case IsoCase.Case2Short:                      /* Body contains only Le. */                      apdu[pos] = (byte) _le;                      break;                    case IsoCase.Case3Short:                      /* Body contains Num(Lc) followed by the data. */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Short:                      /* Body contains Num(Lc) followed by the data                       * and Num(Le). */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                      /* Regarding to OpenSC: T0 has no Le */                      if (Protocol != SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      }                      break;                    case IsoCase.Case2Extended:                      /* Body contains only Le. Regarding to OpenSC: T0 has only                       * a short Le (1 byte instead of 3 bytes).*/                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (_le >> 8); // B1 = higher bits                          apdu[pos] = (byte) (_le & 0xFF); // B2 = lower bits                      }                      break;                    case IsoCase.Case3Extended:                      /* Body contains Num(Lc) followed by the data.                        * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * therefore Num(Lc) cannot be greater then 255. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Extended:                      /* Body contains Num(Lc) followed by the data and Num(Le).                       * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * no Le */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                        if (Protocol != SCardProtocol.T0) {                          /* Case4Extended uses two bytes to "encode"                           * the Le value. */                          apdu[pos++] = (byte) (_le >> 8); // Bl-1 = higher bits                          apdu[pos] = (byte) (_le & 0xff); // Bl = lower bits                      }                      break;                    default:                      throw new NotSupportedException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,ToArray,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one additional                        * byte containing 0x00. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = 0;                      }                      break;                    case IsoCase.Case2Short:                      /* Body contains only Le. */                      apdu[pos] = (byte) _le;                      break;                    case IsoCase.Case3Short:                      /* Body contains Num(Lc) followed by the data. */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Short:                      /* Body contains Num(Lc) followed by the data                       * and Num(Le). */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                      /* Regarding to OpenSC: T0 has no Le */                      if (Protocol != SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      }                      break;                    case IsoCase.Case2Extended:                      /* Body contains only Le. Regarding to OpenSC: T0 has only                       * a short Le (1 byte instead of 3 bytes).*/                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (_le >> 8); // B1 = higher bits                          apdu[pos] = (byte) (_le & 0xFF); // B2 = lower bits                      }                      break;                    case IsoCase.Case3Extended:                      /* Body contains Num(Lc) followed by the data.                        * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * therefore Num(Lc) cannot be greater then 255. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Extended:                      /* Body contains Num(Lc) followed by the data and Num(Le).                       * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * no Le */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                        if (Protocol != SCardProtocol.T0) {                          /* Case4Extended uses two bytes to "encode"                           * the Le value. */                          apdu[pos++] = (byte) (_le >> 8); // Bl-1 = higher bits                          apdu[pos] = (byte) (_le & 0xff); // Bl = lower bits                      }                      break;                    default:                      throw new NotSupportedException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,CommandApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\CommandApdu.cs,ToArray,The following statement contains a magic number: switch (Case) {                  case IsoCase.Case1:                      /* Regarding to OpenSC: T0 needs one additional                        * byte containing 0x00. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = 0;                      }                      break;                    case IsoCase.Case2Short:                      /* Body contains only Le. */                      apdu[pos] = (byte) _le;                      break;                    case IsoCase.Case3Short:                      /* Body contains Num(Lc) followed by the data. */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Short:                      /* Body contains Num(Lc) followed by the data                       * and Num(Le). */                      apdu[pos++] = (byte) Lc;                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                      /* Regarding to OpenSC: T0 has no Le */                      if (Protocol != SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      }                      break;                    case IsoCase.Case2Extended:                      /* Body contains only Le. Regarding to OpenSC: T0 has only                       * a short Le (1 byte instead of 3 bytes).*/                      if (Protocol == SCardProtocol.T0) {                          apdu[pos] = (byte) _le;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (_le >> 8); // B1 = higher bits                          apdu[pos] = (byte) (_le & 0xFF); // B2 = lower bits                      }                      break;                    case IsoCase.Case3Extended:                      /* Body contains Num(Lc) followed by the data.                        * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * therefore Num(Lc) cannot be greater then 255. */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                      Array.Copy(_data' 0' apdu' pos' Lc);                      break;                    case IsoCase.Case4Extended:                      /* Body contains Num(Lc) followed by the data and Num(Le).                       * Regarding to OpenSC: T0 has only 1 byte for Lc and                       * no Le */                      if (Protocol == SCardProtocol.T0) {                          apdu[pos++] = (byte) Lc;                      } else {                          apdu[pos++] = 0; // B0 = 0x00                          apdu[pos++] = (byte) (Lc >> 8); // B1 = higher bits                          apdu[pos++] = (byte) (Lc & 0xFF); // B2 = lower bits                      }                      Array.Copy(_data' 0' apdu' pos' Lc);                      pos += Lc;                        if (Protocol != SCardProtocol.T0) {                          /* Case4Extended uses two bytes to "encode"                           * the Le value. */                          apdu[pos++] = (byte) (_le >> 8); // Bl-1 = higher bits                          apdu[pos] = (byte) (_le & 0xff); // Bl = lower bits                      }                      break;                    default:                      throw new NotSupportedException(string.Format("IsoCase {0} is not supported."' Case));              }
Magic Number,PCSC.Iso7816,ResponseApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\ResponseApdu.cs,GetData,The following statement contains a magic number: if (FullApdu.Length <= 2 ||                  Length <= 2) {                  return null;              }
Magic Number,PCSC.Iso7816,ResponseApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\ResponseApdu.cs,GetData,The following statement contains a magic number: if (FullApdu.Length <= 2 ||                  Length <= 2) {                  return null;              }
Magic Number,PCSC.Iso7816,ResponseApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\ResponseApdu.cs,GetData,The following statement contains a magic number: var tmp = new byte[Length - 2];
Magic Number,PCSC.Iso7816,ResponseApdu,C:\repos\danm-de_pcsc-sharp\pcsc-sharp\Iso7816\ResponseApdu.cs,GetData,The following statement contains a magic number: Array.Copy(FullApdu' tmp' Length - 2);
