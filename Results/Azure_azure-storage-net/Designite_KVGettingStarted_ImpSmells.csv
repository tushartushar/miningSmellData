Implementation smell,Namespace,Class,File,Method,Description
Long Method,KVGettingStarted,Program,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The method has 103 lines of code.
Complex Method,KVGettingStarted,Program,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,Cyclomatic complexity of the method is 11
Long Statement,KVGettingStarted,Program,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The length of the statement  "	// How to create a storage connection string - https://azure.microsoft.com/en-us/documentation/articles/storage-configure-connection-string/ " is 140.
Long Statement,KVGettingStarted,Program,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The length of the statement  "		// Download the encrypted blob. The same policy and options created before can be used because the aggregate resolver contains both " is 131.
Long Statement,EncryptionShared,Utility,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\..\shared\Utility.cs,CreateStorageAccountFromConnectionString,The length of the statement  "		Console.WriteLine ("Invalid storage account information provided. Please confirm the AccountName and AccountKey are valid in the app.config file - then restart the sample."); " is 174.
Long Statement,EncryptionShared,Utility,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\..\shared\Utility.cs,CreateStorageAccountFromConnectionString,The length of the statement  "		Console.WriteLine ("Invalid storage account information provided. Please confirm the AccountName and AccountKey are valid in the app.config file - then restart the sample."); " is 174.
Long Statement,EncryptionShared,KeyVaultUtility,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\..\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "			Console.WriteLine ("Unable to access the specified vault. Please confirm the KVClientId' KVClientKey' and VaultUri are valid in the app.config file."); " is 151.
Long Statement,EncryptionShared,KeyVaultUtility,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\..\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "			Console.WriteLine ("Also ensure that the client ID has previously been granted full permissions for Key Vault secrets using the Set-AzureKeyVaultAccessPolicy command with the -PermissionsToSecrets parameter."); " is 210.
Long Statement,EncryptionShared,KeyVaultUtility,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\..\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "	Secret cloudSecret = cloudVault.SetSecretAsync (vaultUri' secretName' symmetricBytes' null' "application/octet-stream").GetAwaiter ().GetResult (); " is 147.
Long Statement,EncryptionShared,KeyVaultUtility,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\..\shared\KeyVaultUtility.cs,GetAccessToken,The length of the statement  "	ClientCredential credential = new ClientCredential (CloudConfigurationManager.GetSetting ("KVClientId")' CloudConfigurationManager.GetSetting ("KVClientKey")); " is 159.
Magic Number,KVGettingStarted,Program,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The following statement contains a magic number: try {  	container.Create ();  	int size = 5 * 1024 * 1024;  	byte[] buffer = new byte[size];  	Random rand = new Random ();  	rand.NextBytes (buffer);  	// The first blob will use the key stored in Azure Key Vault.  	CloudBlockBlob blob = container.GetBlockBlobReference ("blockblob1");  	// Create the encryption policy using the secret stored in Azure Key Vault to be used for upload.  	BlobEncryptionPolicy uploadPolicy = new BlobEncryptionPolicy (cloudKey' null);  	// Set the encryption policy on the request options.  	BlobRequestOptions uploadOptions = new BlobRequestOptions () {  		EncryptionPolicy = uploadPolicy  	};  	Console.WriteLine ("Uploading the 1st encrypted blob.");  	// Upload the encrypted contents to the blob.  	using (MemoryStream stream = new MemoryStream (buffer)) {  		blob.UploadFromStream (stream' size' null' uploadOptions' null);  	}  	// Download the encrypted blob.  	BlobEncryptionPolicy downloadPolicy = new BlobEncryptionPolicy (null' cachingResolver);  	// Set the decryption policy on the request options.  	BlobRequestOptions downloadOptions = new BlobRequestOptions () {  		EncryptionPolicy = downloadPolicy  	};  	Console.WriteLine ("Downloading the 1st encrypted blob.");  	// Download and decrypt the encrypted contents from the blob.  	using (MemoryStream outputStream = new MemoryStream ()) {  		blob.DownloadToStream (outputStream' null' downloadOptions' null);  	}  	// Upload second blob using the local key.  	blob = container.GetBlockBlobReference ("blockblob2");  	// Create the encryption policy using the local key.  	uploadPolicy = new BlobEncryptionPolicy (rsaKey' null);  	// Set the encryption policy on the request options.  	uploadOptions = new BlobRequestOptions () {  		EncryptionPolicy = uploadPolicy  	};  	Console.WriteLine ("Uploading the 2nd encrypted blob.");  	// Upload the encrypted contents to the blob.  	using (MemoryStream stream = new MemoryStream (buffer)) {  		blob.UploadFromStream (stream' size' null' uploadOptions' null);  	}  	// Download the encrypted blob. The same policy and options created before can be used because the aggregate resolver contains both  	// resolvers and will pick the right one based on the key ID stored in blob metadata on the service.  	Console.WriteLine ("Downloading the 2nd encrypted blob.");  	// Download and decrypt the encrypted contents from the blob.  	using (MemoryStream outputStream = new MemoryStream ()) {  		blob.DownloadToStream (outputStream' null' downloadOptions' null);  	}  	Console.WriteLine ("Press enter key to exit");  	Console.ReadLine ();  } finally {  	container.DeleteIfExists ();  }  
Magic Number,KVGettingStarted,Program,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The following statement contains a magic number: try {  	container.Create ();  	int size = 5 * 1024 * 1024;  	byte[] buffer = new byte[size];  	Random rand = new Random ();  	rand.NextBytes (buffer);  	// The first blob will use the key stored in Azure Key Vault.  	CloudBlockBlob blob = container.GetBlockBlobReference ("blockblob1");  	// Create the encryption policy using the secret stored in Azure Key Vault to be used for upload.  	BlobEncryptionPolicy uploadPolicy = new BlobEncryptionPolicy (cloudKey' null);  	// Set the encryption policy on the request options.  	BlobRequestOptions uploadOptions = new BlobRequestOptions () {  		EncryptionPolicy = uploadPolicy  	};  	Console.WriteLine ("Uploading the 1st encrypted blob.");  	// Upload the encrypted contents to the blob.  	using (MemoryStream stream = new MemoryStream (buffer)) {  		blob.UploadFromStream (stream' size' null' uploadOptions' null);  	}  	// Download the encrypted blob.  	BlobEncryptionPolicy downloadPolicy = new BlobEncryptionPolicy (null' cachingResolver);  	// Set the decryption policy on the request options.  	BlobRequestOptions downloadOptions = new BlobRequestOptions () {  		EncryptionPolicy = downloadPolicy  	};  	Console.WriteLine ("Downloading the 1st encrypted blob.");  	// Download and decrypt the encrypted contents from the blob.  	using (MemoryStream outputStream = new MemoryStream ()) {  		blob.DownloadToStream (outputStream' null' downloadOptions' null);  	}  	// Upload second blob using the local key.  	blob = container.GetBlockBlobReference ("blockblob2");  	// Create the encryption policy using the local key.  	uploadPolicy = new BlobEncryptionPolicy (rsaKey' null);  	// Set the encryption policy on the request options.  	uploadOptions = new BlobRequestOptions () {  		EncryptionPolicy = uploadPolicy  	};  	Console.WriteLine ("Uploading the 2nd encrypted blob.");  	// Upload the encrypted contents to the blob.  	using (MemoryStream stream = new MemoryStream (buffer)) {  		blob.UploadFromStream (stream' size' null' uploadOptions' null);  	}  	// Download the encrypted blob. The same policy and options created before can be used because the aggregate resolver contains both  	// resolvers and will pick the right one based on the key ID stored in blob metadata on the service.  	Console.WriteLine ("Downloading the 2nd encrypted blob.");  	// Download and decrypt the encrypted contents from the blob.  	using (MemoryStream outputStream = new MemoryStream ()) {  		blob.DownloadToStream (outputStream' null' downloadOptions' null);  	}  	Console.WriteLine ("Press enter key to exit");  	Console.ReadLine ();  } finally {  	container.DeleteIfExists ();  }  
Magic Number,KVGettingStarted,Program,F:\newReposMay17\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The following statement contains a magic number: try {  	container.Create ();  	int size = 5 * 1024 * 1024;  	byte[] buffer = new byte[size];  	Random rand = new Random ();  	rand.NextBytes (buffer);  	// The first blob will use the key stored in Azure Key Vault.  	CloudBlockBlob blob = container.GetBlockBlobReference ("blockblob1");  	// Create the encryption policy using the secret stored in Azure Key Vault to be used for upload.  	BlobEncryptionPolicy uploadPolicy = new BlobEncryptionPolicy (cloudKey' null);  	// Set the encryption policy on the request options.  	BlobRequestOptions uploadOptions = new BlobRequestOptions () {  		EncryptionPolicy = uploadPolicy  	};  	Console.WriteLine ("Uploading the 1st encrypted blob.");  	// Upload the encrypted contents to the blob.  	using (MemoryStream stream = new MemoryStream (buffer)) {  		blob.UploadFromStream (stream' size' null' uploadOptions' null);  	}  	// Download the encrypted blob.  	BlobEncryptionPolicy downloadPolicy = new BlobEncryptionPolicy (null' cachingResolver);  	// Set the decryption policy on the request options.  	BlobRequestOptions downloadOptions = new BlobRequestOptions () {  		EncryptionPolicy = downloadPolicy  	};  	Console.WriteLine ("Downloading the 1st encrypted blob.");  	// Download and decrypt the encrypted contents from the blob.  	using (MemoryStream outputStream = new MemoryStream ()) {  		blob.DownloadToStream (outputStream' null' downloadOptions' null);  	}  	// Upload second blob using the local key.  	blob = container.GetBlockBlobReference ("blockblob2");  	// Create the encryption policy using the local key.  	uploadPolicy = new BlobEncryptionPolicy (rsaKey' null);  	// Set the encryption policy on the request options.  	uploadOptions = new BlobRequestOptions () {  		EncryptionPolicy = uploadPolicy  	};  	Console.WriteLine ("Uploading the 2nd encrypted blob.");  	// Upload the encrypted contents to the blob.  	using (MemoryStream stream = new MemoryStream (buffer)) {  		blob.UploadFromStream (stream' size' null' uploadOptions' null);  	}  	// Download the encrypted blob. The same policy and options created before can be used because the aggregate resolver contains both  	// resolvers and will pick the right one based on the key ID stored in blob metadata on the service.  	Console.WriteLine ("Downloading the 2nd encrypted blob.");  	// Download and decrypt the encrypted contents from the blob.  	using (MemoryStream outputStream = new MemoryStream ()) {  		blob.DownloadToStream (outputStream' null' downloadOptions' null);  	}  	Console.WriteLine ("Press enter key to exit");  	Console.ReadLine ();  } finally {  	container.DeleteIfExists ();  }  
