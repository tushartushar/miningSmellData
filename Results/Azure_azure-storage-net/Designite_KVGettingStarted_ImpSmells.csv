Implementation smell,Namespace,Class,File,Method,Description
Long Method,KVGettingStarted,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The method has 108 lines of code.
Long Statement,KVGettingStarted,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The length of the statement  "            // How to create a storage connection string - https://azure.microsoft.com/en-us/documentation/articles/storage-configure-connection-string/ " is 140.
Long Statement,KVGettingStarted,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The length of the statement  "                // Download the encrypted blob. The same policy and options created before can be used because the aggregate resolver contains both " is 131.
Long Statement,EncryptionShared,Utility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\Utility.cs,CreateStorageAccountFromConnectionString,The length of the statement  "                Console.WriteLine("Invalid storage account information provided. Please confirm the AccountName and AccountKey are valid in the app.config file - then restart the sample."); " is 173.
Long Statement,EncryptionShared,Utility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\Utility.cs,CreateStorageAccountFromConnectionString,The length of the statement  "                Console.WriteLine("Invalid storage account information provided. Please confirm the AccountName and AccountKey are valid in the app.config file - then restart the sample."); " is 173.
Long Statement,EncryptionShared,KeyVaultUtility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "                    Console.WriteLine("Unable to access the specified vault. Please confirm the KVClientId' KVClientKey' and VaultUri are valid in the app.config file."); " is 150.
Long Statement,EncryptionShared,KeyVaultUtility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "                    Console.WriteLine("Also ensure that the client ID has previously been granted full permissions for Key Vault secrets using the Set-AzureKeyVaultAccessPolicy command with the -PermissionsToSecrets parameter."); " is 209.
Long Statement,EncryptionShared,KeyVaultUtility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "            Secret cloudSecret = cloudVault.SetSecretAsync(vaultUri' secretName' symmetricBytes' null' "application/octet-stream").GetAwaiter().GetResult(); " is 144.
Long Statement,EncryptionShared,KeyVaultUtility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\KeyVaultUtility.cs,GetAccessToken,The length of the statement  "            ClientCredential credential = new ClientCredential(CloudConfigurationManager.GetSetting("KVClientId")' CloudConfigurationManager.GetSetting("KVClientKey")); " is 156.
Magic Number,KVGettingStarted,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The following statement contains a magic number: CachingKeyResolver cachingResolver = new CachingKeyResolver(2' aggregateResolver);
Magic Number,KVGettingStarted,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The following statement contains a magic number: try              {                  container.Create();                  int size = 5 * 1024 * 1024;                  byte[] buffer = new byte[size];                    Random rand = new Random();                  rand.NextBytes(buffer);                    // The first blob will use the key stored in Azure Key Vault.                  CloudBlockBlob blob = container.GetBlockBlobReference("blockblob1");                    // Create the encryption policy using the secret stored in Azure Key Vault to be used for upload.                  BlobEncryptionPolicy uploadPolicy = new BlobEncryptionPolicy(cloudKey' null);                    // Set the encryption policy on the request options.                  BlobRequestOptions uploadOptions = new BlobRequestOptions() { EncryptionPolicy = uploadPolicy };                    Console.WriteLine("Uploading the 1st encrypted blob.");                    // Upload the encrypted contents to the blob.                  using (MemoryStream stream = new MemoryStream(buffer))                  {                      blob.UploadFromStream(stream' size' null' uploadOptions' null);                  }                    // Download the encrypted blob.                  BlobEncryptionPolicy downloadPolicy = new BlobEncryptionPolicy(null' cachingResolver);                    // Set the decryption policy on the request options.                  BlobRequestOptions downloadOptions = new BlobRequestOptions() { EncryptionPolicy = downloadPolicy };                    Console.WriteLine("Downloading the 1st encrypted blob.");                    // Download and decrypt the encrypted contents from the blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' null' downloadOptions' null);                  }                    // Upload second blob using the local key.                  blob = container.GetBlockBlobReference("blockblob2");                    // Create the encryption policy using the local key.                  uploadPolicy = new BlobEncryptionPolicy(rsaKey' null);                    // Set the encryption policy on the request options.                  uploadOptions = new BlobRequestOptions() { EncryptionPolicy = uploadPolicy };                    Console.WriteLine("Uploading the 2nd encrypted blob.");                    // Upload the encrypted contents to the blob.                  using (MemoryStream stream = new MemoryStream(buffer))                  {                      blob.UploadFromStream(stream' size' null' uploadOptions' null);                  }                    // Download the encrypted blob. The same policy and options created before can be used because the aggregate resolver contains both                  // resolvers and will pick the right one based on the key ID stored in blob metadata on the service.                  Console.WriteLine("Downloading the 2nd encrypted blob.");                    // Download and decrypt the encrypted contents from the blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' null' downloadOptions' null);                  }                    Console.WriteLine("Press enter key to exit");                  Console.ReadLine();              }              finally              {                  container.DeleteIfExists();              }
Magic Number,KVGettingStarted,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The following statement contains a magic number: try              {                  container.Create();                  int size = 5 * 1024 * 1024;                  byte[] buffer = new byte[size];                    Random rand = new Random();                  rand.NextBytes(buffer);                    // The first blob will use the key stored in Azure Key Vault.                  CloudBlockBlob blob = container.GetBlockBlobReference("blockblob1");                    // Create the encryption policy using the secret stored in Azure Key Vault to be used for upload.                  BlobEncryptionPolicy uploadPolicy = new BlobEncryptionPolicy(cloudKey' null);                    // Set the encryption policy on the request options.                  BlobRequestOptions uploadOptions = new BlobRequestOptions() { EncryptionPolicy = uploadPolicy };                    Console.WriteLine("Uploading the 1st encrypted blob.");                    // Upload the encrypted contents to the blob.                  using (MemoryStream stream = new MemoryStream(buffer))                  {                      blob.UploadFromStream(stream' size' null' uploadOptions' null);                  }                    // Download the encrypted blob.                  BlobEncryptionPolicy downloadPolicy = new BlobEncryptionPolicy(null' cachingResolver);                    // Set the decryption policy on the request options.                  BlobRequestOptions downloadOptions = new BlobRequestOptions() { EncryptionPolicy = downloadPolicy };                    Console.WriteLine("Downloading the 1st encrypted blob.");                    // Download and decrypt the encrypted contents from the blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' null' downloadOptions' null);                  }                    // Upload second blob using the local key.                  blob = container.GetBlockBlobReference("blockblob2");                    // Create the encryption policy using the local key.                  uploadPolicy = new BlobEncryptionPolicy(rsaKey' null);                    // Set the encryption policy on the request options.                  uploadOptions = new BlobRequestOptions() { EncryptionPolicy = uploadPolicy };                    Console.WriteLine("Uploading the 2nd encrypted blob.");                    // Upload the encrypted contents to the blob.                  using (MemoryStream stream = new MemoryStream(buffer))                  {                      blob.UploadFromStream(stream' size' null' uploadOptions' null);                  }                    // Download the encrypted blob. The same policy and options created before can be used because the aggregate resolver contains both                  // resolvers and will pick the right one based on the key ID stored in blob metadata on the service.                  Console.WriteLine("Downloading the 2nd encrypted blob.");                    // Download and decrypt the encrypted contents from the blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' null' downloadOptions' null);                  }                    Console.WriteLine("Press enter key to exit");                  Console.ReadLine();              }              finally              {                  container.DeleteIfExists();              }
Magic Number,KVGettingStarted,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KVGettingStarted\Program.cs,Main,The following statement contains a magic number: try              {                  container.Create();                  int size = 5 * 1024 * 1024;                  byte[] buffer = new byte[size];                    Random rand = new Random();                  rand.NextBytes(buffer);                    // The first blob will use the key stored in Azure Key Vault.                  CloudBlockBlob blob = container.GetBlockBlobReference("blockblob1");                    // Create the encryption policy using the secret stored in Azure Key Vault to be used for upload.                  BlobEncryptionPolicy uploadPolicy = new BlobEncryptionPolicy(cloudKey' null);                    // Set the encryption policy on the request options.                  BlobRequestOptions uploadOptions = new BlobRequestOptions() { EncryptionPolicy = uploadPolicy };                    Console.WriteLine("Uploading the 1st encrypted blob.");                    // Upload the encrypted contents to the blob.                  using (MemoryStream stream = new MemoryStream(buffer))                  {                      blob.UploadFromStream(stream' size' null' uploadOptions' null);                  }                    // Download the encrypted blob.                  BlobEncryptionPolicy downloadPolicy = new BlobEncryptionPolicy(null' cachingResolver);                    // Set the decryption policy on the request options.                  BlobRequestOptions downloadOptions = new BlobRequestOptions() { EncryptionPolicy = downloadPolicy };                    Console.WriteLine("Downloading the 1st encrypted blob.");                    // Download and decrypt the encrypted contents from the blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' null' downloadOptions' null);                  }                    // Upload second blob using the local key.                  blob = container.GetBlockBlobReference("blockblob2");                    // Create the encryption policy using the local key.                  uploadPolicy = new BlobEncryptionPolicy(rsaKey' null);                    // Set the encryption policy on the request options.                  uploadOptions = new BlobRequestOptions() { EncryptionPolicy = uploadPolicy };                    Console.WriteLine("Uploading the 2nd encrypted blob.");                    // Upload the encrypted contents to the blob.                  using (MemoryStream stream = new MemoryStream(buffer))                  {                      blob.UploadFromStream(stream' size' null' uploadOptions' null);                  }                    // Download the encrypted blob. The same policy and options created before can be used because the aggregate resolver contains both                  // resolvers and will pick the right one based on the key ID stored in blob metadata on the service.                  Console.WriteLine("Downloading the 2nd encrypted blob.");                    // Download and decrypt the encrypted contents from the blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' null' downloadOptions' null);                  }                    Console.WriteLine("Press enter key to exit");                  Console.ReadLine();              }              finally              {                  container.DeleteIfExists();              }
