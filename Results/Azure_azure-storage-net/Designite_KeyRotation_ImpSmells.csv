Implementation smell,Namespace,Class,File,Method,Description
Long Statement,KeyRotation,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KeyRotation\Program.cs,Main,The length of the statement  "            // How to create a storage connection string - https://azure.microsoft.com/en-us/documentation/articles/storage-configure-connection-string/ " is 140.
Long Statement,EncryptionShared,Utility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\Utility.cs,CreateStorageAccountFromConnectionString,The length of the statement  "                Console.WriteLine("Invalid storage account information provided. Please confirm the AccountName and AccountKey are valid in the app.config file - then restart the sample."); " is 173.
Long Statement,EncryptionShared,Utility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\Utility.cs,CreateStorageAccountFromConnectionString,The length of the statement  "                Console.WriteLine("Invalid storage account information provided. Please confirm the AccountName and AccountKey are valid in the app.config file - then restart the sample."); " is 173.
Long Statement,EncryptionShared,KeyVaultUtility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "                    Console.WriteLine("Unable to access the specified vault. Please confirm the KVClientId' KVClientKey' and VaultUri are valid in the app.config file."); " is 150.
Long Statement,EncryptionShared,KeyVaultUtility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "                    Console.WriteLine("Also ensure that the client ID has previously been granted full permissions for Key Vault secrets using the Set-AzureKeyVaultAccessPolicy command with the -PermissionsToSecrets parameter."); " is 209.
Long Statement,EncryptionShared,KeyVaultUtility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\KeyVaultUtility.cs,SetUpKeyVaultSecret,The length of the statement  "            Secret cloudSecret = cloudVault.SetSecretAsync(vaultUri' secretName' symmetricBytes' null' "application/octet-stream").GetAwaiter().GetResult(); " is 144.
Long Statement,EncryptionShared,KeyVaultUtility,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\shared\KeyVaultUtility.cs,GetAccessToken,The length of the statement  "            ClientCredential credential = new ClientCredential(CloudConfigurationManager.GetSetting("KVClientId")' CloudConfigurationManager.GetSetting("KVClientKey")); " is 156.
Magic Number,KeyRotation,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KeyRotation\Program.cs,Main,The following statement contains a magic number: CachingKeyResolver cachingResolver = new CachingKeyResolver(2' cloudResolver);
Magic Number,KeyRotation,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KeyRotation\Program.cs,Main,The following statement contains a magic number: try              {                  container.Create();                  int size = 5 * 1024 * 1024;                  byte[] buffer1 = new byte[size];                  byte[] buffer2 = new byte[size];                    Random rand = new Random();                  rand.NextBytes(buffer1);                  rand.NextBytes(buffer2);                    // Upload the first blob using the secret stored in Azure Key Vault.                  CloudBlockBlob blob = container.GetBlockBlobReference("blockblob1");                    Console.WriteLine("Uploading Blob 1 using Key 1.");                    // Upload the encrypted contents to the first blob.                  using (MemoryStream stream = new MemoryStream(buffer1))                  {                      blob.UploadFromStream(stream' size);                  }                    Console.WriteLine("Downloading and decrypting Blob 1.");                    // Download and decrypt the encrypted contents from the first blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream);                  }                    // At this point we will rotate our keys so new encrypted content will use the                  // second key. Note that the same resolver is used' as this resolver is capable                  // of decrypting blobs encrypted using either key.                  Console.WriteLine("Rotating the active encryption key to Key 2.");                    client.DefaultRequestOptions.EncryptionPolicy = new BlobEncryptionPolicy(cloudKey2' cachingResolver);                    // Upload the second blob using the key stored in Azure Key Vault.                  CloudBlockBlob blob2 = container.GetBlockBlobReference("blockblob2");                    Console.WriteLine("Uploading Blob 2 using Key 2.");                    // Upload the encrypted contents to the second blob.                  using (MemoryStream stream = new MemoryStream(buffer2))                  {                      blob2.UploadFromStream(stream' size);                  }                    Console.WriteLine("Downloading and decrypting Blob 2.");                    // Download and decrypt the encrypted contents from the second blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob2.DownloadToStream(outputStream);                  }                    // Here we download and re-upload the first blob. This has the effect of updating                  // the blob to use the new key.                  using (MemoryStream memoryStream = new MemoryStream())                  {                      Console.WriteLine("Downloading and decrypting Blob 1.");                      blob.DownloadToStream(memoryStream);                        memoryStream.Seek(0' SeekOrigin.Begin);                        Console.WriteLine("Re-uploading Blob 1 using Key 2.");                      blob.UploadFromStream(memoryStream);                  }                    // For the purposes of demonstration' we now override the encryption policy to only recognize key 2.                  BlobEncryptionPolicy key2OnlyPolicy = new BlobEncryptionPolicy(cloudKey2' null);                  BlobRequestOptions key2OnlyOptions = new BlobRequestOptions()                  {                      EncryptionPolicy = key2OnlyPolicy                  };                    Console.WriteLine("Downloading and decrypting Blob 1.");                    // The first blob can still be decrypted because it is using the second key.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' options: key2OnlyOptions);                  }                    Console.WriteLine("Press enter key to exit");                  Console.ReadLine();              }              finally              {                  container.DeleteIfExists();              }
Magic Number,KeyRotation,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KeyRotation\Program.cs,Main,The following statement contains a magic number: try              {                  container.Create();                  int size = 5 * 1024 * 1024;                  byte[] buffer1 = new byte[size];                  byte[] buffer2 = new byte[size];                    Random rand = new Random();                  rand.NextBytes(buffer1);                  rand.NextBytes(buffer2);                    // Upload the first blob using the secret stored in Azure Key Vault.                  CloudBlockBlob blob = container.GetBlockBlobReference("blockblob1");                    Console.WriteLine("Uploading Blob 1 using Key 1.");                    // Upload the encrypted contents to the first blob.                  using (MemoryStream stream = new MemoryStream(buffer1))                  {                      blob.UploadFromStream(stream' size);                  }                    Console.WriteLine("Downloading and decrypting Blob 1.");                    // Download and decrypt the encrypted contents from the first blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream);                  }                    // At this point we will rotate our keys so new encrypted content will use the                  // second key. Note that the same resolver is used' as this resolver is capable                  // of decrypting blobs encrypted using either key.                  Console.WriteLine("Rotating the active encryption key to Key 2.");                    client.DefaultRequestOptions.EncryptionPolicy = new BlobEncryptionPolicy(cloudKey2' cachingResolver);                    // Upload the second blob using the key stored in Azure Key Vault.                  CloudBlockBlob blob2 = container.GetBlockBlobReference("blockblob2");                    Console.WriteLine("Uploading Blob 2 using Key 2.");                    // Upload the encrypted contents to the second blob.                  using (MemoryStream stream = new MemoryStream(buffer2))                  {                      blob2.UploadFromStream(stream' size);                  }                    Console.WriteLine("Downloading and decrypting Blob 2.");                    // Download and decrypt the encrypted contents from the second blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob2.DownloadToStream(outputStream);                  }                    // Here we download and re-upload the first blob. This has the effect of updating                  // the blob to use the new key.                  using (MemoryStream memoryStream = new MemoryStream())                  {                      Console.WriteLine("Downloading and decrypting Blob 1.");                      blob.DownloadToStream(memoryStream);                        memoryStream.Seek(0' SeekOrigin.Begin);                        Console.WriteLine("Re-uploading Blob 1 using Key 2.");                      blob.UploadFromStream(memoryStream);                  }                    // For the purposes of demonstration' we now override the encryption policy to only recognize key 2.                  BlobEncryptionPolicy key2OnlyPolicy = new BlobEncryptionPolicy(cloudKey2' null);                  BlobRequestOptions key2OnlyOptions = new BlobRequestOptions()                  {                      EncryptionPolicy = key2OnlyPolicy                  };                    Console.WriteLine("Downloading and decrypting Blob 1.");                    // The first blob can still be decrypted because it is using the second key.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' options: key2OnlyOptions);                  }                    Console.WriteLine("Press enter key to exit");                  Console.ReadLine();              }              finally              {                  container.DeleteIfExists();              }
Magic Number,KeyRotation,Program,C:\repos\Azure_azure-storage-net\Samples\GettingStarted\EncryptionSamples\KeyRotation\Program.cs,Main,The following statement contains a magic number: try              {                  container.Create();                  int size = 5 * 1024 * 1024;                  byte[] buffer1 = new byte[size];                  byte[] buffer2 = new byte[size];                    Random rand = new Random();                  rand.NextBytes(buffer1);                  rand.NextBytes(buffer2);                    // Upload the first blob using the secret stored in Azure Key Vault.                  CloudBlockBlob blob = container.GetBlockBlobReference("blockblob1");                    Console.WriteLine("Uploading Blob 1 using Key 1.");                    // Upload the encrypted contents to the first blob.                  using (MemoryStream stream = new MemoryStream(buffer1))                  {                      blob.UploadFromStream(stream' size);                  }                    Console.WriteLine("Downloading and decrypting Blob 1.");                    // Download and decrypt the encrypted contents from the first blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream);                  }                    // At this point we will rotate our keys so new encrypted content will use the                  // second key. Note that the same resolver is used' as this resolver is capable                  // of decrypting blobs encrypted using either key.                  Console.WriteLine("Rotating the active encryption key to Key 2.");                    client.DefaultRequestOptions.EncryptionPolicy = new BlobEncryptionPolicy(cloudKey2' cachingResolver);                    // Upload the second blob using the key stored in Azure Key Vault.                  CloudBlockBlob blob2 = container.GetBlockBlobReference("blockblob2");                    Console.WriteLine("Uploading Blob 2 using Key 2.");                    // Upload the encrypted contents to the second blob.                  using (MemoryStream stream = new MemoryStream(buffer2))                  {                      blob2.UploadFromStream(stream' size);                  }                    Console.WriteLine("Downloading and decrypting Blob 2.");                    // Download and decrypt the encrypted contents from the second blob.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob2.DownloadToStream(outputStream);                  }                    // Here we download and re-upload the first blob. This has the effect of updating                  // the blob to use the new key.                  using (MemoryStream memoryStream = new MemoryStream())                  {                      Console.WriteLine("Downloading and decrypting Blob 1.");                      blob.DownloadToStream(memoryStream);                        memoryStream.Seek(0' SeekOrigin.Begin);                        Console.WriteLine("Re-uploading Blob 1 using Key 2.");                      blob.UploadFromStream(memoryStream);                  }                    // For the purposes of demonstration' we now override the encryption policy to only recognize key 2.                  BlobEncryptionPolicy key2OnlyPolicy = new BlobEncryptionPolicy(cloudKey2' null);                  BlobRequestOptions key2OnlyOptions = new BlobRequestOptions()                  {                      EncryptionPolicy = key2OnlyPolicy                  };                    Console.WriteLine("Downloading and decrypting Blob 1.");                    // The first blob can still be decrypted because it is using the second key.                  using (MemoryStream outputStream = new MemoryStream())                  {                      blob.DownloadToStream(outputStream' options: key2OnlyOptions);                  }                    Console.WriteLine("Press enter key to exit");                  Console.ReadLine();              }              finally              {                  container.DeleteIfExists();              }
