Implementation smell,Namespace,Class,File,Method,Description
Long Method,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The method has 145 lines of code.
Long Method,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The method has 137 lines of code.
Long Method,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The method has 122 lines of code.
Long Method,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The method has 113 lines of code.
Long Method,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The method has 113 lines of code.
Long Method,updateSystemDotNet.Updater.Win32,Security,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\Security.cs,ExecRequireNonAdmin,The method has 112 lines of code.
Complex Method,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,Cyclomatic complexity of the method is 9
Complex Method,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,getActionById,Cyclomatic complexity of the method is 25
Long Parameter List,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,AESEncrypt,The method has 7 parameters. Parameters: PlainText' Password' Salt' HashAlgorithm' PasswordIterations' InitialVector' KeySize
Long Parameter List,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,AESDecrypt,The method has 7 parameters. Parameters: CipherText' Password' Salt' HashAlgorithm' PasswordIterations' InitialVector' KeySize
Long Parameter List,updateSystemDotNet.Updater.Win32,NativeMethods,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeMethods.cs,DuplicateTokenEx,The method has 6 parameters. Parameters: hExistingToken' dwDesiredAccess' lpTokenAttributes' ImpersonationLevel' TokenType' phNewToken
Long Parameter List,updateSystemDotNet.Updater.Win32,NativeMethods,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeMethods.cs,CreateProcessWithTokenW,The method has 9 parameters. Parameters: hToken' dwLogonFlags' lpApplicationName' lpCommandLine' dwCreationFlags' lpEnvironment' lpCurrentDirectory' lpStartupInfo' lpProcessInfo
Long Identifier,updateSystemDotNet.Updater.Win32,NativeConstants,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeConstants.cs,,The length of the parameter PROCESS_QUERY_LIMITED_INFORMATION is 33.
Long Identifier,updateSystemDotNet.Updater.Win32,NativeConstants,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeConstants.cs,,The length of the parameter PF_XMMI_INSTRUCTIONS_AVAILABLE is 30.
Long Identifier,updateSystemDotNet.Updater.Win32,NativeConstants,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeConstants.cs,,The length of the parameter PF_XMMI64_INSTRUCTIONS_AVAILABLE is 32.
Long Identifier,updateSystemDotNet.Updater.Win32,NativeConstants,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeConstants.cs,,The length of the parameter PF_SSE3_INSTRUCTIONS_AVAILABLE is 30.
Long Identifier,updateSystemDotNet.Updater.Win32,NativeConstants,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeConstants.cs,,The length of the parameter IID_IFileOperationProgressSink is 30.
Long Identifier,updateSystemDotNet.Updater.Win32,NativeConstants,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeConstants.cs,,The length of the parameter WTD_STATEACTION_AUTO_CACHE_FLUSH is 32.
Long Identifier,updateSystemDotNet.Updater.Win32,NativeConstants,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeConstants.cs,,The length of the parameter WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT is 39.
Long Statement,updateSystemDotNet.Core.Types,SecureContainer,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Types\SecureContainer.cs,Save,The length of the statement  "					//xT.WriteComment(string.Format("Created with updateSystemDotNet Version {0}"' System.Reflection.Assembly.GetEntryAssembly().GetName().Version.ToString())); " is 156.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The length of the statement  "			//using (UI.Forms.dlgOpenProcesses dlg = new updateSystemDotNet.Updater.UI.Forms.dlgOpenProcesses(action.processList.ToArray())) " is 128.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The length of the statement  "			//        throw new Exception("Ein oder mehrere Prozesse konnten nicht beendet werden weshalb der Updatevorgang abgebrochen werden musste."); " is 141.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The length of the statement  "				//    //onProgressChanged(string.Format("Optimiere .Net Assembly '{0}'..."' file.Filename)' Percent(fileCounter' action.Files.Count)); " is 134.
Long Statement,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The length of the statement  "			TextRenderer.DrawText(e.Graphics' Text' fontText' rectTextArea' ForeColor' TextFormatFlags.WordBreak | TextFormatFlags.VerticalCenter); " is 135.
Long Statement,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The length of the statement  "            this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153))))); " is 125.
Long Statement,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The length of the statement  "			this.lblTitle.Font = new System.Drawing.Font("Tahoma"' 11.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The length of the statement  "			this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153))))); " is 125.
Long Statement,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The length of the statement  "			this.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 149.
Long Statement,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The length of the statement  "            this.lblTitle.Font = new System.Drawing.Font("Segoe UI"' 12F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The length of the statement  "            this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153))))); " is 125.
Long Statement,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The length of the statement  "            this.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 137.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm)); " is 128.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The length of the statement  "			this.lblStatus.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153))))); " is 126.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The length of the statement  "			this.prgUpdate.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 142.
Complex Conditional,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_actionFinished,The conditional expression  "(e.actionException != null && !m_onRollback) || (m_cancellationPending && m_waitForRollback)"  is complex.
Complex Conditional,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The conditional expression  "(bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)"  is complex.
Empty Catch Block,updateSystemDotNet.Core.Types,changelogDocument,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Types\changelogDocument.cs,changelogDocument,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.applyUpdate,applyCleanupAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCleanupAction.cs,cleanObsoleteData,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.applyUpdate,applyCleanupAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCleanupAction.cs,writeObsoleteData,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,getSubKeys,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,BlockLogOff,The method has an empty catch block.
Magic Number,updateSystemDotNet.Administration.UI.Controls,buttonArea,C:\repos\maximilian-krauss_updateSystem.NET\Source\Administration\UI\Controls\buttonArea.cs,buttonArea,The following statement contains a magic number: Size = new Size(200' 50);
Magic Number,updateSystemDotNet.Administration.UI.Controls,buttonArea,C:\repos\maximilian-krauss_updateSystem.NET\Source\Administration\UI\Controls\buttonArea.cs,buttonArea,The following statement contains a magic number: Size = new Size(200' 50);
Magic Number,updateSystemDotNet.Administration.UI.Controls,buttonArea,C:\repos\maximilian-krauss_updateSystem.NET\Source\Administration\UI\Controls\buttonArea.cs,buttonArea,The following statement contains a magic number: Padding = new Padding(0' 10' 12' 0);
Magic Number,updateSystemDotNet.Administration.UI.Controls,buttonArea,C:\repos\maximilian-krauss_updateSystem.NET\Source\Administration\UI\Controls\buttonArea.cs,buttonArea,The following statement contains a magic number: Padding = new Padding(0' 10' 12' 0);
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: try {  				ushort sections;  				uint timestamp;  				uint pSymbolTable;  				uint noOfSymbol;  				ushort optionalHeaderSize;  				ushort characteristics;  				ushort dataDictionaryStart;  				var dataDictionaryRVA = new uint[16];  				var dataDictionarySize = new uint[16];    				Stream fs = File.OpenRead(filename); //new FileStream(filename' FileMode.Open' FileAccess.Read);  				var reader = new BinaryReader(fs);    				fs.Position = 0x3C;  				uint peHeader = reader.ReadUInt32();  				fs.Position = peHeader;  				uint peHeaderSignature = reader.ReadUInt32();  				ushort machine = reader.ReadUInt16();  				sections = reader.ReadUInt16();  				timestamp = reader.ReadUInt32();  				pSymbolTable = reader.ReadUInt32();  				noOfSymbol = reader.ReadUInt32();  				optionalHeaderSize = reader.ReadUInt16();  				characteristics = reader.ReadUInt16();  				dataDictionaryStart = Convert.ToUInt16(Convert.ToUInt16(fs.Position) + 0x60);  				fs.Position = dataDictionaryStart;  				for (int i = 0; i < 15; i++) {  					dataDictionaryRVA[i] = reader.ReadUInt32();  					dataDictionarySize[i] = reader.ReadUInt32();  				}  				if (dataDictionaryRVA[14] == 0) {  					return false;  				}  				else {  					return true;  				}  			}  			catch {  				return false;  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: try {  				ushort sections;  				uint timestamp;  				uint pSymbolTable;  				uint noOfSymbol;  				ushort optionalHeaderSize;  				ushort characteristics;  				ushort dataDictionaryStart;  				var dataDictionaryRVA = new uint[16];  				var dataDictionarySize = new uint[16];    				Stream fs = File.OpenRead(filename); //new FileStream(filename' FileMode.Open' FileAccess.Read);  				var reader = new BinaryReader(fs);    				fs.Position = 0x3C;  				uint peHeader = reader.ReadUInt32();  				fs.Position = peHeader;  				uint peHeaderSignature = reader.ReadUInt32();  				ushort machine = reader.ReadUInt16();  				sections = reader.ReadUInt16();  				timestamp = reader.ReadUInt32();  				pSymbolTable = reader.ReadUInt32();  				noOfSymbol = reader.ReadUInt32();  				optionalHeaderSize = reader.ReadUInt16();  				characteristics = reader.ReadUInt16();  				dataDictionaryStart = Convert.ToUInt16(Convert.ToUInt16(fs.Position) + 0x60);  				fs.Position = dataDictionaryStart;  				for (int i = 0; i < 15; i++) {  					dataDictionaryRVA[i] = reader.ReadUInt32();  					dataDictionarySize[i] = reader.ReadUInt32();  				}  				if (dataDictionaryRVA[14] == 0) {  					return false;  				}  				else {  					return true;  				}  			}  			catch {  				return false;  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: try {  				ushort sections;  				uint timestamp;  				uint pSymbolTable;  				uint noOfSymbol;  				ushort optionalHeaderSize;  				ushort characteristics;  				ushort dataDictionaryStart;  				var dataDictionaryRVA = new uint[16];  				var dataDictionarySize = new uint[16];    				Stream fs = File.OpenRead(filename); //new FileStream(filename' FileMode.Open' FileAccess.Read);  				var reader = new BinaryReader(fs);    				fs.Position = 0x3C;  				uint peHeader = reader.ReadUInt32();  				fs.Position = peHeader;  				uint peHeaderSignature = reader.ReadUInt32();  				ushort machine = reader.ReadUInt16();  				sections = reader.ReadUInt16();  				timestamp = reader.ReadUInt32();  				pSymbolTable = reader.ReadUInt32();  				noOfSymbol = reader.ReadUInt32();  				optionalHeaderSize = reader.ReadUInt16();  				characteristics = reader.ReadUInt16();  				dataDictionaryStart = Convert.ToUInt16(Convert.ToUInt16(fs.Position) + 0x60);  				fs.Position = dataDictionaryStart;  				for (int i = 0; i < 15; i++) {  					dataDictionaryRVA[i] = reader.ReadUInt32();  					dataDictionarySize[i] = reader.ReadUInt32();  				}  				if (dataDictionaryRVA[14] == 0) {  					return false;  				}  				else {  					return true;  				}  			}  			catch {  				return false;  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: try {  				ushort sections;  				uint timestamp;  				uint pSymbolTable;  				uint noOfSymbol;  				ushort optionalHeaderSize;  				ushort characteristics;  				ushort dataDictionaryStart;  				var dataDictionaryRVA = new uint[16];  				var dataDictionarySize = new uint[16];    				Stream fs = File.OpenRead(filename); //new FileStream(filename' FileMode.Open' FileAccess.Read);  				var reader = new BinaryReader(fs);    				fs.Position = 0x3C;  				uint peHeader = reader.ReadUInt32();  				fs.Position = peHeader;  				uint peHeaderSignature = reader.ReadUInt32();  				ushort machine = reader.ReadUInt16();  				sections = reader.ReadUInt16();  				timestamp = reader.ReadUInt32();  				pSymbolTable = reader.ReadUInt32();  				noOfSymbol = reader.ReadUInt32();  				optionalHeaderSize = reader.ReadUInt16();  				characteristics = reader.ReadUInt16();  				dataDictionaryStart = Convert.ToUInt16(Convert.ToUInt16(fs.Position) + 0x60);  				fs.Position = dataDictionaryStart;  				for (int i = 0; i < 15; i++) {  					dataDictionaryRVA[i] = reader.ReadUInt32();  					dataDictionarySize[i] = reader.ReadUInt32();  				}  				if (dataDictionaryRVA[14] == 0) {  					return false;  				}  				else {  					return true;  				}  			}  			catch {  				return false;  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,Percent,The following statement contains a magic number: try {  				return (int) (((CurrVal/((double) MaxVal))*100.0));  			}  			catch {  				return 100;  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,Percent,The following statement contains a magic number: try {  				return (int) (((CurrVal/((double) MaxVal))*100.0));  			}  			catch {  				return 100;  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,AESEncrypt,The following statement contains a magic number: byte[] KeyBytes = DerivedPassword.GetBytes(KeySize/8);
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,AESDecrypt,The following statement contains a magic number: byte[] KeyBytes = DerivedPassword.GetBytes(KeySize/8);
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  				if (lenght < 1024) {  					return string.Format("{0} Bytes"' lenght.ToString());  				}  				else if (lenght > 1023 && lenght < 1048576) {  					double c_lenght = lenght/1024;  					return string.Format("{0} KB"' c_lenght.ToString("###0.00"));  				}  				else if (lenght >= 1048576 && lenght <= 1043741825) {  					double c_lenght = lenght/(float) (Math.Pow(1024' 2));  					return string.Format("{0} MB"' c_lenght.ToString("###0.00"));  				}    				else {  					return "0 Bytes";  				}  			}  			catch {  				return "0 Bytes";  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  				if (lenght < 1024) {  					return string.Format("{0} Bytes"' lenght.ToString());  				}  				else if (lenght > 1023 && lenght < 1048576) {  					double c_lenght = lenght/1024;  					return string.Format("{0} KB"' c_lenght.ToString("###0.00"));  				}  				else if (lenght >= 1048576 && lenght <= 1043741825) {  					double c_lenght = lenght/(float) (Math.Pow(1024' 2));  					return string.Format("{0} MB"' c_lenght.ToString("###0.00"));  				}    				else {  					return "0 Bytes";  				}  			}  			catch {  				return "0 Bytes";  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  				if (lenght < 1024) {  					return string.Format("{0} Bytes"' lenght.ToString());  				}  				else if (lenght > 1023 && lenght < 1048576) {  					double c_lenght = lenght/1024;  					return string.Format("{0} KB"' c_lenght.ToString("###0.00"));  				}  				else if (lenght >= 1048576 && lenght <= 1043741825) {  					double c_lenght = lenght/(float) (Math.Pow(1024' 2));  					return string.Format("{0} MB"' c_lenght.ToString("###0.00"));  				}    				else {  					return "0 Bytes";  				}  			}  			catch {  				return "0 Bytes";  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  				if (lenght < 1024) {  					return string.Format("{0} Bytes"' lenght.ToString());  				}  				else if (lenght > 1023 && lenght < 1048576) {  					double c_lenght = lenght/1024;  					return string.Format("{0} KB"' c_lenght.ToString("###0.00"));  				}  				else if (lenght >= 1048576 && lenght <= 1043741825) {  					double c_lenght = lenght/(float) (Math.Pow(1024' 2));  					return string.Format("{0} MB"' c_lenght.ToString("###0.00"));  				}    				else {  					return "0 Bytes";  				}  			}  			catch {  				return "0 Bytes";  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  				if (lenght < 1024) {  					return string.Format("{0} Bytes"' lenght.ToString());  				}  				else if (lenght > 1023 && lenght < 1048576) {  					double c_lenght = lenght/1024;  					return string.Format("{0} KB"' c_lenght.ToString("###0.00"));  				}  				else if (lenght >= 1048576 && lenght <= 1043741825) {  					double c_lenght = lenght/(float) (Math.Pow(1024' 2));  					return string.Format("{0} MB"' c_lenght.ToString("###0.00"));  				}    				else {  					return "0 Bytes";  				}  			}  			catch {  				return "0 Bytes";  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  				if (lenght < 1024) {  					return string.Format("{0} Bytes"' lenght.ToString());  				}  				else if (lenght > 1023 && lenght < 1048576) {  					double c_lenght = lenght/1024;  					return string.Format("{0} KB"' c_lenght.ToString("###0.00"));  				}  				else if (lenght >= 1048576 && lenght <= 1043741825) {  					double c_lenght = lenght/(float) (Math.Pow(1024' 2));  					return string.Format("{0} MB"' c_lenght.ToString("###0.00"));  				}    				else {  					return "0 Bytes";  				}  			}  			catch {  				return "0 Bytes";  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  				if (lenght < 1024) {  					return string.Format("{0} Bytes"' lenght.ToString());  				}  				else if (lenght > 1023 && lenght < 1048576) {  					double c_lenght = lenght/1024;  					return string.Format("{0} KB"' c_lenght.ToString("###0.00"));  				}  				else if (lenght >= 1048576 && lenght <= 1043741825) {  					double c_lenght = lenght/(float) (Math.Pow(1024' 2));  					return string.Format("{0} MB"' c_lenght.ToString("###0.00"));  				}    				else {  					return "0 Bytes";  				}  			}  			catch {  				return "0 Bytes";  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  				if (lenght < 1024) {  					return string.Format("{0} Bytes"' lenght.ToString());  				}  				else if (lenght > 1023 && lenght < 1048576) {  					double c_lenght = lenght/1024;  					return string.Format("{0} KB"' c_lenght.ToString("###0.00"));  				}  				else if (lenght >= 1048576 && lenght <= 1043741825) {  					double c_lenght = lenght/(float) (Math.Pow(1024' 2));  					return string.Format("{0} MB"' c_lenght.ToString("###0.00"));  				}    				else {  					return "0 Bytes";  				}  			}  			catch {  				return "0 Bytes";  			}
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,setButtonShield,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6)  				SendMessage(button.Handle' BCM_SETSHIELD' 0' 0xFFFFFFFF);
Magic Number,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,removeButtonShield,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6)  				SendMessage(button.Handle' BCM_SETSHIELD' 0' 0);
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,EncryptString,The following statement contains a magic number: int keySize = dwKeySize/8;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,EncryptString,The following statement contains a magic number: int maxLength = keySize - 42;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core,RSA,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\RSA.cs,DecryptString,The following statement contains a magic number: int base64BlockSize = ((dwKeySize/8)%3 != 0) ? (((dwKeySize/8)/3)*4) + 4 : ((dwKeySize/8)/3)*4;
Magic Number,updateSystemDotNet.Core.Types,VersionEx,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 2) {  				Minor = int.Parse(parts[1]);  			}
Magic Number,updateSystemDotNet.Core.Types,VersionEx,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 3) {  				Build = int.Parse(parts[2]);  			}
Magic Number,updateSystemDotNet.Core.Types,VersionEx,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 3) {  				Build = int.Parse(parts[2]);  			}
Magic Number,updateSystemDotNet.Core.Types,VersionEx,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 4) {  				Revision = int.Parse(parts[3]);  			}
Magic Number,updateSystemDotNet.Core.Types,VersionEx,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 4) {  				Revision = int.Parse(parts[3]);  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryKeyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryKeyAction.cs,executeAction,The following statement contains a magic number: onProgressChanged(  				string.Format(Language.GetString("applyAddRegistryKeyAction_progress")' action.Path' action.rootHive.ToString())'  				100);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryKeyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryKeyAction.cs,rollbackAction,The following statement contains a magic number: onProgressChanged(string.Format(Language.GetString("applyAddRegistryKeyAction_rollback")' m_path)' 100);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The following statement contains a magic number: foreach (string processItem in action.processList) {  				Process[] processes = Process.GetProcessesByName(processItem);  				if (processes.Length > 0) {  					foreach (Process process in processes) {  						try {  							process.CloseMainWindow();  							process.WaitForExit(5000);  							process.Kill();  						}  						catch (Exception) {  							/* TODO: Unbedingt noch was wegen ner gescheiten Fehlerbehandlung überlegen */  						}  					}  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The following statement contains a magic number: foreach (FileType file in action.Files) {  				string fileDirectory = ParsePath(file.Destination);  				string fileCompletePath = Path.Combine(fileDirectory' file.Filename);    				//Überprüfe die filecopyflags  				switch (file.copyFlag) {  					case fileCopyFlags.OnlyIfExists:  						if (!File.Exists(fileCompletePath)) {  							fileCounter++;  							continue;  						}  						break;  					case fileCopyFlags.OnlyIfNotExists:  						if (File.Exists(fileCompletePath)) {  							fileCounter++;  							continue;  						}  						break;  				}    				//Überprüfe ob Verzeichnis existiert  				if (!Directory.Exists(fileDirectory)) {  					Directory.CreateDirectory(fileDirectory);  					SetDirectoryAccessControl(fileDirectory);  				}    				//Überprüfe ob die Datei existiert  				if (File.Exists(fileCompletePath)) {  					string rbFilename = Path.Combine(tempDirectory'  					                                 string.Format("{0}_rollback_{1}"' file.Filename' rnd.Next(5000' 10000)));  					//Wenn die Datei noch nicht gesichert wurde' dann sichern.  					if (!rbFileExists(fileCompletePath)) {  						onProgressChanged(string.Format(Language.GetString("applyFileCopyAction_progressStep_1")' file.Filename)'  						                  Percent(fileCounter' action.Files.Count));  						copyFile(fileCompletePath' rbFilename);  					}    					//Versuche Datei zu löschen  					if (deleteFile(fileCompletePath)) {  						m_rollbackFiles.Add(new rollbackFile(fileCompletePath' rbFilename));  					}  					else {  						throw new userCancelledException();  					}  				}  				else {  					m_rollbackFiles.Add(new rollbackFile(fileCompletePath' string.Empty));  				}    				onProgressChanged(string.Format(Language.GetString("applyFileCopyAction_progressStep_2")' file.Filename)'  				                  Percent(fileCounter' action.Files.Count));  				byte[] data = Decompress(accessUpdatePackage(packageFile' file.ID));  				onProgressChanged(string.Format(Language.GetString("applyFileCopyAction_progressStep_3")' file.Filename)'  				                  Percent(fileCounter' action.Files.Count));  				File.WriteAllBytes(fileCompletePath' data);    				SetFileAccessControl(fileCompletePath);    				//NGen Image erzeugen  				//if (Core.Helper.IsNetAssembly(fileCompletePath))  				//{  				//    //onProgressChanged(string.Format("Optimiere .Net Assembly '{0}'..."' file.Filename)' Percent(fileCounter' action.Files.Count));  				//    //NGenUninstall(fileCompletePath);  				//    //NGenInstall(fileCompletePath);  				//}    				if (fileCompletePath.EndsWith(".exe") && currentConfiguration.ServerConfiguration.generateNativeImages &&  				    assemblyInfo.FromFile(fileCompletePath) != null) {  					onProgressChanged(Language.GetString("applyFileCopyAction_progressStep_4")'  					                  Percent(fileCounter' action.Files.Count));  					NGenUninstall(fileCompletePath);  					NGenInstall(fileCompletePath);  				}    				fileCounter++;  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The following statement contains a magic number: foreach (FileType file in action.Files) {  				string fileDirectory = ParsePath(file.Destination);  				string fileCompletePath = Path.Combine(fileDirectory' file.Filename);    				//Überprüfe die filecopyflags  				switch (file.copyFlag) {  					case fileCopyFlags.OnlyIfExists:  						if (!File.Exists(fileCompletePath)) {  							fileCounter++;  							continue;  						}  						break;  					case fileCopyFlags.OnlyIfNotExists:  						if (File.Exists(fileCompletePath)) {  							fileCounter++;  							continue;  						}  						break;  				}    				//Überprüfe ob Verzeichnis existiert  				if (!Directory.Exists(fileDirectory)) {  					Directory.CreateDirectory(fileDirectory);  					SetDirectoryAccessControl(fileDirectory);  				}    				//Überprüfe ob die Datei existiert  				if (File.Exists(fileCompletePath)) {  					string rbFilename = Path.Combine(tempDirectory'  					                                 string.Format("{0}_rollback_{1}"' file.Filename' rnd.Next(5000' 10000)));  					//Wenn die Datei noch nicht gesichert wurde' dann sichern.  					if (!rbFileExists(fileCompletePath)) {  						onProgressChanged(string.Format(Language.GetString("applyFileCopyAction_progressStep_1")' file.Filename)'  						                  Percent(fileCounter' action.Files.Count));  						copyFile(fileCompletePath' rbFilename);  					}    					//Versuche Datei zu löschen  					if (deleteFile(fileCompletePath)) {  						m_rollbackFiles.Add(new rollbackFile(fileCompletePath' rbFilename));  					}  					else {  						throw new userCancelledException();  					}  				}  				else {  					m_rollbackFiles.Add(new rollbackFile(fileCompletePath' string.Empty));  				}    				onProgressChanged(string.Format(Language.GetString("applyFileCopyAction_progressStep_2")' file.Filename)'  				                  Percent(fileCounter' action.Files.Count));  				byte[] data = Decompress(accessUpdatePackage(packageFile' file.ID));  				onProgressChanged(string.Format(Language.GetString("applyFileCopyAction_progressStep_3")' file.Filename)'  				                  Percent(fileCounter' action.Files.Count));  				File.WriteAllBytes(fileCompletePath' data);    				SetFileAccessControl(fileCompletePath);    				//NGen Image erzeugen  				//if (Core.Helper.IsNetAssembly(fileCompletePath))  				//{  				//    //onProgressChanged(string.Format("Optimiere .Net Assembly '{0}'..."' file.Filename)' Percent(fileCounter' action.Files.Count));  				//    //NGenUninstall(fileCompletePath);  				//    //NGenInstall(fileCompletePath);  				//}    				if (fileCompletePath.EndsWith(".exe") && currentConfiguration.ServerConfiguration.generateNativeImages &&  				    assemblyInfo.FromFile(fileCompletePath) != null) {  					onProgressChanged(Language.GetString("applyFileCopyAction_progressStep_4")'  					                  Percent(fileCounter' action.Files.Count));  					NGenUninstall(fileCompletePath);  					NGenInstall(fileCompletePath);  				}    				fileCounter++;  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The following statement contains a magic number: onProgressChanged(Language.GetString("applyRemoveRegistryKeyAction_progressStep_1")' 30);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The following statement contains a magic number: onProgressChanged(Language.GetString("applyRemoveRegistryKeyAction_progressStep_2")' 60);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The following statement contains a magic number: onProgressChanged(  				string.Format(Language.GetString("applyRemoveRegistryKeyAction_progressStep_3")' rootKey' action.Path)' 100);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRenameFileAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRenameFileAction.cs,executeAction,The following statement contains a magic number: if (File.Exists(rPath)) {  				onProgressChanged(string.Format(Language.GetString("applyRenameFileAction_progress")' new FileInfo(rPath).Name)' 100);    				copyFile(rPath' newPath);  				deleteFile(rPath);  				m_originalPath = rPath;  				m_renamedPath = newPath;  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRenameFileAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRenameFileAction.cs,rollbackAction,The following statement contains a magic number: onProgressChanged(  				string.Format(Language.GetString("applyRenameFileAction_rollback")' new FileInfo(m_renamedPath).Name)' 100);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartProcessAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartProcessAction.cs,executeAction,The following statement contains a magic number: onProgressChanged(  				string.Format(Language.GetString("applyStartProcessAction_progress")' new FileInfo(filePath).Name)' 100);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: foreach (ServiceController service in services) {  				if (string.Equals(service.ServiceName.ToLower()' action.serviceName.ToLower())) {  					switch (service.Status) {  						case ServiceControllerStatus.Stopped: //Dienst starten    							//Status senden  							onProgressChanged(  								string.Format(Language.GetString("applyStartServiceAction_startService")' service.DisplayName)' 100);    							//Dienst starten  							if (!string.IsNullOrEmpty(action.Arguments)) {  								service.Start(action.Arguments.Split(' '));  							}  							else {  								service.Start();  							}  							//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  							service.WaitForStatus(ServiceControllerStatus.Running' m_timeout);    							//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  							if (service.Status != ServiceControllerStatus.Running) {  								throw new startServiceException(service.DisplayName);  							}    							break;    						case ServiceControllerStatus.Running:  							if (action.restartIfRunnig)  								//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  							{  								//Status senden  								onProgressChanged(  									string.Format(Language.GetString("applyStartServiceAction_stopService")' service.DisplayName)' 100);  								//Dienst anhalten  								service.Stop();  								//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  								service.WaitForStatus(ServiceControllerStatus.Stopped' m_timeout);    								//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  								if (service.Status == ServiceControllerStatus.Stopped) {  									//Status senden  									onProgressChanged(  										string.Format(Language.GetString("applyStartServiceAction_startService")' service.DisplayName)' 100);    									//Dienst starten  									if (!string.IsNullOrEmpty(action.Arguments)) {  										service.Start(action.Arguments.Split(' '));  									}  									else {  										service.Start();  									}    									service.WaitForStatus(ServiceControllerStatus.Running' m_timeout);  									if (service.Status != ServiceControllerStatus.Running) {  										throw new stopServiceException(service.DisplayName);  									}  								}  								else //Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  								{  									throw new startServiceException(service.DisplayName);  								}  							}  							break;  					}  					return; //Schleife beenden' da Dienst gefunden.  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: foreach (ServiceController service in services) {  				if (string.Equals(service.ServiceName.ToLower()' action.serviceName.ToLower())) {  					switch (service.Status) {  						case ServiceControllerStatus.Stopped: //Dienst starten    							//Status senden  							onProgressChanged(  								string.Format(Language.GetString("applyStartServiceAction_startService")' service.DisplayName)' 100);    							//Dienst starten  							if (!string.IsNullOrEmpty(action.Arguments)) {  								service.Start(action.Arguments.Split(' '));  							}  							else {  								service.Start();  							}  							//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  							service.WaitForStatus(ServiceControllerStatus.Running' m_timeout);    							//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  							if (service.Status != ServiceControllerStatus.Running) {  								throw new startServiceException(service.DisplayName);  							}    							break;    						case ServiceControllerStatus.Running:  							if (action.restartIfRunnig)  								//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  							{  								//Status senden  								onProgressChanged(  									string.Format(Language.GetString("applyStartServiceAction_stopService")' service.DisplayName)' 100);  								//Dienst anhalten  								service.Stop();  								//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  								service.WaitForStatus(ServiceControllerStatus.Stopped' m_timeout);    								//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  								if (service.Status == ServiceControllerStatus.Stopped) {  									//Status senden  									onProgressChanged(  										string.Format(Language.GetString("applyStartServiceAction_startService")' service.DisplayName)' 100);    									//Dienst starten  									if (!string.IsNullOrEmpty(action.Arguments)) {  										service.Start(action.Arguments.Split(' '));  									}  									else {  										service.Start();  									}    									service.WaitForStatus(ServiceControllerStatus.Running' m_timeout);  									if (service.Status != ServiceControllerStatus.Running) {  										throw new stopServiceException(service.DisplayName);  									}  								}  								else //Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  								{  									throw new startServiceException(service.DisplayName);  								}  							}  							break;  					}  					return; //Schleife beenden' da Dienst gefunden.  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: foreach (ServiceController service in services) {  				if (string.Equals(service.ServiceName.ToLower()' action.serviceName.ToLower())) {  					switch (service.Status) {  						case ServiceControllerStatus.Stopped: //Dienst starten    							//Status senden  							onProgressChanged(  								string.Format(Language.GetString("applyStartServiceAction_startService")' service.DisplayName)' 100);    							//Dienst starten  							if (!string.IsNullOrEmpty(action.Arguments)) {  								service.Start(action.Arguments.Split(' '));  							}  							else {  								service.Start();  							}  							//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  							service.WaitForStatus(ServiceControllerStatus.Running' m_timeout);    							//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  							if (service.Status != ServiceControllerStatus.Running) {  								throw new startServiceException(service.DisplayName);  							}    							break;    						case ServiceControllerStatus.Running:  							if (action.restartIfRunnig)  								//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  							{  								//Status senden  								onProgressChanged(  									string.Format(Language.GetString("applyStartServiceAction_stopService")' service.DisplayName)' 100);  								//Dienst anhalten  								service.Stop();  								//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  								service.WaitForStatus(ServiceControllerStatus.Stopped' m_timeout);    								//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  								if (service.Status == ServiceControllerStatus.Stopped) {  									//Status senden  									onProgressChanged(  										string.Format(Language.GetString("applyStartServiceAction_startService")' service.DisplayName)' 100);    									//Dienst starten  									if (!string.IsNullOrEmpty(action.Arguments)) {  										service.Start(action.Arguments.Split(' '));  									}  									else {  										service.Start();  									}    									service.WaitForStatus(ServiceControllerStatus.Running' m_timeout);  									if (service.Status != ServiceControllerStatus.Running) {  										throw new stopServiceException(service.DisplayName);  									}  								}  								else //Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  								{  									throw new startServiceException(service.DisplayName);  								}  							}  							break;  					}  					return; //Schleife beenden' da Dienst gefunden.  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStopServiceAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStopServiceAction.cs,executeAction,The following statement contains a magic number: var timeout = new TimeSpan(0' 0' 10);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStopServiceAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStopServiceAction.cs,executeAction,The following statement contains a magic number: foreach (ServiceController service in services) {  				if (string.Equals(service.ServiceName.ToLower()' action.serviceName.ToLower())) {  					//Überprüfe ob der Dienst läuft  					if (service.Status == ServiceControllerStatus.Running) {  						//Status senden  						onProgressChanged(string.Format(Language.GetString("applyStopServiceAction_stopService")' service.DisplayName)'  						                  100);  						service.Stop();  						service.WaitForStatus(ServiceControllerStatus.Stopped' timeout);  						if (service.Status != ServiceControllerStatus.Stopped) {  							throw new stopServiceException(service.DisplayName);  						}  					}  					break;  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,Percent,The following statement contains a magic number: try {  				return (int) (((CurrVal/((double) MaxVal))*100.0));  			}  			catch {  				return 100;  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,Percent,The following statement contains a magic number: try {  				return (int) (((CurrVal/((double) MaxVal))*100.0));  			}  			catch {  				return 100;  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,GetClrInstallationDirectory,The following statement contains a magic number: int capacity = 260;
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,NGenInstall,The following statement contains a magic number: process.WaitForExit(60*1000);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,NGenInstall,The following statement contains a magic number: process.WaitForExit(60*1000);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,NGenUninstall,The following statement contains a magic number: process.WaitForExit(60*1000);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,NGenUninstall,The following statement contains a magic number: process.WaitForExit(60*1000);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (updateProgressChanged != null) {  				if (m_onRollback) {  					var rArgs = new applyUpdateProgressChangedEventArgs(  						Language.GetString("applyUpdateManager_rollback")'  						e.actionDescription'  						Percent(e.percentDone + (applyUpdateActionCount*100)' m_performedUpdateActions.Count*100));  				}  				else {  					var eArgs = new applyUpdateProgressChangedEventArgs(  						e.actionName'  						e.actionDescription'  						Percent(e.percentDone + (applyUpdateActionCount*100)' m_updateActions.Count*100));  					updateProgressChanged(this' eArgs);  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (updateProgressChanged != null) {  				if (m_onRollback) {  					var rArgs = new applyUpdateProgressChangedEventArgs(  						Language.GetString("applyUpdateManager_rollback")'  						e.actionDescription'  						Percent(e.percentDone + (applyUpdateActionCount*100)' m_performedUpdateActions.Count*100));  				}  				else {  					var eArgs = new applyUpdateProgressChangedEventArgs(  						e.actionName'  						e.actionDescription'  						Percent(e.percentDone + (applyUpdateActionCount*100)' m_updateActions.Count*100));  					updateProgressChanged(this' eArgs);  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (updateProgressChanged != null) {  				if (m_onRollback) {  					var rArgs = new applyUpdateProgressChangedEventArgs(  						Language.GetString("applyUpdateManager_rollback")'  						e.actionDescription'  						Percent(e.percentDone + (applyUpdateActionCount*100)' m_performedUpdateActions.Count*100));  				}  				else {  					var eArgs = new applyUpdateProgressChangedEventArgs(  						e.actionName'  						e.actionDescription'  						Percent(e.percentDone + (applyUpdateActionCount*100)' m_updateActions.Count*100));  					updateProgressChanged(this' eArgs);  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (updateProgressChanged != null) {  				if (m_onRollback) {  					var rArgs = new applyUpdateProgressChangedEventArgs(  						Language.GetString("applyUpdateManager_rollback")'  						e.actionDescription'  						Percent(e.percentDone + (applyUpdateActionCount*100)' m_performedUpdateActions.Count*100));  				}  				else {  					var eArgs = new applyUpdateProgressChangedEventArgs(  						e.actionName'  						e.actionDescription'  						Percent(e.percentDone + (applyUpdateActionCount*100)' m_updateActions.Count*100));  					updateProgressChanged(this' eArgs);  				}  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,Percent,The following statement contains a magic number: try {  				return (int) (((CurrVal/((double) MaxVal))*100.0));  			}  			catch {  				return 100;  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,Percent,The following statement contains a magic number: try {  				return (int) (((CurrVal/((double) MaxVal))*100.0));  			}  			catch {  				return 100;  			}
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUserInteractionAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUserInteractionAction.cs,executeAction,The following statement contains a magic number: onProgressChanged(""' 100);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyValidatePackageSignature,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyValidatePackageSignature.cs,executeAction,The following statement contains a magic number: onProgressChanged(Language.GetString("applyValidatePackageAction_progressStep_1")' 50);
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyValidatePackageSignature,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyValidatePackageSignature.cs,executeAction,The following statement contains a magic number: onProgressChanged(Language.GetString("applyValidatePackageAction_progressStep_2")' 100);
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater,assemblyInfo,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream(file' FileMode.Open' FileAccess.Read)) {  				using (var r = new BinaryReader(s)) {  					byte[] bytes = r.ReadBytes(2);    					// Verify file starts with "MZ" signature.  					if ((bytes[0] != 0x4d) || (bytes[1] != 0x5a)) {  						// Not a PE file.  						return null;  					}    					// Partion II' 25.2.1    					// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  					s.Seek(0x3c' SeekOrigin.Begin);    					// read the offset to the PE Header  					uint offset = r.ReadUInt32();    					// go to the beginning of the PE Header  					s.Seek(offset' SeekOrigin.Begin);    					bytes = r.ReadBytes(4);    					// Verify PE header starts with 'PE\0\0'.  					if ((bytes[0] != 0x50) || (bytes[1] != 0x45) || (bytes[2] != 0) || (bytes[3] != 0)) {  						// Not a PE file.  						return null;  					}      					// It's a PE file' verify that it has the right "machine" code.  					// Partion II' 25.2.2  					//  					ushort machineCode = r.ReadUInt16();    					// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  					// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  					if (!(machineCode == 0x014c || machineCode == 0x8664)) {  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Locate the PE_OPTIONAL_HEADER      					// The PE_FILE_HEADER is 20bytes long we already  					// read the 2 byte machine code (hence 18byte seek)  					s.Seek(18' SeekOrigin.Current);    					ushort magic = r.ReadUInt16();    					switch (magic) {  						case 0x10b: // PE32    							// set to AnyCPU for now - we'll check later if image is x86 specific  							assembInfo.CPUVersion = CPUVersion.AnyCPU;    							break;    						case 0x20b: // PE32+ (aka x64)  							assembInfo.CPUVersion = CPUVersion.x64;  							break;    						default: // unknown assembly type  							return null;  					}      					// Read the SectionAlignment & FileAlignment for  					// conversion from RVA to file address  					s.Seek(30' SeekOrigin.Current);    					uint sectionAlignment = r.ReadUInt32();  					uint fileAlignment = r.ReadUInt32();      					// go to 'NumberOfRvaAndSizes' in the PE Header  					// at 92/108 from start of PE Header for PE32/PE32+  					s.Seek(magic == 0x10b ? 52 : 68' SeekOrigin.Current);    					// verify that the number of data directories is 0x10.    					uint numDataDirs = r.ReadUInt32(); // Partition II' 25.2.3.2    					if (numDataDirs != 0x10) // Partition II' 25.2.3.2  					{  						// Invalid or unrecognized PE file of some kind.  						return null;  					}      					// Go to the CLR Runtime Header  					// at 208/224 from start of PE Header for PE32/PE32+  					s.Seek(112' SeekOrigin.Current);      					// Check for the existence of a non-null CLI header.  					// If found' this is an assembly of some kind' otherwise  					// it's a native PE file of one kind or another.    					uint rvaCLIHeader = r.ReadUInt32(); // Partition II' 25.2.3.3' CLI Header (rva)  					// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)    					if (rvaCLIHeader == 0) {  						// Not an assembly.  						return null;  					}      					// Partition II' 25.3.3 (CLI Header)      					// Go to the begginning of the CLI header (RVA -> file address)    					/*  					-> Converting from Relative Virtual Address to File Address:    					   FA = RVA - sectionAlignment + fileAlignment  				   						   The section alignment in memory is sectionAlignment (usually 0x2000)'  					   and since the RVA for the CLR header is 2008' on subtracting 2000 from  					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes  					   away from the start of the section.     						   A file on disk has the alignment of fileAlignment (usually 512 bytes).  					   Therefore' the first section would start at position 512 from the start  					   of the file. As the CLR is 8 bytes away from the section start' 8 is added  					   to 512' (section start for a file on disk)' thereby arriving at a value of 520.  					   The next 72 bytes (0x48) are picked up from this position' since they  					   constitute the CLR header' and they are loaded at location 0x4002008.    					*/    					// Also' skip the CLI header size = 4 bytes  					s.Seek((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);    					ushort majorVersion = r.ReadUInt16();  					ushort minorVersion = r.ReadUInt16();    					// 2.5 means the file is a .NET Framework 2.0+ assembly  					if (!(majorVersion == 2 && minorVersion == 5))  						return null;      					// RVA for the MetaData (we'll read the metadata later)  					uint rvaMetaData = r.ReadUInt32();  					s.Seek(4' SeekOrigin.Current); // skip the size    					// Partition II' 25.3.3.1    					// read the CLI flags  					uint cliFlags = r.ReadUInt32();    					// Detect if compiled with Platform Target of "x86"  					// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  					if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  						assembInfo.CPUVersion = CPUVersion.x86;  					}    					// Detect if the assembly is built with a strong name  					// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  					assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);    					s.Seek((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);      					// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)    					// read the version string length  					int versionLen = r.ReadInt32();    					char[] versionStr = r.ReadChars(versionLen);    					// read the .NET framework version required from the meta-data  					//Note: we only read the first 2 numbers of the version - if you want to  					//      detect beta vs. rc vs. rtm' then read the whole version.  					// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  					if (versionStr[1] == '2' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  					else if (versionStr[1] == '4' && versionStr[3] == '0')  						assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  					else  						assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,dlgTemplate,The following statement contains a magic number: var f = new Font("Tahoma"' 8);
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 52)' new Point(Width' 52));    				int TextWidth;  				if (m_Image == null) {  					TextWidth = 10;  				}  				else {  					TextWidth = 50;  				}    				//Draw Text  				e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  				e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  				TextRenderer.DrawText(e.Graphics' m_Title' new Font("Tahoma"' 8' FontStyle.Bold)' new Point(TextWidth' 5)'  				                      m_TitleColor);  				Size DesSize = TextRenderer.MeasureText(m_description' new Font("Tahoma"' 8));  				var DesBounds = new Rectangle(TextWidth' 20' DesSize.Width' DesSize.Height);  				TextRenderer.DrawText(e.Graphics' m_description' new Font("Tahoma"' 8)' DesBounds' m_DescriptionColor);    				//DrawImage  				if (m_Image != null) {  					e.Graphics.DrawImage(m_Image' new Point(5' 10));  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: var rectBottom = new Rectangle(0' ClientRectangle.Height - 34' ClientRectangle.Width' 34);
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: var rectBottom = new Rectangle(0' ClientRectangle.Height - 34' ClientRectangle.Width' 34);
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.FillRectangle(new SolidBrush(Color.FromArgb(240' 240' 240))' rectBottom);
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.FillRectangle(new SolidBrush(Color.FromArgb(240' 240' 240))' rectBottom);
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.FillRectangle(new SolidBrush(Color.FromArgb(240' 240' 240))' rectBottom);
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' ClientRectangle.Height - 34)'  			                    new Point(ClientRectangle.Width' ClientRectangle.Height - 34));
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' ClientRectangle.Height - 34)'  			                    new Point(ClientRectangle.Width' ClientRectangle.Height - 34));
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' ClientRectangle.Height - 34)'  			                    new Point(ClientRectangle.Width' ClientRectangle.Height - 34));
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' ClientRectangle.Height - 34)'  			                    new Point(ClientRectangle.Width' ClientRectangle.Height - 34));
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' ClientRectangle.Height - 34)'  			                    new Point(ClientRectangle.Width' ClientRectangle.Height - 34));
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,statusLabel,The following statement contains a magic number: tmrCircle.Interval = 50;
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,tmrCircle_Tick,The following statement contains a magic number: if (circleIndex >= 18) {  				circleIndex = 0;  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: int textPaddingLeft = 3 + 16 + 5;
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: int textPaddingLeft = 3 + 16 + 5;
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: int textPaddingLeft = 3 + 16 + 5;
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: if (_state != statusLabelStates.Waiting) {  				Image image = null;    				switch (_state) {  					case statusLabelStates.Success:  						image = getResourceImage("statuslabel_success.png");  						break;  					case statusLabelStates.Failure:  						image = getResourceImage("statuslabel_error.png");  						break;  					case statusLabelStates.Progress:  						image = getCircleImage();  						break;  				}  				e.Graphics.DrawImage(image'  				                     new Rectangle(new Point(3' (ClientRectangle.Height/2) - (image.Height/2))'  				                                   new Size(image.Width' image.Height)));  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: if (_state != statusLabelStates.Waiting) {  				Image image = null;    				switch (_state) {  					case statusLabelStates.Success:  						image = getResourceImage("statuslabel_success.png");  						break;  					case statusLabelStates.Failure:  						image = getResourceImage("statuslabel_error.png");  						break;  					case statusLabelStates.Progress:  						image = getCircleImage();  						break;  				}  				e.Graphics.DrawImage(image'  				                     new Rectangle(new Point(3' (ClientRectangle.Height/2) - (image.Height/2))'  				                                   new Size(image.Width' image.Height)));  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: if (_state != statusLabelStates.Waiting) {  				Image image = null;    				switch (_state) {  					case statusLabelStates.Success:  						image = getResourceImage("statuslabel_success.png");  						break;  					case statusLabelStates.Failure:  						image = getResourceImage("statuslabel_error.png");  						break;  					case statusLabelStates.Progress:  						image = getCircleImage();  						break;  				}  				e.Graphics.DrawImage(image'  				                     new Rectangle(new Point(3' (ClientRectangle.Height/2) - (image.Height/2))'  				                                   new Size(image.Width' image.Height)));  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: var circle = new Bitmap(16' 16);
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: var circle = new Bitmap(16' 16);
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(circle)) {  				g.DrawImage(  					getResourceImage("statuslabel_progress.png")'  					new Rectangle(0' 0' 16' 16)'  					new Rectangle(0' (16*circleIndex)' 16' 16)'  					GraphicsUnit.Pixel  					);  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(circle)) {  				g.DrawImage(  					getResourceImage("statuslabel_progress.png")'  					new Rectangle(0' 0' 16' 16)'  					new Rectangle(0' (16*circleIndex)' 16' 16)'  					GraphicsUnit.Pixel  					);  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(circle)) {  				g.DrawImage(  					getResourceImage("statuslabel_progress.png")'  					new Rectangle(0' 0' 16' 16)'  					new Rectangle(0' (16*circleIndex)' 16' 16)'  					GraphicsUnit.Pixel  					);  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(circle)) {  				g.DrawImage(  					getResourceImage("statuslabel_progress.png")'  					new Rectangle(0' 0' 16' 16)'  					new Rectangle(0' (16*circleIndex)' 16' 16)'  					GraphicsUnit.Pixel  					);  			}
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(circle)) {  				g.DrawImage(  					getResourceImage("statuslabel_progress.png")'  					new Rectangle(0' 0' 16' 16)'  					new Rectangle(0' (16*circleIndex)' 16' 16)'  					GraphicsUnit.Pixel  					);  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,Close_Process,The following statement contains a magic number: try {  				Process[] processes = Process.GetProcessesByName(proc_name);  				if (processes.Length > 0) {  					foreach (Process proc in processes) {  						proc.CloseMainWindow();  						proc.WaitForExit(0x1388);  						proc.Kill();  					}  				}  				Thread.Sleep(500);  			}  			catch (Exception ex) {  				MessageBox.Show(ex.Message' "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error);  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Location = new System.Drawing.Point(0' 187);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.MaximumSize = new System.Drawing.Size(0' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.MinimumSize = new System.Drawing.Size(0' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding(3);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size(379' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size(379' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.TabIndex = 4;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(297' 6);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(297' 6);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.MinimumSize = new System.Drawing.Size(64' 0);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(73' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(73' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.Location = new System.Drawing.Point(12' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.Location = new System.Drawing.Point(12' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.Size = new System.Drawing.Size(50' 50);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.Size = new System.Drawing.Size(50' 50);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.TabIndex = 5;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point(68' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point(68' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size(247' 16);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size(247' 16);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.TabIndex = 6;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.Location = new System.Drawing.Point(12' 68);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.Location = new System.Drawing.Point(12' 68);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.Size = new System.Drawing.Size(247' 113);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.Size = new System.Drawing.Size(247' 113);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.TabIndex = 7;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.columnHeader1.Width = 219;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.Location = new System.Drawing.Point(265' 68);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.Location = new System.Drawing.Point(265' 68);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.Size = new System.Drawing.Size(105' 23);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.Size = new System.Drawing.Size(105' 23);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.TabIndex = 8;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.Location = new System.Drawing.Point(265' 97);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.Location = new System.Drawing.Point(265' 97);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.Size = new System.Drawing.Size(105' 23);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.Size = new System.Drawing.Size(105' 23);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.TabIndex = 9;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.Location = new System.Drawing.Point(68' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.Location = new System.Drawing.Point(68' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.Size = new System.Drawing.Size(302' 28);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.Size = new System.Drawing.Size(302' 28);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.TabIndex = 10;
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(379' 221);
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(379' 221);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.pnlBottom.Location = new System.Drawing.Point(0' 148);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.pnlBottom.Size = new System.Drawing.Size(346' 35);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.pnlBottom.Size = new System.Drawing.Size(346' 35);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.pnlBottom.TabIndex = 21;
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Location = new System.Drawing.Point(-20' 0);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.MinimumSize = new System.Drawing.Size(0' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding(3' 4' 3' 3);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding(3' 4' 3' 3);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding(3' 4' 3' 3);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding(3' 4' 3' 3);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size(366' 35);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size(366' 35);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.TabIndex = 11;
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.Location = new System.Drawing.Point(247' 7);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.Location = new System.Drawing.Point(247' 7);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.MinimumSize = new System.Drawing.Size(64' 21);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.MinimumSize = new System.Drawing.Size(64' 21);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.Size = new System.Drawing.Size(110' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.Size = new System.Drawing.Size(110' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.Location = new System.Drawing.Point(160' 7);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.Location = new System.Drawing.Point(160' 7);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.MinimumSize = new System.Drawing.Size(64' 21);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.MinimumSize = new System.Drawing.Size(64' 21);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.Size = new System.Drawing.Size(81' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.Size = new System.Drawing.Size(81' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.Location = new System.Drawing.Point(50' 39);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.Location = new System.Drawing.Point(50' 39);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.Size = new System.Drawing.Size(287' 106);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.Size = new System.Drawing.Size(287' 106);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.TabIndex = 23;
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point(47' 9);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point(47' 9);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size(161' 18);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size(161' 18);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.TabIndex = 22;
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.Location = new System.Drawing.Point(9' 9);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.Location = new System.Drawing.Point(9' 9);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.Size = new System.Drawing.Size(32' 32);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.Size = new System.Drawing.Size(32' 32);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.TabIndex = 24;
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(346' 183);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(346' 183);
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.TitleColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.TitleColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: SetClientSizeCore(ClientRectangle.Width' (12 + lblTitle.Height + 10 + lblMessage.Height + 12 + flpBottom.Height));
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: SetClientSizeCore(ClientRectangle.Width' (12 + lblTitle.Height + 10 + lblMessage.Height + 12 + flpBottom.Height));
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: SetClientSizeCore(ClientRectangle.Width' (12 + lblTitle.Height + 10 + lblMessage.Height + 12 + flpBottom.Height));
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: lblMessage.Location = new Point(lblMessage.Location.X' (12 + lblTitle.Height + 10));
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: lblMessage.Location = new Point(lblMessage.Location.X' (12 + lblTitle.Height + 10));
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  				e.Graphics.Clear(Color.FromArgb(240' 240' 240));  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 0)'  				                    new Point(flpBottom.ClientRectangle.Width' 0));  			}  			catch {  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  				e.Graphics.Clear(Color.FromArgb(240' 240' 240));  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 0)'  				                    new Point(flpBottom.ClientRectangle.Width' 0));  			}  			catch {  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  				e.Graphics.Clear(Color.FromArgb(240' 240' 240));  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 0)'  				                    new Point(flpBottom.ClientRectangle.Width' 0));  			}  			catch {  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  				e.Graphics.Clear(Color.FromArgb(240' 240' 240));  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 0)'  				                    new Point(flpBottom.ClientRectangle.Width' 0));  			}  			catch {  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  				e.Graphics.Clear(Color.FromArgb(240' 240' 240));  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 0)'  				                    new Point(flpBottom.ClientRectangle.Width' 0));  			}  			catch {  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  				e.Graphics.Clear(Color.FromArgb(240' 240' 240));  				e.Graphics.DrawLine(new Pen(Color.FromArgb(223' 223' 223)' 1)' new Point(0' 0)'  				                    new Point(flpBottom.ClientRectangle.Width' 0));  			}  			catch {  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Location = new System.Drawing.Point(0' 118);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.MinimumSize = new System.Drawing.Size(0' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding(3);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size(350' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size(350' 34);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.TabIndex = 13;
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(274' 6);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(274' 6);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.MinimumSize = new System.Drawing.Size(64' 0);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(67' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(67' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Location = new System.Drawing.Point(204' 6);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Location = new System.Drawing.Point(204' 6);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.MinimumSize = new System.Drawing.Size(64' 0);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Size = new System.Drawing.Size(64' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Size = new System.Drawing.Size(64' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.TabIndex = 3;
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.Location = new System.Drawing.Point(51' 51);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.Location = new System.Drawing.Point(51' 51);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.MaximumSize = new System.Drawing.Size(288' 0);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.MinimumSize = new System.Drawing.Size(0' 50);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.Size = new System.Drawing.Size(65' 50);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.Size = new System.Drawing.Size(65' 50);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.TabIndex = 16;
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point(50' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point(50' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.MaximumSize = new System.Drawing.Size(288' 0);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.MinimumSize = new System.Drawing.Size(0' 20);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size(54' 21);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size(54' 21);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.TabIndex = 15;
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.Location = new System.Drawing.Point(12' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.Location = new System.Drawing.Point(12' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.Size = new System.Drawing.Size(32' 32);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.Size = new System.Drawing.Size(32' 32);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.TabIndex = 14;
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(350' 152);
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(350' 152);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm,The following statement contains a magic number: lblStatus.Font = new Font(SystemFonts.MessageBoxFont.FontFamily' 12);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The following statement contains a magic number: if (m_updateManager.isBusy) {  				e.Cancel = true;  			}  			else {  				BlockLogOff(false);    				if (m_updateManager.currentConfig.Settings.restartApplication &&  				    File.Exists(m_updateManager.currentConfig.Settings.applicationPath)) {  					if (Environment.OSVersion.Version.Major >= 6 && IsAdmin()) {  						IntPtr hProcess = IntPtr.Zero;  						Security.ExecRequireNonAdmin(this' m_updateManager.currentConfig.Settings.applicationPath'  						                             extendCommandLineArguments()' out hProcess);    						//Wenn Prozess nicht gestartet' dann normal starten  						try {  							if (hProcess == IntPtr.Zero)  								Process.Start(m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments());  						}  						catch (Win32Exception) {  						}  					}  					else {  						try {  							Process.Start(m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments());  						}  						catch (Win32Exception) {  						}  					}  				}  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The following statement contains a magic number: Location = new Point(  				(Screen.PrimaryScreen.WorkingArea.Width/2) - (Width/2)'  				(Screen.PrimaryScreen.WorkingArea.Height/2) - (Height/2));
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The following statement contains a magic number: Location = new Point(  				(Screen.PrimaryScreen.WorkingArea.Width/2) - (Width/2)'  				(Screen.PrimaryScreen.WorkingArea.Height/2) - (Height/2));
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The following statement contains a magic number: Location = new Point(  				(Screen.PrimaryScreen.WorkingArea.Width/2) - (Width/2)'  				(Screen.PrimaryScreen.WorkingArea.Height/2) - (Height/2));
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The following statement contains a magic number: Location = new Point(  				(Screen.PrimaryScreen.WorkingArea.Width/2) - (Width/2)'  				(Screen.PrimaryScreen.WorkingArea.Height/2) - (Height/2));
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,BlockLogOff,The following statement contains a magic number: if (Environment.OSVersion.Version.Major < 6) {  				return;  			}
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Location = new System.Drawing.Point(50' 5);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Location = new System.Drawing.Point(50' 5);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Size = new System.Drawing.Size(336' 32);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Size = new System.Drawing.Size(336' 32);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.TabIndex = 11;
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.Location = new System.Drawing.Point(12' 5);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.Location = new System.Drawing.Point(12' 5);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.Size = new System.Drawing.Size(32' 32);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.Size = new System.Drawing.Size(32' 32);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.TabIndex = 15;
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Location = new System.Drawing.Point(0' 158);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Padding = new System.Windows.Forms.Padding(0' 10' 12' 0);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Padding = new System.Windows.Forms.Padding(0' 10' 12' 0);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Size = new System.Drawing.Size(398' 43);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Size = new System.Drawing.Size(398' 43);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.TabIndex = 18;
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(316' 13);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(316' 13);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(67' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(67' 22);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.Location = new System.Drawing.Point(12' 52);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.Location = new System.Drawing.Point(12' 52);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.Size = new System.Drawing.Size(374' 23);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.Size = new System.Drawing.Size(374' 23);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.TabIndex = 17;
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.Location = new System.Drawing.Point(12' 81);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.Location = new System.Drawing.Point(12' 81);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.Size = new System.Drawing.Size(374' 37);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.Size = new System.Drawing.Size(374' 37);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.TabIndex = 16;
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.Location = new System.Drawing.Point(13' 132);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.Location = new System.Drawing.Point(13' 132);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.Size = new System.Drawing.Size(370' 16);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.Size = new System.Drawing.Size(370' 16);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.TabIndex = 14;
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(398' 201);
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(398' 201);
Missing Default,updateSystemDotNet.Core,Helper,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateController\Core\Helper.cs,getPraefix,The following switch statement is missing a default case: switch (architecure) {  				case updatePackage.SupportedArchitectures.Both:  					return "bth_";  				case updatePackage.SupportedArchitectures.x86:  					return "x86_";  				case updatePackage.SupportedArchitectures.x64:  					return "x64_";  			}
Missing Default,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The following switch statement is missing a default case: switch (file.copyFlag) {  					case fileCopyFlags.OnlyIfExists:  						if (!File.Exists(fileCompletePath)) {  							fileCounter++;  							continue;  						}  						break;  					case fileCopyFlags.OnlyIfNotExists:  						if (File.Exists(fileCompletePath)) {  							fileCounter++;  							continue;  						}  						break;  				}
Missing Default,updateSystemDotNet.Updater.applyUpdate,applyStartProcessAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartProcessAction.cs,executeAction,The following switch statement is missing a default case: switch (currentConfiguration.Settings.processSafetyLevel) {  						case processSafetyLevel.AskAlways:  							if (!Security.VerifySignedFile(ownerForm' filePath' true' true)) {  								throw new SecurityException(string.Format(Language.GetString("applyStartProcessAction_exception")' filePath));  							}  							break;  						case processSafetyLevel.AskIfUnsigned:  							if (!Security.VerifySignedFile(ownerForm' filePath' true' false)) {  								throw new SecurityException(string.Format(Language.GetString("applyStartProcessAction_exception")' filePath));  							}  							break;  					}
Missing Default,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following switch statement is missing a default case: switch (service.Status) {  						case ServiceControllerStatus.Stopped: //Dienst starten    							//Status senden  							onProgressChanged(  								string.Format(Language.GetString("applyStartServiceAction_startService")' service.DisplayName)' 100);    							//Dienst starten  							if (!string.IsNullOrEmpty(action.Arguments)) {  								service.Start(action.Arguments.Split(' '));  							}  							else {  								service.Start();  							}  							//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  							service.WaitForStatus(ServiceControllerStatus.Running' m_timeout);    							//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  							if (service.Status != ServiceControllerStatus.Running) {  								throw new startServiceException(service.DisplayName);  							}    							break;    						case ServiceControllerStatus.Running:  							if (action.restartIfRunnig)  								//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  							{  								//Status senden  								onProgressChanged(  									string.Format(Language.GetString("applyStartServiceAction_stopService")' service.DisplayName)' 100);  								//Dienst anhalten  								service.Stop();  								//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  								service.WaitForStatus(ServiceControllerStatus.Stopped' m_timeout);    								//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  								if (service.Status == ServiceControllerStatus.Stopped) {  									//Status senden  									onProgressChanged(  										string.Format(Language.GetString("applyStartServiceAction_startService")' service.DisplayName)' 100);    									//Dienst starten  									if (!string.IsNullOrEmpty(action.Arguments)) {  										service.Start(action.Arguments.Split(' '));  									}  									else {  										service.Start();  									}    									service.WaitForStatus(ServiceControllerStatus.Running' m_timeout);  									if (service.Status != ServiceControllerStatus.Running) {  										throw new stopServiceException(service.DisplayName);  									}  								}  								else //Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  								{  									throw new startServiceException(service.DisplayName);  								}  							}  							break;  					}
Missing Default,updateSystemDotNet.Updater,Language,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Language.cs,Set_Language,The following switch statement is missing a default case: switch (language) {  				case Languages.Auto:  					if (Thread.CurrentThread.CurrentCulture.Name.StartsWith("de")) {  						res_man = new ResourceManager("updateSystemDotNet.Updater.Localization.language.deu"'  						                              Assembly.GetExecutingAssembly());  					}  					else {  						res_man = new ResourceManager("updateSystemDotNet.Updater.Localization.language.eng"'  						                              Assembly.GetExecutingAssembly());  					}  					break;  				case Languages.Deutsch:  					res_man = new ResourceManager("updateSystemDotNet.Updater.Localization.language.deu"'  					                              Assembly.GetExecutingAssembly());  					break;  				case Languages.English:  					res_man = new ResourceManager("updateSystemDotNet.Updater.Localization.language.eng"'  					                              Assembly.GetExecutingAssembly());  					break;  			}
Missing Default,updateSystemDotNet.Updater.UI.Components,statusLabel,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following switch statement is missing a default case: switch (_state) {  					case statusLabelStates.Success:  						image = getResourceImage("statuslabel_success.png");  						break;  					case statusLabelStates.Failure:  						image = getResourceImage("statuslabel_error.png");  						break;  					case statusLabelStates.Progress:  						image = getCircleImage();  						break;  				}
Missing Default,updateSystemDotNet.Updater.UI.Forms,interactionDialog,C:\repos\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following switch statement is missing a default case: switch (buttons) {  				case interactionButtons.Close:  					btnCancel.Hide();  					btnOk.Text = Language.GetString("general_button_close");  					imgInformation.Image = SystemIcons.Information.ToBitmap();  					ControlBox = true;  					break;  				case interactionButtons.OkCancel:  					btnCancel.Text = Language.GetString("general_button_cancel");  					btnOk.Text = Language.GetString("general_button_ok");  					imgInformation.Image = SystemIcons.Question.ToBitmap();  					break;  				case interactionButtons.YesNo_1: //Abbruch bei Ja  					btnCancel.Text = Language.GetString("general_button_no");  					btnOk.Text = Language.GetString("general_button_yes");  					btnOk.DialogResult = DialogResult.Cancel;  					btnCancel.DialogResult = DialogResult.OK;  					CancelButton = btnOk;  					AcceptButton = btnCancel;  					imgInformation.Image = SystemIcons.Question.ToBitmap();  					break;  				case interactionButtons.YesNo_2: //Abbruch bei Nein  					btnCancel.Text = Language.GetString("general_button_no");  					btnOk.Text = Language.GetString("general_button_yes");  					imgInformation.Image = SystemIcons.Question.ToBitmap();  					break;  			}
