Implementation smell,Namespace,Class,File,Method,Description
Long Method,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The method has 72 lines of code.
Long Method,updateSystemDotNet.Updater.applyUpdate,applyStartProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartProcessAction.cs,executeAction,The method has 65 lines of code.
Long Method,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,getActionById,The method has 63 lines of code.
Long Method,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The method has 141 lines of code.
Long Method,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The method has 137 lines of code.
Long Method,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The method has 121 lines of code.
Long Method,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The method has 113 lines of code.
Long Method,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The method has 112 lines of code.
Long Method,updateSystemDotNet.Updater.Win32,Security,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\Security.cs,ExecRequireNonAdmin,The method has 90 lines of code.
Complex Method,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,Cyclomatic complexity of the method is 15
Complex Method,updateSystemDotNet.Updater.applyUpdate,applyStartProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartProcessAction.cs,executeAction,Cyclomatic complexity of the method is 17
Complex Method,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,Cyclomatic complexity of the method is 17
Complex Method,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_actionFinished,Cyclomatic complexity of the method is 8
Complex Method,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,getActionById,Cyclomatic complexity of the method is 25
Complex Method,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,Cyclomatic complexity of the method is 19
Complex Method,updateSystemDotNet.Updater,Language,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Language.cs,Set_Language,Cyclomatic complexity of the method is 10
Complex Method,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,Cyclomatic complexity of the method is 11
Complex Method,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,Cyclomatic complexity of the method is 25
Complex Method,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,Cyclomatic complexity of the method is 7
Complex Method,updateSystemDotNet.Updater.Win32,Security,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\Security.cs,ExecRequireNonAdmin,Cyclomatic complexity of the method is 9
Long Parameter List,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,SendMessage,The method has 4 parameters.
Long Parameter List,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,AESEncrypt,The method has 7 parameters.
Long Parameter List,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,AESDecrypt,The method has 7 parameters.
Long Parameter List,updateSystemDotNet.Core.Types,changelogDocumentItem,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\changelogDocumentItem.cs,changelogDocumentItem,The method has 4 parameters.
Long Parameter List,updateSystemDotNet.Core.Types,VersionEx,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\VersionEx.cs,VersionEx,The method has 4 parameters.
Long Parameter List,updateSystemDotNet.Core.updateActions,administrationEditorAttribute,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\updateActions\administrationEditorAttribute.cs,administrationEditorAttribute,The method has 4 parameters.
Long Parameter List,updateSystemDotNet.Updater.UI.Components,Windows7Taskbar,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\Windows7ProgressBar.cs,SendMessage,The method has 4 parameters.
Long Parameter List,updateSystemDotNet.Updater.Win32,NativeMethods,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeMethods.cs,DuplicateTokenEx,The method has 6 parameters.
Long Parameter List,updateSystemDotNet.Updater.Win32,NativeMethods,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeMethods.cs,CreateProcessWithTokenW,The method has 9 parameters.
Long Parameter List,updateSystemDotNet.Updater.Win32,SafeNativeMethods,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\SafeNativeMethods.cs,FindWindowExW,The method has 4 parameters.
Long Parameter List,updateSystemDotNet.Updater.Win32,Security,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\Security.cs,ExecRequireNonAdmin,The method has 4 parameters.
Long Parameter List,updateSystemDotNet.Updater.Win32,Security,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\Security.cs,VerifySignedFile,The method has 4 parameters.
Long Statement,updateSystemDotNet.Core.Types,SecureContainer,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\SecureContainer.cs,Save,The length of the statement  "			document.AppendChild (document.CreateComment (string.Format ("Erstellt mit dem updateSystem.Net Designer Version {0}"' Assembly.GetEntryAssembly ().GetName ().Version))); " is 170.
Long Statement,updateSystemDotNet.Core.Types,SecureContainer,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\SecureContainer.cs,Save,The length of the statement  "			document.AppendChild (document.CreateComment (string.Format ("Copyright (c) 2007 - {0} Maximilian Krauss"' DateTime.Now.Year.ToString ()))); " is 140.
Long Statement,updateSystemDotNet.Core.Types,SecureContainer,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\SecureContainer.cs,Save,The length of the statement  "			//xT.WriteComment(string.Format("Created with updateSystemDotNet Version {0}"' System.Reflection.Assembly.GetEntryAssembly().GetName().Version.ToString())); " is 156.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryValueAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryValueAction.cs,executeAction,The length of the statement  "		onProgressChanged (Language.GetString ("applyAddRegistryValueAction_progress")' Percent (itemCount' action.Items.Count)); " is 121.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryValueAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryValueAction.cs,executeAction,The length of the statement  "			m_addedValues.Add (new registryRollbackItem (item.Name' currentData' rootKey.OpenSubKey (action.Path).GetValueKind (item.Name))); " is 129.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryValueAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryValueAction.cs,rollbackAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyAddRegistryValueAction_rollback")' item.Name)' Percent (itemCount' m_addedValues.Count)); " is 149.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryKeyAction.cs,executeAction,The length of the statement  "	onProgressChanged (string.Format (Language.GetString ("applyAddRegistryKeyAction_progress")' action.Path' action.rootHive.ToString ())' 100); " is 141.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryKeyAction.cs,rollbackAction,The length of the statement  "	if (m_rootKey.OpenSubKey (m_path).GetSubKeyNames ().Length > 0 || m_rootKey.OpenSubKey (m_path).GetValueNames ().Length > 0) { " is 126.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyCleanupAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCleanupAction.cs,executeAction,The length of the statement  "		var updateFiles = new List<string> (Directory.GetFiles (currentConfiguration.Settings.downloadLocation' "*"' SearchOption.AllDirectories)); " is 139.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyCleanupAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCleanupAction.cs,executeAction,The length of the statement  "				onProgressChanged (string.Format (Language.GetString ("applyCleanupAction_progress")' Path.GetFileName (file))' Percent (fileCounter' updateFiles.Count)); " is 154.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyCleanupAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCleanupAction.cs,writeObsoleteData,The length of the statement  "		Registry.CurrentUser.OpenSubKey (_registryHive' true).SetValue (currentConfiguration.Settings.ProjektID' currentConfiguration.Settings.downloadLocation); " is 153.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The length of the statement  "	//using (UI.Forms.dlgOpenProcesses dlg = new updateSystemDotNet.Updater.UI.Forms.dlgOpenProcesses(action.processList.ToArray())) " is 128.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The length of the statement  "	//        throw new Exception("Ein oder mehrere Prozesse konnten nicht beendet werden weshalb der Updatevorgang abgebrochen werden musste."); " is 141.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyDeleteFileAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyDeleteFileAction.cs,executeAction,The length of the statement  "			onProgressChanged (string.Format (Language.GetString ("applyDeleteFileAction_progress")' file)' Percent (fileCount' action.filesToRemove.Count)); " is 145.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyDeleteFileAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyDeleteFileAction.cs,rollbackAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyDeleteFileAction_rollback")' backupFile.Key)' Percent (fileCount' m_backupFiles.Count)); " is 148.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The length of the statement  "			string rbFilename = Path.Combine (tempDirectory' string.Format ("{0}_rollback_{1}"' file.Filename' rnd.Next (5000' 10000))); " is 124.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The length of the statement  "				onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_1")' file.Filename)' Percent (fileCounter' action.Files.Count)); " is 152.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_2")' file.Filename)' Percent (fileCounter' action.Files.Count)); " is 152.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_3")' file.Filename)' Percent (fileCounter' action.Files.Count)); " is 152.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The length of the statement  "		//    //onProgressChanged(string.Format("Optimiere .Net Assembly '{0}'..."' file.Filename)' Percent(fileCounter' action.Files.Count)); " is 134.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The length of the statement  "		if (fileCompletePath.EndsWith (".exe") && currentConfiguration.ServerConfiguration.generateNativeImages && assemblyInfo.FromFile (fileCompletePath) != null) { " is 158.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The length of the statement  "			onProgressChanged (Language.GetString ("applyFileCopyAction_progressStep_4")' Percent (fileCounter' action.Files.Count)); " is 121.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,rollbackAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_rollback")' new FileInfo (rbFile.realPath).Name)' Percent (fileCounter' m_rollbackFiles.Count)); " is 171.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The length of the statement  "		m_removedValues.Add (new rollbackRegistryItem (action.Path' baseRegVal' rootKey.OpenSubKey (action.Path).GetValue (baseRegVal)' rootKey.OpenSubKey (action.Path).GetValueKind (baseRegVal))); " is 189.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The length of the statement  "			m_removedValues.Add (new rollbackRegistryItem (Item' regVal' m_rootKey.OpenSubKey (Item).GetValue (regVal)' m_rootKey.OpenSubKey (Item).GetValueKind (regVal))); " is 160.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The length of the statement  "	onProgressChanged (string.Format (Language.GetString ("applyRemoveRegistryKeyAction_progressStep_3")' rootKey' action.Path)' 100); " is 130.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,rollbackAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyRemoveRegistryKeyAction_rollbackStep_1")' rbKey)' Percent (itemCount' totalCount)); " is 143.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,rollbackAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyRemoveRegistryKeyAction_rollbackStep_2")' rbValue.Name)' Percent (itemCount' totalCount)); " is 150.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryValueAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryValueAction.cs,executeAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyRemoveRegistryValueAction_progress")' item)' Percent (itemCount' action.valueNames.Count)); " is 151.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryValueAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryValueAction.cs,executeAction,The length of the statement  "			m_removedValues.Add (new registryRollbackItem (item' itemValue' rootKey.OpenSubKey (action.Path' false).GetValueKind (item))); " is 126.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryValueAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryValueAction.cs,rollbackAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyRemoveRegistryValueAction_rollback")' rbItem.Name)' Percent (itemCount' m_removedValues.Count)); " is 156.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRenameFileAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRenameFileAction.cs,executeAction,The length of the statement  "		onProgressChanged (string.Format (Language.GetString ("applyRenameFileAction_progress")' new FileInfo (rPath).Name)' 100); " is 122.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyRenameFileAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRenameFileAction.cs,rollbackAction,The length of the statement  "	onProgressChanged (string.Format (Language.GetString ("applyRenameFileAction_rollback")' new FileInfo (m_renamedPath).Name)' 100); " is 130.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyStartProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartProcessAction.cs,executeAction,The length of the statement  "	onProgressChanged (string.Format (Language.GetString ("applyStartProcessAction_progress")' new FileInfo (filePath).Name)' 100); " is 127.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyStartProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartProcessAction.cs,executeAction,The length of the statement  "		if (isVistaOrLater && isAdmin)//Wenn Vista und der Benutzer Administrator ist' dann einen Prozess ohne Admintoken erstellen " is 123.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The length of the statement  "				onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100); " is 122.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The length of the statement  "					onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100); " is 121.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The length of the statement  "						onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100); " is 122.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyStopServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStopServiceAction.cs,executeAction,The length of the statement  "				onProgressChanged (string.Format (Language.GetString ("applyStopServiceAction_stopService")' service.DisplayName)' 100); " is 120.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,m_bgwAction_ProgressChanged,The length of the statement  "		progressChanged (this' new applyUpdateProgressChangedEventArgs (actionName' (string)e.UserState' e.ProgressPercentage)); " is 120.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,SetDirectoryAccessControl,The length of the statement  "		var fs_rule = new FileSystemAccessRule (WindowsIdentity.GetCurrent ().Name' FileSystemRights.FullControl' AccessControlType.Allow); " is 131.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,SetFileAccessControl,The length of the statement  "		var fs_rule = new FileSystemAccessRule (WindowsIdentity.GetCurrent ().Name' FileSystemRights.FullControl' AccessControlType.Allow); " is 131.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,runUpdate,The length of the statement  "		applyUpdateBase validationAction = new applyValidatePackageSignature (new validatePackageAction ()' currentConfig' currentPackage); " is 131.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,runUpdate,The length of the statement  "		string latestVersion = currentConfig.ServerConfiguration.updatePackages [currentConfig.ServerConfiguration.updatePackages.Count - 1].releaseInfo.Version; " is 153.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The length of the statement  "			var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100)); " is 222.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The length of the statement  "			var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100)); " is 175.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateRegistryAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateRegistryAction.cs,executeAction,The length of the statement  "	RegistryKey key = Registry.LocalMachine.OpenSubKey (uninstallHive + currentConfiguration.ServerConfiguration.setupId' true); " is 124.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyUpdateRegistryAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateRegistryAction.cs,rollbackAction,The length of the statement  "		RegistryKey key = Registry.LocalMachine.OpenSubKey (uninstallHive + currentConfiguration.ServerConfiguration.setupId' true); " is 124.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyValidatePackageSignature,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyValidatePackageSignature.cs,executeAction,The length of the statement  "	string publicKey = (string.IsNullOrEmpty (currentConfiguration.Settings.PublicKey) ? currentConfiguration.ServerConfiguration.PublicKey : currentConfiguration.Settings.PublicKey); " is 179.
Long Statement,updateSystemDotNet.Updater.applyUpdate,applyValidatePackageSignature,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyValidatePackageSignature.cs,executeAction,The length of the statement  "		throw new ApplicationException (string.Format (Language.GetString ("applyValidatePackageAction_exception")' currentPackage.releaseInfo.Version)); " is 145.
Long Statement,updateSystemDotNet.Updater,Language,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Language.cs,Set_Language,The length of the statement  "			res_man = new ResourceManager ("updateSystemDotNet.Updater.Localization.language.deu"' Assembly.GetExecutingAssembly ()); " is 121.
Long Statement,updateSystemDotNet.Updater,Language,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Language.cs,Set_Language,The length of the statement  "			res_man = new ResourceManager ("updateSystemDotNet.Updater.Localization.language.eng"' Assembly.GetExecutingAssembly ()); " is 121.
Long Statement,updateSystemDotNet.Updater,Language,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Language.cs,Set_Language,The length of the statement  "		res_man = new ResourceManager ("updateSystemDotNet.Updater.Localization.language.deu"' Assembly.GetExecutingAssembly ()); " is 121.
Long Statement,updateSystemDotNet.Updater,Language,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Language.cs,Set_Language,The length of the statement  "		res_man = new ResourceManager ("updateSystemDotNet.Updater.Localization.language.eng"' Assembly.GetExecutingAssembly ()); " is 121.
Long Statement,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The length of the statement  "		TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor); " is 124.
Long Statement,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The length of the statement  "	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' ClientRectangle.Height - 34)' new Point (ClientRectangle.Width' ClientRectangle.Height - 34)); " is 174.
Long Statement,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The length of the statement  "	var rectTextArea = new Rectangle (new Point (textPaddingLeft' 0)' new Size (ClientRectangle.Width - textPaddingLeft' Height)); " is 126.
Long Statement,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The length of the statement  "	TextRenderer.DrawText (e.Graphics' Text' fontText' rectTextArea' ForeColor' TextFormatFlags.WordBreak | TextFormatFlags.VerticalCenter); " is 136.
Long Statement,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The length of the statement  "		e.Graphics.DrawImage (image' new Rectangle (new Point (3' (ClientRectangle.Height / 2) - (image.Height / 2))' new Size (image.Width' image.Height))); " is 149.
Long Statement,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The length of the statement  "		g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel); " is 157.
Long Statement,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getResourceImage,The length of the statement  "	using (Stream strImage = Assembly.GetExecutingAssembly ().GetManifestResourceStream (string.Format ("updateSystemDotNet.Updater.Images.{0}"' imagename))) { " is 155.
Long Statement,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The length of the statement  "	this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153))))); " is 126.
Long Statement,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The length of the statement  "	this.lblDescription.Text = "Die folgenden Prozesse müssen beendet werden' damit der Updatevorgang fortgesetzt" + " werden kann:"; " is 129.
Long Statement,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The length of the statement  "	this.lblInfo.Text = "Der updateInstaller kann die folgende Datei nicht überschreiben: \'{0}\'. Was möcht" + "en Sie machen?"; " is 125.
Long Statement,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The length of the statement  "	this.lblTitle.Font = new System.Drawing.Font ("Tahoma"' 11.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 146.
Long Statement,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The length of the statement  "	this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153))))); " is 126.
Long Statement,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The length of the statement  "	this.Font = new System.Drawing.Font ("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 150.
Long Statement,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The length of the statement  "		e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0)); " is 132.
Long Statement,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The length of the statement  "	this.lblTitle.Font = new System.Drawing.Font ("Segoe UI"' 12F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The length of the statement  "	this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153))))); " is 126.
Long Statement,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The length of the statement  "	this.Font = new System.Drawing.Font ("Segoe UI"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 138.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,showUnhandledException,The length of the statement  "	MessageBox.Show (this' string.Format (Language.GetString ("mainForm_unhandledException_text")' "\r\n"' ex.Message)' "updateInstaller"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 179.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,m_updateManager_rollbackFinished,The length of the statement  "		MessageBox.Show (this' string.Format (Language.GetString ("mainForm_rollback")' "\r\n"' e.actionException.Message)' "updateInstaller"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 179.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The length of the statement  "		if (m_updateManager.currentConfig.Settings.restartApplication && File.Exists (m_updateManager.currentConfig.Settings.applicationPath)) { " is 136.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The length of the statement  "				Security.ExecRequireNonAdmin (this' m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ()' out hProcess); " is 137.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,extendCommandLineArguments,The length of the statement  "		extendedArguments = extendedArguments.Replace ("$oldVersion"' m_updateManager.currentConfig.Settings.releaseInfo.Version); " is 122.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,extendCommandLineArguments,The length of the statement  "		extendedArguments = extendedArguments.Replace ("$newVersion"' m_updateManager.currentConfig.Result [m_updateManager.currentConfig.Result.Count - 1].releaseInfo.Version); " is 169.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The length of the statement  "	Location = new Point ((Screen.PrimaryScreen.WorkingArea.Width / 2) - (Width / 2)' (Screen.PrimaryScreen.WorkingArea.Height / 2) - (Height / 2)); " is 144.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The length of the statement  "	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager (typeof(MainForm)); " is 129.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The length of the statement  "	this.lblStatus.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153))))); " is 127.
Long Statement,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The length of the statement  "	this.prgUpdate.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 188.
Long Statement,updateSystemDotNet.Updater.Win32,NativeMethods,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\NativeMethods.cs,ThrowOnWin32Error,The length of the statement  "		string exMessage = string.Format (exMessageFormat' message' lastWin32Error' ((NativeErrors)lastWin32Error).ToString ()); " is 120.
Long Statement,updateSystemDotNet.Updater.Win32,Security,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\Security.cs,ExecRequireNonAdmin,The length of the statement  "		bool optResult = NativeMethods.OpenProcessToken (hShellProcess' NativeConstants.TOKEN_ASSIGN_PRIMARY | NativeConstants.TOKEN_DUPLICATE | NativeConstants.TOKEN_QUERY' out hShellProcessToken); " is 190.
Long Statement,updateSystemDotNet.Updater.Win32,Security,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\Security.cs,ExecRequireNonAdmin,The length of the statement  "		bool dteResult = NativeMethods.DuplicateTokenEx (hShellProcessToken' NativeConstants.MAXIMUM_ALLOWED' IntPtr.Zero' NativeConstants.SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation' NativeConstants.TOKEN_TYPE.TokenPrimary' out hTokenCopy); " is 240.
Long Statement,updateSystemDotNet.Updater.Win32,Security,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Win32\Security.cs,ExecRequireNonAdmin,The length of the statement  "		bool cpwtResult = NativeMethods.CreateProcessWithTokenW (hTokenCopy' 0' bstrExePath' bstrCommandLine' 0' IntPtr.Zero' bstrDir' IntPtr.Zero' out procInfo); " is 154.
Complex Conditional,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_actionFinished,The conditional expression  "(e.actionException != null && !m_onRollback) || (m_cancellationPending && m_waitForRollback)"  is complex.
Complex Conditional,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The conditional expression  "(bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)"  is complex.
Empty Catch Block,updateSystemDotNet.Updater.applyUpdate,applyCleanupAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCleanupAction.cs,cleanObsoleteData,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.applyUpdate,applyCleanupAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCleanupAction.cs,writeObsoleteData,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,getSubKeys,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The method has an empty catch block.
Empty Catch Block,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,BlockLogOff,The method has an empty catch block.
Magic Number,updateSystemDotNet.Administration.UI.Controls,buttonArea,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\Administration\UI\Controls\buttonArea.cs,buttonArea,The following statement contains a magic number: Size = new Size (200' 50);  
Magic Number,updateSystemDotNet.Administration.UI.Controls,buttonArea,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\Administration\UI\Controls\buttonArea.cs,buttonArea,The following statement contains a magic number: Size = new Size (200' 50);  
Magic Number,updateSystemDotNet.Administration.UI.Controls,buttonArea,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\Administration\UI\Controls\buttonArea.cs,buttonArea,The following statement contains a magic number: Padding = new Padding (0' 10' 12' 0);  
Magic Number,updateSystemDotNet.Administration.UI.Controls,buttonArea,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\Administration\UI\Controls\buttonArea.cs,buttonArea,The following statement contains a magic number: Padding = new Padding (0' 10' 12' 0);  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: try {  	ushort sections;  	uint timestamp;  	uint pSymbolTable;  	uint noOfSymbol;  	ushort optionalHeaderSize;  	ushort characteristics;  	ushort dataDictionaryStart;  	var dataDictionaryRVA = new uint[16];  	var dataDictionarySize = new uint[16];  	Stream fs = File.OpenRead (filename);  	//new FileStream(filename' FileMode.Open' FileAccess.Read);  	var reader = new BinaryReader (fs);  	fs.Position = 0x3C;  	uint peHeader = reader.ReadUInt32 ();  	fs.Position = peHeader;  	uint peHeaderSignature = reader.ReadUInt32 ();  	ushort machine = reader.ReadUInt16 ();  	sections = reader.ReadUInt16 ();  	timestamp = reader.ReadUInt32 ();  	pSymbolTable = reader.ReadUInt32 ();  	noOfSymbol = reader.ReadUInt32 ();  	optionalHeaderSize = reader.ReadUInt16 ();  	characteristics = reader.ReadUInt16 ();  	dataDictionaryStart = Convert.ToUInt16 (Convert.ToUInt16 (fs.Position) + 0x60);  	fs.Position = dataDictionaryStart;  	for (int i = 0; i < 15; i++) {  		dataDictionaryRVA [i] = reader.ReadUInt32 ();  		dataDictionarySize [i] = reader.ReadUInt32 ();  	}  	if (dataDictionaryRVA [14] == 0) {  		return false;  	} else {  		return true;  	}  } catch {  	return false;  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: try {  	ushort sections;  	uint timestamp;  	uint pSymbolTable;  	uint noOfSymbol;  	ushort optionalHeaderSize;  	ushort characteristics;  	ushort dataDictionaryStart;  	var dataDictionaryRVA = new uint[16];  	var dataDictionarySize = new uint[16];  	Stream fs = File.OpenRead (filename);  	//new FileStream(filename' FileMode.Open' FileAccess.Read);  	var reader = new BinaryReader (fs);  	fs.Position = 0x3C;  	uint peHeader = reader.ReadUInt32 ();  	fs.Position = peHeader;  	uint peHeaderSignature = reader.ReadUInt32 ();  	ushort machine = reader.ReadUInt16 ();  	sections = reader.ReadUInt16 ();  	timestamp = reader.ReadUInt32 ();  	pSymbolTable = reader.ReadUInt32 ();  	noOfSymbol = reader.ReadUInt32 ();  	optionalHeaderSize = reader.ReadUInt16 ();  	characteristics = reader.ReadUInt16 ();  	dataDictionaryStart = Convert.ToUInt16 (Convert.ToUInt16 (fs.Position) + 0x60);  	fs.Position = dataDictionaryStart;  	for (int i = 0; i < 15; i++) {  		dataDictionaryRVA [i] = reader.ReadUInt32 ();  		dataDictionarySize [i] = reader.ReadUInt32 ();  	}  	if (dataDictionaryRVA [14] == 0) {  		return false;  	} else {  		return true;  	}  } catch {  	return false;  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: try {  	ushort sections;  	uint timestamp;  	uint pSymbolTable;  	uint noOfSymbol;  	ushort optionalHeaderSize;  	ushort characteristics;  	ushort dataDictionaryStart;  	var dataDictionaryRVA = new uint[16];  	var dataDictionarySize = new uint[16];  	Stream fs = File.OpenRead (filename);  	//new FileStream(filename' FileMode.Open' FileAccess.Read);  	var reader = new BinaryReader (fs);  	fs.Position = 0x3C;  	uint peHeader = reader.ReadUInt32 ();  	fs.Position = peHeader;  	uint peHeaderSignature = reader.ReadUInt32 ();  	ushort machine = reader.ReadUInt16 ();  	sections = reader.ReadUInt16 ();  	timestamp = reader.ReadUInt32 ();  	pSymbolTable = reader.ReadUInt32 ();  	noOfSymbol = reader.ReadUInt32 ();  	optionalHeaderSize = reader.ReadUInt16 ();  	characteristics = reader.ReadUInt16 ();  	dataDictionaryStart = Convert.ToUInt16 (Convert.ToUInt16 (fs.Position) + 0x60);  	fs.Position = dataDictionaryStart;  	for (int i = 0; i < 15; i++) {  		dataDictionaryRVA [i] = reader.ReadUInt32 ();  		dataDictionarySize [i] = reader.ReadUInt32 ();  	}  	if (dataDictionaryRVA [14] == 0) {  		return false;  	} else {  		return true;  	}  } catch {  	return false;  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: try {  	ushort sections;  	uint timestamp;  	uint pSymbolTable;  	uint noOfSymbol;  	ushort optionalHeaderSize;  	ushort characteristics;  	ushort dataDictionaryStart;  	var dataDictionaryRVA = new uint[16];  	var dataDictionarySize = new uint[16];  	Stream fs = File.OpenRead (filename);  	//new FileStream(filename' FileMode.Open' FileAccess.Read);  	var reader = new BinaryReader (fs);  	fs.Position = 0x3C;  	uint peHeader = reader.ReadUInt32 ();  	fs.Position = peHeader;  	uint peHeaderSignature = reader.ReadUInt32 ();  	ushort machine = reader.ReadUInt16 ();  	sections = reader.ReadUInt16 ();  	timestamp = reader.ReadUInt32 ();  	pSymbolTable = reader.ReadUInt32 ();  	noOfSymbol = reader.ReadUInt32 ();  	optionalHeaderSize = reader.ReadUInt16 ();  	characteristics = reader.ReadUInt16 ();  	dataDictionaryStart = Convert.ToUInt16 (Convert.ToUInt16 (fs.Position) + 0x60);  	fs.Position = dataDictionaryStart;  	for (int i = 0; i < 15; i++) {  		dataDictionaryRVA [i] = reader.ReadUInt32 ();  		dataDictionarySize [i] = reader.ReadUInt32 ();  	}  	if (dataDictionaryRVA [14] == 0) {  		return false;  	} else {  		return true;  	}  } catch {  	return false;  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: for (int i = 0; i < 15; i++) {  	dataDictionaryRVA [i] = reader.ReadUInt32 ();  	dataDictionarySize [i] = reader.ReadUInt32 ();  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,IsNetAssembly,The following statement contains a magic number: if (dataDictionaryRVA [14] == 0) {  	return false;  } else {  	return true;  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,Percent,The following statement contains a magic number: try {  	return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  } catch {  	return 100;  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,Percent,The following statement contains a magic number: try {  	return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  } catch {  	return 100;  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,Percent,The following statement contains a magic number: return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,Percent,The following statement contains a magic number: return 100;  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  	if (lenght < 1024) {  		return string.Format ("{0} Bytes"' lenght.ToString ());  	} else if (lenght > 1023 && lenght < 1048576) {  		double c_lenght = lenght / 1024;  		return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  	} else if (lenght >= 1048576 && lenght <= 1043741825) {  		double c_lenght = lenght / (float)(Math.Pow (1024' 2));  		return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  	} else {  		return "0 Bytes";  	}  } catch {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  	if (lenght < 1024) {  		return string.Format ("{0} Bytes"' lenght.ToString ());  	} else if (lenght > 1023 && lenght < 1048576) {  		double c_lenght = lenght / 1024;  		return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  	} else if (lenght >= 1048576 && lenght <= 1043741825) {  		double c_lenght = lenght / (float)(Math.Pow (1024' 2));  		return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  	} else {  		return "0 Bytes";  	}  } catch {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  	if (lenght < 1024) {  		return string.Format ("{0} Bytes"' lenght.ToString ());  	} else if (lenght > 1023 && lenght < 1048576) {  		double c_lenght = lenght / 1024;  		return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  	} else if (lenght >= 1048576 && lenght <= 1043741825) {  		double c_lenght = lenght / (float)(Math.Pow (1024' 2));  		return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  	} else {  		return "0 Bytes";  	}  } catch {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  	if (lenght < 1024) {  		return string.Format ("{0} Bytes"' lenght.ToString ());  	} else if (lenght > 1023 && lenght < 1048576) {  		double c_lenght = lenght / 1024;  		return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  	} else if (lenght >= 1048576 && lenght <= 1043741825) {  		double c_lenght = lenght / (float)(Math.Pow (1024' 2));  		return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  	} else {  		return "0 Bytes";  	}  } catch {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  	if (lenght < 1024) {  		return string.Format ("{0} Bytes"' lenght.ToString ());  	} else if (lenght > 1023 && lenght < 1048576) {  		double c_lenght = lenght / 1024;  		return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  	} else if (lenght >= 1048576 && lenght <= 1043741825) {  		double c_lenght = lenght / (float)(Math.Pow (1024' 2));  		return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  	} else {  		return "0 Bytes";  	}  } catch {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  	if (lenght < 1024) {  		return string.Format ("{0} Bytes"' lenght.ToString ());  	} else if (lenght > 1023 && lenght < 1048576) {  		double c_lenght = lenght / 1024;  		return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  	} else if (lenght >= 1048576 && lenght <= 1043741825) {  		double c_lenght = lenght / (float)(Math.Pow (1024' 2));  		return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  	} else {  		return "0 Bytes";  	}  } catch {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  	if (lenght < 1024) {  		return string.Format ("{0} Bytes"' lenght.ToString ());  	} else if (lenght > 1023 && lenght < 1048576) {  		double c_lenght = lenght / 1024;  		return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  	} else if (lenght >= 1048576 && lenght <= 1043741825) {  		double c_lenght = lenght / (float)(Math.Pow (1024' 2));  		return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  	} else {  		return "0 Bytes";  	}  } catch {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: try {  	if (lenght < 1024) {  		return string.Format ("{0} Bytes"' lenght.ToString ());  	} else if (lenght > 1023 && lenght < 1048576) {  		double c_lenght = lenght / 1024;  		return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  	} else if (lenght >= 1048576 && lenght <= 1043741825) {  		double c_lenght = lenght / (float)(Math.Pow (1024' 2));  		return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  	} else {  		return "0 Bytes";  	}  } catch {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght < 1024) {  	return string.Format ("{0} Bytes"' lenght.ToString ());  } else if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght < 1024) {  	return string.Format ("{0} Bytes"' lenght.ToString ());  } else if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght < 1024) {  	return string.Format ("{0} Bytes"' lenght.ToString ());  } else if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght < 1024) {  	return string.Format ("{0} Bytes"' lenght.ToString ());  } else if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght < 1024) {  	return string.Format ("{0} Bytes"' lenght.ToString ());  } else if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght < 1024) {  	return string.Format ("{0} Bytes"' lenght.ToString ());  } else if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght < 1024) {  	return string.Format ("{0} Bytes"' lenght.ToString ());  } else if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght < 1024) {  	return string.Format ("{0} Bytes"' lenght.ToString ());  } else if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght > 1023 && lenght < 1048576) {  	double c_lenght = lenght / 1024;  	return string.Format ("{0} KB"' c_lenght.ToString ("###0.00"));  } else if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,GetFileSize,The following statement contains a magic number: if (lenght >= 1048576 && lenght <= 1043741825) {  	double c_lenght = lenght / (float)(Math.Pow (1024' 2));  	return string.Format ("{0} MB"' c_lenght.ToString ("###0.00"));  } else {  	return "0 Bytes";  }  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,setButtonShield,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6)  	SendMessage (button.Handle' BCM_SETSHIELD' 0' 0xFFFFFFFF);  
Magic Number,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,removeButtonShield,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6)  	SendMessage (button.Handle' BCM_SETSHIELD' 0' 0);  
Magic Number,updateSystemDotNet.Core.Types,VersionEx,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 2) {  	Minor = int.Parse (parts [1]);  }  
Magic Number,updateSystemDotNet.Core.Types,VersionEx,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 3) {  	Build = int.Parse (parts [2]);  }  
Magic Number,updateSystemDotNet.Core.Types,VersionEx,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 3) {  	Build = int.Parse (parts [2]);  }  
Magic Number,updateSystemDotNet.Core.Types,VersionEx,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: Build = int.Parse (parts [2]);  
Magic Number,updateSystemDotNet.Core.Types,VersionEx,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 4) {  	Revision = int.Parse (parts [3]);  }  
Magic Number,updateSystemDotNet.Core.Types,VersionEx,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: if (parts.Length >= 4) {  	Revision = int.Parse (parts [3]);  }  
Magic Number,updateSystemDotNet.Core.Types,VersionEx,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Types\VersionEx.cs,VersionEx,The following statement contains a magic number: Revision = int.Parse (parts [3]);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryKeyAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyAddRegistryKeyAction_progress")' action.Path' action.rootHive.ToString ())' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyAddRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyAddRegistryKeyAction.cs,rollbackAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyAddRegistryKeyAction_rollback")' m_path)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The following statement contains a magic number: foreach (string processItem in action.processList) {  	Process[] processes = Process.GetProcessesByName (processItem);  	if (processes.Length > 0) {  		foreach (Process process in processes) {  			try {  				process.CloseMainWindow ();  				process.WaitForExit (5000);  				process.Kill ();  			} catch (Exception) {  				/* TODO: Unbedingt noch was wegen ner gescheiten Fehlerbehandlung überlegen */}  		}  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The following statement contains a magic number: if (processes.Length > 0) {  	foreach (Process process in processes) {  		try {  			process.CloseMainWindow ();  			process.WaitForExit (5000);  			process.Kill ();  		} catch (Exception) {  			/* TODO: Unbedingt noch was wegen ner gescheiten Fehlerbehandlung überlegen */}  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The following statement contains a magic number: foreach (Process process in processes) {  	try {  		process.CloseMainWindow ();  		process.WaitForExit (5000);  		process.Kill ();  	} catch (Exception) {  		/* TODO: Unbedingt noch was wegen ner gescheiten Fehlerbehandlung überlegen */}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The following statement contains a magic number: try {  	process.CloseMainWindow ();  	process.WaitForExit (5000);  	process.Kill ();  } catch (Exception) {  	/* TODO: Unbedingt noch was wegen ner gescheiten Fehlerbehandlung überlegen */}  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyCloseProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyCloseProcessAction.cs,executeAction,The following statement contains a magic number: process.WaitForExit (5000);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The following statement contains a magic number: foreach (FileType file in action.Files) {  	string fileDirectory = ParsePath (file.Destination);  	string fileCompletePath = Path.Combine (fileDirectory' file.Filename);  	//Überprüfe die filecopyflags  	switch (file.copyFlag) {  	case fileCopyFlags.OnlyIfExists:  		if (!File.Exists (fileCompletePath)) {  			fileCounter++;  			continue;  		}  		break;  	case fileCopyFlags.OnlyIfNotExists:  		if (File.Exists (fileCompletePath)) {  			fileCounter++;  			continue;  		}  		break;  	}  	//Überprüfe ob Verzeichnis existiert  	if (!Directory.Exists (fileDirectory)) {  		Directory.CreateDirectory (fileDirectory);  		SetDirectoryAccessControl (fileDirectory);  	}  	//Überprüfe ob die Datei existiert  	if (File.Exists (fileCompletePath)) {  		string rbFilename = Path.Combine (tempDirectory' string.Format ("{0}_rollback_{1}"' file.Filename' rnd.Next (5000' 10000)));  		//Wenn die Datei noch nicht gesichert wurde' dann sichern.  		if (!rbFileExists (fileCompletePath)) {  			onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_1")' file.Filename)' Percent (fileCounter' action.Files.Count));  			copyFile (fileCompletePath' rbFilename);  		}  		//Versuche Datei zu löschen  		if (deleteFile (fileCompletePath)) {  			m_rollbackFiles.Add (new rollbackFile (fileCompletePath' rbFilename));  		} else {  			throw new userCancelledException ();  		}  	} else {  		m_rollbackFiles.Add (new rollbackFile (fileCompletePath' string.Empty));  	}  	onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_2")' file.Filename)' Percent (fileCounter' action.Files.Count));  	byte[] data = Decompress (accessUpdatePackage (packageFile' file.ID));  	onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_3")' file.Filename)' Percent (fileCounter' action.Files.Count));  	File.WriteAllBytes (fileCompletePath' data);  	SetFileAccessControl (fileCompletePath);  	//NGen Image erzeugen  	//if (Core.Helper.IsNetAssembly(fileCompletePath))  	//{  	//    //onProgressChanged(string.Format("Optimiere .Net Assembly '{0}'..."' file.Filename)' Percent(fileCounter' action.Files.Count));  	//    //NGenUninstall(fileCompletePath);  	//    //NGenInstall(fileCompletePath);  	//}  	if (fileCompletePath.EndsWith (".exe") && currentConfiguration.ServerConfiguration.generateNativeImages && assemblyInfo.FromFile (fileCompletePath) != null) {  		onProgressChanged (Language.GetString ("applyFileCopyAction_progressStep_4")' Percent (fileCounter' action.Files.Count));  		NGenUninstall (fileCompletePath);  		NGenInstall (fileCompletePath);  	}  	fileCounter++;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The following statement contains a magic number: foreach (FileType file in action.Files) {  	string fileDirectory = ParsePath (file.Destination);  	string fileCompletePath = Path.Combine (fileDirectory' file.Filename);  	//Überprüfe die filecopyflags  	switch (file.copyFlag) {  	case fileCopyFlags.OnlyIfExists:  		if (!File.Exists (fileCompletePath)) {  			fileCounter++;  			continue;  		}  		break;  	case fileCopyFlags.OnlyIfNotExists:  		if (File.Exists (fileCompletePath)) {  			fileCounter++;  			continue;  		}  		break;  	}  	//Überprüfe ob Verzeichnis existiert  	if (!Directory.Exists (fileDirectory)) {  		Directory.CreateDirectory (fileDirectory);  		SetDirectoryAccessControl (fileDirectory);  	}  	//Überprüfe ob die Datei existiert  	if (File.Exists (fileCompletePath)) {  		string rbFilename = Path.Combine (tempDirectory' string.Format ("{0}_rollback_{1}"' file.Filename' rnd.Next (5000' 10000)));  		//Wenn die Datei noch nicht gesichert wurde' dann sichern.  		if (!rbFileExists (fileCompletePath)) {  			onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_1")' file.Filename)' Percent (fileCounter' action.Files.Count));  			copyFile (fileCompletePath' rbFilename);  		}  		//Versuche Datei zu löschen  		if (deleteFile (fileCompletePath)) {  			m_rollbackFiles.Add (new rollbackFile (fileCompletePath' rbFilename));  		} else {  			throw new userCancelledException ();  		}  	} else {  		m_rollbackFiles.Add (new rollbackFile (fileCompletePath' string.Empty));  	}  	onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_2")' file.Filename)' Percent (fileCounter' action.Files.Count));  	byte[] data = Decompress (accessUpdatePackage (packageFile' file.ID));  	onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_3")' file.Filename)' Percent (fileCounter' action.Files.Count));  	File.WriteAllBytes (fileCompletePath' data);  	SetFileAccessControl (fileCompletePath);  	//NGen Image erzeugen  	//if (Core.Helper.IsNetAssembly(fileCompletePath))  	//{  	//    //onProgressChanged(string.Format("Optimiere .Net Assembly '{0}'..."' file.Filename)' Percent(fileCounter' action.Files.Count));  	//    //NGenUninstall(fileCompletePath);  	//    //NGenInstall(fileCompletePath);  	//}  	if (fileCompletePath.EndsWith (".exe") && currentConfiguration.ServerConfiguration.generateNativeImages && assemblyInfo.FromFile (fileCompletePath) != null) {  		onProgressChanged (Language.GetString ("applyFileCopyAction_progressStep_4")' Percent (fileCounter' action.Files.Count));  		NGenUninstall (fileCompletePath);  		NGenInstall (fileCompletePath);  	}  	fileCounter++;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The following statement contains a magic number: if (File.Exists (fileCompletePath)) {  	string rbFilename = Path.Combine (tempDirectory' string.Format ("{0}_rollback_{1}"' file.Filename' rnd.Next (5000' 10000)));  	//Wenn die Datei noch nicht gesichert wurde' dann sichern.  	if (!rbFileExists (fileCompletePath)) {  		onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_1")' file.Filename)' Percent (fileCounter' action.Files.Count));  		copyFile (fileCompletePath' rbFilename);  	}  	//Versuche Datei zu löschen  	if (deleteFile (fileCompletePath)) {  		m_rollbackFiles.Add (new rollbackFile (fileCompletePath' rbFilename));  	} else {  		throw new userCancelledException ();  	}  } else {  	m_rollbackFiles.Add (new rollbackFile (fileCompletePath' string.Empty));  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The following statement contains a magic number: if (File.Exists (fileCompletePath)) {  	string rbFilename = Path.Combine (tempDirectory' string.Format ("{0}_rollback_{1}"' file.Filename' rnd.Next (5000' 10000)));  	//Wenn die Datei noch nicht gesichert wurde' dann sichern.  	if (!rbFileExists (fileCompletePath)) {  		onProgressChanged (string.Format (Language.GetString ("applyFileCopyAction_progressStep_1")' file.Filename)' Percent (fileCounter' action.Files.Count));  		copyFile (fileCompletePath' rbFilename);  	}  	//Versuche Datei zu löschen  	if (deleteFile (fileCompletePath)) {  		m_rollbackFiles.Add (new rollbackFile (fileCompletePath' rbFilename));  	} else {  		throw new userCancelledException ();  	}  } else {  	m_rollbackFiles.Add (new rollbackFile (fileCompletePath' string.Empty));  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (Language.GetString ("applyRemoveRegistryKeyAction_progressStep_1")' 30);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (Language.GetString ("applyRemoveRegistryKeyAction_progressStep_2")' 60);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRemoveRegistryKeyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRemoveRegistryKeyAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyRemoveRegistryKeyAction_progressStep_3")' rootKey' action.Path)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRenameFileAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRenameFileAction.cs,executeAction,The following statement contains a magic number: if (File.Exists (rPath)) {  	onProgressChanged (string.Format (Language.GetString ("applyRenameFileAction_progress")' new FileInfo (rPath).Name)' 100);  	copyFile (rPath' newPath);  	deleteFile (rPath);  	m_originalPath = rPath;  	m_renamedPath = newPath;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRenameFileAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRenameFileAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyRenameFileAction_progress")' new FileInfo (rPath).Name)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyRenameFileAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyRenameFileAction.cs,rollbackAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyRenameFileAction_rollback")' new FileInfo (m_renamedPath).Name)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartProcessAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyStartProcessAction_progress")' new FileInfo (filePath).Name)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: foreach (ServiceController service in services) {  	if (string.Equals (service.ServiceName.ToLower ()' action.serviceName.ToLower ())) {  		switch (service.Status) {  		case ServiceControllerStatus.Stopped:  			//Dienst starten  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  			//Dienst starten  			if (!string.IsNullOrEmpty (action.Arguments)) {  				service.Start (action.Arguments.Split (' '));  			} else {  				service.Start ();  			}  			//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  			service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  			//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  			if (service.Status != ServiceControllerStatus.Running) {  				throw new startServiceException (service.DisplayName);  			}  			break;  		case ServiceControllerStatus.Running:  			if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  			 {  				//Status senden  				onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  				//Dienst anhalten  				service.Stop ();  				//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  				service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  				//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  				if (service.Status == ServiceControllerStatus.Stopped) {  					//Status senden  					onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  					//Dienst starten  					if (!string.IsNullOrEmpty (action.Arguments)) {  						service.Start (action.Arguments.Split (' '));  					} else {  						service.Start ();  					}  					service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  					if (service.Status != ServiceControllerStatus.Running) {  						throw new stopServiceException (service.DisplayName);  					}  				} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  				 {  					throw new startServiceException (service.DisplayName);  				}  			}  			break;  		}  		return;  		//Schleife beenden' da Dienst gefunden.  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: foreach (ServiceController service in services) {  	if (string.Equals (service.ServiceName.ToLower ()' action.serviceName.ToLower ())) {  		switch (service.Status) {  		case ServiceControllerStatus.Stopped:  			//Dienst starten  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  			//Dienst starten  			if (!string.IsNullOrEmpty (action.Arguments)) {  				service.Start (action.Arguments.Split (' '));  			} else {  				service.Start ();  			}  			//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  			service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  			//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  			if (service.Status != ServiceControllerStatus.Running) {  				throw new startServiceException (service.DisplayName);  			}  			break;  		case ServiceControllerStatus.Running:  			if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  			 {  				//Status senden  				onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  				//Dienst anhalten  				service.Stop ();  				//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  				service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  				//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  				if (service.Status == ServiceControllerStatus.Stopped) {  					//Status senden  					onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  					//Dienst starten  					if (!string.IsNullOrEmpty (action.Arguments)) {  						service.Start (action.Arguments.Split (' '));  					} else {  						service.Start ();  					}  					service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  					if (service.Status != ServiceControllerStatus.Running) {  						throw new stopServiceException (service.DisplayName);  					}  				} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  				 {  					throw new startServiceException (service.DisplayName);  				}  			}  			break;  		}  		return;  		//Schleife beenden' da Dienst gefunden.  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: foreach (ServiceController service in services) {  	if (string.Equals (service.ServiceName.ToLower ()' action.serviceName.ToLower ())) {  		switch (service.Status) {  		case ServiceControllerStatus.Stopped:  			//Dienst starten  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  			//Dienst starten  			if (!string.IsNullOrEmpty (action.Arguments)) {  				service.Start (action.Arguments.Split (' '));  			} else {  				service.Start ();  			}  			//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  			service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  			//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  			if (service.Status != ServiceControllerStatus.Running) {  				throw new startServiceException (service.DisplayName);  			}  			break;  		case ServiceControllerStatus.Running:  			if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  			 {  				//Status senden  				onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  				//Dienst anhalten  				service.Stop ();  				//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  				service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  				//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  				if (service.Status == ServiceControllerStatus.Stopped) {  					//Status senden  					onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  					//Dienst starten  					if (!string.IsNullOrEmpty (action.Arguments)) {  						service.Start (action.Arguments.Split (' '));  					} else {  						service.Start ();  					}  					service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  					if (service.Status != ServiceControllerStatus.Running) {  						throw new stopServiceException (service.DisplayName);  					}  				} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  				 {  					throw new startServiceException (service.DisplayName);  				}  			}  			break;  		}  		return;  		//Schleife beenden' da Dienst gefunden.  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: if (string.Equals (service.ServiceName.ToLower ()' action.serviceName.ToLower ())) {  	switch (service.Status) {  	case ServiceControllerStatus.Stopped:  		//Dienst starten  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  		//Dienst starten  		if (!string.IsNullOrEmpty (action.Arguments)) {  			service.Start (action.Arguments.Split (' '));  		} else {  			service.Start ();  		}  		//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  		service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  		//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  		if (service.Status != ServiceControllerStatus.Running) {  			throw new startServiceException (service.DisplayName);  		}  		break;  	case ServiceControllerStatus.Running:  		if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  		 {  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  			//Dienst anhalten  			service.Stop ();  			//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  			service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  			//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  			if (service.Status == ServiceControllerStatus.Stopped) {  				//Status senden  				onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  				//Dienst starten  				if (!string.IsNullOrEmpty (action.Arguments)) {  					service.Start (action.Arguments.Split (' '));  				} else {  					service.Start ();  				}  				service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  				if (service.Status != ServiceControllerStatus.Running) {  					throw new stopServiceException (service.DisplayName);  				}  			} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  			 {  				throw new startServiceException (service.DisplayName);  			}  		}  		break;  	}  	return;  	//Schleife beenden' da Dienst gefunden.  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: if (string.Equals (service.ServiceName.ToLower ()' action.serviceName.ToLower ())) {  	switch (service.Status) {  	case ServiceControllerStatus.Stopped:  		//Dienst starten  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  		//Dienst starten  		if (!string.IsNullOrEmpty (action.Arguments)) {  			service.Start (action.Arguments.Split (' '));  		} else {  			service.Start ();  		}  		//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  		service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  		//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  		if (service.Status != ServiceControllerStatus.Running) {  			throw new startServiceException (service.DisplayName);  		}  		break;  	case ServiceControllerStatus.Running:  		if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  		 {  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  			//Dienst anhalten  			service.Stop ();  			//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  			service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  			//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  			if (service.Status == ServiceControllerStatus.Stopped) {  				//Status senden  				onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  				//Dienst starten  				if (!string.IsNullOrEmpty (action.Arguments)) {  					service.Start (action.Arguments.Split (' '));  				} else {  					service.Start ();  				}  				service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  				if (service.Status != ServiceControllerStatus.Running) {  					throw new stopServiceException (service.DisplayName);  				}  			} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  			 {  				throw new startServiceException (service.DisplayName);  			}  		}  		break;  	}  	return;  	//Schleife beenden' da Dienst gefunden.  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: if (string.Equals (service.ServiceName.ToLower ()' action.serviceName.ToLower ())) {  	switch (service.Status) {  	case ServiceControllerStatus.Stopped:  		//Dienst starten  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  		//Dienst starten  		if (!string.IsNullOrEmpty (action.Arguments)) {  			service.Start (action.Arguments.Split (' '));  		} else {  			service.Start ();  		}  		//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  		service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  		//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  		if (service.Status != ServiceControllerStatus.Running) {  			throw new startServiceException (service.DisplayName);  		}  		break;  	case ServiceControllerStatus.Running:  		if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  		 {  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  			//Dienst anhalten  			service.Stop ();  			//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  			service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  			//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  			if (service.Status == ServiceControllerStatus.Stopped) {  				//Status senden  				onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  				//Dienst starten  				if (!string.IsNullOrEmpty (action.Arguments)) {  					service.Start (action.Arguments.Split (' '));  				} else {  					service.Start ();  				}  				service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  				if (service.Status != ServiceControllerStatus.Running) {  					throw new stopServiceException (service.DisplayName);  				}  			} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  			 {  				throw new startServiceException (service.DisplayName);  			}  		}  		break;  	}  	return;  	//Schleife beenden' da Dienst gefunden.  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: switch (service.Status) {  case ServiceControllerStatus.Stopped:  	//Dienst starten  	//Status senden  	onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  	//Dienst starten  	if (!string.IsNullOrEmpty (action.Arguments)) {  		service.Start (action.Arguments.Split (' '));  	} else {  		service.Start ();  	}  	//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  	service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  	//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  	if (service.Status != ServiceControllerStatus.Running) {  		throw new startServiceException (service.DisplayName);  	}  	break;  case ServiceControllerStatus.Running:  	if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  	 {  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  		//Dienst anhalten  		service.Stop ();  		//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  		service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  		//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  		if (service.Status == ServiceControllerStatus.Stopped) {  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  			//Dienst starten  			if (!string.IsNullOrEmpty (action.Arguments)) {  				service.Start (action.Arguments.Split (' '));  			} else {  				service.Start ();  			}  			service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  			if (service.Status != ServiceControllerStatus.Running) {  				throw new stopServiceException (service.DisplayName);  			}  		} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  		 {  			throw new startServiceException (service.DisplayName);  		}  	}  	break;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: switch (service.Status) {  case ServiceControllerStatus.Stopped:  	//Dienst starten  	//Status senden  	onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  	//Dienst starten  	if (!string.IsNullOrEmpty (action.Arguments)) {  		service.Start (action.Arguments.Split (' '));  	} else {  		service.Start ();  	}  	//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  	service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  	//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  	if (service.Status != ServiceControllerStatus.Running) {  		throw new startServiceException (service.DisplayName);  	}  	break;  case ServiceControllerStatus.Running:  	if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  	 {  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  		//Dienst anhalten  		service.Stop ();  		//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  		service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  		//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  		if (service.Status == ServiceControllerStatus.Stopped) {  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  			//Dienst starten  			if (!string.IsNullOrEmpty (action.Arguments)) {  				service.Start (action.Arguments.Split (' '));  			} else {  				service.Start ();  			}  			service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  			if (service.Status != ServiceControllerStatus.Running) {  				throw new stopServiceException (service.DisplayName);  			}  		} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  		 {  			throw new startServiceException (service.DisplayName);  		}  	}  	break;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: switch (service.Status) {  case ServiceControllerStatus.Stopped:  	//Dienst starten  	//Status senden  	onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  	//Dienst starten  	if (!string.IsNullOrEmpty (action.Arguments)) {  		service.Start (action.Arguments.Split (' '));  	} else {  		service.Start ();  	}  	//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  	service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  	//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  	if (service.Status != ServiceControllerStatus.Running) {  		throw new startServiceException (service.DisplayName);  	}  	break;  case ServiceControllerStatus.Running:  	if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  	 {  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  		//Dienst anhalten  		service.Stop ();  		//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  		service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  		//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  		if (service.Status == ServiceControllerStatus.Stopped) {  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  			//Dienst starten  			if (!string.IsNullOrEmpty (action.Arguments)) {  				service.Start (action.Arguments.Split (' '));  			} else {  				service.Start ();  			}  			service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  			if (service.Status != ServiceControllerStatus.Running) {  				throw new stopServiceException (service.DisplayName);  			}  		} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  		 {  			throw new startServiceException (service.DisplayName);  		}  	}  	break;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist   {  	//Status senden  	onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  	//Dienst anhalten  	service.Stop ();  	//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  	service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  	//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  	if (service.Status == ServiceControllerStatus.Stopped) {  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  		//Dienst starten  		if (!string.IsNullOrEmpty (action.Arguments)) {  			service.Start (action.Arguments.Split (' '));  		} else {  			service.Start ();  		}  		service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  		if (service.Status != ServiceControllerStatus.Running) {  			throw new stopServiceException (service.DisplayName);  		}  	} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  	 {  		throw new startServiceException (service.DisplayName);  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist   {  	//Status senden  	onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  	//Dienst anhalten  	service.Stop ();  	//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  	service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  	//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  	if (service.Status == ServiceControllerStatus.Stopped) {  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  		//Dienst starten  		if (!string.IsNullOrEmpty (action.Arguments)) {  			service.Start (action.Arguments.Split (' '));  		} else {  			service.Start ();  		}  		service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  		if (service.Status != ServiceControllerStatus.Running) {  			throw new stopServiceException (service.DisplayName);  		}  	} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  	 {  		throw new startServiceException (service.DisplayName);  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: if (service.Status == ServiceControllerStatus.Stopped) {  	//Status senden  	onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  	//Dienst starten  	if (!string.IsNullOrEmpty (action.Arguments)) {  		service.Start (action.Arguments.Split (' '));  	} else {  		service.Start ();  	}  	service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  	if (service.Status != ServiceControllerStatus.Running) {  		throw new stopServiceException (service.DisplayName);  	}  } else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.   {  	throw new startServiceException (service.DisplayName);  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStopServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStopServiceAction.cs,executeAction,The following statement contains a magic number: foreach (ServiceController service in services) {  	if (string.Equals (service.ServiceName.ToLower ()' action.serviceName.ToLower ())) {  		//Überprüfe ob der Dienst läuft  		if (service.Status == ServiceControllerStatus.Running) {  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStopServiceAction_stopService")' service.DisplayName)' 100);  			service.Stop ();  			service.WaitForStatus (ServiceControllerStatus.Stopped' timeout);  			if (service.Status != ServiceControllerStatus.Stopped) {  				throw new stopServiceException (service.DisplayName);  			}  		}  		break;  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStopServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStopServiceAction.cs,executeAction,The following statement contains a magic number: if (string.Equals (service.ServiceName.ToLower ()' action.serviceName.ToLower ())) {  	//Überprüfe ob der Dienst läuft  	if (service.Status == ServiceControllerStatus.Running) {  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStopServiceAction_stopService")' service.DisplayName)' 100);  		service.Stop ();  		service.WaitForStatus (ServiceControllerStatus.Stopped' timeout);  		if (service.Status != ServiceControllerStatus.Stopped) {  			throw new stopServiceException (service.DisplayName);  		}  	}  	break;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStopServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStopServiceAction.cs,executeAction,The following statement contains a magic number: if (service.Status == ServiceControllerStatus.Running) {  	//Status senden  	onProgressChanged (string.Format (Language.GetString ("applyStopServiceAction_stopService")' service.DisplayName)' 100);  	service.Stop ();  	service.WaitForStatus (ServiceControllerStatus.Stopped' timeout);  	if (service.Status != ServiceControllerStatus.Stopped) {  		throw new stopServiceException (service.DisplayName);  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyStopServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStopServiceAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (string.Format (Language.GetString ("applyStopServiceAction_stopService")' service.DisplayName)' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,Percent,The following statement contains a magic number: try {  	return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  } catch {  	return 100;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,Percent,The following statement contains a magic number: try {  	return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  } catch {  	return 100;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,Percent,The following statement contains a magic number: return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,Percent,The following statement contains a magic number: return 100;  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,NGenInstall,The following statement contains a magic number: process.WaitForExit (60 * 1000);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,NGenInstall,The following statement contains a magic number: process.WaitForExit (60 * 1000);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,NGenUninstall,The following statement contains a magic number: process.WaitForExit (60 * 1000);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateBase,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateBase.cs,NGenUninstall,The following statement contains a magic number: process.WaitForExit (60 * 1000);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (updateProgressChanged != null) {  	if (m_onRollback) {  		var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100));  	} else {  		var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100));  		updateProgressChanged (this' eArgs);  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (updateProgressChanged != null) {  	if (m_onRollback) {  		var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100));  	} else {  		var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100));  		updateProgressChanged (this' eArgs);  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (updateProgressChanged != null) {  	if (m_onRollback) {  		var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100));  	} else {  		var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100));  		updateProgressChanged (this' eArgs);  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (updateProgressChanged != null) {  	if (m_onRollback) {  		var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100));  	} else {  		var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100));  		updateProgressChanged (this' eArgs);  	}  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (m_onRollback) {  	var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100));  } else {  	var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100));  	updateProgressChanged (this' eArgs);  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (m_onRollback) {  	var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100));  } else {  	var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100));  	updateProgressChanged (this' eArgs);  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (m_onRollback) {  	var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100));  } else {  	var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100));  	updateProgressChanged (this' eArgs);  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,action_progressChanged,The following statement contains a magic number: if (m_onRollback) {  	var rArgs = new applyUpdateProgressChangedEventArgs (Language.GetString ("applyUpdateManager_rollback")' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_performedUpdateActions.Count * 100));  } else {  	var eArgs = new applyUpdateProgressChangedEventArgs (e.actionName' e.actionDescription' Percent (e.percentDone + (applyUpdateActionCount * 100)' m_updateActions.Count * 100));  	updateProgressChanged (this' eArgs);  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,Percent,The following statement contains a magic number: try {  	return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  } catch {  	return 100;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,Percent,The following statement contains a magic number: try {  	return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  } catch {  	return 100;  }  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,Percent,The following statement contains a magic number: return (int)(((CurrVal / ((double)MaxVal)) * 100.0));  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUpdateManager,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUpdateManager.cs,Percent,The following statement contains a magic number: return 100;  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyUserInteractionAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyUserInteractionAction.cs,executeAction,The following statement contains a magic number: onProgressChanged (""' 100);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyValidatePackageSignature,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyValidatePackageSignature.cs,executeAction,The following statement contains a magic number: onProgressChanged (Language.GetString ("applyValidatePackageAction_progressStep_1")' 50);  
Magic Number,updateSystemDotNet.Updater.applyUpdate,applyValidatePackageSignature,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyValidatePackageSignature.cs,executeAction,The following statement contains a magic number: onProgressChanged (Language.GetString ("applyValidatePackageAction_progressStep_2")' 100);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var s = new FileStream (file' FileMode.Open' FileAccess.Read)) {  	using (var r = new BinaryReader (s)) {  		byte[] bytes = r.ReadBytes (2);  		// Verify file starts with "MZ" signature.  		if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  			// Not a PE file.  			return null;  		}  		// Partion II' 25.2.1  		// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  		s.Seek (0x3c' SeekOrigin.Begin);  		// read the offset to the PE Header  		uint offset = r.ReadUInt32 ();  		// go to the beginning of the PE Header  		s.Seek (offset' SeekOrigin.Begin);  		bytes = r.ReadBytes (4);  		// Verify PE header starts with 'PE\0\0'.  		if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  			// Not a PE file.  			return null;  		}  		// It's a PE file' verify that it has the right "machine" code.  		// Partion II' 25.2.2  		//  		ushort machineCode = r.ReadUInt16 ();  		// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  		// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  		if (!(machineCode == 0x014c || machineCode == 0x8664)) {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Locate the PE_OPTIONAL_HEADER  		// The PE_FILE_HEADER is 20bytes long we already  		// read the 2 byte machine code (hence 18byte seek)  		s.Seek (18' SeekOrigin.Current);  		ushort magic = r.ReadUInt16 ();  		switch (magic) {  		case 0x10b:  			// PE32  			// set to AnyCPU for now - we'll check later if image is x86 specific  			assembInfo.CPUVersion = CPUVersion.AnyCPU;  			break;  		case 0x20b:  			// PE32+ (aka x64)  			assembInfo.CPUVersion = CPUVersion.x64;  			break;  		default:  			// unknown assembly type  			return null;  		}  		// Read the SectionAlignment & FileAlignment for  		// conversion from RVA to file address  		s.Seek (30' SeekOrigin.Current);  		uint sectionAlignment = r.ReadUInt32 ();  		uint fileAlignment = r.ReadUInt32 ();  		// go to 'NumberOfRvaAndSizes' in the PE Header  		// at 92/108 from start of PE Header for PE32/PE32+  		s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  		// verify that the number of data directories is 0x10.  		uint numDataDirs = r.ReadUInt32 ();  		// Partition II' 25.2.3.2  		if (numDataDirs != 0x10)// Partition II' 25.2.3.2  		 {  			// Invalid or unrecognized PE file of some kind.  			return null;  		}  		// Go to the CLR Runtime Header  		// at 208/224 from start of PE Header for PE32/PE32+  		s.Seek (112' SeekOrigin.Current);  		// Check for the existence of a non-null CLI header.  		// If found' this is an assembly of some kind' otherwise  		// it's a native PE file of one kind or another.  		uint rvaCLIHeader = r.ReadUInt32 ();  		// Partition II' 25.2.3.3' CLI Header (rva)  		// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  		if (rvaCLIHeader == 0) {  			// Not an assembly.  			return null;  		}  		// Partition II' 25.3.3 (CLI Header)  		// Go to the begginning of the CLI header (RVA -> file address)  		/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  		s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  		ushort majorVersion = r.ReadUInt16 ();  		ushort minorVersion = r.ReadUInt16 ();  		// 2.5 means the file is a .NET Framework 2.0+ assembly  		if (!(majorVersion == 2 && minorVersion == 5))  			return null;  		// RVA for the MetaData (we'll read the metadata later)  		uint rvaMetaData = r.ReadUInt32 ();  		s.Seek (4' SeekOrigin.Current);  		// skip the size  		// Partition II' 25.3.3.1  		// read the CLI flags  		uint cliFlags = r.ReadUInt32 ();  		// Detect if compiled with Platform Target of "x86"  		// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  		if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  			assembInfo.CPUVersion = CPUVersion.x86;  		}  		// Detect if the assembly is built with a strong name  		// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  		assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  		s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  		// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  		// read the version string length  		int versionLen = r.ReadInt32 ();  		char[] versionStr = r.ReadChars (versionLen);  		// read the .NET framework version required from the meta-data  		//Note: we only read the first 2 numbers of the version - if you want to  		//      detect beta vs. rc vs. rtm' then read the whole version.  		// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  		if (versionStr [1] == '2' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  		else if (versionStr [1] == '4' && versionStr [3] == '0')  			assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  		else  			assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  	}  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: using (var r = new BinaryReader (s)) {  	byte[] bytes = r.ReadBytes (2);  	// Verify file starts with "MZ" signature.  	if ((bytes [0] != 0x4d) || (bytes [1] != 0x5a)) {  		// Not a PE file.  		return null;  	}  	// Partion II' 25.2.1  	// OFFSET_TO_PE_HEADER_OFFSET = 0x3c  	s.Seek (0x3c' SeekOrigin.Begin);  	// read the offset to the PE Header  	uint offset = r.ReadUInt32 ();  	// go to the beginning of the PE Header  	s.Seek (offset' SeekOrigin.Begin);  	bytes = r.ReadBytes (4);  	// Verify PE header starts with 'PE\0\0'.  	if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  		// Not a PE file.  		return null;  	}  	// It's a PE file' verify that it has the right "machine" code.  	// Partion II' 25.2.2  	//  	ushort machineCode = r.ReadUInt16 ();  	// IMAGE_FILE_MACHINE_AMD64 (aka x64) = 0x8664  	// IMAGE_FILE_MACHINE_I386 (aka x86) = 0x14c  	if (!(machineCode == 0x014c || machineCode == 0x8664)) {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Locate the PE_OPTIONAL_HEADER  	// The PE_FILE_HEADER is 20bytes long we already  	// read the 2 byte machine code (hence 18byte seek)  	s.Seek (18' SeekOrigin.Current);  	ushort magic = r.ReadUInt16 ();  	switch (magic) {  	case 0x10b:  		// PE32  		// set to AnyCPU for now - we'll check later if image is x86 specific  		assembInfo.CPUVersion = CPUVersion.AnyCPU;  		break;  	case 0x20b:  		// PE32+ (aka x64)  		assembInfo.CPUVersion = CPUVersion.x64;  		break;  	default:  		// unknown assembly type  		return null;  	}  	// Read the SectionAlignment & FileAlignment for  	// conversion from RVA to file address  	s.Seek (30' SeekOrigin.Current);  	uint sectionAlignment = r.ReadUInt32 ();  	uint fileAlignment = r.ReadUInt32 ();  	// go to 'NumberOfRvaAndSizes' in the PE Header  	// at 92/108 from start of PE Header for PE32/PE32+  	s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  	// verify that the number of data directories is 0x10.  	uint numDataDirs = r.ReadUInt32 ();  	// Partition II' 25.2.3.2  	if (numDataDirs != 0x10)// Partition II' 25.2.3.2  	 {  		// Invalid or unrecognized PE file of some kind.  		return null;  	}  	// Go to the CLR Runtime Header  	// at 208/224 from start of PE Header for PE32/PE32+  	s.Seek (112' SeekOrigin.Current);  	// Check for the existence of a non-null CLI header.  	// If found' this is an assembly of some kind' otherwise  	// it's a native PE file of one kind or another.  	uint rvaCLIHeader = r.ReadUInt32 ();  	// Partition II' 25.2.3.3' CLI Header (rva)  	// uint cliHeaderSize = UIntFromBytes(pPEOptionalHeader + 212); // Partition II' 25.2.3.3' CLI Header (size)  	if (rvaCLIHeader == 0) {  		// Not an assembly.  		return null;  	}  	// Partition II' 25.3.3 (CLI Header)  	// Go to the begginning of the CLI header (RVA -> file address)  	/* 					-> Converting from Relative Virtual Address to File Address:  					   FA = RVA - sectionAlignment + fileAlignment 				  						   The section alignment in memory is sectionAlignment (usually 0x2000)' 					   and since the RVA for the CLR header is 2008' on subtracting 2000 from 					   2008' the difference comes to 8. Thus' the CLR header is placed 8 bytes 					   away from the start of the section.   						   A file on disk has the alignment of fileAlignment (usually 512 bytes). 					   Therefore' the first section would start at position 512 from the start 					   of the file. As the CLR is 8 bytes away from the section start' 8 is added 					   to 512' (section start for a file on disk)' thereby arriving at a value of 520. 					   The next 72 bytes (0x48) are picked up from this position' since they 					   constitute the CLR header' and they are loaded at location 0x4002008.  					*/// Also' skip the CLI header size = 4 bytes  	s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  	ushort majorVersion = r.ReadUInt16 ();  	ushort minorVersion = r.ReadUInt16 ();  	// 2.5 means the file is a .NET Framework 2.0+ assembly  	if (!(majorVersion == 2 && minorVersion == 5))  		return null;  	// RVA for the MetaData (we'll read the metadata later)  	uint rvaMetaData = r.ReadUInt32 ();  	s.Seek (4' SeekOrigin.Current);  	// skip the size  	// Partition II' 25.3.3.1  	// read the CLI flags  	uint cliFlags = r.ReadUInt32 ();  	// Detect if compiled with Platform Target of "x86"  	// COMIMAGE_FLAGS_32BITREQUIRED = 0x2;  	if (assembInfo.CPUVersion == CPUVersion.AnyCPU && (cliFlags & 0x2) == 0x2) {  		assembInfo.CPUVersion = CPUVersion.x86;  	}  	// Detect if the assembly is built with a strong name  	// CLI_FLAG_STRONG_NAME_SIGNED = 0x8;  	assembInfo.StrongName = ((cliFlags & 0x8) == 0x8);  	s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  	// Read the framework version required (meta data - Partition II' 24.2.1 - pg 200)  	// read the version string length  	int versionLen = r.ReadInt32 ();  	char[] versionStr = r.ReadChars (versionLen);  	// read the .NET framework version required from the meta-data  	//Note: we only read the first 2 numbers of the version - if you want to  	//      detect beta vs. rc vs. rtm' then read the whole version.  	// We assume no one will be stupid enough to use beta created exes/dlls in the wild.  	if (versionStr [1] == '2' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  	else if (versionStr [1] == '4' && versionStr [3] == '0')  		assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  	else  		assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: bytes = r.ReadBytes (4);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  	// Not a PE file.  	return null;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: if ((bytes [0] != 0x50) || (bytes [1] != 0x45) || (bytes [2] != 0) || (bytes [3] != 0)) {  	// Not a PE file.  	return null;  }  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: s.Seek (18' SeekOrigin.Current);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: s.Seek (30' SeekOrigin.Current);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: s.Seek (magic == 0x10b ? 52 : 68' SeekOrigin.Current);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: s.Seek (112' SeekOrigin.Current);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: s.Seek ((rvaCLIHeader - sectionAlignment + fileAlignment) + 4' SeekOrigin.Begin);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: if (!(majorVersion == 2 && minorVersion == 5))  	return null;  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: if (!(majorVersion == 2 && minorVersion == 5))  	return null;  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: s.Seek (4' SeekOrigin.Current);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: s.Seek ((rvaMetaData - sectionAlignment + fileAlignment) + 12' SeekOrigin.Begin);  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: if (versionStr [1] == '2' && versionStr [3] == '0')  	assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  else if (versionStr [1] == '4' && versionStr [3] == '0')  	assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  else  	assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: if (versionStr [1] == '2' && versionStr [3] == '0')  	assembInfo.FrameworkVersion = FrameworkVersion.Net2_0;  else if (versionStr [1] == '4' && versionStr [3] == '0')  	assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  else  	assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  
Magic Number,updateSystemDotNet.Updater,assemblyInfo,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\assemblyInfo.cs,FromFile,The following statement contains a magic number: if (versionStr [1] == '4' && versionStr [3] == '0')  	assembInfo.FrameworkVersion = FrameworkVersion.Net4_0;  else  	assembInfo.FrameworkVersion = FrameworkVersion.Unknown;  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_drawTop) {  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  	int TextWidth;  	if (m_Image == null) {  		TextWidth = 10;  	} else {  		TextWidth = 50;  	}  	//Draw Text  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;  	TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  	Size DesSize = TextRenderer.MeasureText (m_description' new Font ("Tahoma"' 8));  	var DesBounds = new Rectangle (TextWidth' 20' DesSize.Width' DesSize.Height);  	TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  	//DrawImage  	if (m_Image != null) {  		e.Graphics.DrawImage (m_Image' new Point (5' 10));  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 52)' new Point (Width' 52));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_Image == null) {  	TextWidth = 10;  } else {  	TextWidth = 50;  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_Image == null) {  	TextWidth = 10;  } else {  	TextWidth = 50;  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: TextWidth = 10;  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: TextWidth = 50;  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: TextRenderer.DrawText (e.Graphics' m_Title' new Font ("Tahoma"' 8' FontStyle.Bold)' new Point (TextWidth' 5)' m_TitleColor);  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: TextRenderer.DrawText (e.Graphics' m_description' new Font ("Tahoma"' 8)' DesBounds' m_DescriptionColor);  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_Image != null) {  	e.Graphics.DrawImage (m_Image' new Point (5' 10));  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: if (m_Image != null) {  	e.Graphics.DrawImage (m_Image' new Point (5' 10));  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawImage (m_Image' new Point (5' 10));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawImage (m_Image' new Point (5' 10));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.FillRectangle (new SolidBrush (Color.FromArgb (240' 240' 240))' rectBottom);  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.FillRectangle (new SolidBrush (Color.FromArgb (240' 240' 240))' rectBottom);  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.FillRectangle (new SolidBrush (Color.FromArgb (240' 240' 240))' rectBottom);  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' ClientRectangle.Height - 34)' new Point (ClientRectangle.Width' ClientRectangle.Height - 34));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' ClientRectangle.Height - 34)' new Point (ClientRectangle.Width' ClientRectangle.Height - 34));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' ClientRectangle.Height - 34)' new Point (ClientRectangle.Width' ClientRectangle.Height - 34));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' ClientRectangle.Height - 34)' new Point (ClientRectangle.Width' ClientRectangle.Height - 34));  
Magic Number,updateSystemDotNet.Updater.UI.Components,dlgTemplate,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\dlgTemplate.cs,OnPaintBackground,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' ClientRectangle.Height - 34)' new Point (ClientRectangle.Width' ClientRectangle.Height - 34));  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,statusLabel,The following statement contains a magic number: tmrCircle.Interval = 50;  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,tmrCircle_Tick,The following statement contains a magic number: if (circleIndex >= 18) {  	circleIndex = 0;  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: if (_state != statusLabelStates.Waiting) {  	Image image = null;  	switch (_state) {  	case statusLabelStates.Success:  		image = getResourceImage ("statuslabel_success.png");  		break;  	case statusLabelStates.Failure:  		image = getResourceImage ("statuslabel_error.png");  		break;  	case statusLabelStates.Progress:  		image = getCircleImage ();  		break;  	}  	e.Graphics.DrawImage (image' new Rectangle (new Point (3' (ClientRectangle.Height / 2) - (image.Height / 2))' new Size (image.Width' image.Height)));  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: if (_state != statusLabelStates.Waiting) {  	Image image = null;  	switch (_state) {  	case statusLabelStates.Success:  		image = getResourceImage ("statuslabel_success.png");  		break;  	case statusLabelStates.Failure:  		image = getResourceImage ("statuslabel_error.png");  		break;  	case statusLabelStates.Progress:  		image = getCircleImage ();  		break;  	}  	e.Graphics.DrawImage (image' new Rectangle (new Point (3' (ClientRectangle.Height / 2) - (image.Height / 2))' new Size (image.Width' image.Height)));  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: if (_state != statusLabelStates.Waiting) {  	Image image = null;  	switch (_state) {  	case statusLabelStates.Success:  		image = getResourceImage ("statuslabel_success.png");  		break;  	case statusLabelStates.Failure:  		image = getResourceImage ("statuslabel_error.png");  		break;  	case statusLabelStates.Progress:  		image = getCircleImage ();  		break;  	}  	e.Graphics.DrawImage (image' new Rectangle (new Point (3' (ClientRectangle.Height / 2) - (image.Height / 2))' new Size (image.Width' image.Height)));  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawImage (image' new Rectangle (new Point (3' (ClientRectangle.Height / 2) - (image.Height / 2))' new Size (image.Width' image.Height)));  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawImage (image' new Rectangle (new Point (3' (ClientRectangle.Height / 2) - (image.Height / 2))' new Size (image.Width' image.Height)));  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawImage (image' new Rectangle (new Point (3' (ClientRectangle.Height / 2) - (image.Height / 2))' new Size (image.Width' image.Height)));  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (circle)) {  	g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (circle)) {  	g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (circle)) {  	g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (circle)) {  	g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (circle)) {  	g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  }  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  
Magic Number,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,getCircleImage,The following statement contains a magic number: g.DrawImage (getResourceImage ("statuslabel_progress.png")' new Rectangle (0' 0' 16' 16)' new Rectangle (0' (16 * circleIndex)' 16' 16)' GraphicsUnit.Pixel);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,Close_Process,The following statement contains a magic number: try {  	Process[] processes = Process.GetProcessesByName (proc_name);  	if (processes.Length > 0) {  		foreach (Process proc in processes) {  			proc.CloseMainWindow ();  			proc.WaitForExit (0x1388);  			proc.Kill ();  		}  	}  	Thread.Sleep (500);  } catch (Exception ex) {  	MessageBox.Show (ex.Message' "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error);  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,Close_Process,The following statement contains a magic number: Thread.Sleep (500);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Location = new System.Drawing.Point (0' 187);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.MaximumSize = new System.Drawing.Size (0' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.MinimumSize = new System.Drawing.Size (0' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size (379' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size (379' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.TabIndex = 4;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (297' 6);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (297' 6);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.MinimumSize = new System.Drawing.Size (64' 0);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (73' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (73' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.Location = new System.Drawing.Point (12' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.Location = new System.Drawing.Point (12' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.Size = new System.Drawing.Size (50' 50);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.Size = new System.Drawing.Size (50' 50);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.imgProcess.TabIndex = 5;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point (68' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point (68' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size (247' 16);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size (247' 16);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.TabIndex = 6;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.Location = new System.Drawing.Point (12' 68);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.Location = new System.Drawing.Point (12' 68);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.Size = new System.Drawing.Size (247' 113);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.Size = new System.Drawing.Size (247' 113);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lvwProcesses.TabIndex = 7;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.columnHeader1.Width = 219;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.Location = new System.Drawing.Point (265' 68);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.Location = new System.Drawing.Point (265' 68);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.Size = new System.Drawing.Size (105' 23);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.Size = new System.Drawing.Size (105' 23);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnKillProcess.TabIndex = 8;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.Location = new System.Drawing.Point (265' 97);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.Location = new System.Drawing.Point (265' 97);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.Size = new System.Drawing.Size (105' 23);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.Size = new System.Drawing.Size (105' 23);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.btnRefresh.TabIndex = 9;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.Location = new System.Drawing.Point (68' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.Location = new System.Drawing.Point (68' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.Size = new System.Drawing.Size (302' 28);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.Size = new System.Drawing.Size (302' 28);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.lblDescription.TabIndex = 10;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (379' 221);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,dlgOpenProcesses,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\dlgOpenProcesses.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (379' 221);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.pnlBottom.Location = new System.Drawing.Point (0' 148);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.pnlBottom.Size = new System.Drawing.Size (346' 35);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.pnlBottom.Size = new System.Drawing.Size (346' 35);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.pnlBottom.TabIndex = 21;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Location = new System.Drawing.Point (-20' 0);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.MinimumSize = new System.Drawing.Size (0' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding (3' 4' 3' 3);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding (3' 4' 3' 3);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding (3' 4' 3' 3);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding (3' 4' 3' 3);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size (366' 35);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size (366' 35);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.TabIndex = 11;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.Location = new System.Drawing.Point (247' 7);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.Location = new System.Drawing.Point (247' 7);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.MinimumSize = new System.Drawing.Size (64' 21);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.MinimumSize = new System.Drawing.Size (64' 21);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.Size = new System.Drawing.Size (110' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnAbort.Size = new System.Drawing.Size (110' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.Location = new System.Drawing.Point (160' 7);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.Location = new System.Drawing.Point (160' 7);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.MinimumSize = new System.Drawing.Size (64' 21);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.MinimumSize = new System.Drawing.Size (64' 21);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.Size = new System.Drawing.Size (81' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnRetry.Size = new System.Drawing.Size (81' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.Location = new System.Drawing.Point (50' 39);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.Location = new System.Drawing.Point (50' 39);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.Size = new System.Drawing.Size (287' 106);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.Size = new System.Drawing.Size (287' 106);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblInfo.TabIndex = 23;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point (47' 9);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point (47' 9);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size (161' 18);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size (161' 18);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.TabIndex = 22;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.Location = new System.Drawing.Point (9' 9);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.Location = new System.Drawing.Point (9' 9);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.Size = new System.Drawing.Size (32' 32);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.Size = new System.Drawing.Size (32' 32);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgExclamation.TabIndex = 24;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (346' 183);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (346' 183);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.TitleColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,fileAccessDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\fileAccessDialog.cs,InitializeComponent,The following statement contains a magic number: this.TitleColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: SetClientSizeCore (ClientRectangle.Width' (12 + lblTitle.Height + 10 + lblMessage.Height + 12 + flpBottom.Height));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: SetClientSizeCore (ClientRectangle.Width' (12 + lblTitle.Height + 10 + lblMessage.Height + 12 + flpBottom.Height));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: SetClientSizeCore (ClientRectangle.Width' (12 + lblTitle.Height + 10 + lblMessage.Height + 12 + flpBottom.Height));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: lblMessage.Location = new Point (lblMessage.Location.X' (12 + lblTitle.Height + 10));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following statement contains a magic number: lblMessage.Location = new Point (lblMessage.Location.X' (12 + lblTitle.Height + 10));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  	e.Graphics.Clear (Color.FromArgb (240' 240' 240));  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  } catch {  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  	e.Graphics.Clear (Color.FromArgb (240' 240' 240));  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  } catch {  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  	e.Graphics.Clear (Color.FromArgb (240' 240' 240));  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  } catch {  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  	e.Graphics.Clear (Color.FromArgb (240' 240' 240));  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  } catch {  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  	e.Graphics.Clear (Color.FromArgb (240' 240' 240));  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  } catch {  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: try {  	e.Graphics.Clear (Color.FromArgb (240' 240' 240));  	e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  } catch {  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: e.Graphics.Clear (Color.FromArgb (240' 240' 240));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: e.Graphics.Clear (Color.FromArgb (240' 240' 240));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: e.Graphics.Clear (Color.FromArgb (240' 240' 240));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,flpBottom_Paint,The following statement contains a magic number: e.Graphics.DrawLine (new Pen (Color.FromArgb (223' 223' 223)' 1)' new Point (0' 0)' new Point (flpBottom.ClientRectangle.Width' 0));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Location = new System.Drawing.Point (0' 118);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.MinimumSize = new System.Drawing.Size (0' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size (350' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.Size = new System.Drawing.Size (350' 34);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.flpBottom.TabIndex = 13;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (274' 6);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (274' 6);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.MinimumSize = new System.Drawing.Size (64' 0);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (67' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (67' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Location = new System.Drawing.Point (204' 6);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Location = new System.Drawing.Point (204' 6);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.MinimumSize = new System.Drawing.Size (64' 0);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Size = new System.Drawing.Size (64' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Size = new System.Drawing.Size (64' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.TabIndex = 3;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.Location = new System.Drawing.Point (51' 51);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.Location = new System.Drawing.Point (51' 51);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.MaximumSize = new System.Drawing.Size (288' 0);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.MinimumSize = new System.Drawing.Size (0' 50);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.Size = new System.Drawing.Size (65' 50);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.Size = new System.Drawing.Size (65' 50);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblMessage.TabIndex = 16;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point (50' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point (50' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.MaximumSize = new System.Drawing.Size (288' 0);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.MinimumSize = new System.Drawing.Size (0' 20);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size (54' 21);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size (54' 21);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.TabIndex = 15;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.Location = new System.Drawing.Point (12' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.Location = new System.Drawing.Point (12' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.Size = new System.Drawing.Size (32' 32);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.Size = new System.Drawing.Size (32' 32);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.imgInformation.TabIndex = 14;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (350' 152);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (350' 152);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm,The following statement contains a magic number: lblStatus.Font = new Font (SystemFonts.MessageBoxFont.FontFamily' 12);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The following statement contains a magic number: if (m_updateManager.isBusy) {  	e.Cancel = true;  } else {  	BlockLogOff (false);  	if (m_updateManager.currentConfig.Settings.restartApplication && File.Exists (m_updateManager.currentConfig.Settings.applicationPath)) {  		if (Environment.OSVersion.Version.Major >= 6 && IsAdmin ()) {  			IntPtr hProcess = IntPtr.Zero;  			Security.ExecRequireNonAdmin (this' m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ()' out hProcess);  			//Wenn Prozess nicht gestartet' dann normal starten  			try {  				if (hProcess == IntPtr.Zero)  					Process.Start (m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ());  			} catch (Win32Exception) {  			}  		} else {  			try {  				Process.Start (m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ());  			} catch (Win32Exception) {  			}  		}  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The following statement contains a magic number: if (m_updateManager.currentConfig.Settings.restartApplication && File.Exists (m_updateManager.currentConfig.Settings.applicationPath)) {  	if (Environment.OSVersion.Version.Major >= 6 && IsAdmin ()) {  		IntPtr hProcess = IntPtr.Zero;  		Security.ExecRequireNonAdmin (this' m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ()' out hProcess);  		//Wenn Prozess nicht gestartet' dann normal starten  		try {  			if (hProcess == IntPtr.Zero)  				Process.Start (m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ());  		} catch (Win32Exception) {  		}  	} else {  		try {  			Process.Start (m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ());  		} catch (Win32Exception) {  		}  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_FormClosing,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6 && IsAdmin ()) {  	IntPtr hProcess = IntPtr.Zero;  	Security.ExecRequireNonAdmin (this' m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ()' out hProcess);  	//Wenn Prozess nicht gestartet' dann normal starten  	try {  		if (hProcess == IntPtr.Zero)  			Process.Start (m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ());  	} catch (Win32Exception) {  	}  } else {  	try {  		Process.Start (m_updateManager.currentConfig.Settings.applicationPath' extendCommandLineArguments ());  	} catch (Win32Exception) {  	}  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The following statement contains a magic number: Location = new Point ((Screen.PrimaryScreen.WorkingArea.Width / 2) - (Width / 2)' (Screen.PrimaryScreen.WorkingArea.Height / 2) - (Height / 2));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The following statement contains a magic number: Location = new Point ((Screen.PrimaryScreen.WorkingArea.Width / 2) - (Width / 2)' (Screen.PrimaryScreen.WorkingArea.Height / 2) - (Height / 2));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The following statement contains a magic number: Location = new Point ((Screen.PrimaryScreen.WorkingArea.Width / 2) - (Width / 2)' (Screen.PrimaryScreen.WorkingArea.Height / 2) - (Height / 2));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,MainForm_Load,The following statement contains a magic number: Location = new Point ((Screen.PrimaryScreen.WorkingArea.Width / 2) - (Width / 2)' (Screen.PrimaryScreen.WorkingArea.Height / 2) - (Height / 2));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,BlockLogOff,The following statement contains a magic number: if (Environment.OSVersion.Version.Major < 6) {  	return;  }  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(51))))' ((int)(((byte)(153)))));  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Location = new System.Drawing.Point (50' 5);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Location = new System.Drawing.Point (50' 5);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Size = new System.Drawing.Size (336' 32);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Size = new System.Drawing.Size (336' 32);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.TabIndex = 11;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.Location = new System.Drawing.Point (12' 5);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.Location = new System.Drawing.Point (12' 5);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.Size = new System.Drawing.Size (32' 32);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.Size = new System.Drawing.Size (32' 32);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.imageApplication.TabIndex = 15;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Location = new System.Drawing.Point (0' 158);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Padding = new System.Windows.Forms.Padding (0' 10' 12' 0);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Padding = new System.Windows.Forms.Padding (0' 10' 12' 0);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Size = new System.Drawing.Size (398' 43);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.Size = new System.Drawing.Size (398' 43);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonArea1.TabIndex = 18;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (316' 13);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (316' 13);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (67' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (67' 22);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.Location = new System.Drawing.Point (12' 52);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.Location = new System.Drawing.Point (12' 52);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.Size = new System.Drawing.Size (374' 23);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.Size = new System.Drawing.Size (374' 23);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclDownload.TabIndex = 17;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.Location = new System.Drawing.Point (12' 81);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.Location = new System.Drawing.Point (12' 81);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.Size = new System.Drawing.Size (374' 37);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.Size = new System.Drawing.Size (374' 37);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aclApply.TabIndex = 16;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.Location = new System.Drawing.Point (13' 132);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.Location = new System.Drawing.Point (13' 132);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.Size = new System.Drawing.Size (370' 16);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.Size = new System.Drawing.Size (370' 16);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.prgUpdate.TabIndex = 14;  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (398' 201);  
Magic Number,updateSystemDotNet.Updater.UI.Forms,MainForm,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (398' 201);  
Missing Default,updateSystemDotNet.Core,Helper,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\..\updateController\Core\Helper.cs,getPraefix,The following switch statement is missing a default case: switch (architecure) {  case updatePackage.SupportedArchitectures.Both:  	return "bth_";  case updatePackage.SupportedArchitectures.x86:  	return "x86_";  case updatePackage.SupportedArchitectures.x64:  	return "x64_";  }  
Missing Default,updateSystemDotNet.Updater.applyUpdate,applyFileCopyAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyFileCopyAction.cs,executeAction,The following switch statement is missing a default case: switch (file.copyFlag) {  case fileCopyFlags.OnlyIfExists:  	if (!File.Exists (fileCompletePath)) {  		fileCounter++;  		continue;  	}  	break;  case fileCopyFlags.OnlyIfNotExists:  	if (File.Exists (fileCompletePath)) {  		fileCounter++;  		continue;  	}  	break;  }  
Missing Default,updateSystemDotNet.Updater.applyUpdate,applyStartProcessAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartProcessAction.cs,executeAction,The following switch statement is missing a default case: switch (currentConfiguration.Settings.processSafetyLevel) {  case processSafetyLevel.AskAlways:  	if (!Security.VerifySignedFile (ownerForm' filePath' true' true)) {  		throw new SecurityException (string.Format (Language.GetString ("applyStartProcessAction_exception")' filePath));  	}  	break;  case processSafetyLevel.AskIfUnsigned:  	if (!Security.VerifySignedFile (ownerForm' filePath' true' false)) {  		throw new SecurityException (string.Format (Language.GetString ("applyStartProcessAction_exception")' filePath));  	}  	break;  }  
Missing Default,updateSystemDotNet.Updater.applyUpdate,applyStartServiceAction,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\applyUpdate\applyStartServiceAction.cs,executeAction,The following switch statement is missing a default case: switch (service.Status) {  case ServiceControllerStatus.Stopped:  	//Dienst starten  	//Status senden  	onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  	//Dienst starten  	if (!string.IsNullOrEmpty (action.Arguments)) {  		service.Start (action.Arguments.Split (' '));  	} else {  		service.Start ();  	}  	//Warten bis der Dienst den Status ändert (max. 10 Sekunden)  	service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  	//Wenn der Status nicht Runnig ist' dann eine Exception werfen' dass der Dienst nicht gestartet werden konnte  	if (service.Status != ServiceControllerStatus.Running) {  		throw new startServiceException (service.DisplayName);  	}  	break;  case ServiceControllerStatus.Running:  	if (action.restartIfRunnig)//Dienst neu starten wenn dieser bereits läuft und die entsprechende Option gegeben ist  	 {  		//Status senden  		onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_stopService")' service.DisplayName)' 100);  		//Dienst anhalten  		service.Stop ();  		//Warten bis der Dienst angehalten wurde (max 10 Sekunden)  		service.WaitForStatus (ServiceControllerStatus.Stopped' m_timeout);  		//Wenn der Dienst gestoppt wurde versuchen diesen neu zu starten  		if (service.Status == ServiceControllerStatus.Stopped) {  			//Status senden  			onProgressChanged (string.Format (Language.GetString ("applyStartServiceAction_startService")' service.DisplayName)' 100);  			//Dienst starten  			if (!string.IsNullOrEmpty (action.Arguments)) {  				service.Start (action.Arguments.Split (' '));  			} else {  				service.Start ();  			}  			service.WaitForStatus (ServiceControllerStatus.Running' m_timeout);  			if (service.Status != ServiceControllerStatus.Running) {  				throw new stopServiceException (service.DisplayName);  			}  		} else//Andernfalls eine Exception werfen' dass der Dienst nicht beendet werden konnte.  		 {  			throw new startServiceException (service.DisplayName);  		}  	}  	break;  }  
Missing Default,updateSystemDotNet.Updater,Language,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\Language.cs,Set_Language,The following switch statement is missing a default case: switch (language) {  case Languages.Auto:  	if (Thread.CurrentThread.CurrentCulture.Name.StartsWith ("de")) {  		res_man = new ResourceManager ("updateSystemDotNet.Updater.Localization.language.deu"' Assembly.GetExecutingAssembly ());  	} else {  		res_man = new ResourceManager ("updateSystemDotNet.Updater.Localization.language.eng"' Assembly.GetExecutingAssembly ());  	}  	break;  case Languages.Deutsch:  	res_man = new ResourceManager ("updateSystemDotNet.Updater.Localization.language.deu"' Assembly.GetExecutingAssembly ());  	break;  case Languages.English:  	res_man = new ResourceManager ("updateSystemDotNet.Updater.Localization.language.eng"' Assembly.GetExecutingAssembly ());  	break;  }  
Missing Default,updateSystemDotNet.Updater.UI.Components,statusLabel,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Components\statusLabel.cs,OnPaint,The following switch statement is missing a default case: switch (_state) {  case statusLabelStates.Success:  	image = getResourceImage ("statuslabel_success.png");  	break;  case statusLabelStates.Failure:  	image = getResourceImage ("statuslabel_error.png");  	break;  case statusLabelStates.Progress:  	image = getCircleImage ();  	break;  }  
Missing Default,updateSystemDotNet.Updater.UI.Forms,interactionDialog,D:\newReposJune17\maximilian-krauss_updateSystem.NET\Source\updateInstaller\UI\Forms\interactionDialog.cs,interactionDialog,The following switch statement is missing a default case: switch (buttons) {  case interactionButtons.Close:  	btnCancel.Hide ();  	btnOk.Text = Language.GetString ("general_button_close");  	imgInformation.Image = SystemIcons.Information.ToBitmap ();  	ControlBox = true;  	break;  case interactionButtons.OkCancel:  	btnCancel.Text = Language.GetString ("general_button_cancel");  	btnOk.Text = Language.GetString ("general_button_ok");  	imgInformation.Image = SystemIcons.Question.ToBitmap ();  	break;  case interactionButtons.YesNo_1:  	//Abbruch bei Ja  	btnCancel.Text = Language.GetString ("general_button_no");  	btnOk.Text = Language.GetString ("general_button_yes");  	btnOk.DialogResult = DialogResult.Cancel;  	btnCancel.DialogResult = DialogResult.OK;  	CancelButton = btnOk;  	AcceptButton = btnCancel;  	imgInformation.Image = SystemIcons.Question.ToBitmap ();  	break;  case interactionButtons.YesNo_2:  	//Abbruch bei Nein  	btnCancel.Text = Language.GetString ("general_button_no");  	btnOk.Text = Language.GetString ("general_button_yes");  	imgInformation.Image = SystemIcons.Question.ToBitmap ();  	break;  }  
