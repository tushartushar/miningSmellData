Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Trinity.Encore.Game.IO.Compression,HuffmanDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\HuffmanDecompressor.cs,AdjustTree,Cyclomatic complexity of the method is 10
Complex Method,Trinity.Encore.Game.IO.Formats.Databases,DB2Reader<T>,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\Databases\DB2Reader.cs,ReadData,Cyclomatic complexity of the method is 11
Long Parameter List,Trinity.Encore.Game.Network.Handling,PacketHandlerBase<TPacket>,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Network\Handling\PacketHandlerBase.cs,InvalidValueRange,The method has 5 parameters. Parameters: client' field' expectedLower' expectedUpper' disconnect
Long Statement,Trinity.Encore.Game.Commands,CommandManager,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Commands\CommandManager.cs,ExecuteCommand,The length of the statement  "            if (sender != null && permission != null && permission != typeof(ConsolePermission) && !sender.HasPermission(permission)) " is 121.
Long Statement,Trinity.Encore.Game.Cryptography,SC2AuthenticationParameters,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Cryptography\SC2AuthenticationParameters.cs,SetupParameters,The length of the statement  "            Modulus = new BigInteger("86A7F6DEEB306CE519770FE37D556F29944132554DED0BD68205E27F3231FEF5A10108238A3150C59CAF7B0B6478691C13A6ACF5E1B5ADAFD4A943D4A21A142B800E8A55F8BFBAC700EB77A7235EE5A609E350EA9FC19F10D921C2FA832E4461B7125D38D254A0BE873DFC27858ACB3F8B9F258461E4373BC3A6C2A9634324AB"); " is 285.
Long Statement,Trinity.Encore.Game.Network.Handling,PacketHandlerBase<TPacket>,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Network\Handling\PacketHandlerBase.cs,InvalidValueRange,The length of the statement  "            LogError("{0} was expected to be between {1} and {2} (was {3})".Interpolate(field.Name' expectedLower' expectedUpper' field.Value)' " is 131.
Long Statement,Trinity.Encore.Game.Network.Handling,PacketPropagatorBase<TAttribute;TPacket;THandler>,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Network\Handling\PacketPropagatorBase.cs,HandlePayload,The length of the statement  "                _log.Warn("Client {0} sent an unhandled opcode {1} - disconnected."' client' opCode.ToString("X8"' CultureInfo.InvariantCulture)); " is 130.
Complex Conditional,Trinity.Encore.Game.Commands,CommandManager,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Commands\CommandManager.cs,ExecuteCommand,The conditional expression  "sender != null && permission != null && permission != typeof(ConsolePermission) && !sender.HasPermission(permission)"  is complex.
Magic Number,Trinity.Encore.Game,GameUtility,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\GameUtility.cs,GetClientTypeFromFourCC,The following statement contains a magic number: Contract.Requires(fourCC.Length == 4);
Magic Number,Trinity.Encore.Game,GameUtility,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\GameUtility.cs,GetClientLocaleFromFourCC,The following statement contains a magic number: Contract.Requires(fourCC.Length == 4);
Magic Number,Trinity.Encore.Game,GameUtility,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\GameUtility.cs,GetProcessorFromFourCC,The following statement contains a magic number: Contract.Requires(fourCC.Length == 4);
Magic Number,Trinity.Encore.Game,GameUtility,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\GameUtility.cs,GetPlatformFromFourCC,The following statement contains a magic number: Contract.Requires(fourCC.Length == 4);
Magic Number,Trinity.Encore.Game.Cryptography,WowAuthenticationParameters,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Cryptography\WowAuthenticationParameters.cs,SetupParameters,The following statement contains a magic number: Generator = new BigInteger(7);
Magic Number,Trinity.Encore.Game.Cryptography,SC2AuthenticationParameters,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Cryptography\SC2AuthenticationParameters.cs,SetupParameters,The following statement contains a magic number: Generator = new BigInteger(2);
Magic Number,Trinity.Encore.Game.IO,BitPacker,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\BitPacker.cs,WriteBits,The following statement contains a magic number: var shiftNum = (7 - ((Position & 0x7) - 1));
Magic Number,Trinity.Encore.Game.IO,BitPacker,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\BitPacker.cs,WriteBits,The following statement contains a magic number: var num = 8 - Position;
Magic Number,Trinity.Encore.Game.IO,BitPacker,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\BitPacker.cs,WriteBits,The following statement contains a magic number: if (Position == 7 - (shiftNum - 1))              {                  FlushBuffer(shiftNum);                  return;              }
Magic Number,Trinity.Encore.Game.IO,BitStreamReader,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\BitStreamReader.cs,PeekByte,The following statement contains a magic number: if (!EnsureBits(sizeof(byte) * 8))                  return -1;
Magic Number,Trinity.Encore.Game.IO,BitStreamReader,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\BitStreamReader.cs,EnsureBits,The following statement contains a magic number: _bitCount += sizeof(byte) * 8;
Magic Number,Trinity.Encore.Game.IO,BitUnpacker,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\BitUnpacker.cs,GetNextBit,The following statement contains a magic number: if (_position == 8) // If we've read one byte' get a new one.              {                  _currentValue = _reader.ReadByte();                  _position = 0;              }
Magic Number,Trinity.Encore.Game.IO,BitUnpacker,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\BitUnpacker.cs,GetNextBit,The following statement contains a magic number: return (byte)(bit >> 7);
Magic Number,Trinity.Encore.Game.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\IOExtensions.cs,ReadPackedUInt64,The following statement contains a magic number: for (var i = 0; i < 8; ++i)              {                  if ((guidMark & (1 << i)) == 0)                      continue;                    var bit = reader.ReadByte();                  guid |= (ulong)bit << (i * 8);              }
Magic Number,Trinity.Encore.Game.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\IOExtensions.cs,ReadPackedUInt64,The following statement contains a magic number: for (var i = 0; i < 8; ++i)              {                  if ((guidMark & (1 << i)) == 0)                      continue;                    var bit = reader.ReadByte();                  guid |= (ulong)bit << (i * 8);              }
Magic Number,Trinity.Encore.Game.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\IOExtensions.cs,WritePackedUInt64,The following statement contains a magic number: var packedGuid = new byte[8 + 1];
Magic Number,Trinity.Encore.Game.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\IOExtensions.cs,WritePackedUInt64,The following statement contains a magic number: for (var i = 0; value != 0; ++i)              {                  var guidPart = value & 0xff;                  if (guidPart != 0)                  {                      packedGuid[0] |= (byte)(1 << i);                      packedGuid[size] = (byte)guidPart;                        ++size;                  }                    value >>= 8;              }
Magic Number,Trinity.Encore.Game.IO.Compression,HuffmanDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\HuffmanDecompressor.cs,Decompress,The following statement contains a magic number: using (var outputStream = new MemoryStream())              {                  var bitStream = new BitStreamReader(data);                    int decoded;                  do                  {                      var node = Decode(bitStream' head);                      decoded = node.DecompressedValue;                        switch (decoded)                      {                          case byte.MaxValue:                              break;                          case byte.MaxValue + 1:                              var newValue = bitStream.ReadBits(8);                              outputStream.WriteByte((byte)newValue);                              Contract.Assume(tail != null);                              tail = InsertNode(tail' newValue);                              break;                          default:                              outputStream.WriteByte((byte)decoded);                              break;                      }                  } while (decoded != byte.MaxValue);                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,ImaAdpcmDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\ImaAdpcmDecompressor.cs,Decompress,The following statement contains a magic number: using (var output = new BinaryWriter(outputStream))              {                  input.ReadByte();                  var shift = input.ReadByte();                    for (var i = 0; i < channelCount; i++)                  {                      var temp = input.ReadInt16();                      array2[i] = temp;                      output.Write(temp);                  }                    var channel = channelCount - 1;                    while (!input.BaseStream.IsRead())                  {                      var value = input.ReadByte();                        if (channelCount == 2)                          channel = 1 - channel;                        if ((value & 0x80) != 0)                      {                          switch (value & 0x7f)                          {                              case 0:                                  if (array1[channel] != 0)                                      array1[channel]--;                                    output.Write((short)array2[channel]);                                  break;                              case 1:                                  array1[channel] += 8;                                    if (array1[channel] > 0x58)                                      array1[channel] = 0x58;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                              case 2:                                  break;                              default:                                  array1[channel] -= 8;                                  if (array1[channel] < 0)                                      array1[channel] = 0;                                    if (channelCount == 2)                                      channel = 1 - channel;                                  break;                          }                      }                      else                      {                          var temp1 = _sLookup1[array1[channel]];                          var temp2 = temp1 >> shift;                            if ((value & 1) != 0)                              temp2 += (temp1 >> 0);                            if ((value & 2) != 0)                              temp2 += (temp1 >> 1);                            if ((value & 4) != 0)                              temp2 += (temp1 >> 2);                            if ((value & 8) != 0)                              temp2 += (temp1 >> 3);                            if ((value & 0x10) != 0)                              temp2 += (temp1 >> 4);                            if ((value & 0x20) != 0)                              temp2 += (temp1 >> 5);                            var temp3 = array2[channel];                            if ((value & 0x40) != 0)                          {                              temp3 -= temp2;                              if (temp3 <= short.MinValue)                                  temp3 = short.MinValue;                          }                          else                          {                              temp3 += temp2;                              if (temp3 >= short.MaxValue)                                  temp3 = short.MaxValue;                          }                            array2[channel] = temp3;                          output.Write((short)temp3);                            array1[channel] += _sLookup2[value & 0x1f];                            if (array1[channel] < 0)                              array1[channel] = 0;                          else if (array1[channel] > 0x58)                              array1[channel] = 0x58;                      }                  }                    return outputStream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Compression,PkLibDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\PkLibDecompressor.cs,Decompress,The following statement contains a magic number: if (dictSizeBits < 4 || dictSizeBits > 6)                  throw new InvalidDataException("Invalid dictionary size: {0}".Interpolate(dictSizeBits));
Magic Number,Trinity.Encore.Game.IO.Compression,PkLibDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\PkLibDecompressor.cs,Decompress,The following statement contains a magic number: if (dictSizeBits < 4 || dictSizeBits > 6)                  throw new InvalidDataException("Invalid dictionary size: {0}".Interpolate(dictSizeBits));
Magic Number,Trinity.Encore.Game.IO.Compression,PkLibDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\PkLibDecompressor.cs,DecodeLiteral,The following statement contains a magic number: switch (bitStream.ReadBits(1))              {                  case -1:                      return -1;                  case 1:                      // The next bits are positions in buffers.                      int pos = _sPosition2[bitStream.PeekByte()];                        // Skip the bits we just used.                      var numBits = _sLenBits[pos];                      Contract.Assume(numBits < BitStreamReader.MaxBitCount);                      if (bitStream.ReadBits(numBits) == -1)                          return -1;                            var nBits = _sExLenBits[pos];                      if (nBits != 0)                      {                          Contract.Assume(nBits < BitStreamReader.MaxBitCount);                          var val2 = bitStream.ReadBits(nBits);                          if (val2 == -1 && (pos + val2 != 0x10e))                              return -1;                            pos = _sLenBase[pos] + val2;                      }                        return pos + 0x100; // Return number of bytes to repeat.                  case 0:                      if (compressionType == PkLibCompressionType.Binary)                          return bitStream.ReadBits(sizeof(byte) * 8);                        // TODO: Implement ASCII mode.                      throw new NotImplementedException("ASCII mode is not yet implemented.");                  default:                      return 0;              }
Magic Number,Trinity.Encore.Game.IO.Compression,PkLibDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\PkLibDecompressor.cs,DecodeDistance,The following statement contains a magic number: if (bitStream.EnsureBits(8) == false)                  return 0;
Magic Number,Trinity.Encore.Game.IO.Compression,PkLibDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\PkLibDecompressor.cs,DecodeDistance,The following statement contains a magic number: if (length == 2)              {                  if (bitStream.EnsureBits(2) == false)                      return 0;                    pos = (pos << 2) | bitStream.ReadBits(2);              }              else              {                  if (bitStream.EnsureBits(dictSizeBits) == false)                      return 0;                    pos = ((pos << dictSizeBits)) | bitStream.ReadBits(dictSizeBits);              }
Magic Number,Trinity.Encore.Game.IO.Compression,PkLibDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\PkLibDecompressor.cs,DecodeDistance,The following statement contains a magic number: if (length == 2)              {                  if (bitStream.EnsureBits(2) == false)                      return 0;                    pos = (pos << 2) | bitStream.ReadBits(2);              }              else              {                  if (bitStream.EnsureBits(dictSizeBits) == false)                      return 0;                    pos = ((pos << dictSizeBits)) | bitStream.ReadBits(dictSizeBits);              }
Magic Number,Trinity.Encore.Game.IO.Compression,PkLibDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\PkLibDecompressor.cs,DecodeDistance,The following statement contains a magic number: if (length == 2)              {                  if (bitStream.EnsureBits(2) == false)                      return 0;                    pos = (pos << 2) | bitStream.ReadBits(2);              }              else              {                  if (bitStream.EnsureBits(dictSizeBits) == false)                      return 0;                    pos = ((pos << dictSizeBits)) | bitStream.ReadBits(dictSizeBits);              }
Magic Number,Trinity.Encore.Game.IO.Compression,PkLibDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\PkLibDecompressor.cs,DecodeDistance,The following statement contains a magic number: if (length == 2)              {                  if (bitStream.EnsureBits(2) == false)                      return 0;                    pos = (pos << 2) | bitStream.ReadBits(2);              }              else              {                  if (bitStream.EnsureBits(dictSizeBits) == false)                      return 0;                    pos = ((pos << dictSizeBits)) | bitStream.ReadBits(dictSizeBits);              }
Magic Number,Trinity.Encore.Game.IO.Compression,SparseDecompressor,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Compression\SparseDecompressor.cs,Decompress,The following statement contains a magic number: using (var writer = new BinaryWriter(stream))              {                  var outputLength = reader.ReadInt32BigEndian();                  if (outputLength < 0)                      throw new InvalidDataException("Negative output length encountered.");                    writer.Write(outputLength);                    while (reader.BaseStream.Position < endPos)                  {                      var b = reader.ReadByte();                      var normalData = (b & 0x80) != 0;                        var chunkSize = b & 0x7f + (normalData ? 1 : 3);                      chunkSize = (chunkSize < outputLength) ? chunkSize : outputLength;                        if (chunkSize < 0)                          throw new InvalidDataException("Negative length encountered.");                        var data = normalData ? reader.ReadBytes(chunkSize) : new byte[chunkSize] /* Zero bytes. */;                        writer.Write(data);                  }                    return stream.ToArray();              }
Magic Number,Trinity.Encore.Game.IO.Formats.Databases,DB2Reader<T>,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\Databases\DB2Reader.cs,ReadData,The following statement contains a magic number: if (Build > NewHeaderBuild)              {                  MinId = reader.ReadInt32();                    if (MinId < 0)                      throw new InvalidDataException("Negative minimum ID was encountered.");                    MaxId = reader.ReadInt32();                    if (MaxId < 0)                      throw new InvalidDataException("Negative maximum ID was encountered.");                    Locale = (ClientLocale)reader.ReadInt32();                  Unknown4 = reader.ReadInt32();                    // No idea what these are...                  // TODO: Unhackify this.                  if (MaxId > 0)                  {                      if (MaxId < 12)                          throw new InvalidDataException("Invalid maximum ID value was encountered.");                        var size = MaxId * 4 - 48;                      reader.ReadBytes(size);                      reader.ReadBytes(size * 2);                  }              }
Magic Number,Trinity.Encore.Game.IO.Formats.Databases,DB2Reader<T>,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\Databases\DB2Reader.cs,ReadData,The following statement contains a magic number: if (Build > NewHeaderBuild)              {                  MinId = reader.ReadInt32();                    if (MinId < 0)                      throw new InvalidDataException("Negative minimum ID was encountered.");                    MaxId = reader.ReadInt32();                    if (MaxId < 0)                      throw new InvalidDataException("Negative maximum ID was encountered.");                    Locale = (ClientLocale)reader.ReadInt32();                  Unknown4 = reader.ReadInt32();                    // No idea what these are...                  // TODO: Unhackify this.                  if (MaxId > 0)                  {                      if (MaxId < 12)                          throw new InvalidDataException("Invalid maximum ID value was encountered.");                        var size = MaxId * 4 - 48;                      reader.ReadBytes(size);                      reader.ReadBytes(size * 2);                  }              }
Magic Number,Trinity.Encore.Game.IO.Formats.Databases,DB2Reader<T>,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\Databases\DB2Reader.cs,ReadData,The following statement contains a magic number: if (Build > NewHeaderBuild)              {                  MinId = reader.ReadInt32();                    if (MinId < 0)                      throw new InvalidDataException("Negative minimum ID was encountered.");                    MaxId = reader.ReadInt32();                    if (MaxId < 0)                      throw new InvalidDataException("Negative maximum ID was encountered.");                    Locale = (ClientLocale)reader.ReadInt32();                  Unknown4 = reader.ReadInt32();                    // No idea what these are...                  // TODO: Unhackify this.                  if (MaxId > 0)                  {                      if (MaxId < 12)                          throw new InvalidDataException("Invalid maximum ID value was encountered.");                        var size = MaxId * 4 - 48;                      reader.ReadBytes(size);                      reader.ReadBytes(size * 2);                  }              }
Magic Number,Trinity.Encore.Game.IO.Formats.Databases,DB2Reader<T>,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\Databases\DB2Reader.cs,ReadData,The following statement contains a magic number: if (Build > NewHeaderBuild)              {                  MinId = reader.ReadInt32();                    if (MinId < 0)                      throw new InvalidDataException("Negative minimum ID was encountered.");                    MaxId = reader.ReadInt32();                    if (MaxId < 0)                      throw new InvalidDataException("Negative maximum ID was encountered.");                    Locale = (ClientLocale)reader.ReadInt32();                  Unknown4 = reader.ReadInt32();                    // No idea what these are...                  // TODO: Unhackify this.                  if (MaxId > 0)                  {                      if (MaxId < 12)                          throw new InvalidDataException("Invalid maximum ID value was encountered.");                        var size = MaxId * 4 - 48;                      reader.ReadBytes(size);                      reader.ReadBytes(size * 2);                  }              }
Magic Number,Trinity.Encore.Game.IO.Formats,PTCHReader,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\PTCHReader.cs,Apply,The following statement contains a magic number: while (newFileOffset < sizeAfter)              {                  var diffChunkSize = controlBlock.ReadInt32();                    if (diffChunkSize < 0)                      throw new InvalidDataException("Negative diff chunk size encountered.");                    var extraChunkSize = controlBlock.ReadInt32();                    if (extraChunkSize < 0)                      throw new InvalidDataException("Negative extra chunk size encountered.");                    var extraOffset = controlBlock.ReadInt32();                    var diffChunk = diffBlock.ReadBytes(diffChunkSize);                  Buffer.BlockCopy(diffChunk' 0' newFile' newFileOffset' diffChunkSize);                    for (var i = 0; i < diffChunkSize; i++)                  {                      var oldPlusI = oldFileOffset + i;                      if (oldPlusI < 0 || oldPlusI >= PTCH.OldSize)                          continue;                        var newPlusI = newFileOffset + i;                      var nb = newFile[newPlusI];                      var ob = oldFile[oldPlusI];                        newFile[newPlusI] = (byte)((nb + ob) % 256);                  }                    newFileOffset += diffChunkSize;                  oldFileOffset += diffChunkSize;                    var extraChunk = extraBlock.ReadBytes(extraChunkSize);                  Buffer.BlockCopy(extraChunk' 0' newFile' newFileOffset' extraChunkSize);                    newFileOffset += extraChunkSize;                  oldFileOffset += ((extraOffset & 0x80000000) != 0) ? (int)(0x80000000 - extraOffset) : extraOffset;              }
Magic Number,Trinity.Encore.Game.IO.Formats,PTCHChunk,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\PTCHReader.cs,Invariant,The following statement contains a magic number: Contract.Invariant(Magic.Length == 4);
Magic Number,Trinity.Encore.Game.IO.Formats,MD5Chunk,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\PTCHReader.cs,Invariant,The following statement contains a magic number: Contract.Invariant(Magic.Length == 4);
Magic Number,Trinity.Encore.Game.IO.Formats,XFRMChunk,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\PTCHReader.cs,Invariant,The following statement contains a magic number: Contract.Invariant(Magic.Length == 4);
Magic Number,Trinity.Encore.Game.IO.Formats,XFRMChunk,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\PTCHReader.cs,Invariant,The following statement contains a magic number: Contract.Invariant(Type.Length == 4);
Magic Number,Trinity.Encore.Game.IO.Formats,BSDIFF40Chunk,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\PTCHReader.cs,Invariant,The following statement contains a magic number: Contract.Invariant(Magic.Length == 8);
Magic Number,Trinity.Encore.Game.Mathematics,CatmullRomSpline,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Mathematics\CatmullRomSpline.cs,RecalculateTangents,The following statement contains a magic number: if (numPoints < 2)                  return;
Magic Number,Trinity.Encore.Game.Mathematics,CatmullRomSpline,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Mathematics\CatmullRomSpline.cs,RecalculateTangents,The following statement contains a magic number: for (var i = 0; i < numPoints; i++)              {                  const float round = FastMath.RoundValue;                    if (i == 0)                  {                      if (isClosed)                          _tangentList.Add(round * (_pointList[1] - _pointList[numPoints - 2]));                      else                          _tangentList.Add(round * (_pointList[1] - _pointList[0]));                  }                  else if (i == numPoints - 1)                  {                      if (isClosed)                          _tangentList.Add(_tangentList[0]);                      else                          _tangentList.Add(round * (_pointList[i] - _pointList[i - 1]));                  }                  else                      _tangentList.Add(round * (_pointList[i + 1] - _pointList[i - 1]));              }
Magic Number,Trinity.Encore.Game.Network.Handling,WorldPacketPropagator,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Network\Handling\WorldPacketPropagator.cs,HandleHeader,The following statement contains a magic number: var opCode = (int)BitConverter.ToUInt32(header' 2);
Magic Number,Trinity.Encore.Game.Network.Handling,WorldPacketPropagator,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Network\Handling\WorldPacketPropagator.cs,WriteHeader,The following statement contains a magic number: if (large)                  buffer[headerIdx++] = (byte)(0x80 | (0xff & length >> 16));
Magic Number,Trinity.Encore.Game.Network.Handling,WorldPacketPropagator,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Network\Handling\WorldPacketPropagator.cs,WriteHeader,The following statement contains a magic number: buffer[headerIdx++] = (byte)(0xff & length >> 8);
Magic Number,Trinity.Encore.Game.Network.Handling,WorldPacketPropagator,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Network\Handling\WorldPacketPropagator.cs,WriteHeader,The following statement contains a magic number: Buffer.BlockCopy(opCode' 0' buffer' headerIdx' 2);
Magic Number,Trinity.Encore.Game.Network.Transmission,TransmissionExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Network\Transmission\TransmissionExtensions.cs,ReadFourCCField,The following statement contains a magic number: Contract.Ensures(Contract.Result<PacketField<string>>().Value.Length == 4);
Magic Number,Trinity.Encore.Game.Partitioning,DynamicQuadTree,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\DynamicQuadTree.cs,Partition,The following statement contains a magic number: float halfX = Boundaries.Min.X + Length / 2;
Magic Number,Trinity.Encore.Game.Partitioning,DynamicQuadTree,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\DynamicQuadTree.cs,Partition,The following statement contains a magic number: float halfY = Boundaries.Min.Y + Width / 2;
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,AddEntity,The following statement contains a magic number: for (var i = 0; i < 2; i++)              {                  for (var j = 0; j < 2; j++)                  {                      var node = _children[i' j];                      if (node.Bounds.Contains(pos) != ContainmentType.Contains)                          continue;                        return node.AddEntity(entity);                  }              }
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,AddEntity,The following statement contains a magic number: for (var i = 0; i < 2; i++)              {                  for (var j = 0; j < 2; j++)                  {                      var node = _children[i' j];                      if (node.Bounds.Contains(pos) != ContainmentType.Contains)                          continue;                        return node.AddEntity(entity);                  }              }
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,RemoveEntity,The following statement contains a magic number: for (var i = 0; i < 2; i++)              {                  for (var j = 0; j < 2; j++)                  {                      var node = _children[i' j];                      if (node.Bounds.Contains(pos) != ContainmentType.Contains)                          continue;                        return node.RemoveEntity(entity);                  }              }
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,RemoveEntity,The following statement contains a magic number: for (var i = 0; i < 2; i++)              {                  for (var j = 0; j < 2; j++)                  {                      var node = _children[i' j];                      if (node.Bounds.Contains(pos) != ContainmentType.Contains)                          continue;                        return node.RemoveEntity(entity);                  }              }
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,RecursiveSearch,The following statement contains a magic number: for (var i = 0; i < 2; i++)              {                  for (var j = 0; j < 2; j++)                  {                      // Break out early if we've hit the max amount of results.                      if (maxCount != QuadTree.NoMaxCount && results.Count >= maxCount)                          return results;                        var node = _children[i' j];                      if (nodeInclusionFunc != null && !nodeInclusionFunc(node))                          continue;                        node.RecursiveSearch(criteria' results' maxCount);                  }              }
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,RecursiveSearch,The following statement contains a magic number: for (var i = 0; i < 2; i++)              {                  for (var j = 0; j < 2; j++)                  {                      // Break out early if we've hit the max amount of results.                      if (maxCount != QuadTree.NoMaxCount && results.Count >= maxCount)                          return results;                        var node = _children[i' j];                      if (nodeInclusionFunc != null && !nodeInclusionFunc(node))                          continue;                        node.RecursiveSearch(criteria' results' maxCount);                  }              }
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,Partition,The following statement contains a magic number: var width = Length / 2;
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,Partition,The following statement contains a magic number: var height = Width / 2;
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,Partition,The following statement contains a magic number: if (startDepth < maxDepth && width > MinNodeLength && height > MinNodeLength)              {                  _children = new QuadTreeNode[2' 2];                    var min = Bounds.Min;                  var max = Bounds.Max;                    var minX = min.X;                  var minY = min.Y;                  var minZ = min.Z;                  var maxX = max.X;                  var maxY = max.Y;                  var maxZ = max.Z;                    var minXWidth = minX + width;                  var minYHeight = minY + height;                    _children[South' West] = new QuadTreeNode(new BoundingBox(new Vector3(minX' minY' minZ)'                      new Vector3(minXWidth' minYHeight' maxZ)));                    _children[North' West] = new QuadTreeNode(new BoundingBox(new Vector3(minX' minYHeight' minZ)'                      new Vector3(minXWidth' maxY' maxZ)));                    _children[South' East] = new QuadTreeNode(new BoundingBox(new Vector3(minXWidth' minY' minZ)'                      new Vector3(maxX' minYHeight' maxZ)));                    _children[North' East] = new QuadTreeNode(new BoundingBox(new Vector3(minXWidth' minYHeight' minZ)'                      new Vector3(maxX' maxY' maxZ)));                    startDepth++;                    for (var i = 0; i < 2; i++)                      for (var j = 0; j < 2; j++)                          _children[i' j].Partition(maxDepth' startDepth);              }              else                  _entities = new Dictionary<EntityGuid' IWorldEntity>();
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,Partition,The following statement contains a magic number: if (startDepth < maxDepth && width > MinNodeLength && height > MinNodeLength)              {                  _children = new QuadTreeNode[2' 2];                    var min = Bounds.Min;                  var max = Bounds.Max;                    var minX = min.X;                  var minY = min.Y;                  var minZ = min.Z;                  var maxX = max.X;                  var maxY = max.Y;                  var maxZ = max.Z;                    var minXWidth = minX + width;                  var minYHeight = minY + height;                    _children[South' West] = new QuadTreeNode(new BoundingBox(new Vector3(minX' minY' minZ)'                      new Vector3(minXWidth' minYHeight' maxZ)));                    _children[North' West] = new QuadTreeNode(new BoundingBox(new Vector3(minX' minYHeight' minZ)'                      new Vector3(minXWidth' maxY' maxZ)));                    _children[South' East] = new QuadTreeNode(new BoundingBox(new Vector3(minXWidth' minY' minZ)'                      new Vector3(maxX' minYHeight' maxZ)));                    _children[North' East] = new QuadTreeNode(new BoundingBox(new Vector3(minXWidth' minYHeight' minZ)'                      new Vector3(maxX' maxY' maxZ)));                    startDepth++;                    for (var i = 0; i < 2; i++)                      for (var j = 0; j < 2; j++)                          _children[i' j].Partition(maxDepth' startDepth);              }              else                  _entities = new Dictionary<EntityGuid' IWorldEntity>();
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,Partition,The following statement contains a magic number: if (startDepth < maxDepth && width > MinNodeLength && height > MinNodeLength)              {                  _children = new QuadTreeNode[2' 2];                    var min = Bounds.Min;                  var max = Bounds.Max;                    var minX = min.X;                  var minY = min.Y;                  var minZ = min.Z;                  var maxX = max.X;                  var maxY = max.Y;                  var maxZ = max.Z;                    var minXWidth = minX + width;                  var minYHeight = minY + height;                    _children[South' West] = new QuadTreeNode(new BoundingBox(new Vector3(minX' minY' minZ)'                      new Vector3(minXWidth' minYHeight' maxZ)));                    _children[North' West] = new QuadTreeNode(new BoundingBox(new Vector3(minX' minYHeight' minZ)'                      new Vector3(minXWidth' maxY' maxZ)));                    _children[South' East] = new QuadTreeNode(new BoundingBox(new Vector3(minXWidth' minY' minZ)'                      new Vector3(maxX' minYHeight' maxZ)));                    _children[North' East] = new QuadTreeNode(new BoundingBox(new Vector3(minXWidth' minYHeight' minZ)'                      new Vector3(maxX' maxY' maxZ)));                    startDepth++;                    for (var i = 0; i < 2; i++)                      for (var j = 0; j < 2; j++)                          _children[i' j].Partition(maxDepth' startDepth);              }              else                  _entities = new Dictionary<EntityGuid' IWorldEntity>();
Magic Number,Trinity.Encore.Game.Partitioning,QuadTreeNode,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\Partitioning\QuadTreeNode.cs,Partition,The following statement contains a magic number: if (startDepth < maxDepth && width > MinNodeLength && height > MinNodeLength)              {                  _children = new QuadTreeNode[2' 2];                    var min = Bounds.Min;                  var max = Bounds.Max;                    var minX = min.X;                  var minY = min.Y;                  var minZ = min.Z;                  var maxX = max.X;                  var maxY = max.Y;                  var maxZ = max.Z;                    var minXWidth = minX + width;                  var minYHeight = minY + height;                    _children[South' West] = new QuadTreeNode(new BoundingBox(new Vector3(minX' minY' minZ)'                      new Vector3(minXWidth' minYHeight' maxZ)));                    _children[North' West] = new QuadTreeNode(new BoundingBox(new Vector3(minX' minYHeight' minZ)'                      new Vector3(minXWidth' maxY' maxZ)));                    _children[South' East] = new QuadTreeNode(new BoundingBox(new Vector3(minXWidth' minY' minZ)'                      new Vector3(maxX' minYHeight' maxZ)));                    _children[North' East] = new QuadTreeNode(new BoundingBox(new Vector3(minXWidth' minYHeight' minZ)'                      new Vector3(maxX' maxY' maxZ)));                    startDepth++;                    for (var i = 0; i < 2; i++)                      for (var j = 0; j < 2; j++)                          _children[i' j].Partition(maxDepth' startDepth);              }              else                  _entities = new Dictionary<EntityGuid' IWorldEntity>();
Missing Default,Trinity.Encore.Game.IO.Formats,PTCHReader,C:\repos\Trinity-Encore_Encore\Trinity.Encore.Game\IO\Formats\PTCHReader.cs,Read,The following switch statement is missing a default case: switch (XFRM.Type)              {                  case BSD0ChunkName:                      BSD0 = new BSD0Chunk(reader);                      BSDIFF40 = BSD0.Unpack();                      break;                  case COPYChunkName:                      COPY = new COPYChunk(reader);                      break;              }
