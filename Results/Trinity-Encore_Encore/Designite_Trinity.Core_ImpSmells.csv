Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Trinity.Core.Configuration,ApplicationConfiguration,C:\repos\Trinity-Encore_Encore\Trinity.Core\Configuration\ApplicationConfiguration.cs,ScanAssembly,Cyclomatic complexity of the method is 11
Complex Method,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 11
Complex Method,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,MultiByteDivide,Cyclomatic complexity of the method is 16
Complex Method,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,SingleByteDivide,Cyclomatic complexity of the method is 10
Complex Method,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ModPow,Cyclomatic complexity of the method is 11
Complex Method,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BarrettReduction,Cyclomatic complexity of the method is 13
Complex Method,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,GenerateRandomBits,Cyclomatic complexity of the method is 8
Complex Method,Trinity.Core.Initialization,InitializationManager,C:\repos\Trinity-Encore_Encore\Trinity.Core\Initialization\InitializationManager.cs,Initialize,Cyclomatic complexity of the method is 11
Complex Method,Trinity.Core.Initialization,InitializationManager,C:\repos\Trinity-Encore_Encore\Trinity.Core\Initialization\InitializationManager.cs,RunInitializable,Cyclomatic complexity of the method is 8
Long Parameter List,Trinity.Core.Runtime,HashCodeUtility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\HashCodeUtility.cs,GetHashCode,The method has 5 parameters. Parameters: t1' t2' t3' t4' t5
Long Parameter List,Trinity.Core.Runtime,HashCodeUtility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\HashCodeUtility.cs,GetHashCode,The method has 6 parameters. Parameters: t1' t2' t3' t4' t5' t6
Long Parameter List,Trinity.Core.Runtime,HashCodeUtility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\HashCodeUtility.cs,GetHashCode,The method has 7 parameters. Parameters: t1' t2' t3' t4' t5' t6' t7
Long Parameter List,Trinity.Core.Runtime,HashCodeUtility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\HashCodeUtility.cs,GetHashCode,The method has 8 parameters. Parameters: t1' t2' t3' t4' t5' t6' t7' t8
Long Parameter List,Trinity.Core.Runtime,HashCodeUtility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\HashCodeUtility.cs,GetHashCode,The method has 9 parameters. Parameters: t1' t2' t3' t4' t5' t6' t7' t8' t9
Long Parameter List,Trinity.Core.Runtime,HashCodeUtility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\HashCodeUtility.cs,GetHashCode,The method has 10 parameters. Parameters: t1' t2' t3' t4' t5' t6' t7' t8' t9' t10
Long Parameter List,Trinity.Core.Runtime,HashCodeUtility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\HashCodeUtility.cs,GetHashCode,The method has 11 parameters. Parameters: t1' t2' t3' t4' t5' t6' t7' t8' t9' t10' t11
Long Parameter List,Trinity.Core.Runtime,HashCodeUtility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\HashCodeUtility.cs,GetHashCode,The method has 12 parameters. Parameters: t1' t2' t3' t4' t5' t6' t7' t8' t9' t10' t11' t12
Long Statement,Trinity.Core.Runtime.InteropServices,Union,C:\repos\Trinity-Encore_Encore\Trinity.Core\Runtime\InteropServices\Union.cs,GetHashCode,The length of the statement  "            return HashCodeUtility.GetHashCode(Byte' SByte' UInt16' Int16' UInt32' Int32' UInt64' Int64' Char' Single' Double' Decimal); " is 124.
Virtual Method Call from Constructor,Trinity.Core.Cryptography.SRP,SRPParameters,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\SRP\SRPParameters.cs,SRPParameters,The constructor "SRPParameters" calls a virtual method "SetupParameters".
Virtual Method Call from Constructor,Trinity.Core.Threading.Actors,Actor,C:\repos\Trinity-Encore_Encore\Trinity.Core\Threading\Actors\Actor.cs,Actor,The constructor "Actor" calls a virtual method "Main".
Empty Catch Block,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ToString,The method has an empty catch block.
Magic Number,Trinity.Core.Configuration,ApplicationConfiguration,C:\repos\Trinity-Encore_Encore\Trinity.Core\Configuration\ApplicationConfiguration.cs,ScanAssembly,The following statement contains a magic number: foreach (var type in asm.GetTypes())              {                  foreach (var prop in type.GetProperties())                  {                      Contract.Assume(prop != null);                        var attr = prop.GetCustomAttribute<ConfigurationVariableAttribute>();                        if (attr == null)                          continue;                        if (type.IsGenericType)                          throw new ReflectionException("Config value is within a generic type.");                        if (!prop.PropertyType.IsSimple())                          throw new ReflectionException("Config value must be of a simple type.");                        if (prop.GetIndexParameters().Length > 0)                          throw new ReflectionException("Config values cannot be indexers.");                        var accessors = prop.GetAccessors();                        if (accessors.Length != 2)                          throw new ReflectionException("Config value must have get/set accessors.");                        foreach (var accessor in accessors)                      {                          if (!accessor.IsStatic)                              throw new ReflectionException("Config value must not have static accessor.");                            if (!accessor.IsPublic)                              throw new ReflectionException("Config value must not have non-public accessor.");                      }                        _configs.Add(new ConfigurationInfo(prop' attr));                  }              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: while (value != 0 && _dataLength < MaxLength)              {                  _data[_dataLength] = (uint)(value & 0xffffffff);                  value >>= 32;                  _dataLength++;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: while (value != 0 && _dataLength < MaxLength)              {                  _data[_dataLength] = (uint)(value & 0xffffffff);                  value >>= 32;                  _dataLength++;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (var i = value.Length - 1; i >= limit; i--)              {                  int posVal = value[i];                    if (posVal >= '0' && posVal <= '9')                      posVal -= '0';                  else if (posVal >= 'A' && posVal <= 'Z')                      posVal = (posVal - 'A') + 10;                  else                      posVal = 9999999;                    if (posVal >= radix)                      throw new ArgumentException("Invalid string.");                    if (value[0] == '-')                      posVal = -posVal;                    result = result + (multiplier * posVal);                    if ((i - 1) >= limit)                      multiplier = multiplier * radix;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (var i = value.Length - 1; i >= limit; i--)              {                  int posVal = value[i];                    if (posVal >= '0' && posVal <= '9')                      posVal -= '0';                  else if (posVal >= 'A' && posVal <= 'Z')                      posVal = (posVal - 'A') + 10;                  else                      posVal = 9999999;                    if (posVal >= radix)                      throw new ArgumentException("Invalid string.");                    if (value[0] == '-')                      posVal = -posVal;                    result = result + (multiplier * posVal);                    if ((i - 1) >= limit)                      multiplier = multiplier * radix;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: var dataLength = inData.Length >> 2;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)                  _data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                      (inData[i - 1] << 8) + inData[i]);
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)                  _data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                      (inData[i - 1] << 8) + inData[i]);
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)                  _data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                      (inData[i - 1] << 8) + inData[i]);
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)                  _data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                      (inData[i - 1] << 8) + inData[i]);
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)                  _data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                      (inData[i - 1] << 8) + inData[i]);
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)                  _data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                      (inData[i - 1] << 8) + inData[i]);
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)                  _data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                      (inData[i - 1] << 8) + inData[i]);
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      _data[_dataLength - 1] = inData[0];                      break;                  case 2:                      _data[_dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);                      break;                  case 3:                      _data[_dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      _data[_dataLength - 1] = inData[0];                      break;                  case 2:                      _data[_dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);                      break;                  case 3:                      _data[_dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      _data[_dataLength - 1] = inData[0];                      break;                  case 2:                      _data[_dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);                      break;                  case 3:                      _data[_dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      _data[_dataLength - 1] = inData[0];                      break;                  case 2:                      _data[_dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);                      break;                  case 3:                      _data[_dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      _data[_dataLength - 1] = inData[0];                      break;                  case 2:                      _data[_dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);                      break;                  case 3:                      _data[_dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      _data[_dataLength - 1] = inData[0];                      break;                  case 2:                      _data[_dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);                      break;                  case 3:                      _data[_dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,MultiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2._data[bi2._dataLength - 2];
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,MultiByteDivide,The following statement contains a magic number: while (j > 0)              {                  var dividend = ((ulong)remainder[pos] << 32) + remainder[pos - 1];                  Contract.Assume(firstDivisorByte > 0);                  var q_hat = dividend / firstDivisorByte;                  var r_hat = dividend % firstDivisorByte;                  var done = false;                    while (!done)                  {                      done = true;                        if (q_hat != 0x100000000 && (q_hat * secondDivisorByte) <=                          ((r_hat << 32) + remainder[pos - 2]))                          continue;                        q_hat--;                      r_hat += firstDivisorByte;                        if (r_hat < 0x100000000)                          done = false;                  }                    for (var h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    var kk = new BigInteger(dividendPart);                  var ss = bi2 * (long)q_hat;                    while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                  }                    var yy = kk - ss;                    for (var h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy._data[bi2._dataLength - h];                    result[resultPos++] = (uint)q_hat;                    pos--;                  j--;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,MultiByteDivide,The following statement contains a magic number: while (j > 0)              {                  var dividend = ((ulong)remainder[pos] << 32) + remainder[pos - 1];                  Contract.Assume(firstDivisorByte > 0);                  var q_hat = dividend / firstDivisorByte;                  var r_hat = dividend % firstDivisorByte;                  var done = false;                    while (!done)                  {                      done = true;                        if (q_hat != 0x100000000 && (q_hat * secondDivisorByte) <=                          ((r_hat << 32) + remainder[pos - 2]))                          continue;                        q_hat--;                      r_hat += firstDivisorByte;                        if (r_hat < 0x100000000)                          done = false;                  }                    for (var h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    var kk = new BigInteger(dividendPart);                  var ss = bi2 * (long)q_hat;                    while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                  }                    var yy = kk - ss;                    for (var h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy._data[bi2._dataLength - h];                    result[resultPos++] = (uint)q_hat;                    pos--;                  j--;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,MultiByteDivide,The following statement contains a magic number: while (j > 0)              {                  var dividend = ((ulong)remainder[pos] << 32) + remainder[pos - 1];                  Contract.Assume(firstDivisorByte > 0);                  var q_hat = dividend / firstDivisorByte;                  var r_hat = dividend % firstDivisorByte;                  var done = false;                    while (!done)                  {                      done = true;                        if (q_hat != 0x100000000 && (q_hat * secondDivisorByte) <=                          ((r_hat << 32) + remainder[pos - 2]))                          continue;                        q_hat--;                      r_hat += firstDivisorByte;                        if (r_hat < 0x100000000)                          done = false;                  }                    for (var h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    var kk = new BigInteger(dividendPart);                  var ss = bi2 * (long)q_hat;                    while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                  }                    var yy = kk - ss;                    for (var h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy._data[bi2._dataLength - h];                    result[resultPos++] = (uint)q_hat;                    pos--;                  j--;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,SingleByteDivide,The following statement contains a magic number: while (pos >= 0)              {                  dividend = ((ulong)outRemainder._data[pos + 1] << 32) + outRemainder._data[pos];                  var quotient = dividend / divisor;                  result[resultPos++] = (uint)quotient;                    outRemainder._data[pos + 1] = 0;                  outRemainder._data[pos--] = (uint)(dividend % divisor);              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ShiftLeft,The following statement contains a magic number: var shiftAmount = 32;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ShiftLeft,The following statement contains a magic number: for (var count = shiftVal; count > 0; )              {                  if (count < shiftAmount)                      shiftAmount = count;                    ulong carry = 0;                    for (var i = 0; i < bufLen; i++)                  {                      var val = ((ulong)buffer[i]) << shiftAmount;                      val |= carry;                      buffer[i] = (uint)(val & 0xffffffff);                      carry = val >> 32;                  }                    if (carry != 0)                  {                      if (bufLen + 1 <= buffer.Count)                      {                          buffer[bufLen] = (uint)carry;                          bufLen++;                      }                  }                    count -= shiftAmount;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ShiftRight,The following statement contains a magic number: var shiftAmount = 32;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ShiftRight,The following statement contains a magic number: for (var count = shiftVal; count > 0; )              {                  if (count < shiftAmount)                  {                      shiftAmount = count;                      invShift = 32 - shiftAmount;                  }                    ulong carry = 0;                    for (var i = bufLen - 1; i >= 0; i--)                  {                      var val = ((ulong)buffer[i]) >> shiftAmount;                      val |= carry;                      carry = ((ulong)buffer[i]) << invShift;                      buffer[i] = (uint)(val);                  }                    count -= shiftAmount;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ModPow,The following statement contains a magic number: for (var pos = 0; pos < exp._dataLength; pos++)              {                  uint mask = 0x01;                    for (var index = 0; index < 32; index++)                  {                      if ((exp._data[pos] & mask) != 0)                      {                          var resultNumTemp = resultNum * tempNum;                          resultNum = BarrettReduction(resultNumTemp' n' constant);                      }                        mask <<= 1;                        var tempNum2 = tempNum * tempNum;                      tempNum = BarrettReduction(tempNum2' n' constant);                        if (tempNum._dataLength == 1 && tempNum._data[0] == 1)                      {                          if (thisNegative && (exp._data[0] & 0x1) != 0)                              return -resultNum;                            return resultNum;                      }                        count++;                        if (count == totalBits)                          break;                  }              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BarrettReduction,The following statement contains a magic number: for (var i = 0; i < q3._dataLength; i++)              {                  if (q3._data[i] == 0)                      continue;                    ulong mcarry = 0;                  var t = i;                    for (var j = 0; j < n._dataLength && t < kPlusOne; j++' t++)                  {                      var val = (q3._data[i] * (ulong)n._data[j]) + r2._data[t] + mcarry;                        r2._data[t] = (uint)(val & 0xffffffff);                      mcarry = (val >> 32);                  }                    if (t < kPlusOne)                      r2._data[t] = (uint)mcarry;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,GenerateRandomBits,The following statement contains a magic number: var dwords = bits >> 5;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,GenerateRandomBits,The following statement contains a magic number: if (remBits != 0)              {                  var mask = (uint)(0x01 << (remBits - 1));                  _data[dwords - 1] |= mask;                    mask = 0xffffffff >> (32 - remBits);                  _data[dwords - 1] &= mask;              }              else                  _data[dwords - 1] |= 0x80000000;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ModInverse,The following statement contains a magic number: var q = new BigInteger[2];
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: var realNumBytes = numBits >> 3;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: for (var i = 0; i < realNumBytes; i++)              {                  for (var b = 0; b < 4; b++)                  {                      if (i * 4 + b >= realNumBytes)                          return result;                        result[i * 4 + b] = (byte)(_data[i] >> (b * 8) & 0xff);                  }              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: for (var i = 0; i < realNumBytes; i++)              {                  for (var b = 0; b < 4; b++)                  {                      if (i * 4 + b >= realNumBytes)                          return result;                        result[i * 4 + b] = (byte)(_data[i] >> (b * 8) & 0xff);                  }              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: for (var i = 0; i < realNumBytes; i++)              {                  for (var b = 0; b < 4; b++)                  {                      if (i * 4 + b >= realNumBytes)                          return result;                        result[i * 4 + b] = (byte)(_data[i] >> (b * 8) & 0xff);                  }              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: for (var i = 0; i < realNumBytes; i++)              {                  for (var b = 0; b < 4; b++)                  {                      if (i * 4 + b >= realNumBytes)                          return result;                        result[i * 4 + b] = (byte)(_data[i] >> (b * 8) & 0xff);                  }              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,SetBit,The following statement contains a magic number: var bytePos = bitNum >> 5;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,UnsetBit,The following statement contains a magic number: var bytePos = bitNum >> 5;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,Sqrt,The following statement contains a magic number: var bytePos = numBits >> 5;
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ToString,The following statement contains a magic number: return "0x" + ToString(16);
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ToString,The following statement contains a magic number: if (a._dataLength == 1 && a._data[0] == 0)                  result = "0";              else              {                  while (a._dataLength > 1 || (a._dataLength == 1 && a._data[0] != 0))                  {                      SingleByteDivide(a' biRadix' ref quotient' ref remainder);                        if (remainder._data[0] >= 10)                      {                          var chr = (int)remainder._data[0] - 10;                          Contract.Assume(chr < charSet.Length);                          result = charSet[chr] + result;                      }                      else                          result = remainder._data[0] + result;                        a = quotient;                  }                    if (negative)                      result = "-" + result;              }
Magic Number,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,ToString,The following statement contains a magic number: if (a._dataLength == 1 && a._data[0] == 0)                  result = "0";              else              {                  while (a._dataLength > 1 || (a._dataLength == 1 && a._data[0] != 0))                  {                      SingleByteDivide(a' biRadix' ref quotient' ref remainder);                        if (remainder._data[0] >= 10)                      {                          var chr = (int)remainder._data[0] - 10;                          Contract.Assume(chr < charSet.Length);                          result = charSet[chr] + result;                      }                      else                          result = remainder._data[0] + result;                        a = quotient;                  }                    if (negative)                      result = "-" + result;              }
Magic Number,Trinity.Core.Cryptography,CryptographyExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\CryptographyExtensions.cs,FinalizeHash,The following statement contains a magic number: Contract.Ensures(Contract.Result<BigInteger>().ByteLength == algorithm.HashSize / 8);
Magic Number,Trinity.Core.Cryptography,CryptographyExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\CryptographyExtensions.cs,FinalizeHash,The following statement contains a magic number: using (var buffer = new MemoryStream())              {                  foreach (var broker in brokers)                      buffer.Write(broker.GetRawData()' 0' broker.Length);                    buffer.Position = 0;                    var result = new BigInteger(algorithm.ComputeHash(buffer));                  Contract.Assume(result.ByteLength == algorithm.HashSize / 8);                  return result;              }
Magic Number,Trinity.Core.Cryptography.SRP,SRPParameters,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\SRP\SRPParameters.cs,SRPParameters,The following statement contains a magic number: Multiplier = version == SRPVersion.SRP6 ? (BigInteger)3 : Hash.FinalizeHash(Modulus' Generator);
Magic Number,Trinity.Core,Utility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Utility.cs,HexStringToBinary,The following statement contains a magic number: Contract.Requires(data.Length % 2 == 0);
Magic Number,Trinity.Core,Utility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Utility.cs,HexStringToBinary,The following statement contains a magic number: for (var i = 0; i < data.Length; i += 2)              {                  Contract.Assume(i + 2 <= data.Length);                  bytes.Add(byte.Parse(data.Substring(i' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture));              }
Magic Number,Trinity.Core,Utility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Utility.cs,HexStringToBinary,The following statement contains a magic number: for (var i = 0; i < data.Length; i += 2)              {                  Contract.Assume(i + 2 <= data.Length);                  bytes.Add(byte.Parse(data.Substring(i' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture));              }
Magic Number,Trinity.Core,Utility,C:\repos\Trinity-Encore_Encore\Trinity.Core\Utility.cs,HexStringToBinary,The following statement contains a magic number: for (var i = 0; i < data.Length; i += 2)              {                  Contract.Assume(i + 2 <= data.Length);                  bytes.Add(byte.Parse(data.Substring(i' 2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture));              }
Magic Number,Trinity.Core.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Core\IO\IOExtensions.cs,WriteFourCC,The following statement contains a magic number: Contract.Requires(value.Length == 4);
Magic Number,Trinity.Core.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Core\IO\IOExtensions.cs,ReadFourCC,The following statement contains a magic number: Contract.Ensures(Contract.Result<string>().Length == 4);
Magic Number,Trinity.Core.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Core\IO\IOExtensions.cs,ReadFourCC,The following statement contains a magic number: var fourCC = Encoding.ASCII.GetString(reader.ReadBytes(4));
Magic Number,Trinity.Core.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Core\IO\IOExtensions.cs,ReadFourCC,The following statement contains a magic number: Contract.Assume(fourCC.Length == 4);
Magic Number,Trinity.Core.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Core\IO\IOExtensions.cs,ReadIPAddress,The following statement contains a magic number: return new IPAddress(reader.ReadBytes(ipv6 ? 16 : 4));
Magic Number,Trinity.Core.IO,IOExtensions,C:\repos\Trinity-Encore_Encore\Trinity.Core\IO\IOExtensions.cs,ReadIPAddress,The following statement contains a magic number: return new IPAddress(reader.ReadBytes(ipv6 ? 16 : 4));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: var t = (_x ^ (_x << 11));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: var t = (_x ^ (_x << 11));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: var value = (int)((RealUnitInt32 * (int)(0x7fffffff & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))))) * maxValue);
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: var value = (int)((RealUnitInt32 * (int)(0x7fffffff & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))))) * maxValue);
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: var t = (_x ^ (_x << 11));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {                  // If range is < 0 then an overflow has occurred and we must resort to                  // using long integer arithmetic instead (slower). We also must use                  // all 32 bits of precision' instead of the normal 31' which again                  // is slower.                  return minValue + (int)((RealUnitUInt32 * (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)))) *                      ((long)maxValue - minValue));              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {                  // If range is < 0 then an overflow has occurred and we must resort to                  // using long integer arithmetic instead (slower). We also must use                  // all 32 bits of precision' instead of the normal 31' which again                  // is slower.                  return minValue + (int)((RealUnitUInt32 * (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)))) *                      ((long)maxValue - minValue));              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: var value = minValue + (int)((RealUnitInt32 * (int)(0x7fffffff & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))))) * range);
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,Next,The following statement contains a magic number: var value = minValue + (int)((RealUnitInt32 * (int)(0x7fffffff & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))))) * range);
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextDouble,The following statement contains a magic number: var t = (_x ^ (_x << 11));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextDouble,The following statement contains a magic number: return (RealUnitInt32 * (int)(0x7fffffff & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextDouble,The following statement contains a magic number: return (RealUnitInt32 * (int)(0x7fffffff & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: if (buffer.Length % 8 != 0)                  throw new ArgumentException("Buffer length must be divisible by 8.");
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: fixed (byte* pByte0 = buffer)              {                  var pDWord = (uint*)pByte0;                  var len = buffer.Length >> 2;                    for (var i = 0; i < len; i += 2)                  {                      var t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                        t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i + 1] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                  }              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: fixed (byte* pByte0 = buffer)              {                  var pDWord = (uint*)pByte0;                  var len = buffer.Length >> 2;                    for (var i = 0; i < len; i += 2)                  {                      var t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                        t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i + 1] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                  }              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: fixed (byte* pByte0 = buffer)              {                  var pDWord = (uint*)pByte0;                  var len = buffer.Length >> 2;                    for (var i = 0; i < len; i += 2)                  {                      var t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                        t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i + 1] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                  }              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: fixed (byte* pByte0 = buffer)              {                  var pDWord = (uint*)pByte0;                  var len = buffer.Length >> 2;                    for (var i = 0; i < len; i += 2)                  {                      var t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                        t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i + 1] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                  }              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: fixed (byte* pByte0 = buffer)              {                  var pDWord = (uint*)pByte0;                  var len = buffer.Length >> 2;                    for (var i = 0; i < len; i += 2)                  {                      var t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                        t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i + 1] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                  }              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: fixed (byte* pByte0 = buffer)              {                  var pDWord = (uint*)pByte0;                  var len = buffer.Length >> 2;                    for (var i = 0; i < len; i += 2)                  {                      var t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                        t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i + 1] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                  }              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: fixed (byte* pByte0 = buffer)              {                  var pDWord = (uint*)pByte0;                  var len = buffer.Length >> 2;                    for (var i = 0; i < len; i += 2)                  {                      var t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                        t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i + 1] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                  }              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBytes,The following statement contains a magic number: fixed (byte* pByte0 = buffer)              {                  var pDWord = (uint*)pByte0;                  var len = buffer.Length >> 2;                    for (var i = 0; i < len; i += 2)                  {                      var t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                        t = (x ^ (x << 11));                      x = y;                      y = z;                      z = w;                      pDWord[i + 1] = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                  }              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextUInt32,The following statement contains a magic number: var t = (_x ^ (_x << 11));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextUInt32,The following statement contains a magic number: return (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextUInt32,The following statement contains a magic number: return (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextInt32,The following statement contains a magic number: var t = (_x ^ (_x << 11));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextInt32,The following statement contains a magic number: return (int)(0x7fffffff & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextInt32,The following statement contains a magic number: return (int)(0x7fffffff & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBoolean,The following statement contains a magic number: if (_bitMask == 1)              {                  // Generate 32 more bits.                  var t = (_x ^ (_x << 11));                  _x = _y;                  _y = _z;                  _z = _w;                    _bitBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitmask that tells us which bit to read next.                  _bitMask = 0x80000000;                  return (_bitBuffer & _bitMask) == 0;              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBoolean,The following statement contains a magic number: if (_bitMask == 1)              {                  // Generate 32 more bits.                  var t = (_x ^ (_x << 11));                  _x = _y;                  _y = _z;                  _z = _w;                    _bitBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitmask that tells us which bit to read next.                  _bitMask = 0x80000000;                  return (_bitBuffer & _bitMask) == 0;              }
Magic Number,Trinity.Core.Mathematics,FastRandom,C:\repos\Trinity-Encore_Encore\Trinity.Core\Mathematics\FastRandom.cs,NextBoolean,The following statement contains a magic number: if (_bitMask == 1)              {                  // Generate 32 more bits.                  var t = (_x ^ (_x << 11));                  _x = _y;                  _y = _z;                  _z = _w;                    _bitBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitmask that tells us which bit to read next.                  _bitMask = 0x80000000;                  return (_bitBuffer & _bitMask) == 0;              }
Missing Default,Trinity.Core.Cryptography,BigInteger,C:\repos\Trinity-Encore_Encore\Trinity.Core\Cryptography\BigInteger.cs,BigInteger,The following switch statement is missing a default case: switch (leftOver)              {                  case 1:                      _data[_dataLength - 1] = inData[0];                      break;                  case 2:                      _data[_dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);                      break;                  case 3:                      _data[_dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
