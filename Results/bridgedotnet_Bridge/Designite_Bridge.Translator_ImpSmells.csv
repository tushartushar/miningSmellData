Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bridge.Translator,ArrayCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ArrayCreateBlock.cs,VisitArrayCreateExpression,The method has 110 lines of code.
Long Method,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The method has 355 lines of code.
Long Method,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The method has 162 lines of code.
Long Method,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,NarrowingNumericOrEnumerationConversion,The method has 139 lines of code.
Long Method,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,HandleAttributes,The method has 118 lines of code.
Long Method,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetOutputForType,The method has 119 lines of code.
Long Method,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,DoEmit,The method has 116 lines of code.
Long Method,Bridge.Translator,TryCatchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\TryCatchBlock.cs,VisitAsyncTryCatchStatement,The method has 123 lines of code.
Long Method,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,VisitAsyncForeachStatement,The method has 116 lines of code.
Long Method,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The method has 370 lines of code.
Long Method,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The method has 304 lines of code.
Long Method,Bridge.Translator,IfElseBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IfElseBlock.cs,VisitIfElseStatement,The method has 100 lines of code.
Long Method,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The method has 189 lines of code.
Long Method,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,WriteObjectInitializer,The method has 109 lines of code.
Long Method,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The method has 392 lines of code.
Long Method,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,ResolveOperator,The method has 100 lines of code.
Long Method,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The method has 269 lines of code.
Long Method,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The method has 363 lines of code.
Long Method,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,VisitUnaryOperatorExpression,The method has 215 lines of code.
Long Method,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The method has 230 lines of code.
Long Method,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The method has 892 lines of code.
Long Method,Bridge.Translator,FieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\FieldBlock.cs,WriteObject,The method has 152 lines of code.
Long Method,Bridge.Translator,MethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MethodBlock.cs,EmitStructMethods,The method has 110 lines of code.
Long Method,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The method has 116 lines of code.
Long Method,Bridge.Translator,ExpressionListBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionListBlock.cs,EmitExpressionList,The method has 106 lines of code.
Long Method,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The method has 493 lines of code.
Long Method,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The method has 123 lines of code.
Long Method,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitInvocationResolveResult,The method has 103 lines of code.
Long Method,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The method has 127 lines of code.
Complex Method,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildTypedArguments,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildArgumentsList,Cyclomatic complexity of the method is 16
Complex Method,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildOperatorArgumentsList,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,ConvertParamsToReferences,Cyclomatic complexity of the method is 12
Complex Method,Bridge.Translator,AbstractObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractObjectCreateBlock.cs,WriteObjectInitializer,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,ArrayCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ArrayCreateBlock.cs,VisitArrayCreateExpression,Cyclomatic complexity of the method is 21
Complex Method,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,ResolveOperator,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,Cyclomatic complexity of the method is 127
Complex Method,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,HandleType,Cyclomatic complexity of the method is 12
Complex Method,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,HandleDecimal,Cyclomatic complexity of the method is 36
Complex Method,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,HandleLong,Cyclomatic complexity of the method is 51
Complex Method,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,IsTaskResult,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,InjectCatchHandlers,Cyclomatic complexity of the method is 12
Complex Method,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,InjectSteps,Cyclomatic complexity of the method is 18
Complex Method,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,Cyclomatic complexity of the method is 42
Complex Method,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckLong,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,NarrowingNumericOrEnumerationConversion,Cyclomatic complexity of the method is 35
Complex Method,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,GetEventsAndAutoStartupMethods,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,HandleAttributes,Cyclomatic complexity of the method is 27
Complex Method,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetOutputForType,Cyclomatic complexity of the method is 42
Complex Method,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,DoEmit,Cyclomatic complexity of the method is 23
Complex Method,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,Cyclomatic complexity of the method is 25
Complex Method,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,DoEmit,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,Cyclomatic complexity of the method is 20
Complex Method,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,GetInlineInit,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteObjectInitializer,Cyclomatic complexity of the method is 23
Complex Method,Bridge.Translator,CommentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CommentBlock.cs,WriteMultiLineComment,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,SwitchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\SwitchBlock.cs,VisitAsyncSwitchSection,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,TryCatchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\TryCatchBlock.cs,VisitAsyncTryCatchStatement,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,TryCatchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\TryCatchBlock.cs,EmitMultipleCatchBlock,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,VisitAsyncForeachStatement,Cyclomatic complexity of the method is 13
Complex Method,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,VisitForeachStatement,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,ReturnBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ReturnBlock.cs,VisitReturnStatement,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitInlineIndexer,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,Cyclomatic complexity of the method is 50
Complex Method,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,Cyclomatic complexity of the method is 37
Complex Method,Bridge.Translator,ForBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForBlock.cs,VisitAsyncForStatement,Cyclomatic complexity of the method is 12
Complex Method,Bridge.Translator,IfElseBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IfElseBlock.cs,VisitIfElseStatement,Cyclomatic complexity of the method is 16
Complex Method,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,Cyclomatic complexity of the method is 37
Complex Method,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,GetInlineInit,Cyclomatic complexity of the method is 13
Complex Method,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,WriteObjectInitializer,Cyclomatic complexity of the method is 26
Complex Method,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,IsConditionallyRemoved,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,Cyclomatic complexity of the method is 66
Complex Method,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,ResolveOperator,Cyclomatic complexity of the method is 29
Complex Method,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,Cyclomatic complexity of the method is 105
Complex Method,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,HandleDecimal,Cyclomatic complexity of the method is 41
Complex Method,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,HandleLong,Cyclomatic complexity of the method is 58
Complex Method,Bridge.Translator,BaseReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BaseReferenceBlock.cs,EmitConversionExpression,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,Cyclomatic complexity of the method is 59
Complex Method,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,VisitUnaryOperatorExpression,Cyclomatic complexity of the method is 55
Complex Method,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,Cyclomatic complexity of the method is 106
Complex Method,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,KeepLineAfterBlock,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,DoEmitBlock,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,EndEmitBlock,Cyclomatic complexity of the method is 18
Complex Method,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteInterfaceMember,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,Cyclomatic complexity of the method is 170
Complex Method,Bridge.Translator,VariableBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VariableBlock.cs,VisitVariableDeclarationStatement,Cyclomatic complexity of the method is 17
Complex Method,Bridge.Translator,VisitorMethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VisitorMethodBlock.cs,VisitMethodDeclaration,Cyclomatic complexity of the method is 12
Complex Method,Bridge.Translator,FieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\FieldBlock.cs,EmitFields,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,FieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\FieldBlock.cs,WriteObject,Cyclomatic complexity of the method is 27
Complex Method,Bridge.Translator,FieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\FieldBlock.cs,WriteAlias,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,FieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\FieldBlock.cs,EmitMemberAlias,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator,LambdaBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\LambdaBlock.cs,EmitLambda,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator,MethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MethodBlock.cs,EmitMethods,Cyclomatic complexity of the method is 17
Complex Method,Bridge.Translator,MethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MethodBlock.cs,EmitStructMethods,Cyclomatic complexity of the method is 13
Complex Method,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,EmitClassHeader,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,GetDefineMethods,Cyclomatic complexity of the method is 31
Complex Method,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,Cyclomatic complexity of the method is 25
Complex Method,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,GetCastCode,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitInlineCast,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,ExpressionListBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionListBlock.cs,EmitExpressionList,Cyclomatic complexity of the method is 25
Complex Method,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,Cyclomatic complexity of the method is 25
Complex Method,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitMethodParameters,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,GenerateMemberBindings,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitInvocationResolveResult,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,GetMember,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,GetPlugins,Cyclomatic complexity of the method is 18
Complex Method,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,GetResourceOutputPath,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,TranslatorProcessor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\TranslatorProcessor.cs,SetLoggerConfigurationParameters,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,Cyclomatic complexity of the method is 13
Complex Method,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructParameterInfo,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,Cyclomatic complexity of the method is 30
Complex Method,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructConstructorInfo,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,GetCommonMemberInfoProperties,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitAssignmentExpression,Cyclomatic complexity of the method is 38
Complex Method,Bridge.Translator,ResolveResultVisitorExtensions,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\IResolveResultVisitor.cs,DefaultVisitResolveResult,Cyclomatic complexity of the method is 23
Complex Method,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitArgument,Cyclomatic complexity of the method is 19
Complex Method,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitInterpolatedStringExpression,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,NeedRewriteInitializer,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitObjectCreationExpression,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,ConvertInitializers,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,IsCSharpKeyword,Cyclomatic complexity of the method is 78
Complex Method,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,FullyQualifiedName,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,Cyclomatic complexity of the method is 19
Complex Method,Bridge.Translator,MemberResolver,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MemberResolver.cs,ResolveNode,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitTypeDeclaration,Cyclomatic complexity of the method is 13
Complex Method,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,AddMissingAliases,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitFieldDeclaration,Cyclomatic complexity of the method is 13
Complex Method,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitPropertyDeclaration,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,Cyclomatic complexity of the method is 24
Complex Method,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadReflectionInfo,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,Cyclomatic complexity of the method is 11
Complex Method,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,GetCustomTypeName,Cyclomatic complexity of the method is 15
Complex Method,Bridge.Translator.TypeScript,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\ClassBlock.cs,EmitBlock,Cyclomatic complexity of the method is 9
Complex Method,Bridge.Translator.TypeScript,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\ClassBlock.cs,WriteNestedTypes,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator.TypeScript,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\ConstructorBlock.cs,EmitCtorForInstantiableClass,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator.TypeScript,MemberBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\MemberBlock.cs,EmitFields,Cyclomatic complexity of the method is 10
Complex Method,Bridge.Translator.TypeScript,MethodsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\MethodsBlock.cs,EmitMethods,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Translator.TypeScript,MethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\MethodBlock.cs,VisitMethodDeclaration,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Translator.Logging,FileLoggerWriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Logging\FileLoggerWriter.cs,Flush,Cyclomatic complexity of the method is 11
Long Parameter List,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,HandleType,The method has 5 parameters.
Long Parameter List,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The method has 5 parameters.
Long Parameter List,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckLong,The method has 5 parameters.
Long Parameter List,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,NarrowingNumericOrEnumerationConversion,The method has 7 parameters.
Long Parameter List,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,FloatToInt,The method has 5 parameters.
Long Parameter List,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,HandleAttributes,The method has 11 parameters.
Long Parameter List,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteObjectInitializer,The method has 5 parameters.
Long Parameter List,Bridge.Translator,SwitchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\SwitchBlock.cs,VisitAsyncSwitchStatement,The method has 6 parameters.
Long Parameter List,Bridge.Translator,SwitchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\SwitchBlock.cs,VisitAsyncSwitchSection,The method has 7 parameters.
Long Parameter List,Bridge.Translator,VisitorIndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VisitorIndexerBlock.cs,EmitIndexerMethod,The method has 5 parameters.
Long Parameter List,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,GetCastMethod,The method has 5 parameters.
Long Parameter List,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,WriteObjectInitializer,The method has 8 parameters.
Long Parameter List,Bridge.Translator,NameBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\NameBlock.cs,NameBlock,The method has 5 parameters.
Long Parameter List,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,HandleType,The method has 5 parameters.
Long Parameter List,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteTarget,The method has 5 parameters.
Long Parameter List,Bridge.Translator,VisitorPropertyBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VisitorPropertyBlock.cs,EmitPropertyMethod,The method has 5 parameters.
Long Parameter List,Bridge.Translator,FieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\FieldBlock.cs,FieldBlock,The method has 5 parameters.
Long Parameter List,Bridge.Translator,LambdaBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\LambdaBlock.cs,LambdaBlock,The method has 5 parameters.
Long Parameter List,Bridge.Translator,LambdaBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\LambdaBlock.cs,EmitLambda,The method has 5 parameters.
Long Parameter List,Bridge.Translator,MethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MethodBlock.cs,EmitMethods,The method has 6 parameters.
Long Parameter List,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitInlineCast,The method has 6 parameters.
Long Parameter List,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,GetCastMethod,The method has 5 parameters.
Long Parameter List,Bridge.Translator,ExpressionListBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionListBlock.cs,ExpressionListBlock,The method has 5 parameters.
Long Parameter List,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,InlineArgumentsBlock,The method has 5 parameters.
Long Parameter List,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,ReplaceInlineArgs,The method has 5 parameters.
Long Parameter List,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The method has 12 parameters.
Long Parameter List,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The method has 6 parameters.
Long Parameter List,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitInvocationResolveResult,The method has 6 parameters.
Long Parameter List,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,FindIndexInReflectableMembers,The method has 5 parameters.
Long Parameter List,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,GetPlugins,The method has 5 parameters.
Long Parameter List,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,CheckInvalidCharacters,The method has 5 parameters.
Long Parameter List,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,PrepareResourcesConfig,The method has 6 parameters.
Long Parameter List,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The method has 8 parameters.
Long Parameter List,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructITypeMetadata,The method has 5 parameters.
Long Parameter List,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructParameterInfo,The method has 6 parameters.
Long Parameter List,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The method has 11 parameters.
Long Parameter List,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructFieldPropertyAccessor,The method has 8 parameters.
Long Parameter List,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructConstructorInfo,The method has 9 parameters.
Long Parameter List,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,GetCommonMemberInfoProperties,The method has 5 parameters.
Long Parameter List,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitPropertyDeclaration,The method has 5 parameters.
Long Parameter List,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateNamespace,The method has 5 parameters.
Long Parameter List,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,AddMissingAliases,The method has 6 parameters.
Long Parameter List,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitFieldDeclaration,The method has 6 parameters.
Long Parameter List,Bridge.Translator.Logging,Logger,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Logging\Logger.cs,Logger,The method has 6 parameters.
Long Identifier,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,ValidateResourceSettings,The length of the parameter rawNonDefaultResourcesWithExtractAndNoOutput is 44.
Long Identifier,Bridge.Translator,LocalUsageData,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\LocalUsageGatherer.cs,LocalUsageData,The length of the parameter directlyOrIndirectlyUsedVariables is 33.
Long Identifier,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateMethodParameter,The length of the parameter isExtensionMethodFirstParameter is 31.
Long Statement,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildTypedArguments,The length of the statement  "		if (method.DeclaringType != null && method.DeclaringTypeDefinition != null && method.DeclaringTypeDefinition.TypeParameters.Count > 0) { " is 136.
Long Statement,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildArgumentsList,The length of the statement  "		if (resolvedMethod != null && invocationResult != null && resolvedMethod.IsExtensionMethod && invocationResult.IsExtensionMethodInvocation) { " is 141.
Long Statement,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildArgumentsList,The length of the statement  "			isInterfaceMember = resolveResult.Member.DeclaringTypeDefinition != null && resolveResult.Member.DeclaringTypeDefinition.Kind == TypeKind.Interface; " is 148.
Long Statement,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildArgumentsList,The length of the statement  "					if (resolveResult.Member.DeclaringTypeDefinition == null || !this.Emitter.Validator.IsIgnoreType (resolveResult.Member.DeclaringTypeDefinition)) { " is 146.
Long Statement,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildArgumentsList,The length of the statement  "					if (resolveResult.Member.DeclaringTypeDefinition == null || !this.Emitter.Validator.IsIgnoreType (resolveResult.Member.DeclaringTypeDefinition)) { " is 146.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,AddLocals,The length of the statement  "		if (item.Parent == null && item.Name == "value" && visitor.DirectionExpression.Any (expr => expr is IdentifierExpression && ((IdentifierExpression)expr).Identifier == "value")) { " is 178.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,AddLocals,The length of the statement  "			this.Emitter.LocalsMap [rr != null ? rr.Variable : new DefaultVariable (ReflectionHelper.FindType (this.Emitter.Resolver.Compilation' TypeCode.Object)' name)] = vName + ".v"; " is 174.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,AddLocals,The length of the statement  "			this.Emitter.LocalsMap [rr != null ? rr.Variable : new DefaultVariable (ReflectionHelper.FindType (this.Emitter.Resolver.Compilation' TypeCode.Object)' name)] = vName; " is 167.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,AddLocal,The length of the statement  "	var lrr = node != null && node.Parent != null ? this.Emitter.Resolver.ResolveNode (node' this.Emitter) as LocalResolveResult : null; " is 132.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,ConvertParamsToReferences,The length of the statement  "							if (prm.ConstantValue == null && prm.Type.Kind == TypeKind.Struct && !prm.Type.IsKnownType (KnownTypeCode.NullableOfT)) { " is 121.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,ConvertParamsToReferences,The length of the statement  "								this.Write (string.Format ("{0} = " + JS.Types.ARRAY + "." + JS.Fields.PROTOTYPE + "." + JS.Funcs.SLICE + "." + JS.Funcs.CALL + "(" + JS.Vars.ARGUMENTS + "' {1});"' name' method.Parameters.IndexOf (prm) + method.TypeParameters.Count)); " is 235.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,ConvertParamsToReferences,The length of the statement  "		var isReferenceLocal = lrr != null && this.Emitter.LocalsMap.ContainsKey (lrr.Variable) && this.Emitter.LocalsMap [lrr.Variable].EndsWith (".v"); " is 145.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,ConvertParamsToReferences,The length of the statement  "		if (isReferenceLocal && !(item.ParameterModifier == ParameterModifier.Out || item.ParameterModifier == ParameterModifier.Ref)) { " is 128.
Long Statement,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,GetTempVarName,The length of the statement  "	while (this.Emitter.TempVariables.ContainsKey (name) || (this.Emitter.ParentTempVariables != null && this.Emitter.ParentTempVariables.ContainsKey (name))) { " is 156.
Long Statement,Bridge.Translator,ArrayCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ArrayCreateBlock.cs,VisitArrayCreateExpression,The length of the statement  "	var rr = this.ArrayCreateResolveResult ?? (this.Emitter.Resolver.ResolveNode (arrayCreateExpression' this.Emitter) as ArrayCreateResolveResult); " is 144.
Long Statement,Bridge.Translator,ArrayCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ArrayCreateBlock.cs,VisitArrayCreateExpression,The length of the statement  "		if (this.Emitter.AssemblyInfo.UseTypedArrays && (typedArrayName = Helpers.GetTypedArrayName (at.ElementType)) != null) { " is 120.
Long Statement,Bridge.Translator,ArrayCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ArrayCreateBlock.cs,VisitArrayCreateExpression,The length of the statement  "		var defaultInitializer = new PrimitiveExpression (Inspector.GetDefaultFieldValue (at.ElementType' arrayCreateExpression.Type)' "?"); " is 132.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,ResolveOperator,The length of the statement  "			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' assignmentExpression' orr' method)' inline).Emit (); " is 125.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	bool isUint = rr.Type.IsKnownType (KnownTypeCode.UInt16) || rr.Type.IsKnownType (KnownTypeCode.UInt32) || rr.Type.IsKnownType (KnownTypeCode.UInt64); " is 149.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	bool isField = (memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult)) || leftResolverResult is ThisResolveResult || leftResolverResult is LocalResolveResult || leftResolverResult is ConstantResolveResult; " is 316.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	bool isRightSimple = (rightMemberTargetrr != null && rightMemberTargetrr.Member is IField && (rightMemberTargetrr.TargetResult is ThisResolveResult || rightMemberTargetrr.TargetResult is LocalResolveResult)) || rightResolverResult is ThisResolveResult || rightResolverResult is LocalResolveResult || rightResolverResult is ConstantResolveResult; " is 345.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	var needTempVar = needReturnValue && (!isRightSimple && !isField || assignmentExpression.Operator != AssignmentOperatorType.Assign); " is 132.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	if (assignmentExpression.Operator == AssignmentOperatorType.Divide && !(this.Emitter.IsJavaScriptOverflowMode && !ConversionBlock.InsideOverflowContext (this.Emitter' assignmentExpression)) && !isLong && !isLongExpected && ((Helpers.IsIntegerType (leftResolverResult.Type' this.Emitter.Resolver) && Helpers.IsIntegerType (rightResolverResult.Type' this.Emitter.Resolver)) || (Helpers.IsIntegerType (this.Emitter.Resolver.Resolver.GetExpectedType (assignmentExpression.Left)' this.Emitter.Resolver) && Helpers.IsIntegerType (this.Emitter.Resolver.Resolver.GetExpectedType (assignmentExpression.Right)' this.Emitter.Resolver)))) { " is 628.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	if (assignmentExpression.Operator == AssignmentOperatorType.Add || assignmentExpression.Operator == AssignmentOperatorType.Subtract) { " is 134.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	bool isBool = NullableType.IsNullable (rr.Type) ? NullableType.GetUnderlyingType (rr.Type).IsKnownType (KnownTypeCode.Boolean) : rr.Type.IsKnownType (KnownTypeCode.Boolean); " is 173.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "				throw new EmitterException (assignmentExpression' "Unsupported assignment operator: " + assignmentExpression.Operator.ToString ()); " is 131.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "				throw new EmitterException (assignmentExpression' "Unsupported assignment operator: " + assignmentExpression.Operator.ToString ()); " is 131.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	if (!special && isBool && (assignmentExpression.Operator == AssignmentOperatorType.BitwiseAnd || assignmentExpression.Operator == AssignmentOperatorType.BitwiseOr)) { " is 166.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "		var wrap = assignmentExpression.Operator != AssignmentOperatorType.Assign && this.Emitter.Writers.Count > initCount && !AssigmentExpressionHelper.CheckIsRightAssigmentExpression (assignmentExpression); " is 201.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The length of the statement  "	if (!special && isBool && (assignmentExpression.Operator == AssignmentOperatorType.BitwiseAnd || assignmentExpression.Operator == AssignmentOperatorType.BitwiseOr)) { " is 166.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,HandleType,The length of the statement  "			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' this.AssignmentExpression' orr' method)' inline).Emit (); " is 130.
Long Statement,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,AddOveflowFlag,The length of the statement  "	if ((typeCode == KnownTypeCode.Int64 || typeCode == KnownTypeCode.UInt64) && ConversionBlock.IsInCheckedContext (this.Emitter' this.AssignmentExpression)) { " is 156.
Long Statement,Bridge.Translator,AnonymousTypeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AnonymousTypeCreateBlock.cs,DoEmit,The length of the statement  "		if (member_rr != null && member_rr.Member.DeclaringTypeDefinition != null && this.Emitter.Validator.IsObjectLiteral (member_rr.Member.DeclaringTypeDefinition)) { " is 161.
Long Statement,Bridge.Translator,AnonymousTypeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AnonymousTypeCreateBlock.cs,VisitAnonymousTypeCreateExpression,The length of the statement  "	var invocationrr = this.Emitter.Resolver.ResolveNode (anonymousTypeCreateExpression' this.Emitter) as InvocationResolveResult; " is 126.
Long Statement,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,DetectReturnType,The length of the statement  "	this.IsTaskReturn = this.ReturnType != null && this.ReturnType.Name == "Task" && this.ReturnType.FullName.StartsWith ("System.Threading.Tasks.Task"); " is 149.
Long Statement,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,IsTaskResult,The length of the statement  "	if ((type.FullName == "System.Threading.Tasks.TaskAwaiter" || type.FullName == "System.Threading.Tasks.Task") && type.TypeParameterCount > 0) { " is 143.
Long Statement,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,IsTaskResult,The length of the statement  "				if ((type.FullName == "System.Threading.Tasks.TaskAwaiter" || type.FullName == "System.Threading.Tasks.Task") && type.TypeParameterCount > 0) { " is 143.
Long Statement,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,InjectStepsChecker,The length of the statement  "	this.Emitter.Output.Insert (pos' JS.Vars.ASYNC_STEP + " = " + JS.Types.SYSTEM_ARRAY + ".min(" + this.Emitter.ToJavaScript (list.ToArray ()) + "' " + JS.Vars.ASYNC_STEP + ");"); " is 176.
Long Statement,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,InjectCatchHandlers,The length of the statement  "			this.Write (string.Format (JS.Vars.ASYNC_STEP + " >= {0} && " + JS.Vars.ASYNC_STEP + " <= {1}"' info.StartStep' info.EndStep)); " is 127.
Long Statement,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,InjectCatchHandlers,The length of the statement  "			this.Write (string.Format (JS.Vars.ASYNC_STEP + " >= {0} && " + JS.Vars.ASYNC_STEP + " <= {1}"' info.StartStep' info.CatchBlocks.Count > 0 ? info.CatchBlocks.Last ().Item4 : info.EndStep)); " is 189.
Long Statement,Bridge.Translator,AsyncBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AsyncBlock.cs,InjectSteps,The length of the statement  "				this.Write (string.Format ("{0}{1} = {2}{1}.{3}();"' JS.Vars.ASYNC_TASK_RESULT' step.FromTaskNumber' JS.Vars.ASYNC_TASK' JS.Funcs.GET_AWAITED_RESULT)); " is 151.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "	if (Helpers.Is64Type (toType' block.Emitter.Resolver) && expression.Parent is IndexerExpression && ((IndexerExpression)expression.Parent).Arguments.Contains (expression)) { " is 172.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		if (!(current != null && current.InlineAttr != null) && !(!(isIgnore || (current != null && current.IgnoreAccessor)) || isAccessorsIndexer)) { " is 142.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		if (!(expression.Parent is ArrayInitializerExpression) && Helpers.Is64Type (fromType' block.Emitter.Resolver) && Helpers.IsFloatType (toType' block.Emitter.Resolver) && !Helpers.IsDecimalType (toType' block.Emitter.Resolver)) { " is 227.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		else if (Helpers.IsDecimalType (toType' block.Emitter.Resolver) && !Helpers.IsDecimalType (fromType' block.Emitter.Resolver)) { " is 127.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		else if (Helpers.IsFloatType (fromType' block.Emitter.Resolver) && Helpers.IsIntegerType (toType' block.Emitter.Resolver)) { " is 124.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "	else if (conversion.IsNumericConversion && conversion.IsImplicit && !(expression.Parent is ArrayInitializerExpression) && Helpers.Is64Type (fromType' block.Emitter.Resolver) && Helpers.IsFloatType (toType' block.Emitter.Resolver) && !Helpers.IsDecimalType (toType' block.Emitter.Resolver)) { " is 291.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "	else if (((!Helpers.Is64Type (toType' block.Emitter.Resolver) && Helpers.IsIntegerType (toType' block.Emitter.Resolver)) || (rr is OperatorResolveResult && !Helpers.Is64Type (fromType' block.Emitter.Resolver) && Helpers.IsIntegerType (fromType' block.Emitter.Resolver))) && (expression is BinaryOperatorExpression || expression is UnaryOperatorExpression || expression.Parent is AssignmentExpression) && IsInCheckedContext (block.Emitter' expression)) { " is 453.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		bool isBitwiseOperator = be != null && (be.Operator == BinaryOperatorType.ShiftLeft || be.Operator == BinaryOperatorType.ShiftRight || be.Operator == BinaryOperatorType.BitwiseAnd || be.Operator == BinaryOperatorType.BitwiseOr || be.Operator == BinaryOperatorType.ExclusiveOr); " is 277.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		if ((Helpers.IsKnownType (KnownTypeCode.Int32' toType' block.Emitter.Resolver) && isBitwiseOperator) || (Helpers.IsKnownType (KnownTypeCode.UInt32' toType' block.Emitter.Resolver) && be != null && be.Operator == BinaryOperatorType.ShiftRight)) { " is 245.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		else if (be != null && (be.Operator == BinaryOperatorType.Add || be.Operator == BinaryOperatorType.Divide || be.Operator == BinaryOperatorType.Multiply || isBitwiseOperator || be.Operator == BinaryOperatorType.Subtract)) { " is 222.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "			if (ue != null && (ue.Operator == UnaryOperatorType.Minus || ue.Operator == UnaryOperatorType.Increment || ue.Operator == UnaryOperatorType.Decrement || ue.Operator == UnaryOperatorType.PostIncrement || ue.Operator == UnaryOperatorType.PostDecrement)) { " is 253.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "				isBitwiseOperator = ae != null && (ae.Operator == AssignmentOperatorType.ShiftRight || ae.Operator == AssignmentOperatorType.ShiftLeft || ae.Operator == AssignmentOperatorType.BitwiseAnd || ae.Operator == AssignmentOperatorType.BitwiseOr || ae.Operator == AssignmentOperatorType.ExclusiveOr); " is 292.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "				if ((isBitwiseOperator && Helpers.IsKnownType (KnownTypeCode.Int32' toType' block.Emitter.Resolver)) || (ae != null && ae.Operator == AssignmentOperatorType.ShiftRight && Helpers.IsKnownType (KnownTypeCode.UInt32' toType' block.Emitter.Resolver))) { " is 249.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "				else if (ae != null && (isBitwiseOperator || ae.Operator == AssignmentOperatorType.Add || ae.Operator == AssignmentOperatorType.Divide || ae.Operator == AssignmentOperatorType.Multiply || ae.Operator == AssignmentOperatorType.Subtract)) { " is 238.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "	else if (((!Helpers.Is64Type (toType' block.Emitter.Resolver) && Helpers.IsIntegerType (toType' block.Emitter.Resolver)) || (rr is OperatorResolveResult && !Helpers.Is64Type (fromType' block.Emitter.Resolver) && Helpers.IsIntegerType (fromType' block.Emitter.Resolver))) && (expression is BinaryOperatorExpression || expression is UnaryOperatorExpression || expression.Parent is AssignmentExpression) && IsInUncheckedContext (block.Emitter' expression)) { " is 455.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		bool isBitwiseOperator = be != null && (be.Operator == BinaryOperatorType.ShiftLeft || be.Operator == BinaryOperatorType.ShiftRight || be.Operator == BinaryOperatorType.BitwiseAnd || be.Operator == BinaryOperatorType.BitwiseOr || be.Operator == BinaryOperatorType.ExclusiveOr); " is 277.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		if ((Helpers.IsKnownType (KnownTypeCode.Int32' toType' block.Emitter.Resolver) && isBitwiseOperator) || (Helpers.IsKnownType (KnownTypeCode.UInt32' toType' block.Emitter.Resolver) && be != null && be.Operator == BinaryOperatorType.ShiftRight)) { " is 245.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "		else if (be != null && !(be.Left is PrimitiveExpression && be.Right is PrimitiveExpression) && (be.Operator == BinaryOperatorType.Add || be.Operator == BinaryOperatorType.Divide || be.Operator == BinaryOperatorType.Multiply || isBitwiseOperator || be.Operator == BinaryOperatorType.Subtract)) { " is 294.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "			if (ue != null && !(ue.Expression is PrimitiveExpression) && (ue.Operator == UnaryOperatorType.Minus || ue.Operator == UnaryOperatorType.Increment || ue.Operator == UnaryOperatorType.Decrement || ue.Operator == UnaryOperatorType.PostIncrement || ue.Operator == UnaryOperatorType.PostDecrement)) { " is 296.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "				isBitwiseOperator = ae != null && (ae.Operator == AssignmentOperatorType.ShiftRight || ae.Operator == AssignmentOperatorType.ShiftLeft || ae.Operator == AssignmentOperatorType.BitwiseAnd || ae.Operator == AssignmentOperatorType.BitwiseOr || ae.Operator == AssignmentOperatorType.ExclusiveOr); " is 292.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "				if ((isBitwiseOperator && Helpers.IsKnownType (KnownTypeCode.Int32' toType' block.Emitter.Resolver)) || (ae != null && ae.Operator == AssignmentOperatorType.ShiftRight && Helpers.IsKnownType (KnownTypeCode.UInt32' toType' block.Emitter.Resolver))) { " is 249.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The length of the statement  "				else if (ae != null && (isBitwiseOperator || ae.Operator == AssignmentOperatorType.Add || ae.Operator == AssignmentOperatorType.Divide || ae.Operator == AssignmentOperatorType.Multiply || ae.Operator == AssignmentOperatorType.Subtract)) { " is 238.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,NeedsNarrowingNumericConversion,The length of the statement  "	return fromTypeCode >= KnownTypeCode.Char && fromTypeCode <= KnownTypeCode.Decimal && _needNarrowingConversion [fromTypeCode - KnownTypeCode.Char' toTypeCode - KnownTypeCode.Char]; " is 180.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,NarrowingNumericOrEnumerationConversion,The length of the statement  "			var skipOuterWrap = (expression.Parent is VariableInitializer) || (expression.Parent is AssignmentExpression) || targetType.IsKnownType (KnownTypeCode.Int64) || targetType.IsKnownType (KnownTypeCode.UInt64) || targetType.IsKnownType (KnownTypeCode.Int16) || targetType.IsKnownType (KnownTypeCode.SByte); " is 303.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,NarrowingNumericOrEnumerationConversion,The length of the statement  "			var rr = block.Emitter.Resolver.ResolveNode (expression is CastExpression ? ((CastExpression)expression).Expression : expression' block.Emitter); " is 145.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,NarrowingNumericOrEnumerationConversion,The length of the statement  "			bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult); " is 180.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,ClipInteger,The length of the statement  "	NarrowingNumericOrEnumerationConversion (block' expression' specialType' false' false' NullableType.IsNullable (type)' isExplicit); " is 131.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckInteger,The length of the statement  "	NarrowingNumericOrEnumerationConversion (block' expression' NullableType.IsNullable (type) ? NullableType.GetUnderlyingType (type) : type' false' true' NullableType.IsNullable (type)); " is 184.
Long Statement,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,FloatToInt,The length of the statement  "	NarrowingNumericOrEnumerationConversion (block' expression' NullableType.IsNullable (targetType) ? NullableType.GetUnderlyingType (targetType) : targetType' true' isChecked' NullableType.IsNullable (sourceType)); " is 212.
Long Statement,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,GetEventsAndAutoStartupMethods,The length of the statement  "					if (method.Name == CS.Methods.AUTO_STARTUP_METHOD_NAME && method.HasModifier (Modifiers.Static) && !method.HasModifier (Modifiers.Abstract) && Helpers.IsEntryPointCandidate (this.Emitter' method)) { " is 198.
Long Statement,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,HandleAttributes,The length of the statement  "						selector = ((ICSharpCode.NRefactory.CSharp.PrimitiveExpression)(attr.Arguments.ElementAt (selectorIndex))).Value.ToString (); " is 125.
Long Statement,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,HandleAttributes,The length of the statement  "						var memberResolveResult = this.Emitter.Resolver.ResolveNode (attr.Arguments.ElementAt (selectorIndex + 1)' this.Emitter) as MemberResolveResult; " is 144.
Long Statement,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,HandleAttributes,The length of the statement  "								if (field != null && field.ConstantValue != null && Convert.ToInt32 (field.ConstantValue.ToString ()) == templateValue) { " is 121.
Long Statement,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,HandleAttributes,The length of the statement  "								if (field1 != null && field1.ConstantValue != null && Convert.ToInt32 (field1.ConstantValue.ToString ()) == templateValue) { " is 124.
Long Statement,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,LogAutoStartupWarning,The length of the statement  "	this.LogWarning (string.Format ("'{0}.{1}': an entry point cannot be generic or in a generic type"' this.TypeInfo.Type.ReflectionName' method.Name)); " is 149.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetOutputForType,The length of the statement  "		var isPathRelated = this.Emitter.AssemblyInfo.OutputBy == OutputBy.ClassPath || this.Emitter.AssemblyInfo.OutputBy == OutputBy.NamespacePath; " is 141.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetIteractiveClassPath,The length of the statement  "		throw new EmitterException (typeInfo.TypeDeclaration' "Iteration count for class '" + typeInfo.Type.FullName + "' exceeded " + maxIterations + " depth iterations until root class!"); " is 182.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,DoEmit,The length of the statement  "			var ignore = mode == 0 && !type.Type.GetMethods (null' GetMemberOptions.IgnoreInheritedMembers).Any (m => !m.IsConstructor && !m.IsAccessor); " is 141.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,DoEmit,The length of the statement  "			isGlobal = typeDef.Attributes.Any (a => a.AttributeType.FullName == "Bridge.GlobalMethodsAttribute" || a.AttributeType.FullName == "Bridge.MixinAttribute"); " is 156.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,DoEmit,The length of the statement  "		var meta = MetadataUtils.ConstructTypeMetadata (typeDef' this.Emitter' true' type.TypeDeclaration.GetParent<SyntaxTree> ()); " is 124.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,DoEmit,The length of the statement  "	var scriptableAttributes = MetadataUtils.GetScriptableAttributes (this.Emitter.Resolver.Compilation.MainAssembly.AssemblyAttributes' this.Emitter' null).ToList (); " is 163.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,DoEmit,The length of the statement  "		this.Write (string.Format ("Bridge.setMetadata({0}' function ({2}) {{ return {1}; }});"' BridgeTypes.ToJsName (meta.Key' this.Emitter' true)' metaData.ToString (Formatting.None)' typeArgs)); " is 190.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The length of the statement  "	bool? enable = config.Enabled.HasValue ? config.Enabled : (configInternal.Enabled.HasValue ? configInternal.Enabled : null); " is 124.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The length of the statement  "	TypeAccessibility? typeAccessibility = config.TypeAccessibility.HasValue ? config.TypeAccessibility : (configInternal.TypeAccessibility.HasValue ? configInternal.TypeAccessibility : null); " is 188.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The length of the statement  "	string filter = !string.IsNullOrEmpty (config.Filter) ? config.Filter : (!string.IsNullOrEmpty (configInternal.Filter) ? configInternal.Filter : null); " is 151.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The length of the statement  "	var hasSettings = !string.IsNullOrEmpty (config.Filter) || config.MemberAccessibility.HasValue || config.TypeAccessibility.HasValue || !string.IsNullOrEmpty (configInternal.Filter) || configInternal.MemberAccessibility.HasValue || configInternal.TypeAccessibility.HasValue; " is 273.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The length of the statement  "			var isGlobal = typeDef.Attributes.Any (a => a.AttributeType.FullName == "Bridge.GlobalMethodsAttribute" || a.AttributeType.FullName == "Bridge.MixinAttribute"); " is 160.
Long Statement,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The length of the statement  "			if (typeAccessibility.Value.HasFlag (TypeAccessibility.Public) && (typeDef == null || typeDef.IsPublic || typeDef.IsInternal)) { " is 128.
Long Statement,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,DoEmit,The length of the statement  "			if (!this.Emitter.Validator.IsIgnoreType (type) && type.Methods.Count (m => m.IsConstructor && !m.IsStatic) > (type.IsValueType ? 0 : 1)) { " is 139.
Long Statement,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,DoEmit,The length of the statement  "			var inlineInit = this.WriteObjectInitializer (attribute.NamedArguments' this.Emitter.AssemblyInfo.PreserveMemberCase' type' attribute); " is 135.
Long Statement,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteObjectInitializer,The length of the statement  "			if (attr.Constructor.Parameters.Count == 1 && attr.Constructor.Parameters.First ().Type.FullName == "Bridge.DefaultValueMode") { " is 128.
Long Statement,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteObjectInitializer,The length of the statement  "				var oattr = this.Emitter.Validator.GetAttribute (itype.Attributes' Translator.Bridge_ASSEMBLY + ".ObjectLiteralAttribute"); " is 123.
Long Statement,Bridge.Translator,YieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\YieldBlock.cs,DoEmit,The length of the statement  "		if (this.YieldBreakStatement.GetParent<ForStatement> () == null && this.YieldBreakStatement.GetParent<ForeachStatement> () == null && this.YieldBreakStatement.GetParent<WhileStatement> () == null && this.YieldBreakStatement.GetParent<DoWhileStatement> () == null) { " is 265.
Long Statement,Bridge.Translator,YieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\YieldBlock.cs,EmitYieldReturn,The length of the statement  "			block.Write (JS.Types.SYSTEM_ARRAY + "." + JS.Funcs.TO_ENUMERATOR + "(" + JS.Vars.YIELD + "' " + BridgeTypes.ToJsName (returnType.TypeArguments.First ()' block.Emitter) + ")"); " is 176.
Long Statement,Bridge.Translator,DefaultValueBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\DefaultValueBlock.cs,DefaultValue,The length of the statement  "	if ((!resolveResult.IsError && resolveResult.Type.IsReferenceType.HasValue && resolveResult.Type.IsReferenceType.Value) || resolveResult.Type.Kind == TypeKind.Dynamic || resolveResult.Type.IsKnownType (KnownTypeCode.NullableOfT)) { " is 231.
Long Statement,Bridge.Translator,DefaultValueBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\DefaultValueBlock.cs,DefaultValue,The length of the statement  "	return JS.Funcs.BRIDGE_GETDEFAULTVALUE + "(" + (astType != null ? BridgeTypes.ToJsName (astType' emitter) : BridgeTypes.ToJsName (resolveResult.Type' emitter)) + ")"; " is 166.
Long Statement,Bridge.Translator,BreakBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BreakBlock.cs,DoEmit,The length of the statement  "				if (n is ForStatement || n is ForeachStatement || n is WhileStatement || n is DoWhileStatement || n is AnonymousMethodExpression || n is LambdaExpression) { " is 156.
Long Statement,Bridge.Translator,SwitchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\SwitchBlock.cs,DoEmit,The length of the statement  "			throw new EmitterException (this.SwitchSection' "Async switch section must be handled by VisitAsyncSwitchStatement method"); " is 124.
Long Statement,Bridge.Translator,SwitchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\SwitchBlock.cs,VisitCaseLabel,The length of the statement  "		var rr = this.Emitter.Resolver.ResolveNode (caseLabel.Expression.GetParent<SwitchStatement> ().Expression' this.Emitter); " is 121.
Long Statement,Bridge.Translator,VisitorIndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VisitorIndexerBlock.cs,DoEmit,The length of the statement  "	this.EmitIndexerMethod (this.IndexerDeclaration' prop' this.IndexerDeclaration.Getter' prop == null ? null : prop.Getter' false); " is 129.
Long Statement,Bridge.Translator,VisitorIndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VisitorIndexerBlock.cs,DoEmit,The length of the statement  "	this.EmitIndexerMethod (this.IndexerDeclaration' prop' this.IndexerDeclaration.Setter' prop == null ? null : prop.Setter' true); " is 128.
Long Statement,Bridge.Translator,TryCatchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\TryCatchBlock.cs,VisitAsyncTryCatchStatement,The length of the statement  "		tryInfo.CatchBlocks.Add (new Tuple<string' string' int' int> (varName' clause.Type.IsNull ? JS.Types.SYSTEM_EXCEPTION : BridgeTypes.ToJsName (clause.Type' this.Emitter)' catchStep.Step' Emitter.AsyncBlock.Steps.Last ().Step)); " is 226.
Long Statement,Bridge.Translator,TryCatchBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\TryCatchBlock.cs,VisitTryCatchStatement,The length of the statement  "		var exceptionType = (firstClause == null || firstClause.Type.IsNull) ? null : BridgeTypes.ToJsName (firstClause.Type' this.Emitter); " is 132.
Long Statement,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,VisitAsyncForeachStatement,The length of the statement  "	var varName = this.AddLocal (foreachStatement.VariableName' foreachStatement.VariableNameToken' foreachStatement.VariableType); " is 127.
Long Statement,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,VisitForeachStatement,The length of the statement  "	if (in_rr.Type.Kind != TypeKind.Array && !in_rr.Type.IsKnownType (KnownTypeCode.String) && !in_rr.Type.IsKnownType (KnownTypeCode.Array)) { " is 139.
Long Statement,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,VisitForeachStatement,The length of the statement  "		var varName = this.AddLocal (foreachStatement.VariableName' foreachStatement.VariableNameToken' foreachStatement.VariableType); " is 127.
Long Statement,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,GetCastCode,The length of the statement  "		method = this.GetCastMethod (NullableType.IsNullable (fromType) ? NullableType.GetUnderlyingType (fromType) : fromType' NullableType.IsNullable (toType) ? NullableType.GetUnderlyingType (toType) : toType' out inline); " is 217.
Long Statement,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,GetCastMethod,The length of the statement  "		if (m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1 && m.ReturnType.ReflectionName == toType.ReflectionName && m.Parameters [0].Type.ReflectionName == fromType.ReflectionName) { " is 225.
Long Statement,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,GetCastMethod,The length of the statement  "			if (m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1 && m.ReturnType.ReflectionName == toType.ReflectionName && (m.Parameters [0].Type.ReflectionName == fromType.ReflectionName)) { " is 227.
Long Statement,Bridge.Translator,ThrowBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ThrowBlock.cs,DoEmit,The length of the statement  "		var exceptionType = (firstClause == null || firstClause.Type.IsNull) ? null : BridgeTypes.ToJsName (firstClause.Type' this.Emitter); " is 132.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,WriteInterfaceMember,The length of the statement  "	var externalInterface = this.Emitter.Validator.IsExternalInterface (resolveResult.Member.DeclaringTypeDefinition' out nativeImplementation); " is 140.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,WriteInterfaceMember,The length of the statement  "		var interfaceName = OverloadsCollection.Create (Emitter' resolveResult.Member' isSetter).GetOverloadName (false' prefix); " is 121.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitInlineIndexer,The length of the statement  "		new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' indexerExpression' this.Emitter.Resolver.ResolveNode (indexerExpression' this.Emitter) as InvocationResolveResult)' inlineCode).Emit (); " is 209.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "	var isExternalInterface = this.Emitter.Validator.IsExternalInterface (memberResolveResult.Member.DeclaringTypeDefinition' out nativeImplementation); " is 148.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "	if (memberResolveResult != null && memberResolveResult.Member.DeclaringTypeDefinition != null && memberResolveResult.Member.DeclaringTypeDefinition.Kind == TypeKind.Interface && (isExternalInterface || hasTypeParemeter)) { " is 222.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "		isStatement = indexerExpression.Parent is UnaryOperatorExpression && indexerExpression.Parent.Parent is ExpressionStatement; " is 124.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "	bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult); " is 180.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "	if (isInterfaceMember && (!this.Emitter.IsUnaryAccessor || isStatement) && !(targetrr is ThisResolveResult || targetrr is LocalResolveResult || targetrr is ConstantResolveResult || isField)) { " is 192.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "		if (!(targetrr is ThisResolveResult || targetrr is LocalResolveResult || targetrr is ConstantResolveResult || isField)) { " is 121.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "	var name = Helpers.GetPropertyRef (member' this.Emitter' this.Emitter.IsAssignment' ignoreInterface: !nativeImplementation); " is 124.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "					this.Write (Helpers.GetPropertyRef (memberResolveResult.Member' this.Emitter' true' ignoreInterface: !nativeImplementation)); " is 125.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "					if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "					if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "				bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement; " is 142.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "				this.WriteInterfaceMember (targetVar' memberResolveResult' this.Emitter.IsAssignment' Helpers.GetSetOrGet (this.Emitter.IsAssignment)); " is 135.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "				this.WriteInterfaceMember (targetVar' memberResolveResult' this.Emitter.IsAssignment' Helpers.GetSetOrGet (this.Emitter.IsAssignment)); " is 135.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "				getterMember = "." + Helpers.GetPropertyRef (memberResolveResult.Member' this.Emitter' false' ignoreInterface: !nativeImplementation); " is 134.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "				this.PushWriter (string.Concat (memberStr' "("' paramsStr' "' "' targetVar' getterMember' isBase ? "." + JS.Funcs.CALL : ""' "("' isBase ? "this' " : ""' paramsStr' "){0})")); " is 175.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "				this.PushWriter (string.Concat (memberStr' "("' paramsStr' "' "' trg' getterMember' isBase ? "." + JS.Funcs.CALL : ""' "("' isBase ? "this' " : ""' paramsStr' "){0})")); " is 169.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The length of the statement  "				this.WriteInterfaceMember (targetVar' memberResolveResult' this.Emitter.IsAssignment' Helpers.GetSetOrGet (this.Emitter.IsAssignment)); " is 135.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "		isStatement = indexerExpression.Parent is UnaryOperatorExpression && indexerExpression.Parent.Parent is ExpressionStatement; " is 124.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "		bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult); " is 180.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "					if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "					if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "				var isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement; " is 141.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The length of the statement  "				this.PushWriter (string.Concat (JS.Funcs.Property.SET' "(["' paramsStr' "]'"' targetVar' ".get(["' paramsStr' "]){0})")' () =>  { " is 129.
Long Statement,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitSingleDimArrayIndexer,The length of the statement  "	if (primitive != null && primitive.Value != null && Regex.Match (primitive.Value.ToString ()' "^[_$a-z][_$a-z0-9]*$"' RegexOptions.IgnoreCase).Success) { " is 153.
Long Statement,Bridge.Translator,IfElseBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IfElseBlock.cs,VisitIfElseStatement,The length of the statement  "		if (this.Emitter.AsyncBlock.Steps.Count <= elseCount && !AbstractEmitterBlock.IsJumpStatementLast (this.Emitter.Output.ToString ())) { " is 134.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "	var invocationResolveResult = this.Emitter.Resolver.ResolveNode (objectCreateExpression' this.Emitter) as InvocationResolveResult; " is 130.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "		if (invocationResolveResult.Member.DeclaringType.Kind == TypeKind.Struct && objectCreateExpression.Arguments.Count == 0) { " is 122.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "			var defCtor = ctors.FirstOrDefault (c => c.Parameters.First ().Type.FullName == "System.Runtime.CompilerServices.DummyTypeUsedToAddAttributeToDefaultValueTypeConstructor"); " is 172.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "	var hasInitializer = !objectCreateExpression.Initializer.IsNull && objectCreateExpression.Initializer.Elements.Count > 0; " is 121.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "			var ctorMember = ((InvocationResolveResult)this.Emitter.Resolver.ResolveNode (objectCreateExpression' this.Emitter)).Member; " is 124.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "				if (ctor_rr.Type.Kind == TypeKind.Array && !(paramsArg is ArrayCreateExpression) && objectCreateExpression.Arguments.Last () == paramsArg) { " is 140.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "			if (!isTypeParam && !this.Emitter.Validator.IsIgnoreType (type) && type.Methods.Count (m => m.IsConstructor && !m.IsStatic) > (type.IsValueType || isObjectLiteral ? 0 : 1)) { " is 174.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "				var name = OverloadsCollection.Create (this.Emitter' ((InvocationResolveResult)this.Emitter.Resolver.ResolveNode (objectCreateExpression' this.Emitter)).Member).GetOverloadName (); " is 180.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The length of the statement  "						new NameBlock (this.Emitter' namedArgumentExpression.Name' namedArgumentExpression' namedArgumentExpression.Expression' true).Emit (); " is 134.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,WriteObjectInitializer,The length of the statement  "			if (p.Type.FullName == "Bridge.DefaultValueMode" || p.Type.FullName == "Bridge.ObjectInitializationMode" || p.Type.FullName == "Bridge.ObjectCreateMode") { " is 155.
Long Statement,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,WriteObjectInitializer,The length of the statement  "				if (!this.Emitter.AssemblyInfo.PreserveMemberCase && itemrr.Member is IProperty && !itemrr.Member.Attributes.Any (attr => attr.AttributeType.FullName == "Bridge.NameAttribute") && !this.Emitter.Validator.IsObjectLiteral (itemrr.Member.DeclaringTypeDefinition)) { " is 262.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "	bool isObjectLiteral = csharpInvocation != null && csharpInvocation.Member.DeclaringTypeDefinition != null ? this.Emitter.Validator.IsObjectLiteral (csharpInvocation.Member.DeclaringTypeDefinition) : false; " is 206.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "	var interceptor = this.Emitter.Plugins.OnInvocation (this' this.InvocationExpression' targetResolve as InvocationResolveResult); " is 128.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "					value = InlineArgumentsBlock.ReplaceInlineArgs (this' inlineExpression.Value.ToString ()' invocationExpression.Arguments.Skip (1).ToArray ()); " is 142.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "					if (value [value.Length - 1] == ';' || value.EndsWith ("*/"' StringComparison.InvariantCulture) || value.StartsWith ("//")) { " is 125.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "				if (member != null && member.Type.Kind == TypeKind.Delegate && (/*csharpInvocation.Member.Name == "Invoke" || */csharpInvocation.Member.Name == "BeginInvoke" || csharpInvocation.Member.Name == "EndInvoke") && !csharpInvocation.IsExtensionMethodInvocation) { " is 257.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "					throw new EmitterException (invocationExpression' "Delegate's 'Invoke' methods are not supported. Please use direct delegate invoke."); " is 135.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "				if (this.IsEmptyPartialInvoking (csharpInvocation.Member as IMethod) || IsConditionallyRemoved (invocationExpression' csharpInvocation.Member)) { " is 145.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "				if (invocationResult != null && (this.IsEmptyPartialInvoking (invocationResult.Member as IMethod) || IsConditionallyRemoved (invocationExpression' invocationResult.Member))) { " is 175.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "							var isIgnoreClass = resolvedMethod.DeclaringTypeDefinition != null && this.Emitter.Validator.IsIgnoreType (resolvedMethod.DeclaringTypeDefinition); " is 147.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "		var baseType = this.Emitter.GetBaseMethodOwnerTypeDefinition (targetMember.MemberName' targetMember.TypeArguments.Count); " is 121.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "			//throw (System.Exception)this.Emitter.CreateException(targetMember.Target' "Cannot call base method' because parent class code is ignored"); " is 141.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "			baseMethod = this.Emitter.AssemblyInfo.PreserveMemberCase ? baseMethod : Object.Net.Utilities.StringUtils.ToLowerCamelCase (baseMethod); " is 136.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "		var dynamicResolveResult = this.Emitter.Resolver.ResolveNode (invocationExpression' this.Emitter) as DynamicInvocationResolveResult; " is 132.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "				throw new EmitterException (invocationExpression' "Cannot compile this dynamic invocation because there are two or more method overloads with the same parameter count. To work around this limitation' assign the dynamic value to a non-dynamic variable before use or call a method with different parameter count"); " is 312.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "		bool isIgnore = method != null && method.DeclaringTypeDefinition != null && this.Emitter.Validator.IsIgnoreType (method.DeclaringTypeDefinition); " is 145.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "					new ExpressionListBlock (this.Emitter' argsExpressions.Take (argsExpressions.Length - 1).ToArray ()' paramsArg' invocationExpression' openPos).Emit (); " is 151.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The length of the statement  "	Helpers.CheckValueTypeClone (this.Emitter.Resolver.ResolveNode (invocationExpression' this.Emitter)' invocationExpression' this' pos); " is 134.
Long Statement,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,IsNativeMethod,The length of the statement  "	return resolvedMethod.DeclaringTypeDefinition != null && this.Emitter.Validator.IsIgnoreType (resolvedMethod.DeclaringTypeDefinition); " is 134.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,FindOperatorTrueOrFalse,The length of the statement  "	return (IMethod)type.GetMethods (null' GetMemberOptions.IgnoreInheritedMembers).Single (m => m.Name == (findTrue ? "op_True" : "op_False") && m.Parameters.Count == 1 && NullableType.IsNullable (m.Parameters [0].Type) == isNullable); " is 232.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,ResolveOperator,The length of the statement  "			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' binaryOperatorExpression' orr' method)' inline).Emit (); " is 129.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,ResolveOperator,The length of the statement  "				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult); " is 180.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,ResolveOperator,The length of the statement  "				if (!(left is ThisResolveResult || left is TypeResolveResult || left is LocalResolveResult || left is ConstantResolveResult || isField)) { " is 138.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,IsOperatorSimple,The length of the statement  "	bool leftIsSimple = binaryOperatorExpression.Left is PrimitiveExpression || leftResolverResult.Type.IsReferenceType != null && !leftResolverResult.Type.IsReferenceType.Value; " is 174.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,IsOperatorSimple,The length of the statement  "	bool rightIsSimple = binaryOperatorExpression.Right is PrimitiveExpression || rightResolverResult.Type.IsReferenceType != null && !rightResolverResult.Type.IsReferenceType.Value; " is 178.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	bool isUint = resolveOperator.Type.IsKnownType (KnownTypeCode.UInt16) || resolveOperator.Type.IsKnownType (KnownTypeCode.UInt32) || resolveOperator.Type.IsKnownType (KnownTypeCode.UInt64); " is 188.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	var resultIsString = expectedType.IsKnownType (KnownTypeCode.String) || resolveOperator.Type.IsKnownType (KnownTypeCode.String); " is 128.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	if (!isStringConcat && (Helpers.IsDecimalType (leftResolverResult.Type' this.Emitter.Resolver) || Helpers.IsDecimalType (rightResolverResult.Type' this.Emitter.Resolver))) { " is 173.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "		if (leftExpected.Kind == TypeKind.Enum && Helpers.Is64Type (leftExpected.GetDefinition ().EnumUnderlyingType' this.Emitter.Resolver)) { " is 135.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "		if (rightExpected.Kind == TypeKind.Enum && Helpers.Is64Type (rightExpected.GetDefinition ().EnumUnderlyingType' this.Emitter.Resolver)) { " is 137.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	if (binaryOperatorExpression.Operator == BinaryOperatorType.Equality || binaryOperatorExpression.Operator == BinaryOperatorType.InEquality) { " is 141.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	if (binaryOperatorExpression.Operator == BinaryOperatorType.Divide && !(this.Emitter.IsJavaScriptOverflowMode && !ConversionBlock.InsideOverflowContext (this.Emitter' binaryOperatorExpression)) && ((Helpers.IsIntegerType (leftResolverResult.Type' this.Emitter.Resolver) && Helpers.IsIntegerType (rightResolverResult.Type' this.Emitter.Resolver)) || (Helpers.IsIntegerType (this.Emitter.Resolver.Resolver.GetExpectedType (binaryOperatorExpression.Left)' this.Emitter.Resolver) && Helpers.IsIntegerType (this.Emitter.Resolver.Resolver.GetExpectedType (binaryOperatorExpression.Right)' this.Emitter.Resolver)))) { " is 610.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	if (binaryOperatorExpression.Operator == BinaryOperatorType.Add || binaryOperatorExpression.Operator == BinaryOperatorType.Subtract) { " is 134.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "		if (this.Emitter.Validator.IsDelegateOrLambda (leftResolverResult) && this.Emitter.Validator.IsDelegateOrLambda (rightResolverResult)) { " is 136.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	bool isCoalescing = (this.Emitter.AssemblyInfo.StrictNullChecks || NullableType.IsNullable (leftResolverResult.Type) || leftResolverResult.Type.IsKnownType (KnownTypeCode.String) || leftResolverResult.Type.IsKnownType (KnownTypeCode.Object)) && binaryOperatorExpression.Operator == BinaryOperatorType.NullCoalescing; " is 316.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	bool isBool = NullableType.IsNullable (resolveOperator.Type) ? NullableType.GetUnderlyingType (resolveOperator.Type).IsKnownType (KnownTypeCode.Boolean) : resolveOperator.Type.IsKnownType (KnownTypeCode.Boolean); " is 212.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	bool toBool = isBool && !rootSpecial && !delegateOperator && (binaryOperatorExpression.Operator == BinaryOperatorType.BitwiseAnd || binaryOperatorExpression.Operator == BinaryOperatorType.BitwiseOr); " is 199.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "	bool isRefEquals = !isCoalescing && !strictNullChecks && (binaryOperatorExpression.Operator == BinaryOperatorType.InEquality || binaryOperatorExpression.Operator == BinaryOperatorType.Equality) && leftExpected.IsReferenceType.HasValue && leftExpected.IsReferenceType.Value && rightExpected.IsReferenceType.HasValue && rightExpected.IsReferenceType.Value; " is 354.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The length of the statement  "			throw new EmitterException (binaryOperatorExpression' "Unsupported binary operator: " + binaryOperatorExpression.Operator.ToString ()); " is 135.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,HandleType,The length of the statement  "			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' this.BinaryOperatorExpression' orr' method)' inline).Emit (); " is 134.
Long Statement,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,AddOveflowFlag,The length of the statement  "	if ((typeCode == KnownTypeCode.Int64 || typeCode == KnownTypeCode.UInt64) && ConversionBlock.IsInCheckedContext (this.Emitter' this.BinaryOperatorExpression)) { " is 160.
Long Statement,Bridge.Translator,BaseReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BaseReferenceBlock.cs,EmitConversionExpression,The length of the statement  "			this.Write (BridgeTypes.ToJsName (this.Emitter.TypeInfo.GetBaseClass (this.Emitter)' this.Emitter)' "." + JS.Fields.PROTOTYPE); " is 127.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "		if (this.Emitter.LocalsMap != null && this.Emitter.LocalsMap.ContainsKey (lrr.Variable) && !(identifierExpression.Parent is DirectionExpression)) { " is 147.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "		/*if (this.Emitter.Validator.IsIgnoreType(resolveResult.Type.GetDefinition()) || resolveResult.Type.Kind == TypeKind.Enum)" is 122.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "	var isInvoke = identifierExpression.Parent is InvocationExpression && (((InvocationExpression)(identifierExpression.Parent)).Target == identifierExpression); " is 157.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "		var i_rr = this.Emitter.Resolver.ResolveNode (identifierExpression.Parent' this.Emitter) as CSharpInvocationResolveResult; " is 122.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "	if (string.IsNullOrEmpty (inlineCode) && memberResult != null && memberResult.Member is IMethod && !(memberResult is InvocationResolveResult) && !(identifierExpression.Parent is InvocationExpression && identifierExpression.NextSibling != null && identifierExpression.NextSibling.Role is TokenRole && ((TokenRole)identifierExpression.NextSibling.Role).Token == "(")) { " is 367.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "			/*if (!this.Emitter.Validator.IsIgnoreType(memberResult.Member.DeclaringTypeDefinition) && memberResult.Member.DeclaringTypeDefinition.Kind != TypeKind.Enum)" is 157.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' this.IdentifierExpression' resolveResult)' oldInline' (IMethod)memberResult.Member' targetrr).EmitFunctionReference (); " is 192.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' this.IdentifierExpression' resolveResult)' inlineCode' (IMethod)memberResult.Member' targetrr).EmitFunctionReference (); " is 193.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "	if (memberResult != null && memberResult.Member is IMethod && !(memberResult is InvocationResolveResult) && !(identifierExpression.Parent is InvocationExpression && identifierExpression.NextSibling != null && identifierExpression.NextSibling.Role is TokenRole && ((TokenRole)identifierExpression.NextSibling.Role).Token == "(")) { " is 330.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' identifierExpression' resolveResult)' inlineCode' (IMethod)memberResult.Member' targetrr).EmitFunctionReference (); " is 188.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "	if (memberResult != null && memberResult.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (memberResult.Member) && this.Emitter.IsInlineConst (memberResult.Member)) { " is 185.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "	if (memberResult != null && memberResult.Member.SymbolKind == SymbolKind.Property && memberResult.TargetResult.Type.Kind != TypeKind.Anonymous) { " is 145.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "			isStatement = identifierExpression.Parent is UnaryOperatorExpression && identifierExpression.Parent.Parent is ExpressionStatement; " is 130.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "			if (resolveResult is InvocationResolveResult || (memberResult.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) { " is 135.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "					if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement) { " is 133.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "			this.PushWriter (string.Concat (Helpers.GetPropertyRef (memberResult.Member' this.Emitter' true)' "("' trg' "."' Helpers.GetPropertyRef (memberResult.Member' this.Emitter' false)' "()"' "{0})")); " is 195.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) { " is 161.
Long Statement,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The length of the statement  "				this.Write (OverloadsCollection.Create (this.Emitter' memberResult.Member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract).GetOverloadName ()); " is 159.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,ResolveOperator,The length of the statement  "			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' unaryOperatorExpression' orr' method)' inline).Emit (); " is 128.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,VisitUnaryOperatorExpression,The length of the statement  "		if (op != UnaryOperatorType.Increment && op != UnaryOperatorType.Decrement && op != UnaryOperatorType.PostIncrement && op != UnaryOperatorType.PostDecrement) { " is 159.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,VisitUnaryOperatorExpression,The length of the statement  "	if ((isAccessor) && (op == UnaryOperatorType.Increment || op == UnaryOperatorType.Decrement || op == UnaryOperatorType.PostIncrement || op == UnaryOperatorType.PostDecrement)) { " is 177.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,VisitUnaryOperatorExpression,The length of the statement  "			throw new EmitterException (unaryOperatorExpression' "Unsupported unary operator: " + unaryOperatorExpression.Operator.ToString ()); " is 132.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,AddOveflowFlag,The length of the statement  "	if ((typeCode == KnownTypeCode.Int64 || typeCode == KnownTypeCode.UInt64) && ConversionBlock.IsInCheckedContext (this.Emitter' this.UnaryOperatorExpression)) { " is 159.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The length of the statement  "		var inlineAttr = this.Emitter.GetAttribute (memberArgResolverResult.Member.Attributes' Translator.Bridge_ASSEMBLY + ".TemplateAttribute"); " is 138.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The length of the statement  "	var isOneOp = op == UnaryOperatorType.Increment || op == UnaryOperatorType.Decrement || op == UnaryOperatorType.PostIncrement || op == UnaryOperatorType.PostDecrement; " is 167.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The length of the statement  "			this.Write (" = " + JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1 + "('" + (op == UnaryOperatorType.Decrement ? JS.Funcs.Math.DEC : JS.Funcs.Math.INC) + "'' "); " is 167.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The length of the statement  "			this.Write (" = " + JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1 + "('" + (op == UnaryOperatorType.PostDecrement ? JS.Funcs.Math.DEC : JS.Funcs.Math.INC) + "'' "); " is 171.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The length of the statement  "				if (isStatement || this.UnaryOperatorExpression.Operator == UnaryOperatorType.Increment || this.UnaryOperatorExpression.Operator == UnaryOperatorType.Decrement) { " is 162.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The length of the statement  "					new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' this.UnaryOperatorExpression' orr' method)' inline).Emit (); " is 133.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The length of the statement  "					new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' this.UnaryOperatorExpression' orr' method)' inline).Emit (); " is 133.
Long Statement,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The length of the statement  "				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' this.UnaryOperatorExpression' orr' method)' inline).Emit (); " is 133.
Long Statement,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,DoEmit,The length of the statement  "	if ((!this.WrapByFn.HasValue || this.WrapByFn.Value) && (this.BlockStatement.Parent is ForStatement || this.BlockStatement.Parent is ForeachStatement || this.BlockStatement.Parent is WhileStatement || this.BlockStatement.Parent is DoWhileStatement)) { " is 251.
Long Statement,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,DoEmit,The length of the statement  "		this.Emitter.ReplaceJump = (this.HandleContinue.HasValue && this.HandleContinue.Value) || (this.HandleBreak.HasValue && this.HandleBreak.Value) || (this.HandleReturn.HasValue && this.HandleReturn.Value); " is 203.
Long Statement,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,KeepLineAfterBlock,The length of the statement  "	if (parent is Accessor && (parent.Parent is PropertyDeclaration || parent.Parent is CustomEventDeclaration || parent.Parent is IndexerDeclaration)) { " is 149.
Long Statement,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,KeepLineAfterBlock,The length of the statement  "	if (ifStatement != null && ifStatement.FalseStatement != null && !ifStatement.FalseStatement.IsNull && ifStatement.FalseStatement != block) { " is 141.
Long Statement,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,EndEmitBlock,The length of the statement  "	if (!this.NoBraces && (!this.Emitter.IsAsync || (!this.AsyncNoBraces && this.BlockStatement.Parent != this.Emitter.AsyncBlock.Node))) { " is 135.
Long Statement,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,EndEmitBlock,The length of the statement  "		var isBlock = (this.HandleContinue.HasValue && this.HandleContinue.Value) || (this.HandleBreak.HasValue && this.HandleBreak.Value) || (this.HandleReturn.HasValue && this.HandleReturn.Value); " is 190.
Long Statement,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,BeginEmitBlock,The length of the statement  "		if ((this.HandleContinue.HasValue && this.HandleContinue.Value) || (this.HandleBreak.HasValue && this.HandleBreak.Value) || (this.HandleReturn.HasValue && this.HandleReturn.Value)) { " is 182.
Long Statement,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,BeginEmitBlock,The length of the statement  "	else if (!this.NoBraces && (!this.Emitter.IsAsync || (!this.AsyncNoBraces && this.BlockStatement.Parent != this.Emitter.AsyncBlock.Node))) { " is 140.
Long Statement,Bridge.Translator,ExpressionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionBlock.cs,DoEmit,The length of the statement  "	bool isAwaiter = this.ExpressionStatement.Expression is UnaryOperatorExpression && ((UnaryOperatorExpression)this.ExpressionStatement.Expression).Operator == UnaryOperatorType.Await; " is 182.
Long Statement,Bridge.Translator,PrimitiveExpressionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\PrimitiveExpressionBlock.cs,EmitConversionExpression,The length of the statement  "		this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (this.PrimitiveExpression.Value' this.PrimitiveExpression' this.Emitter)); " is 134.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteTarget,The length of the statement  "		var externalInterface = member != null && this.Emitter.Validator.IsExternalInterface (member.Member.DeclaringTypeDefinition' out nativeImplementation); " is 151.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteTarget,The length of the statement  "		bool isField = externalInterface && memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult); " is 201.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteTarget,The length of the statement  "		if (externalInterface && !nativeImplementation && !(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) { " is 163.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteInterfaceMember,The length of the statement  "	var externalInterface = this.Emitter.Validator.IsExternalInterface (resolveResult.Member.DeclaringTypeDefinition' out nativeImplementation); " is 140.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteInterfaceMember,The length of the statement  "		var interfaceName = OverloadsCollection.Create (Emitter' resolveResult.Member' isSetter).GetOverloadName (false' prefix); " is 121.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteInterfaceMember,The length of the statement  "	this.Write (OverloadsCollection.Create (Emitter' resolveResult.Member' isSetter).GetOverloadName (!nativeImplementation' prefix)); " is 130.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "	if (memberTargetrr != null && memberTargetrr.Type.Kind == TypeKind.Enum && memberTargetrr.Member is DefaultResolvedField && this.Emitter.Validator.EnumEmitMode (memberTargetrr.Type) == 2) { " is 189.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "	if (memberReferenceExpression.Target is ParenthesizedExpression || (targetrr is ConstantResolveResult && targetrr.Type.IsKnownType (KnownTypeCode.Int64)) || (targetrr is ConstantResolveResult && targetrr.Type.IsKnownType (KnownTypeCode.UInt64)) || (targetrr is ConstantResolveResult && targetrr.Type.IsKnownType (KnownTypeCode.Decimal))) { " is 339.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "	var isInvoke = memberReferenceExpression.Parent is InvocationExpression && (((InvocationExpression)(memberReferenceExpression.Parent)).Target == memberReferenceExpression); " is 172.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "	if (member != null && member.Member.Attributes.Any (a => a.AttributeType.FullName == "Bridge.NonScriptableAttribute")) { " is 120.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "		throw new EmitterException (this.MemberReferenceExpression' "Member " + member.ToString () + " is marked as not usable from script"); " is 133.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "			var memberExpression = member.Member is IMethod ? memberReferenceExpression.Parent.Parent : memberReferenceExpression.Parent; " is 125.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "	if (string.IsNullOrEmpty (inline) && member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) { " is 365.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "		var i_rr = this.Emitter.Resolver.ResolveNode (memberReferenceExpression.Parent' this.Emitter) as CSharpInvocationResolveResult; " is 127.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "	bool isInterface = inline == null && member != null && member.Member.DeclaringTypeDefinition != null && member.Member.DeclaringTypeDefinition.Kind == TypeKind.Interface; " is 169.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "	if (isInterface && (this.Emitter.Validator.IsExternalInterface (member.Member.DeclaringTypeDefinition' out nativeImplementation) || hasTypeParemeter)) { " is 152.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				bool isField = mrr != null && mrr.Member is IField && (mrr.TargetResult is ThisResolveResult || mrr.TargetResult is LocalResolveResult); " is 136.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				isSimple = (mrr != null && (mrr.TargetResult is ThisResolveResult || mrr.TargetResult is ConstantResolveResult || mrr.TargetResult is LocalResolveResult)) || isField; " is 166.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit (); " is 132.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' oldInline' (IMethod)member.Member' targetrr).EmitFunctionReference (); " is 186.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "	if (member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)) { " is 161.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "		this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter)); " is 125.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference (); " is 183.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit (); " is 132.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "		else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) { " is 337.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference (); " is 183.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) { " is 134.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "			if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) { " is 210.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement; " is 140.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult); " is 180.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "			if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) { " is 120.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference (); " is 183.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) { " is 134.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "		else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) { " is 225.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) { " is 157.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ())); " is 200.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) { " is 156.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ())); " is 201.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "			if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) { " is 253.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "								if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "								if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "								if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "								if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) { " is 137.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "						bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement; " is 142.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation); " is 121.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  { " is 179.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")); " is 165.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter)); " is 125.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "			else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) { " is 163.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation)); " is 121.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "				this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation)); " is 120.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "			if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) { " is 161.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add)); " is 214.
Long Statement,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The length of the statement  "					this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation)); " is 162.
Long Statement,Bridge.Translator,VariableBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VariableBlock.cs,VisitVariableDeclarationStatement,The length of the statement  "		if (variable.Initializer != null && !variable.Initializer.IsNull && variable.Initializer.ToString ().Contains (JS.Vars.FIX_ARGUMENT_NAME)) { " is 140.
Long Statement,Bridge.Translator,VariableBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VariableBlock.cs,VisitVariableDeclarationStatement,The length of the statement  "				this.Write (string.Concat ("new "' isGeneric ? "(" : ""' BridgeTypes.ToJsName (this.VariableDeclarationStatement.Type' this.Emitter)' isGeneric ? ")" : ""' "()")); " is 163.
Long Statement,Bridge.Translator,VisitorPropertyBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VisitorPropertyBlock.cs,EmitPropertyMethod,The length of the statement  "	if (memberResult != null && (memberResult.Member.Attributes.Any (a => a.AttributeType.FullName == "Bridge.FieldPropertyAttribute" || a.AttributeType.FullName == "Bridge.ExternalAttribute") || (propertyDeclaration.Getter.IsNull && propertyDeclaration.Setter.IsNull))) { " is 268.
Long Statement,Bridge.Translator,VisitorMethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VisitorMethodBlock.cs,VisitMethodDeclaration,The length of the statement  "	this.EmitMethodParameters (methodDeclaration.Parameters' methodDeclaration.TypeParameters.Count > 0 && Helpers.IsIgnoreGeneric (methodDeclaration' this.Emitter) ? null : methodDeclaration.TypeParameters' methodDeclaration); " is 223.
Long Statement,Bridge.Translator,FieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\FieldBlock.cs,EmitFields,The length of the statement  "		var hasProperties = this.WriteObject (JS.Fields.EVENTS' info.Events' JS.Funcs.BRIDGE_EVENT + "(this' \"{0}\"' {1});"' JS.Funcs.BRIDGE_EVENT + "(this' {0}' {1});"); " is 163.
Long Statement,Bridge.Translator,FieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\FieldBlock.cs,EmitFields,The length of the statement  "		var hasProperties = this.WriteObject (JS.Fields.PROPERTIES' info.Properties' JS.Funcs.BRIDGE_PROPERTY + "(this' \"{0}\"' {1});"' JS.Funcs.BRIDGE_PROPERTY + "(this' {0}' {1});"); " is 177.
Long Statement,Bridge.Translator,LambdaBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\LambdaBlock.cs,DoEmit,The length of the statement  "				var expr = new ExpressionTreeBuilder (this.Emitter.Resolver.Compilation' this.Emitter' this.Context.GetParent<SyntaxTree> ()' this).BuildExpressionTree ((LambdaResolveResult)rr); " is 178.
Long Statement,Bridge.Translator,LambdaBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\LambdaBlock.cs,EmitLambda,The length of the statement  "		this.Emitter.Output.Insert (savedPos' JS.Vars.D_ + "." + BridgeTypes.ToJsName (this.Emitter.TypeInfo.Type' this.Emitter' true) + "." + name); " is 141.
Long Statement,Bridge.Translator,MethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MethodBlock.cs,EmitMethods,The length of the statement  "		var ctor = this.TypeInfo.Type.GetConstructors ().FirstOrDefault (c => c.Parameters.Count == 0 && this.Emitter.GetInline (c) != null); " is 133.
Long Statement,Bridge.Translator,MethodBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MethodBlock.cs,EmitStructMethods,The length of the statement  "		var mutableFields = this.TypeInfo.Type.GetFields (f => !f.IsReadOnly && !f.IsConst' GetMemberOptions.IgnoreInheritedMembers); " is 125.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,CheckGlobalClass,The length of the statement  "		throw new EmitterException (this.TypeInfo.TypeDeclaration' string.Format ("The type {0} must be static in order to be decorated with a [MixinAttribute] or [GlobalMethodsAttribute]"' this.TypeInfo.Type.FullName)); " is 212.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,CheckGlobalClass,The length of the statement  "		throw new EmitterException (this.TypeInfo.TypeDeclaration' string.Format ("[MixinAttribute] or [GlobalMethodsAttribute] cannot be applied to the generic type {0}."' this.TypeInfo.Type.FullName)); " is 195.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,CheckGlobalClass,The length of the statement  "		throw new EmitterException (this.TypeInfo.TypeDeclaration' string.Format ("The type {0} can contain only methods in order to be decorated with a [MixinAttribute] or [GlobalMethodsAttribute]"' this.TypeInfo.Type.FullName)); " is 222.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,EmitClassHeader,The length of the statement  "		if (this.TypeInfo.InstanceMethods.Any (m => m.Value.Any (subm => this.Emitter.GetEntityName (subm) == JS.Fields.INHERITS)) || this.TypeInfo.InstanceConfig.Fields.Any (m => m.GetName (this.Emitter) == JS.Fields.INHERITS)) { " is 222.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,WriteVariance,The length of the statement  "	if (itypeDef.Kind == TypeKind.Interface && MetadataUtils.IsJsGeneric (itypeDef' this.Emitter) && itypeDef.TypeParameters != null && itypeDef.TypeParameters.Any (typeParameter => typeParameter.Variance != VarianceModifier.Invariant)) { " is 234.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,WriteVariance,The length of the statement  "		this.WriteScript (itypeDef.TypeParameters.Select (typeParameter => ClassBlock.ConvertVarianceToInt (typeParameter.Variance)).ToArray ()); " is 137.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,EmitStaticBlock,The length of the statement  "		if (this.TypeInfo.InstanceMethods.Any (m => m.Value.Any (subm => this.Emitter.GetEntityName (subm) == JS.Fields.STATICS)) || this.TypeInfo.InstanceConfig.Fields.Any (m => m.GetName (this.Emitter) == JS.Fields.STATICS)) { " is 220.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,EmitInstantiableBlock,The length of the statement  "		if (this.Emitter.GetTypeDefinition (this.TypeInfo.Type).CustomAttributes.Any (attr => attr.AttributeType.FullName == "System.FlagsAttribute")) { " is 144.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,EmitInstantiableBlock,The length of the statement  "	if (this.TypeInfo.HasRealInstantiable (this.Emitter) || this.Emitter.Plugins.HasConstructorInjectors (ctorBlock) || this.TypeInfo.ClassType == ClassType.Struct) { " is 162.
Long Statement,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,GetAfterDefineMethods,The length of the statement  "	return this.GetDefineMethods ("After"' (method' rrMethod) => BridgeTypes.ToJsName (rrMethod.DeclaringTypeDefinition' this.Emitter) + "." + this.Emitter.GetEntityName (method) + "();"); " is 184.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The length of the statement  "	if (itype != null && castCode == null && method != CS.Ops.CAST && itype.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (itype.GetDefinition ())) { " is 166.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The length of the statement  "		throw new EmitterException (expression' "The type " + itype.FullName + " cannot be used in cast operation because there is no way to check its type"); " is 150.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The length of the statement  "		if (ConversionBlock.IsUserDefinedConversion (this' this.CastExpression.Expression) || ConversionBlock.IsUserDefinedConversion (this' this.CastExpression)) { " is 156.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The length of the statement  "	if (conversion.IsNumericConversion || conversion.IsEnumerationConversion || (isCast && conversion.IsIdentityConversion)) { " is 122.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The length of the statement  "	bool unbox = !(itype.IsReferenceType.HasValue ? itype.IsReferenceType.Value : true) && !NullableType.IsNullable (itype) && isCast && conversion.IsUnboxingConversion; " is 165.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,GetCastCode,The length of the statement  "	if (method == null && (NullableType.IsNullable (exprResolveResult.Type) || NullableType.IsNullable (resolveResult.Type))) { " is 123.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,GetCastCode,The length of the statement  "		method = this.GetCastMethod (NullableType.IsNullable (exprResolveResult.Type) ? NullableType.GetUnderlyingType (exprResolveResult.Type) : exprResolveResult.Type' NullableType.IsNullable (resolveResult.Type) ? NullableType.GetUnderlyingType (resolveResult.Type) : resolveResult.Type' out inline); " is 295.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitInlineCast,The length of the statement  "	bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult); " is 180.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitInlineCast,The length of the statement  "	if (!(expressionrr is ThisResolveResult || expressionrr is ConstantResolveResult || expressionrr is LocalResolveResult || isField) && isCastAttr) { " is 147.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitInlineCast,The length of the statement  "			castCode = string.Format ("({0} = {1}' Bridge.{2}({0}' {4}({0}) && ({3})))"' tempVar' expressionStr' method' castCode' JS.Funcs.BRIDGE_HASVALUE); " is 145.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitInlineCast,The length of the statement  "			castCode = string.Format ("Bridge.{1}({0}' {3}({0}) && ({2}))"' expressionStr' method' castCode' JS.Funcs.BRIDGE_HASVALUE); " is 123.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,GetCastMethod,The length of the statement  "		if (m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1 && m.ReturnType.ReflectionName == toType.ReflectionName && m.Parameters [0].Type.ReflectionName == fromType.ReflectionName) { " is 225.
Long Statement,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,GetCastMethod,The length of the statement  "			if (m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1 && m.ReturnType.ReflectionName == toType.ReflectionName && (m.Parameters [0].Type.ReflectionName == fromType.ReflectionName)) { " is 227.
Long Statement,Bridge.Translator,ExpressionListBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionListBlock.cs,EmitExpressionList,The length of the statement  "		if (resolveResult.Type.Kind == TypeKind.Array && !(paramArg is ArrayCreateExpression) && expressions.Last () == paramArg) { " is 123.
Long Statement,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,GetStringArgumentByKey,The length of the statement  "		return p1.IsParams ? this.ArgumentsInfo.StringArguments.Skip (i).ToList () : this.ArgumentsInfo.StringArguments.Skip (i).Take (1).ToList (); " is 140.
Long Statement,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The length of the statement  "		var withoutTypeParams = this.Method.TypeArguments.Count > 0 && this.Method.TypeArguments.All (t => t.Kind != TypeKind.TypeParameter); " is 133.
Long Statement,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The length of the statement  "		if (withoutTypeParams && (!this.Method.IsStatic || this.Method.IsExtensionMethod && this.TargetResolveResult is ThisResolveResult) && (this.TargetResolveResult is ThisResolveResult || this.TargetResolveResult == null) && (inline.Contains ("{this}") || this.Method.IsStatic || this.Method.IsExtensionMethod && inline.Contains ("{" + this.Method.Parameters.First ().Name + "}"))) { " is 379.
Long Statement,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The length of the statement  "		this.EmitMethodParameters (this.Method' this.Method.Parameters' withoutTypeParams ? null : this.Method.TypeParameters' isNull); " is 127.
Long Statement,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The length of the statement  "		expandParams = argsInfo.ResolveResult.Member.Attributes.Any (a => a.AttributeType.FullName == "Bridge.ExpandParamsAttribute"); " is 126.
Long Statement,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,NeedName,The length of the statement  "	return (def != null && def.IsSealed) || type.Kind == TypeKind.Enum || type.IsKnownType (KnownTypeCode.Enum) || Helpers.IsIntegerType (type' this.Emitter.Resolver) || Helpers.IsFloatType (type' this.Emitter.Resolver) || Helpers.IsKnownType (KnownTypeCode.Enum' type' this.Emitter.Resolver) || Helpers.IsKnownType (KnownTypeCode.Boolean' type' this.Emitter.Resolver) || Helpers.IsKnownType (KnownTypeCode.Type' type' this.Emitter.Resolver) || Helpers.IsKnownType (KnownTypeCode.Array' type' this.Emitter.Resolver) || Helpers.IsKnownType (KnownTypeCode.Char' type' this.Emitter.Resolver) || Helpers.IsKnownType (KnownTypeCode.DateTime' type' this.Emitter.Resolver) || Helpers.IsKnownType (KnownTypeCode.Delegate' type' this.Emitter.Resolver) || Helpers.IsKnownType (KnownTypeCode.String' type' this.Emitter.Resolver); " is 814.
Long Statement,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitMethodParameters,The length of the statement  "	else if (this.Method.IsExtensionMethod && !(this.TargetResolveResult is TypeResolveResult) && this.TargetResolveResult != null) { " is 129.
Long Statement,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,IsSimpleResolveResult,The length of the statement  "	bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult); " is 180.
Long Statement,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,CompareTypeInfosByName,The length of the statement  "		throw new TranslatorException ("Class with name '" + x.Key + "' is not found in the assembly' probably rebuild is required"); " is 125.
Long Statement,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,CompareTypeInfosByName,The length of the statement  "		throw new TranslatorException ("Class with name '" + y.Key + "' is not found in the assembly' probably rebuild is required"); " is 125.
Long Statement,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,IsInheritedFrom,The length of the statement  "	if (Helpers.IsSubclassOf (xTypeDefinition' yTypeDefinition' this) || (yTypeDefinition.IsInterface && Helpers.IsImplementationOf (xTypeDefinition' yTypeDefinition' this)) || Helpers.IsTypeArgInSubclass (xTypeDefinition' yTypeDefinition' this)) { " is 244.
Long Statement,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The length of the statement  "			this.LogWarning (string.Format ("Topological sort failed {0} with error {1}"' tInfo != null ? "at type " + tInfo.Type.ReflectionName : string.Empty' ex)); " is 154.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,TypesMatch,The length of the statement  "		if (!method.Parameters [i].Type.Equals (ReflectionHelper.ParseReflectionName (argumentTypes [i].FullName).Resolve (_compilation))) " is 130.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,CompileFactoryCall,The length of the statement  "	var method = _expression.Methods.Single (m => m.Name == factoryMethodName && m.TypeParameters.Count == 0 && TypesMatch (m' argumentTypes)); " is 139.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitOperatorResolveResult,The length of the statement  "	bool isUserDefined = rr.UserDefinedOperatorMethod != null && !this._emitter.Validator.IsIgnoreType (rr.UserDefinedOperatorMethod.DeclaringTypeDefinition); " is 154.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitOperatorResolveResult,The length of the statement  "	arguments [arguments.Length - 1] = isUserDefined ? this.GetMember (rr.UserDefinedOperatorMethod) : ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter); " is 158.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitConversionResolveResult,The length of the statement  "				this.GetMember (methodInfo.GetMethods ().Single (m => m.Name == "CreateDelegate" && m.Parameters.Count == 2 && m.Parameters [0].Type.FullName == typeof(Type).FullName && m.Parameters [1].Type.FullName == typeof(object).FullName))' " is 230.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitConversionResolveResult,The length of the statement  "					new JRaw (rr.Conversion.Method.IsStatic ? "null" : VisitResolveResult (((MethodGroupResolveResult)rr.Input).TargetResult' null)) " is 128.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitInvocationResolveResult,The length of the statement  "				if (assign == null || assign.OperatorType != ExpressionType.Assign || !(assign.Operands [0] is MemberResolveResult) || !(((MemberResolveResult)assign.Operands [0]).Member is IProperty)) " is 185.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitInvocationResolveResult,The length of the statement  "				if (rr.InitializerStatements [0] is InvocationResolveResult && ((InvocationResolveResult)rr.InitializerStatements [0]).TargetResult is InitializedObjectResolveResult) { " is 168.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,MakeConstant,The length of the statement  "	var value = rr.ConstantValue == null ? DefaultValueBlock.DefaultValue (rr' this._emitter) : AbstractEmitterBlock.ToJavaScript (rr.ConstantValue' this._emitter); " is 160.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitArrayCreateResolveResult,The length of the statement  "			this._emitter.ToJavaScript (rr.InitializerElements.Select (e => new JRaw (this.VisitResolveResult (e' null))).ToArray ()) " is 121.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,FindIndexInReflectableMembers,The length of the statement  "	foreach (var m in member.DeclaringTypeDefinition.Members.Where (m => MetadataUtils.IsReflectable (m' this._emitter' hasAttr' this._syntaxTree)).OrderBy (m => m' MemberOrderer.Instance)) { " is 187.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,GetMember,The length of the statement  "		string result = string.Format ("Bridge.getMetadata({0}).members[{1}]"' ExpressionTreeBuilder.GetTypeName (member.DeclaringType' this._emitter)' index); " is 151.
Long Statement,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,GetMember,The length of the statement  "		return MetadataUtils.ConstructMemberInfo (member' this._emitter' true' false' this._syntaxTree).ToString (Formatting.None); " is 123.
Long Statement,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,GetPluginPath,The length of the statement  "		path = Path.Combine (translator.FolderMode ? translator.Location : Path.GetDirectoryName (translator.Location)' config.PluginsPath); " is 132.
Long Statement,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,GetPluginPath,The length of the statement  "		path = Path.Combine (translator.FolderMode ? translator.Location : Path.GetDirectoryName (translator.Location)' "Bridge" + Path.DirectorySeparatorChar + "plugins"); " is 164.
Long Statement,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,GetPlugins,The length of the statement  "	logger.Trace ("Will search all translator references to find resource(s) with names starting from \"" + PLUGIN_RESOURCE_NAME_PREFIX + "\" ..."); " is 144.
Long Statement,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,GetPlugins,The length of the statement  "		if (skipPluginAssemblies != null && skipPluginAssemblies.FirstOrDefault (x => reference.Name.FullName.Contains (x)) != null) { " is 126.
Long Statement,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,LoadAssemblyFromResources,The length of the statement  "		logger.Warn ("Cannot try to load assembly " + assemblyName.FullName + " from resources as the source assembly is null"); " is 120.
Long Statement,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,LoadAssemblyFromResources,The length of the statement  "	logger.Trace ("Trying to resolve " + assemblyName.FullName + " in the resources of " + sourceAssembly.FullName + " ..."); " is 121.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,InjectResources,The length of the statement  "	if (resourcesConfig.Default != null && resourcesConfig.Default.Inject != true && !resourcesConfig.HasEmbedResources ()) { " is 121.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,EmbeddResources,The length of the statement  "	var listResources = new EmbeddedResource (resourceListName' ManifestResourceAttributes.Private' Translator.OutputEncoding.GetBytes (sb.ToString ())); " is 149.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,CheckInvalidCharacters,The length of the statement  "		var message = "There is invalid path character contained in resource.output setting = " + s + " for resource " + resource.Name; " is 127.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,ReadResourseFiles,The length of the statement  "				this.Log.Trace ("Cleaned folder path part: " + dirPathInFileName + " from location: " + fileName + " and added to the directory path: " + directoryPath); " is 153.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,ReadResourseFiles,The length of the statement  "				throw new InvalidOperationException ("Could not find any folder: " + directory.FullName + " for resource " + item.Name + " and location " + fileName); " is 150.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,ReadResourseFiles,The length of the statement  "				throw new InvalidOperationException ("Could not find any file in folder: " + directory.FullName + " for resource " + item.Name + " and location " + fileName); " is 158.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,PrepareResourcesConfig,The length of the statement  "			this.Log.Error ("There are more than one default resource in the configuration setting file (resources section). Will use the first occurrence as a default resource settings"); " is 176.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,ValidateResourceSettings,The length of the statement  "	var rawNonDefaultResourcesWithExtractAndNoOutput = rawNonDefaultResources.Where (x => x.Output == null && (x.Extract == true || defaultExtract)); " is 145.
Long Statement,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,ValidateResourceSettings,The length of the statement  "			this.Log.Error ("The resource config setting has a default output setting " + defaultSetting.Output + " containing file part " + defaultOutputFileName + " .However' there are several resources with no output setting defined and active extract option." + " It means the resources will be overwritten by each other."); " is 316.
Long Statement,Bridge.Translator,TranslatorProcessor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\TranslatorProcessor.cs,GetOutputFolder,The length of the statement  "	string basePath = bridgeOptions.IsFolderMode ? bridgeOptions.Folder : Path.GetDirectoryName (bridgeOptions.ProjectLocation); " is 124.
Long Statement,Bridge.Translator,TranslatorProcessor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\TranslatorProcessor.cs,GetOutputFolder,The length of the statement  "	string outputPath = string.IsNullOrWhiteSpace (assemblyOutput) ? Path.Combine (basePath' Path.GetDirectoryName (bridgeOptions.OutputLocation)) : Path.Combine (basePath' assemblyOutput); " is 185.
Long Statement,Bridge.Translator,TranslatorProcessor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\TranslatorProcessor.cs,SetLoggerConfigurationParameters,The length of the statement  "		logger.Info ("To enable further logging use configuration setting \"logging\" in bridge.json. See http://bridge.net/docs/global-configuration/#logging"); " is 153.
Long Statement,Bridge.Translator,TranslatorProcessor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\TranslatorProcessor.cs,SetTranslatorProperties,The length of the statement  "			translator = new Bridge.Translator.Translator (bridgeOptions.Folder' bridgeOptions.Source' bridgeOptions.Recursive' bridgeOptions.Lib); " is 135.
Long Statement,Bridge.Translator,TranslatorProcessor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\TranslatorProcessor.cs,SetTranslatorProperties,The length of the statement  "			bridgeOptions.BridgeLocation = Path.Combine (Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location)' "Bridge.dll"); " is 126.
Long Statement,Bridge.Translator,TranslatorProcessor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\TranslatorProcessor.cs,SetTranslatorProperties,The length of the statement  "			translator.DefineConstants.AddRange (bridgeOptions.DefinitionConstants.Split (';').Select (s => s.Trim ()).Where (s => s != "")); " is 129.
Long Statement,Bridge.Translator,TranslatorProcessor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\TranslatorProcessor.cs,SetTranslatorProperties,The length of the statement  "		translator.Log.Info ("\tDefineConstants:" + (translator.DefineConstants != null ? string.Join (" "' translator.DefineConstants) : "")); " is 135.
Long Statement,Bridge.Translator,DependencyFinderVisitor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\DependencyFinderVisitor.cs,CheckDependency,The length of the statement  "		if (typeInfo != null && typeInfo.TypeInfo != null && typeInfo.Type.FullName != this.Type.Type.FullName && this.Dependencies.All (d => d.Type.FullName != typeInfo.TypeInfo.Type.FullName)) { " is 188.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The length of the statement  "		var members = type.Members.Where (m => MetadataUtils.IsReflectable (m' emitter' ifHasAttribute' tree)).OrderBy (m => m' MemberOrderer.Instance).Select (m => MetadataUtils.ConstructMemberInfo (m' emitter' false' false' tree)).ToList (); " is 235.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructITypeMetadata,The length of the statement  "		var members = type.GetMembers (null' GetMemberOptions.IgnoreInheritedMembers).Where (m => MetadataUtils.IsReflectable (m' emitter' false' null)).OrderBy (m => m' MemberOrderer.Instance).Select (m => MetadataUtils.ConstructMemberInfo (m' emitter' false' false' null)).ToList (); " is 277.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,GetScriptableAttributes,The length of the statement  "		return typeDef != null && !MetadataUtils.IsConditionallyRemoved (a' emitter.Translator' tree) && !emitter.Validator.IsIgnoreType (typeDef) && !Helpers.IsNonScriptable (typeDef); " is 177.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructParameterInfo,The length of the statement  "			result.Add ("defaultValue"' typeParam.OwnerType == SymbolKind.Method ? new JRaw (emitter.ToJavaScript (p.ConstantValue)) : new JRaw (string.Format ("{0}({1})"' JS.Funcs.BRIDGE_GETDEFAULTVALUE' typeParam.Name))); " is 211.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "		return MetadataUtils.ConstructConstructorInfo ((IMethod)m' emitter' includeDeclaringType' isGenericSpecialization' tree); " is 121.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "	var properties = MetadataUtils.GetCommonMemberInfoProperties (m' emitter' includeDeclaringType' isGenericSpecialization' tree); " is 127.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "		if (string.IsNullOrEmpty (inline) && method.Attributes.Any (a => a.AttributeType.FullName == "Bridge.ExpandParamsAttribute")) { " is 127.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "		var parametersInfo = method.Parameters.Select (p => MetadataUtils.ConstructParameterInfo (p' emitter' false' false' tree)).ToList (); " is 133.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "		properties.Add ("returnType"' new JRaw (MetadataUtils.GetTypeName (method.ReturnType' emitter' isGenericSpecialization))); " is 122.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "			properties.Add ("params"' new JArray (method.Parameters.Select (p => new JRaw (MetadataUtils.GetTypeName (p.Type' emitter' isGenericSpecialization))))); " is 152.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "		properties.Add ("returnType"' new JRaw (MetadataUtils.GetTypeName (field.ReturnType' emitter' isGenericSpecialization))); " is 121.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "		properties.Add ("returnType"' new JRaw (MetadataUtils.GetTypeName (prop.ReturnType' emitter' isGenericSpecialization))); " is 120.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "			properties.Add ("params"' new JArray (prop.Parameters.Select (p => new JRaw (MetadataUtils.GetTypeName (p.Type' emitter' isGenericSpecialization))))); " is 150.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "				var parametersInfo = prop.Getter.Parameters.Select (p => MetadataUtils.ConstructParameterInfo (p' emitter' false' false' tree)).ToList (); " is 138.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "				var parametersInfo = prop.Setter.Parameters.Take (prop.Setter.Parameters.Count - 1).Select (p => MetadataUtils.ConstructParameterInfo (p' emitter' false' false' tree)).ToList (); " is 178.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "				properties.Add ("getter"' MetadataUtils.ConstructMemberInfo (prop.Getter' emitter' includeDeclaringType' isGenericSpecialization' tree)); " is 137.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "				properties.Add ("setter"' MetadataUtils.ConstructMemberInfo (prop.Setter' emitter' includeDeclaringType' isGenericSpecialization' tree)); " is 137.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "				properties.Add ("getter"' MetadataUtils.ConstructFieldPropertyAccessor (prop.Getter' emitter' fieldName' true' includeDeclaringType' isGenericSpecialization' tree)); " is 165.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "				properties.Add ("setter"' MetadataUtils.ConstructFieldPropertyAccessor (prop.Setter' emitter' fieldName' false' includeDeclaringType' isGenericSpecialization' tree)); " is 166.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "		properties.Add ("adder"' MetadataUtils.ConstructMemberInfo (evt.AddAccessor' emitter' includeDeclaringType' isGenericSpecialization' tree)); " is 140.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The length of the statement  "		properties.Add ("remover"' MetadataUtils.ConstructMemberInfo (evt.RemoveAccessor' emitter' includeDeclaringType' isGenericSpecialization' tree)); " is 145.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructFieldPropertyAccessor,The length of the statement  "	var properties = MetadataUtils.GetCommonMemberInfoProperties (m' emitter' includeDeclaringType' isGenericSpecialization' tree); " is 127.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructFieldPropertyAccessor,The length of the statement  "		properties.Add ("params"' new JArray (m.Parameters.Select (p => new JRaw (MetadataUtils.GetTypeName (p.Type' emitter' isGenericSpecialization))))); " is 147.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructConstructorInfo,The length of the statement  "	var properties = MetadataUtils.GetCommonMemberInfoProperties (constructor' emitter' includeDeclaringType' isGenericSpecialization' tree); " is 137.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructConstructorInfo,The length of the statement  "		properties.Add ("params"' new JArray (constructor.Parameters.Select (p => new JRaw (MetadataUtils.GetTypeName (p.Type' emitter' isGenericSpecialization))))); " is 157.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructConstructorInfo,The length of the statement  "	var parametersInfo = constructor.Parameters.Select (p => MetadataUtils.ConstructParameterInfo (p' emitter' false' false' tree)).ToList (); " is 138.
Long Statement,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructConstructorInfo,The length of the statement  "	if (string.IsNullOrEmpty (inline) && constructor.Attributes.Any (a => a.AttributeType.FullName == "Bridge.ExpandParamsAttribute")) { " is 132.
Long Statement,Bridge.Translator,PreconverterDetecter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "	if (unaryOperatorExpression.Operator == UnaryOperatorType.Increment || unaryOperatorExpression.Operator == UnaryOperatorType.PostIncrement || unaryOperatorExpression.Operator == UnaryOperatorType.Decrement || unaryOperatorExpression.Operator == UnaryOperatorType.PostDecrement) { " is 279.
Long Statement,Bridge.Translator,PreconverterDetecter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitAssignmentExpression,The length of the statement  "	if (assignmentExpression.Operator != AssignmentOperatorType.Any && assignmentExpression.Operator != AssignmentOperatorType.Assign) { " is 132.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,EmitUsing,The length of the statement  "		wrapper.Statements.Add (new VariableDeclarationStatement (varStat != null ? varStat.Type.Clone () : AstType.Null' varInit.Name' varInit.Initializer.Clone ())); " is 159.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,EmitUsing,The length of the statement  "		wrapper.Statements.Add (new VariableDeclarationStatement (varStat != null ? varStat.Type.Clone () : AstType.Null' name' expression.Clone () as Expression)); " is 156.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,EmitUsing,The length of the statement  "	var dispose = new InvocationExpression (new MemberReferenceExpression (new MemberReferenceExpression (new IdentifierExpression ("Bridge")' "Script")' "Write")' new PrimitiveExpression (string.Format ("if (" + JS.Funcs.BRIDGE_HASVALUE + "({0})) {0}.dispose();"' name))); " is 269.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitInvocationExpression,The length of the statement  "		InvocationExpression clonInvocationExpression = (InvocationExpression)base.VisitInvocationExpression (invocationExpression); " is 124.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "	if (unaryOperatorExpression.Operator == UnaryOperatorType.Increment || unaryOperatorExpression.Operator == UnaryOperatorType.PostIncrement || unaryOperatorExpression.Operator == UnaryOperatorType.Decrement || unaryOperatorExpression.Operator == UnaryOperatorType.PostDecrement) { " is 279.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "			UnaryOperatorExpression clonUnaryOperatorExpression = (UnaryOperatorExpression)base.VisitUnaryOperatorExpression (unaryOperatorExpression); " is 139.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "			bool isPost = clonUnaryOperatorExpression.Operator == UnaryOperatorType.PostDecrement || clonUnaryOperatorExpression.Operator == UnaryOperatorType.PostIncrement; " is 161.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "			var isIncr = clonUnaryOperatorExpression.Operator == UnaryOperatorType.Increment || clonUnaryOperatorExpression.Operator == UnaryOperatorType.PostIncrement; " is 156.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "			ae = new AssignmentExpression (clonUnaryOperatorExpression.Expression.Clone ()' new BinaryOperatorExpression (clonUnaryOperatorExpression.Expression.Clone ()' isIncr ? BinaryOperatorType.Add : BinaryOperatorType.Subtract' new PrimitiveExpression (1))); " is 252.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "				return new InvocationExpression (new MemberReferenceExpression (new MemberReferenceExpression (new IdentifierExpression ("Bridge")' "Script")' "Identity")' clonUnaryOperatorExpression.Expression.Clone ()' ae); " is 209.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "			UnaryOperatorExpression clonUnaryOperatorExpression = (UnaryOperatorExpression)base.VisitUnaryOperatorExpression (unaryOperatorExpression); " is 139.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "			bool isPost = clonUnaryOperatorExpression.Operator == UnaryOperatorType.PostDecrement || clonUnaryOperatorExpression.Operator == UnaryOperatorType.PostIncrement; " is 161.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "			var isIncr = clonUnaryOperatorExpression.Operator == UnaryOperatorType.Increment || clonUnaryOperatorExpression.Operator == UnaryOperatorType.PostIncrement; " is 156.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "				ae = new AssignmentExpression (clonUnaryOperatorExpression.Expression.Clone ()' new BinaryOperatorExpression (clonUnaryOperatorExpression.Expression.Clone ()' isIncr ? BinaryOperatorType.Add : BinaryOperatorType.Subtract' new PrimitiveExpression (1))); " is 252.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The length of the statement  "				return new InvocationExpression (new MemberReferenceExpression (new MemberReferenceExpression (new IdentifierExpression ("Bridge")' "Script")' "Identity")' clonUnaryOperatorExpression.Expression.Clone ()' ae); " is 209.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitAssignmentExpression,The length of the statement  "	if (assignmentExpression.Operator != AssignmentOperatorType.Any && assignmentExpression.Operator != AssignmentOperatorType.Assign && found) { " is 141.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitAssignmentExpression,The length of the statement  "		AssignmentExpression clonAssignmentExpression = (AssignmentExpression)base.VisitAssignmentExpression (assignmentExpression); " is 124.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitAssignmentExpression,The length of the statement  "		var wrapRightExpression = AssigmentExpressionHelper.CheckIsRightAssigmentExpression (clonAssignmentExpression) ? clonAssignmentExpression.Right.Clone () : new ParenthesizedExpression (clonAssignmentExpression.Right.Clone ()); " is 225.
Long Statement,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitAssignmentExpression,The length of the statement  "		clonAssignmentExpression.Right = new BinaryOperatorExpression (clonAssignmentExpression.Left.Clone ()' opType' wrapRightExpression); " is 132.
Long Statement,Bridge.Translator,EmptyLambdaDetecter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\EmptyLambdaFixer.cs,VisitIfElseStatement,The length of the statement  "	if (ifElseStatement.FalseStatement != null && !ifElseStatement.FalseStatement.IsNull && !(ifElseStatement.FalseStatement is BlockStatement || ifElseStatement.FalseStatement is IfElseStatement)) { " is 195.
Long Statement,Bridge.Translator,EmptyLambdaFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\EmptyLambdaFixer.cs,VisitIfElseStatement,The length of the statement  "	if (ifElseStatement.TrueStatement is BlockStatement && (!hasFalse || ifElseStatement.FalseStatement is BlockStatement || ifElseStatement.FalseStatement is IfElseStatement)) { " is 174.
Long Statement,Bridge.Translator,EmptyLambdaFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\EmptyLambdaFixer.cs,VisitIfElseStatement,The length of the statement  "	var noblock = !(ifElseStatement.TrueStatement is BlockStatement) || (hasFalse && !(ifElseStatement.FalseStatement is BlockStatement)); " is 134.
Long Statement,Bridge.Translator,CaptureAnalyzer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\CaptureAnalyzer.cs,VisitIdentifierExpression,The length of the statement  "		if (!_variables.Contains (localResolveResult.Variable.Name) && !_usedVariables.Contains (localResolveResult.Variable)) { " is 120.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,CreateCompilation,The length of the statement  "	var parseOptions = new CSharpParseOptions (LanguageVersion.CSharp6' Microsoft.CodeAnalysis.DocumentationMode.None' SourceCodeKind.Regular' translator.DefineConstants); " is 167.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,CreateCompilation,The length of the statement  "	var syntaxTrees = translator.SourceFiles.Select (s => ParseSourceFile (s' parseOptions)).Where (s => s != null).ToList (); " is 122.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,CreateCompilation,The length of the statement  "		references.Add (MetadataReference.CreateFromFile (r.MainModule.FullyQualifiedName' new MetadataReferenceProperties (MetadataImageKind.Assembly' ImmutableArray.Create ("global")))); " is 180.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitArgument,The length of the statement  "		if (pType.TypeKind == TypeKind.Delegate || parameter.IsParams && ((IArrayTypeSymbol)parameter.Type).ElementType.TypeKind == TypeKind.Delegate) { " is 144.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitArgument,The length of the statement  "			var name = SyntaxFactory.IdentifierName (pType.ToDisplayString (SymbolDisplayFormat.FullyQualifiedFormat)).WithoutTrivia (); " is 124.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitInvocationExpression,The length of the statement  "					ma = SyntaxFactory.MemberAccessExpression (SyntaxKind.SimpleMemberAccessExpression' SyntaxFactory.IdentifierName (clsName)' genericName); " is 137.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitInvocationExpression,The length of the statement  "					node = node.WithArgumentList (node.ArgumentList.WithArguments (node.ArgumentList.Arguments.Insert (0' SyntaxFactory.Argument (target)))); " is 137.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitInterpolatedStringExpression,The length of the statement  "	expressions.Insert (0' SyntaxFactory.LiteralExpression (SyntaxKind.StringLiteralExpression' SyntaxFactory.Literal (str))); " is 122.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitInterpolatedStringExpression,The length of the statement  "	var invocation = SyntaxFactory.InvocationExpression (methodIdentifier' SyntaxFactory.ArgumentList (SyntaxFactory.SeparatedList (expressions.Select (SyntaxFactory.Argument)))); " is 175.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The length of the statement  "	bool needHandle = !node.IsVar && symbol is ITypeSymbol && symbol.ContainingType != null && thisType != null && !thisType.InheritsFromOrEquals (symbol.ContainingType) && !thisType.Equals (symbol); " is 195.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The length of the statement  "		if (namedType != null && namedType.IsGenericType && namedType.TypeArguments.Length > 0 && !namedType.TypeArguments.Any (SyntaxHelper.IsAnonymous)) { " is 148.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The length of the statement  "			return SyntaxHelper.GenerateGenericName (SyntaxFactory.Identifier (node.GetLeadingTrivia ()' symbol.FullyQualifiedName (false)' node.GetTrailingTrivia ())' namedType.TypeArguments); " is 181.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The length of the statement  "		return SyntaxFactory.IdentifierName (SyntaxFactory.Identifier (node.GetLeadingTrivia ()' symbol.FullyQualifiedName ()' node.GetTrailingTrivia ())); " is 147.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The length of the statement  "	if (symbol != null && symbol.IsStatic && symbol.ContainingType != null && thisType != null && !thisType.InheritsFromOrEquals (symbol.ContainingType) && !(node.Parent is MemberAccessExpressionSyntax) && ((methodSymbol = symbol as IMethodSymbol) != null || symbol is IPropertySymbol || symbol is IFieldSymbol || symbol is IEventSymbol)) { " is 336.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The length of the statement  "		if (methodSymbol != null && methodSymbol.IsGenericMethod && methodSymbol.TypeArguments.Length > 0 && !methodSymbol.TypeArguments.Any (SyntaxHelper.IsAnonymous)) { " is 162.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The length of the statement  "			return SyntaxHelper.GenerateGenericName (SyntaxFactory.Identifier (node.GetLeadingTrivia ()' symbol.FullyQualifiedName (false)' node.GetTrailingTrivia ())' methodSymbol.TypeArguments); " is 184.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The length of the statement  "		return SyntaxFactory.IdentifierName (SyntaxFactory.Identifier (node.GetLeadingTrivia ()' symbol.FullyQualifiedName ()' node.GetTrailingTrivia ())); " is 147.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The length of the statement  "	bool needHandle = !node.IsVar && symbol is ITypeSymbol && symbol.ContainingType != null && thisType != null && !thisType.InheritsFromOrEquals (symbol.ContainingType) && !thisType.Equals (symbol); " is 195.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The length of the statement  "		if (namedType != null && namedType.IsGenericType && namedType.TypeArguments.Length > 0 && !namedType.TypeArguments.Any (SyntaxHelper.IsAnonymous)) { " is 148.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The length of the statement  "		return SyntaxFactory.IdentifierName (SyntaxFactory.Identifier (node.GetLeadingTrivia ()' symbol.FullyQualifiedName ()' node.GetTrailingTrivia ())); " is 147.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The length of the statement  "	if (symbol != null && symbol.IsStatic && symbol.ContainingType != null && thisType != null && !thisType.InheritsFromOrEquals (symbol.ContainingType) && !(node.Parent is MemberAccessExpressionSyntax) && ((methodSymbol = symbol as IMethodSymbol) != null || symbol is IPropertySymbol || symbol is IFieldSymbol || symbol is IEventSymbol)) { " is 336.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The length of the statement  "		if (methodSymbol != null && methodSymbol.IsGenericMethod && methodSymbol.TypeArguments.Length > 0 && !methodSymbol.TypeArguments.Any (SyntaxHelper.IsAnonymous)) { " is 162.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The length of the statement  "		return SyntaxFactory.IdentifierName (SyntaxFactory.Identifier (node.GetLeadingTrivia ()' symbol.FullyQualifiedName ()' node.GetTrailingTrivia ())); " is 147.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitMemberAccessExpression,The length of the statement  "	if (node.Expression is IdentifierNameSyntax && symbol != null && symbol.IsStatic && symbol.ContainingType != null && thisType != null && !thisType.InheritsFromOrEquals (symbol.ContainingType) && (symbol is IMethodSymbol || symbol is IPropertySymbol || symbol is IFieldSymbol || symbol is IEventSymbol)) { " is 304.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitMemberAccessExpression,The length of the statement  "		return SyntaxFactory.MemberAccessExpression (SyntaxKind.SimpleMemberAccessExpression' SyntaxFactory.IdentifierName (SyntaxFactory.Identifier (node.GetLeadingTrivia ()' symbol.FullyQualifiedName ()' node.GetTrailingTrivia ()))' node.OperatorToken' node.Name); " is 258.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitPropertyDeclaration,The length of the statement  "			setter = SyntaxFactory.AccessorDeclaration (SyntaxKind.SetAccessorDeclaration).WithModifiers (SyntaxTokenList.Create (SyntaxFactory.Token (SyntaxKind.PrivateKeyword).WithTrailingTrivia (SyntaxFactory.Space))).WithBody (null).WithSemicolonToken (SyntaxFactory.Token (SyntaxKind.SemicolonToken)).WithLeadingTrivia (getter.GetLeadingTrivia ()).WithTrailingTrivia (getter.GetTrailingTrivia ()); " is 390.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitPropertyDeclaration,The length of the statement  "			var modifiers = SyntaxTokenList.Create (SyntaxFactory.Token (SyntaxKind.PrivateKeyword).WithTrailingTrivia (SyntaxFactory.Space)); " is 130.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitPropertyDeclaration,The length of the statement  "			var field = SyntaxFactory.FieldDeclaration (SyntaxFactory.List<AttributeListSyntax> ()' modifiers' SyntaxFactory.VariableDeclaration (node.Type' SyntaxFactory.SeparatedList (new[] { " is 181.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitPropertyDeclaration,The length of the statement  "				SyntaxFactory.VariableDeclarator (SyntaxFactory.Identifier (AutoInitFieldPrefix + node.Identifier.Text)' null' newNode.Initializer) " is 131.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,NeedRewriteInitializer,The length of the statement  "			if (NeedRewriteInitializer ((InitializerExpressionSyntax)ae.Right' info.nested' ref extensionMethodExists' ref isImplicitElementAccessSyntax)) { " is 144.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitObjectCreationExpression,The length of the statement  "		needRewrite = NeedRewriteInitializer (node.Initializer' initializerInfos' ref extensionMethodExists' ref isImplicitElementAccessSyntax); " is 136.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitObjectCreationExpression,The length of the statement  "				throw new Exception (string.Format (CultureInfo.InvariantCulture' "{2} - {3}({0}'{1}): {4}"' mapped.StartLinePosition.Line + 1' mapped.StartLinePosition.Character + 1' "Index collection initializer is not supported inside Expression<T>"' this.semanticModel.SyntaxTree.FilePath' node.ToString ())); " is 297.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitObjectCreationExpression,The length of the statement  "				throw new Exception (string.Format (CultureInfo.InvariantCulture' "{2} - {3}({0}'{1}): {4}"' mapped.StartLinePosition.Line + 1' mapped.StartLinePosition.Character + 1' "Extension method for collection initializer is not supported inside Expression<T>"' this.semanticModel.SyntaxTree.FilePath' node.ToString ())); " is 312.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitObjectCreationExpression,The length of the statement  "		statements.Add (SyntaxFactory.ReturnStatement (SyntaxFactory.IdentifierName (instance).WithLeadingTrivia (SyntaxFactory.Space))); " is 129.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitObjectCreationExpression,The length of the statement  "		var lambda = SyntaxFactory.ParenthesizedLambdaExpression (SyntaxFactory.ParameterList (SyntaxFactory.SeparatedList (new[] { " is 123.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitObjectCreationExpression,The length of the statement  "		var invocation = SyntaxFactory.InvocationExpression (methodIdentifier' SyntaxFactory.ArgumentList (SyntaxFactory.SeparatedList (args.Select (SyntaxFactory.Argument)))); " is 168.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,ConvertInitializers,The length of the statement  "					name = SyntaxFactory.ElementAccessExpression (SyntaxFactory.IdentifierName (instance)' ((ImplicitElementAccessSyntax)be.Left).ArgumentList.WithoutTrivia ()).ToString (); " is 169.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,ConvertInitializers,The length of the statement  "				SharpSixRewriter.ConvertInitializers (((InitializerExpressionSyntax)be.Right).Expressions' name' statements' info.nested); " is 122.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,ConvertInitializers,The length of the statement  "					be = be.WithLeft (SyntaxFactory.ElementAccessExpression (SyntaxFactory.IdentifierName (instance)' indexerKeys.ArgumentList.WithoutTrivia ())); " is 142.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,ConvertInitializers,The length of the statement  "					be = be.WithLeft (SyntaxFactory.MemberAccessExpression (SyntaxKind.SimpleMemberAccessExpression' SyntaxFactory.IdentifierName (instance)' SyntaxFactory.IdentifierName (identifier.Identifier.ValueText))); " is 203.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitTryStatement,The length of the statement  "			var ifStatement = SyntaxFactory.IfStatement (filter.FilterExpression' catchItem.Block.WithoutTrivia ()' SyntaxFactory.ElseClause (SyntaxFactory.ThrowStatement ().WithLeadingTrivia (SyntaxFactory.Space))); " is 204.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "			var arg = parentTarget != null ? SyntaxFactory.ParseExpression (parentTarget.ToString () + info.Node.Expression.WithoutTrivia ().ToString ()) : info.Node.Expression.WithoutTrivia (); " is 182.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "			leftForCondition = SyntaxFactory.InvocationExpression (methodIdentifier' SyntaxFactory.ArgumentList (SyntaxFactory.SeparatedList (new[] { " is 137.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "			var parentMethodIdentifier = SyntaxFactory.GenericName (SyntaxFactory.Identifier ("Bridge.Script.FromTemp")' SyntaxFactory.TypeArgumentList (SyntaxFactory.SeparatedList (new[] { " is 177.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "			var invocation = SyntaxFactory.InvocationExpression (parentMethodIdentifier' SyntaxFactory.ArgumentList (SyntaxFactory.SeparatedList (new[] { " is 141.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "			leftForCondition = parentTarget != null ? SyntaxFactory.ParseExpression (parentTarget.ToString () + info.Node.Expression.WithoutTrivia ().ToString ()) : info.Node.Expression.WithoutTrivia (); " is 191.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "		conditions.Add (SyntaxFactory.BinaryExpression (SyntaxKind.NotEqualsExpression' leftForCondition' SyntaxFactory.LiteralExpression (SyntaxKind.NullLiteralExpression))); " is 167.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "	ExpressionSyntax whenTrue = SyntaxFactory.ParseExpression (parentTarget.ToString () + lastInfo.Node.WhenNotNull.WithoutTrivia ().ToString ()); " is 142.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "		var invocation = SyntaxFactory.InvocationExpression (methodIdentifier' SyntaxFactory.ArgumentList (SyntaxFactory.SeparatedList (new[] { " is 135.
Long Statement,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitConditionalAccessExpression,The length of the statement  "	ExpressionSyntax whenFalse = lastInfo.IsResultVoid ? (ExpressionSyntax)SyntaxFactory.LiteralExpression (SyntaxKind.NullLiteralExpression) : SyntaxFactory.CastExpression (lastInfo.ResultType' SyntaxFactory.LiteralExpression (SyntaxKind.NullLiteralExpression)); " is 259.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateStaticMethodCall,The length of the statement  "	return SyntaxFactory.ExpressionStatement (SyntaxFactory.InvocationExpression (methodIdentifier' SyntaxFactory.ArgumentList (SyntaxFactory.SeparatedList (arguments ?? new ArgumentSyntax[] { " is 188.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateMethodCall,The length of the statement  "	return SyntaxFactory.ExpressionStatement (SyntaxFactory.InvocationExpression (methodIdentifier' SyntaxFactory.ArgumentList (SyntaxFactory.SeparatedList (arguments ?? new ArgumentSyntax[] { " is 188.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateMethodIdentifier,The length of the statement  "		methodIdentifier = SyntaxFactory.GenericName (SyntaxFactory.Identifier (targetIdentifierOrTypeName + "." + methodName)' SyntaxFactory.TypeArgumentList (SyntaxFactory.SeparatedList (typeArguments.Select (GenerateTypeSyntax)))); " is 226.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateVariableDeclarationAndObjectCreationStatement,The length of the statement  "	return GenerateVariableDeclarationAndObjectCreationStatement (variableName' () => SyntaxFactory.ParseTypeName (typeName)); " is 122.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateVariableDeclarationAndObjectCreationStatement,The length of the statement  "	return SyntaxFactory.LocalDeclarationStatement (SyntaxFactory.VariableDeclaration (typeSyntaxFactory ()' SyntaxFactory.SeparatedList (new[] { " is 141.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateVariableDeclarationAndObjectCreationStatement,The length of the statement  "		SyntaxFactory.VariableDeclarator (SyntaxFactory.Identifier (variableName)' null' SyntaxFactory.EqualsValueClause (SyntaxFactory.ObjectCreationExpression (typeSyntaxFactory ()' SyntaxFactory.ArgumentList ()' null))) " is 214.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateExtensionMethod,The length of the statement  "	var methodDeclaration = SyntaxFactory.MethodDeclaration (SyntaxFactory.ParseTypeName (returnTypeName ?? "void")' methodName).WithModifiers (SyntaxTokenList.Create (SyntaxFactory.Token (SyntaxKind.PublicKeyword)).Add (SyntaxFactory.Token (SyntaxKind.StaticKeyword))).WithParameterList (SyntaxFactory.ParameterList (SyntaxFactory.SeparatedList<ParameterSyntax> (parameters))); " is 374.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateMethodParameter,The length of the statement  "	return SyntaxFactory.Parameter (SyntaxFactory.List<AttributeListSyntax> ()' isExtensionMethodFirstParameter ? SyntaxFactory.TokenList (SyntaxFactory.Token (SyntaxKind.ThisKeyword)) : SyntaxFactory.TokenList ()' SyntaxFactory.ParseTypeName (typeName)' SyntaxFactory.Identifier (parameterName)' null); " is 299.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateClass,The length of the statement  "	var classDeclaration = SyntaxFactory.ClassDeclaration (className).WithModifiers (list).WithMembers (SyntaxFactory.List (methods)); " is 130.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateNamespace,The length of the statement  "	return SyntaxFactory.NamespaceDeclaration (SyntaxFactory.ParseName (namespaceName)).WithUsings (SyntaxFactory.List<UsingDirectiveSyntax> (builtinUsings.Distinct ().Where (u => namespaceName != u).Select (u => SyntaxFactory.UsingDirective (SyntaxFactory.ParseName (u))).ToArray ())).WithMembers (SyntaxFactory.List<MemberDeclarationSyntax> (members)); " is 350.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateGenericName,The length of the statement  "	return SyntaxFactory.GenericName (SyntaxFactory.Identifier (name)' SyntaxFactory.TypeArgumentList (SyntaxFactory.SeparatedList (types.Select (GenerateTypeSyntax)))); " is 165.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateGenericName,The length of the statement  "	return SyntaxFactory.GenericName (name' SyntaxFactory.TypeArgumentList (SyntaxFactory.SeparatedList (types.Select (GenerateTypeSyntax)))); " is 138.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateAssignmentStatement,The length of the statement  "	return SyntaxFactory.ExpressionStatement (SyntaxFactory.BinaryExpression (SyntaxKind.SimpleAssignmentExpression' leftSide' rightSide)); " is 135.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GenerateAttribute,The length of the statement  "	return SyntaxFactory.Attribute (SyntaxFactory.ParseName (type.FullName)' SyntaxFactory.AttributeArgumentList (SyntaxFactory.SeparatedList (parameters.Select (SyntaxFactory.AttributeArgument)))); " is 194.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,IsAutoProperty,The length of the statement  "	if (propertyDeclaration.Modifiers.Any (m => m.Kind () == SyntaxKind.AbstractKeyword || m.Kind () == SyntaxKind.ExternKeyword)) { " is 128.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,IsAutoProperty,The length of the statement  "	var getter = propertyDeclaration.AccessorList.Accessors.SingleOrDefault (a => a.Keyword.Kind () == SyntaxKind.GetKeyword); " is 122.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,IsAutoProperty,The length of the statement  "	var setter = propertyDeclaration.AccessorList.Accessors.SingleOrDefault (a => a.Keyword.Kind () == SyntaxKind.SetKeyword); " is 122.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,RemoveSemicolon,The length of the statement  "		bool addNewline = semicolonToken.HasTrailingTrivia && trailingTrivia.Count () == 1 && trailingTrivia.First ().Kind () == SyntaxKind.EndOfLineTrivia; " is 148.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,ToStatementBody,The length of the statement  "	var accessor = SyntaxFactory.AccessorDeclaration (SyntaxKind.GetAccessorDeclaration).WithBody (SyntaxFactory.Block (SyntaxFactory.ReturnStatement (property.ExpressionBody.Expression.WithLeadingTrivia (SyntaxFactory.Space)))); " is 225.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,ToStatementBody,The length of the statement  "	return property.WithAccessorList (SyntaxFactory.AccessorList (accessorDeclList)).WithExpressionBody (null).WithSemicolonToken (SyntaxFactory.MissingToken (SyntaxKind.SemicolonToken)).WithTrailingTrivia (property.GetTrailingTrivia ()); " is 234.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,ToStatementBody,The length of the statement  "	return method.WithBody (SyntaxFactory.Block (isVoid ? SyntaxFactory.ExpressionStatement (body) : (StatementSyntax)SyntaxFactory.ReturnStatement (body))).WithExpressionBody (null).WithSemicolonToken (SyntaxFactory.MissingToken (SyntaxKind.SemicolonToken)).WithTrailingTrivia (method.GetTrailingTrivia ()); " is 304.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,ToStatementBody,The length of the statement  "	return method.WithBody (SyntaxFactory.Block (isVoid ? SyntaxFactory.ExpressionStatement (body) : (StatementSyntax)SyntaxFactory.ReturnStatement (body))).WithExpressionBody (null).WithSemicolonToken (SyntaxFactory.MissingToken (SyntaxKind.SemicolonToken)).WithTrailingTrivia (method.GetTrailingTrivia ()); " is 304.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,ToStatementBody,The length of the statement  "	return method.WithBody (SyntaxFactory.Block ((StatementSyntax)SyntaxFactory.ReturnStatement (body))).WithExpressionBody (null).WithSemicolonToken (SyntaxFactory.MissingToken (SyntaxKind.SemicolonToken)).WithTrailingTrivia (method.GetTrailingTrivia ()); " is 252.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,ToStatementBody,The length of the statement  "	var accessor = SyntaxFactory.AccessorDeclaration (SyntaxKind.GetAccessorDeclaration).WithBody (SyntaxFactory.Block (SyntaxFactory.ReturnStatement (property.ExpressionBody.Expression.WithLeadingTrivia (SyntaxFactory.Space)))); " is 225.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,ToStatementBody,The length of the statement  "	return property.WithAccessorList (SyntaxFactory.AccessorList (accessorDeclList)).WithExpressionBody (null).WithSemicolonToken (SyntaxFactory.MissingToken (SyntaxKind.SemicolonToken)).WithTrailingTrivia (property.GetTrailingTrivia ()); " is 234.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The length of the statement  "				if (attr.AttributeClass != null && attr.AttributeClass.FullyQualifiedName () == enumAttr && attr.ConstructorArguments.Any ()) { " is 127.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The length of the statement  "		var nameAttr = SyntaxHelper.GetInheritedAttribute (symbol' Bridge.Translator.Translator.Bridge_ASSEMBLY + ".NameAttribute"); " is 124.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,IsIgnoreType,The length of the statement  "	return SyntaxHelper.HasAttribute (symbol.GetAttributes ()' externalAttr) || SyntaxHelper.HasAttribute (symbol.GetAttributes ()' objectLiteralAttr); " is 147.
Long Statement,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,IsExpressionOfT,The length of the statement  "	return type is INamedTypeSymbol && type.OriginalDefinition.MetadataName == typeof(System.Linq.Expressions.Expression<>).Name && type.ContainingNamespace.FullyQualifiedName () == typeof(System.Linq.Expressions.Expression<>).Namespace; " is 233.
Long Statement,Bridge.Translator,MemberResolver,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MemberResolver.cs,ResolveNode,The length of the statement  "			var or = methodGroupResolveResult.PerformOverloadResolution (this.compilation' parentInvocation.GetArgumentsForCall ().ToArray ()); " is 131.
Long Statement,Bridge.Translator,MemberResolver,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MemberResolver.cs,ResolveNode,The length of the statement  "			MemberResolveResult memberResolveResult = new MemberResolveResult (new TypeResolveResult (method.DeclaringType)' method); " is 121.
Long Statement,Bridge.Translator,MemberResolver,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MemberResolver.cs,ResolveNode,The length of the statement  "		if (result is CSharpInvocationResolveResult && ((CSharpInvocationResolveResult)result).OverloadResolutionErrors != OverloadResolutionErrors.None) { " is 147.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitTypeDeclaration,The length of the statement  "	if ((ignored || this.HasIgnore (typeDeclaration) || this.IsNonScriptable (typeDeclaration)) && !this.IsObjectLiteral (typeDeclaration)) { " is 137.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitTypeDeclaration,The length of the statement  "		if (parentTypeInfo != null && JS.Reserved.StaticNames.Any (n => String.Equals (this.CurrentType.Name' n' StringComparison.InvariantCultureIgnoreCase))) { " is 153.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitTypeDeclaration,The length of the statement  "			throw new EmitterException (typeDeclaration' "Nested class cannot have such name: " + this.CurrentType.Name + ". Please rename it."); " is 133.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,AddMissingAliases,The length of the statement  "							baseMembers = baseType.GetAccessors (m => m.Name == interfaceMember.Name && !m.IsExplicitInterfaceImplementation' GetMemberOptions.IgnoreInheritedMembers); " is 155.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,AddMissingAliases,The length of the statement  "							baseMembers = baseType.GetMembers (m => m.Name == interfaceMember.Name && !m.IsExplicitInterfaceImplementation' GetMemberOptions.IgnoreInheritedMembers); " is 153.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitFieldDeclaration,The length of the statement  "	bool isStatic = this.CurrentType.ClassType == ClassType.Enum || fieldDeclaration.HasModifier (Modifiers.Static) || fieldDeclaration.HasModifier (Modifiers.Const); " is 162.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitFieldDeclaration,The length of the statement  "		if (fieldDeclaration.HasModifier (Modifiers.Const) && rr != null && rr.Member.Attributes.Any (a => a.AttributeType.FullName == Bridge.Translator.Translator.Bridge_ASSEMBLY + ".InlineConstAttribute")) { " is 201.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitCustomEventDeclaration,The length of the statement  "	IDictionary<string' List<EntityDeclaration>> dict = isStatic ? CurrentType.StaticProperties : CurrentType.InstanceProperties; " is 125.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitPropertyDeclaration,The length of the statement  "	IDictionary<string' List<EntityDeclaration>> dict = isStatic ? CurrentType.StaticProperties : CurrentType.InstanceProperties; " is 125.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitPropertyDeclaration,The length of the statement  "	if (!propertyDeclaration.Getter.IsNull && !this.HasIgnore (propertyDeclaration) && !this.HasInline (propertyDeclaration.Getter) && propertyDeclaration.Getter.Body.IsNull && !this.HasScript (propertyDeclaration.Getter)) { " is 220.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitPropertyDeclaration,The length of the statement  "			if (resolvedProperty != null && resolvedProperty.Member.ImplementedInterfaceMembers.Count > 0 && resolvedProperty.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.AssemblyInfo))) { " is 209.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitPropertyDeclaration,The length of the statement  "				throw new EmitterException (propertyDeclaration' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' resolvedProperty.Member.ToString ())); " is 205.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitPropertyDeclaration,The length of the statement  "			if (resolvedProperty != null && resolvedProperty.Member.ImplementedInterfaceMembers.Count > 0 && !resolvedProperty.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.AssemblyInfo))) { " is 210.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitPropertyDeclaration,The length of the statement  "				throw new EmitterException (propertyDeclaration' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' resolvedProperty.Member.ToString ())); " is 204.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,CheckFieldProperty,The length of the statement  "	var possiblyWrongGetter = !propertyDeclaration.Getter.IsNull && !propertyDeclaration.Getter.Body.IsNull && !this.HasInline (propertyDeclaration.Getter) && !this.HasScript (propertyDeclaration.Getter); " is 200.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,CheckFieldProperty,The length of the statement  "	var possiblyWrongSetter = !propertyDeclaration.Setter.IsNull && !propertyDeclaration.Setter.Body.IsNull && !this.HasInline (propertyDeclaration.Setter) && !this.HasScript (propertyDeclaration.Setter); " is 200.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,CheckFieldProperty,The length of the statement  "				var message = string.Format ("{0} is marked with [FieldProperty] attribute but implements {1}{2}. To fix the problem either remove [FieldProperty] (swith off bridge.json option `autoPropertyToField`) or add [External]/[Template] attributes"' resolvedProperty.Member.ToString ()' possiblyWrongGetter ? "getter" : string.Empty' possiblyWrongSetter ? (possiblyWrongGetter ? " and " : string.Empty) + "setter" : string.Empty); " is 422.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The length of the statement  "			else if (member != null && member.Member.DeclaringTypeDefinition.EnumUnderlyingType.IsKnownType (KnownTypeCode.UInt64)) { " is 121.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The length of the statement  "				else if (member != null && member.Member.DeclaringTypeDefinition.EnumUnderlyingType.IsKnownType (KnownTypeCode.UInt64)) { " is 121.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadReflectionInfo,The length of the statement  "	if (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == Translator.Bridge_ASSEMBLY + ".ReflectableAttribute") { " is 145.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadModuleInfo,The length of the statement  "	if ((name == (Translator.Bridge_ASSEMBLY + ".Module")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".ModuleAttribute"))) { " is 198.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadFileNameInfo,The length of the statement  "	if ((name == (Translator.Bridge_ASSEMBLY + ".FileName")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".FileNameAttribute"))) { " is 202.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadOutputPathInfo,The length of the statement  "	if ((name == (Translator.Bridge_ASSEMBLY + ".Output")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".OutputPathAttribute"))) { " is 202.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadFileHierarchyInfo,The length of the statement  "	if ((name == (Translator.Bridge_ASSEMBLY + ".FilesHierarchy")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".FilesHierarchyAttribute"))) { " is 214.
Long Statement,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadModuleDependency,The length of the statement  "	if ((name == (Translator.Bridge_ASSEMBLY + ".ModuleDependency")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".ModuleDependencyAttribute"))) { " is 218.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,The length of the statement  "			if (objectCreateMode == 1 && baseType != null && baseType.FullName != "System.Object" && this.GetObjectCreateMode (baseType) == 0) { " is 132.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,The length of the statement  "				TranslatorException.Throw ("[ObjectLiteral] with Constructor mode should be inherited from class with same options: {0}"' type); " is 128.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,The length of the statement  "				TranslatorException.Throw ("[ObjectLiteral] with Plain mode cannot be inherited from [ObjectLiteral] with Constructor mode: {0}"' type); " is 136.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,The length of the statement  "					TranslatorException.Throw ("[ObjectLiteral] should implement an interface which must be object literal also: {0}"' type); " is 121.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,IsIgnoreType,The length of the statement  "	return this.HasAttribute (type.CustomAttributes' externalAttr) || this.HasAttribute (type.CustomAttributes' nonScriptableAttr); " is 127.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,IsIgnoreType,The length of the statement  "	return typeDefinition.Attributes.Any (attr => attr.Constructor != null && attr.Constructor.DeclaringType.FullName == externalAttr); " is 131.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,IsExternalInterface,The length of the statement  "	var attr = typeDefinition.Attributes.FirstOrDefault (a => a.Constructor != null && (a.Constructor.DeclaringType.FullName == externalAttr)); " is 139.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,EnumEmitMode,The length of the statement  "		if (attr.Constructor != null && attr.Constructor.DeclaringType.FullName == enumAttr && attr.PositionalArguments.Count > 0) { " is 124.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,EnumEmitMode,The length of the statement  "		if (attr.Constructor != null && attr.Constructor.DeclaringType.FullName == enumAttr && attr.PositionalArguments.Count > 0) { " is 124.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,GetAttribute,The length of the statement  "	ICSharpCode.NRefactory.TypeSystem.IAttribute a = attributes.FirstOrDefault (attr => attr.AttributeType.FullName == name); " is 121.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,GetObjectInitializationMode,The length of the statement  "	var attr = type.CustomAttributes.FirstOrDefault (a => a.AttributeType.FullName == Translator.Bridge_ASSEMBLY + ".ObjectLiteralAttribute"); " is 138.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,GetObjectCreateMode,The length of the statement  "	var attr = type.CustomAttributes.FirstOrDefault (a => a.AttributeType.FullName == Translator.Bridge_ASSEMBLY + ".ObjectLiteralAttribute"); " is 138.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,GetCustomTypeName,The length of the statement  "		name = (string.IsNullOrEmpty (name) ? "" : (name + ".")) + BridgeTypes.ConvertName (changeCase ? type.Name.ToLowerCamelCase () : type.Name); " is 140.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,GetCustomTypeName,The length of the statement  "		var ignore = mode == 0 && !type.Methods.Any (m => !m.IsConstructor && !m.IsGetter && !m.IsSetter && !m.IsRemoveOn && !m.IsAddOn); " is 129.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,GetCustomConstructor,The length of the statement  "	if (this.HasAttribute (type.CustomAttributes' Translator.Bridge_ASSEMBLY + ".ObjectLiteralAttribute") && this.GetObjectCreateMode (type) == 0) { " is 144.
Long Statement,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckMethods,The length of the statement  "		if (method.HasCustomAttributes && method.CustomAttributes.Any (a => a.AttributeType.FullName == "System.Runtime.CompilerServices.CompilerGeneratedAttribute")) { " is 160.
Long Statement,Bridge.Translator,TypeInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\TypeInfo.cs,HasRealStatic,The length of the statement  "	var result = this.ClassType == ClassType.Struct || this.StaticConfig.HasMembers || this.StaticProperties.Count > 0 || this.StaticCtor != null || this.Operators.Count > 0; " is 170.
Long Statement,Bridge.Translator.TypeScript,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\ClassBlock.cs,EmitBlock,The length of the statement  "	if (this.Emitter.TypeInfo.TypeDeclaration.ClassType != ICSharpCode.NRefactory.CSharp.ClassType.Interface || this.IsGeneric) { " is 125.
Long Statement,Bridge.Translator.TypeScript,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\EmitBlock.cs,DoEmit,The length of the statement  "	Array.Sort (types' (t1' t2) => BridgeTypes.GetNamespaceFilename (t1' this.Emitter).Item1.CompareTo (BridgeTypes.GetNamespaceFilename (t2' this.Emitter).Item1)); " is 160.
Long Statement,Bridge.Translator.TypeScript,MemberBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\MemberBlock.cs,EmitFields,The length of the statement  "				string typeName = this.TypeInfo.IsEnum ? "number" : BridgeTypes.ToTypeScriptName (field.Entity.ReturnType' this.Emitter); " is 121.
Long Statement,Bridge.Translator.TypeScript,PropertyBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\PropertyBlock.cs,DoEmit,The length of the statement  "	if (this.PropertyDeclaration.Getter.Body.IsNull && this.PropertyDeclaration.Setter.Body.IsNull && this.Emitter.TypeInfo.TypeDeclaration.ClassType != ClassType.Interface) { " is 171.
Long Statement,Bridge.Translator.TypeScript,PropertyBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\PropertyBlock.cs,EmitPropertyMethod,The length of the statement  "	if (memberResult != null && (memberResult.Member.Attributes.Any (a => a.AttributeType.FullName == "Bridge.FieldPropertyAttribute") || (propertyDeclaration.Getter.IsNull && propertyDeclaration.Setter.IsNull))) { " is 210.
Long Statement,Bridge.Translator.Logging,FileLoggerWriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Logging\FileLoggerWriter.cs,Flush,The length of the statement  "			using (Stream stream = file.Open (FileMode.Append' FileAccess.Write' FileShare.Write | FileShare.ReadWrite | FileShare.Delete)) { " is 129.
Long Statement,Bridge.Translator.Utils,AssigmentExpressionHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\AssigmentExpressionHelper.cs,CheckIsRightAssigmentExpression,The length of the statement  "	return (expression.Right is ParenthesizedExpression || expression.Right is IdentifierExpression || expression.Right is MemberReferenceExpression || expression.Right is PrimitiveExpression || expression.Right is IndexerExpression || expression.Right is LambdaExpression || expression.Right is AnonymousMethodExpression || expression.Right is ObjectCreateExpression); " is 365.
Complex Conditional,Bridge.Translator,ArgumentsInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ArgumentsInfo.cs,BuildArgumentsList,The conditional expression  "resolvedMethod != null && invocationResult != null && resolvedMethod.IsExtensionMethod && invocationResult.IsExtensionMethodInvocation"  is complex.
Complex Conditional,Bridge.Translator,AbstractEmitterBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AbstractEmitterBlock.Locals.cs,AddLocals,The conditional expression  "item.Parent == null && item.Name == "value" && visitor.DirectionExpression.Any (expr => expr is IdentifierExpression && ((IdentifierExpression)expr).Identifier == "value")"  is complex.
Complex Conditional,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The conditional expression  "assignmentExpression.Operator == AssignmentOperatorType.Divide && !(this.Emitter.IsJavaScriptOverflowMode && !ConversionBlock.InsideOverflowContext (this.Emitter' assignmentExpression)) && !isLong && !isLongExpected && ((Helpers.IsIntegerType (leftResolverResult.Type' this.Emitter.Resolver) && Helpers.IsIntegerType (rightResolverResult.Type' this.Emitter.Resolver)) || (Helpers.IsIntegerType (this.Emitter.Resolver.Resolver.GetExpectedType (assignmentExpression.Left)' this.Emitter.Resolver) && Helpers.IsIntegerType (this.Emitter.Resolver.Resolver.GetExpectedType (assignmentExpression.Right)' this.Emitter.Resolver)))"  is complex.
Complex Conditional,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The conditional expression  "special || (isDecimal && isDecimalExpected) || (isLong && isLongExpected) || isUserOperator"  is complex.
Complex Conditional,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The conditional expression  "!special && isBool && (assignmentExpression.Operator == AssignmentOperatorType.BitwiseAnd || assignmentExpression.Operator == AssignmentOperatorType.BitwiseOr)"  is complex.
Complex Conditional,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,VisitAssignmentExpression,The conditional expression  "!special && isBool && (assignmentExpression.Operator == AssignmentOperatorType.BitwiseAnd || assignmentExpression.Operator == AssignmentOperatorType.BitwiseOr)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "!(current != null && current.InlineAttr != null) && !(!(isIgnore || (current != null && current.IgnoreAccessor)) || isAccessorsIndexer)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "!(expression.Parent is ArrayInitializerExpression) && Helpers.Is64Type (fromType' block.Emitter.Resolver) && Helpers.IsFloatType (toType' block.Emitter.Resolver) && !Helpers.IsDecimalType (toType' block.Emitter.Resolver)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "conversion.IsNumericConversion && conversion.IsImplicit && !(expression.Parent is ArrayInitializerExpression) && Helpers.Is64Type (fromType' block.Emitter.Resolver) && Helpers.IsFloatType (toType' block.Emitter.Resolver) && !Helpers.IsDecimalType (toType' block.Emitter.Resolver)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "((!Helpers.Is64Type (toType' block.Emitter.Resolver) && Helpers.IsIntegerType (toType' block.Emitter.Resolver)) || (rr is OperatorResolveResult && !Helpers.Is64Type (fromType' block.Emitter.Resolver) && Helpers.IsIntegerType (fromType' block.Emitter.Resolver))) && (expression is BinaryOperatorExpression || expression is UnaryOperatorExpression || expression.Parent is AssignmentExpression) && IsInCheckedContext (block.Emitter' expression)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "(Helpers.IsKnownType (KnownTypeCode.Int32' toType' block.Emitter.Resolver) && isBitwiseOperator) || (Helpers.IsKnownType (KnownTypeCode.UInt32' toType' block.Emitter.Resolver) && be != null && be.Operator == BinaryOperatorType.ShiftRight)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "be != null && (be.Operator == BinaryOperatorType.Add || be.Operator == BinaryOperatorType.Divide || be.Operator == BinaryOperatorType.Multiply || isBitwiseOperator || be.Operator == BinaryOperatorType.Subtract)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "ue != null && (ue.Operator == UnaryOperatorType.Minus || ue.Operator == UnaryOperatorType.Increment || ue.Operator == UnaryOperatorType.Decrement || ue.Operator == UnaryOperatorType.PostIncrement || ue.Operator == UnaryOperatorType.PostDecrement)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "(isBitwiseOperator && Helpers.IsKnownType (KnownTypeCode.Int32' toType' block.Emitter.Resolver)) || (ae != null && ae.Operator == AssignmentOperatorType.ShiftRight && Helpers.IsKnownType (KnownTypeCode.UInt32' toType' block.Emitter.Resolver))"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "ae != null && (isBitwiseOperator || ae.Operator == AssignmentOperatorType.Add || ae.Operator == AssignmentOperatorType.Divide || ae.Operator == AssignmentOperatorType.Multiply || ae.Operator == AssignmentOperatorType.Subtract)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "((!Helpers.Is64Type (toType' block.Emitter.Resolver) && Helpers.IsIntegerType (toType' block.Emitter.Resolver)) || (rr is OperatorResolveResult && !Helpers.Is64Type (fromType' block.Emitter.Resolver) && Helpers.IsIntegerType (fromType' block.Emitter.Resolver))) && (expression is BinaryOperatorExpression || expression is UnaryOperatorExpression || expression.Parent is AssignmentExpression) && IsInUncheckedContext (block.Emitter' expression)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "(Helpers.IsKnownType (KnownTypeCode.Int32' toType' block.Emitter.Resolver) && isBitwiseOperator) || (Helpers.IsKnownType (KnownTypeCode.UInt32' toType' block.Emitter.Resolver) && be != null && be.Operator == BinaryOperatorType.ShiftRight)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "be != null && !(be.Left is PrimitiveExpression && be.Right is PrimitiveExpression) && (be.Operator == BinaryOperatorType.Add || be.Operator == BinaryOperatorType.Divide || be.Operator == BinaryOperatorType.Multiply || isBitwiseOperator || be.Operator == BinaryOperatorType.Subtract)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "ue != null && !(ue.Expression is PrimitiveExpression) && (ue.Operator == UnaryOperatorType.Minus || ue.Operator == UnaryOperatorType.Increment || ue.Operator == UnaryOperatorType.Decrement || ue.Operator == UnaryOperatorType.PostIncrement || ue.Operator == UnaryOperatorType.PostDecrement)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "(isBitwiseOperator && Helpers.IsKnownType (KnownTypeCode.Int32' toType' block.Emitter.Resolver)) || (ae != null && ae.Operator == AssignmentOperatorType.ShiftRight && Helpers.IsKnownType (KnownTypeCode.UInt32' toType' block.Emitter.Resolver))"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,CheckNumericConversion,The conditional expression  "ae != null && (isBitwiseOperator || ae.Operator == AssignmentOperatorType.Add || ae.Operator == AssignmentOperatorType.Divide || ae.Operator == AssignmentOperatorType.Multiply || ae.Operator == AssignmentOperatorType.Subtract)"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,NarrowingNumericOrEnumerationConversion,The conditional expression  "rr is ThisResolveResult || rr is LocalResolveResult || rr is ConstantResolveResult || isField"  is complex.
Complex Conditional,Bridge.Translator,ConversionBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConversionBlock.Number.cs,InsideOverflowContext,The conditional expression  "p is UncheckedExpression || p is UncheckedStatement || p is CheckedExpression || p is CheckedStatement"  is complex.
Complex Conditional,Bridge.Translator,ConstructorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ConstructorBlock.Events.cs,GetEventsAndAutoStartupMethods,The conditional expression  "method.Name == CS.Methods.AUTO_STARTUP_METHOD_NAME && method.HasModifier (Modifiers.Static) && !method.HasModifier (Modifiers.Abstract) && Helpers.IsEntryPointCandidate (this.Emitter' method)"  is complex.
Complex Conditional,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The conditional expression  "enable.HasValue && enable.Value && !hasSettings && thisAssembly"  is complex.
Complex Conditional,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The conditional expression  "typeAccessibility.Value.HasFlag (TypeAccessibility.Public) && (typeDef == null || typeDef.IsPublic || typeDef.IsInternal)"  is complex.
Complex Conditional,Bridge.Translator,YieldBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\YieldBlock.cs,DoEmit,The conditional expression  "this.YieldBreakStatement.GetParent<ForStatement> () == null && this.YieldBreakStatement.GetParent<ForeachStatement> () == null && this.YieldBreakStatement.GetParent<WhileStatement> () == null && this.YieldBreakStatement.GetParent<DoWhileStatement> () == null"  is complex.
Complex Conditional,Bridge.Translator,DefaultValueBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\DefaultValueBlock.cs,DefaultValue,The conditional expression  "(!resolveResult.IsError && resolveResult.Type.IsReferenceType.HasValue && resolveResult.Type.IsReferenceType.Value) || resolveResult.Type.Kind == TypeKind.Dynamic || resolveResult.Type.IsKnownType (KnownTypeCode.NullableOfT)"  is complex.
Complex Conditional,Bridge.Translator,BreakBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BreakBlock.cs,DoEmit,The conditional expression  "n is ForStatement || n is ForeachStatement || n is WhileStatement || n is DoWhileStatement || n is AnonymousMethodExpression || n is LambdaExpression"  is complex.
Complex Conditional,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,GetCastMethod,The conditional expression  "m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1 && m.ReturnType.ReflectionName == toType.ReflectionName && m.Parameters [0].Type.ReflectionName == fromType.ReflectionName"  is complex.
Complex Conditional,Bridge.Translator,ForeachBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ForeachBlock.cs,GetCastMethod,The conditional expression  "m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1 && m.ReturnType.ReflectionName == toType.ReflectionName && (m.Parameters [0].Type.ReflectionName == fromType.ReflectionName)"  is complex.
Complex Conditional,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,VisitIndexerExpression,The conditional expression  "!(isIgnore || (current != null && current.IgnoreAccessor)) || isAccessorsIndexer"  is complex.
Complex Conditional,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The conditional expression  "memberResolveResult != null && memberResolveResult.Member.DeclaringTypeDefinition != null && memberResolveResult.Member.DeclaringTypeDefinition.Kind == TypeKind.Interface && (isExternalInterface || hasTypeParemeter)"  is complex.
Complex Conditional,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The conditional expression  "isInterfaceMember && (!this.Emitter.IsUnaryAccessor || isStatement) && !(targetrr is ThisResolveResult || targetrr is LocalResolveResult || targetrr is ConstantResolveResult || isField)"  is complex.
Complex Conditional,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitAccessorIndexer,The conditional expression  "!(targetrr is ThisResolveResult || targetrr is LocalResolveResult || targetrr is ConstantResolveResult || isField)"  is complex.
Complex Conditional,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,VisitObjectCreateExpression,The conditional expression  "!isTypeParam && !this.Emitter.Validator.IsIgnoreType (type) && type.Methods.Count (m => m.IsConstructor && !m.IsStatic) > (type.IsValueType || isObjectLiteral ? 0 : 1)"  is complex.
Complex Conditional,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,WriteObjectInitializer,The conditional expression  "!this.Emitter.AssemblyInfo.PreserveMemberCase && itemrr.Member is IProperty && !itemrr.Member.Attributes.Any (attr => attr.AttributeType.FullName == "Bridge.NameAttribute") && !this.Emitter.Validator.IsObjectLiteral (itemrr.Member.DeclaringTypeDefinition)"  is complex.
Complex Conditional,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The conditional expression  "member != null && member.Type.Kind == TypeKind.Delegate && (/*csharpInvocation.Member.Name == "Invoke" || */csharpInvocation.Member.Name == "BeginInvoke" || csharpInvocation.Member.Name == "EndInvoke") && !csharpInvocation.IsExtensionMethodInvocation"  is complex.
Complex Conditional,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,ResolveOperator,The conditional expression  "!(left is ThisResolveResult || left is TypeResolveResult || left is LocalResolveResult || left is ConstantResolveResult || isField)"  is complex.
Complex Conditional,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The conditional expression  "!(resultIsString && binaryOperatorExpression.Operator == BinaryOperatorType.Add) && (isLeftLong || isRightLong)"  is complex.
Complex Conditional,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The conditional expression  "binaryOperatorExpression.Operator == BinaryOperatorType.Divide && !(this.Emitter.IsJavaScriptOverflowMode && !ConversionBlock.InsideOverflowContext (this.Emitter' binaryOperatorExpression)) && ((Helpers.IsIntegerType (leftResolverResult.Type' this.Emitter.Resolver) && Helpers.IsIntegerType (rightResolverResult.Type' this.Emitter.Resolver)) || (Helpers.IsIntegerType (this.Emitter.Resolver.Resolver.GetExpectedType (binaryOperatorExpression.Left)' this.Emitter.Resolver) && Helpers.IsIntegerType (this.Emitter.Resolver.Resolver.GetExpectedType (binaryOperatorExpression.Right)' this.Emitter.Resolver)))"  is complex.
Complex Conditional,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,VisitBinaryOperatorExpression,The conditional expression  "delegateOperator || special || isStringConcat && !parentIsString && !isSimpleConcat"  is complex.
Complex Conditional,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,WritePart,The conditional expression  "m.Name == "ToString" && !m.IsStatic && m.ReturnType.IsKnownType (KnownTypeCode.String) && m.IsOverride"  is complex.
Complex Conditional,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The conditional expression  "string.IsNullOrEmpty (inlineCode) && memberResult != null && memberResult.Member is IMethod && !(memberResult is InvocationResolveResult) && !(identifierExpression.Parent is InvocationExpression && identifierExpression.NextSibling != null && identifierExpression.NextSibling.Role is TokenRole && ((TokenRole)identifierExpression.NextSibling.Role).Token == "(")"  is complex.
Complex Conditional,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The conditional expression  "memberResult != null && memberResult.Member is IMethod && !(memberResult is InvocationResolveResult) && !(identifierExpression.Parent is InvocationExpression && identifierExpression.NextSibling != null && identifierExpression.NextSibling.Role is TokenRole && ((TokenRole)identifierExpression.NextSibling.Role).Token == "(")"  is complex.
Complex Conditional,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The conditional expression  "memberResult != null && memberResult.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (memberResult.Member) && this.Emitter.IsInlineConst (memberResult.Member)"  is complex.
Complex Conditional,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,VisitUnaryOperatorExpression,The conditional expression  "op != UnaryOperatorType.Increment && op != UnaryOperatorType.Decrement && op != UnaryOperatorType.PostIncrement && op != UnaryOperatorType.PostDecrement"  is complex.
Complex Conditional,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,VisitUnaryOperatorExpression,The conditional expression  "inlineAttr == null && (isIgnore || ignoreAccessor) && !isAccessorsIndexer"  is complex.
Complex Conditional,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,VisitUnaryOperatorExpression,The conditional expression  "(isAccessor) && (op == UnaryOperatorType.Increment || op == UnaryOperatorType.Decrement || op == UnaryOperatorType.PostIncrement || op == UnaryOperatorType.PostDecrement)"  is complex.
Complex Conditional,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The conditional expression  "inlineAttr == null && (isIgnore || ignoreAccessor) && !isAccessorsIndexer"  is complex.
Complex Conditional,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,DoEmit,The conditional expression  "(!this.WrapByFn.HasValue || this.WrapByFn.Value) && (this.BlockStatement.Parent is ForStatement || this.BlockStatement.Parent is ForeachStatement || this.BlockStatement.Parent is WhileStatement || this.BlockStatement.Parent is DoWhileStatement)"  is complex.
Complex Conditional,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,KeepLineAfterBlock,The conditional expression  "parent is Accessor && (parent.Parent is PropertyDeclaration || parent.Parent is CustomEventDeclaration || parent.Parent is IndexerDeclaration)"  is complex.
Complex Conditional,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,KeepLineAfterBlock,The conditional expression  "ifStatement != null && ifStatement.FalseStatement != null && !ifStatement.FalseStatement.IsNull && ifStatement.FalseStatement != block"  is complex.
Complex Conditional,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,EndEmitBlock,The conditional expression  "!this.NoBraces && (!this.Emitter.IsAsync || (!this.AsyncNoBraces && this.BlockStatement.Parent != this.Emitter.AsyncBlock.Node))"  is complex.
Complex Conditional,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,BeginEmitBlock,The conditional expression  "(this.HandleContinue.HasValue && this.HandleContinue.Value) || (this.HandleBreak.HasValue && this.HandleBreak.Value) || (this.HandleReturn.HasValue && this.HandleReturn.Value)"  is complex.
Complex Conditional,Bridge.Translator,Block,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\Block.cs,BeginEmitBlock,The conditional expression  "!this.NoBraces && (!this.Emitter.IsAsync || (!this.AsyncNoBraces && this.BlockStatement.Parent != this.Emitter.AsyncBlock.Node))"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,WriteTarget,The conditional expression  "externalInterface && !nativeImplementation && !(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "memberTargetrr != null && memberTargetrr.Type.Kind == TypeKind.Enum && memberTargetrr.Member is DefaultResolvedField && this.Emitter.Validator.EnumEmitMode (memberTargetrr.Type) == 2"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "memberReferenceExpression.Target is ParenthesizedExpression || (targetrr is ConstantResolveResult && targetrr.Type.IsKnownType (KnownTypeCode.Int64)) || (targetrr is ConstantResolveResult && targetrr.Type.IsKnownType (KnownTypeCode.UInt64)) || (targetrr is ConstantResolveResult && targetrr.Type.IsKnownType (KnownTypeCode.Decimal))"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "string.IsNullOrEmpty (inline) && member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)"  is complex.
Complex Conditional,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The conditional expression  "expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member"  is complex.
Complex Conditional,Bridge.Translator,VisitorPropertyBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\VisitorPropertyBlock.cs,EmitPropertyMethod,The conditional expression  "memberResult != null && (memberResult.Member.Attributes.Any (a => a.AttributeType.FullName == "Bridge.FieldPropertyAttribute" || a.AttributeType.FullName == "Bridge.ExternalAttribute") || (propertyDeclaration.Getter.IsNull && propertyDeclaration.Setter.IsNull))"  is complex.
Complex Conditional,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,WriteVariance,The conditional expression  "itypeDef.Kind == TypeKind.Interface && MetadataUtils.IsJsGeneric (itypeDef' this.Emitter) && itypeDef.TypeParameters != null && itypeDef.TypeParameters.Any (typeParameter => typeParameter.Variance != VarianceModifier.Invariant)"  is complex.
Complex Conditional,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The conditional expression  "itype != null && castCode == null && method != CS.Ops.CAST && itype.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (itype.GetDefinition ())"  is complex.
Complex Conditional,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The conditional expression  "conversion.IsNumericConversion || conversion.IsEnumerationConversion || (isCast && conversion.IsIdentityConversion)"  is complex.
Complex Conditional,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitInlineCast,The conditional expression  "!(expressionrr is ThisResolveResult || expressionrr is ConstantResolveResult || expressionrr is LocalResolveResult || isField) && isCastAttr"  is complex.
Complex Conditional,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,GetCastMethod,The conditional expression  "m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1 && m.ReturnType.ReflectionName == toType.ReflectionName && m.Parameters [0].Type.ReflectionName == fromType.ReflectionName"  is complex.
Complex Conditional,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,GetCastMethod,The conditional expression  "m.IsOperator && (m.Name == "op_Explicit" || m.Name == "op_Implicit") && m.Parameters.Count == 1 && m.ReturnType.ReflectionName == toType.ReflectionName && (m.Parameters [0].Type.ReflectionName == fromType.ReflectionName)"  is complex.
Complex Conditional,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The conditional expression  "withoutTypeParams && (!this.Method.IsStatic || this.Method.IsExtensionMethod && this.TargetResolveResult is ThisResolveResult) && (this.TargetResolveResult is ThisResolveResult || this.TargetResolveResult == null) && (inline.Contains ("{this}") || this.Method.IsStatic || this.Method.IsExtensionMethod && inline.Contains ("{" + this.Method.Parameters.First ().Name + "}"))"  is complex.
Complex Conditional,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The conditional expression  "key == "this" || key == argsInfo.ThisName || (key == "0" && argsInfo.IsExtensionMethod)"  is complex.
Complex Conditional,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,IsInheritedFrom,The conditional expression  "Helpers.IsSubclassOf (xTypeDefinition' yTypeDefinition' this) || (yTypeDefinition.IsInterface && Helpers.IsImplementationOf (xTypeDefinition' yTypeDefinition' this)) || Helpers.IsTypeArgInSubclass (xTypeDefinition' yTypeDefinition' this)"  is complex.
Complex Conditional,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,GetParents,The conditional expression  "bType != null && bType.TypeInfo != null && (includeSelf || bType.Type != typeDef)"  is complex.
Complex Conditional,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitInvocationResolveResult,The conditional expression  "assign == null || assign.OperatorType != ExpressionType.Assign || !(assign.Operands [0] is MemberResolveResult) || !(((MemberResolveResult)assign.Operands [0]).Member is IProperty)"  is complex.
Complex Conditional,Bridge.Translator,DependencyFinderVisitor,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\DependencyFinderVisitor.cs,CheckDependency,The conditional expression  "typeInfo != null && typeInfo.TypeInfo != null && typeInfo.Type.FullName != this.Type.Type.FullName && this.Dependencies.All (d => d.Type.FullName != typeInfo.TypeInfo.Type.FullName)"  is complex.
Complex Conditional,Bridge.Translator,PreconverterDetecter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The conditional expression  "unaryOperatorExpression.Operator == UnaryOperatorType.Increment || unaryOperatorExpression.Operator == UnaryOperatorType.PostIncrement || unaryOperatorExpression.Operator == UnaryOperatorType.Decrement || unaryOperatorExpression.Operator == UnaryOperatorType.PostDecrement"  is complex.
Complex Conditional,Bridge.Translator,PreconverterFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Preconverter.cs,VisitUnaryOperatorExpression,The conditional expression  "unaryOperatorExpression.Operator == UnaryOperatorType.Increment || unaryOperatorExpression.Operator == UnaryOperatorType.PostIncrement || unaryOperatorExpression.Operator == UnaryOperatorType.Decrement || unaryOperatorExpression.Operator == UnaryOperatorType.PostDecrement"  is complex.
Complex Conditional,Bridge.Translator,EmptyLambdaDetecter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\EmptyLambdaFixer.cs,VisitIfElseStatement,The conditional expression  "ifElseStatement.FalseStatement != null && !ifElseStatement.FalseStatement.IsNull && !(ifElseStatement.FalseStatement is BlockStatement || ifElseStatement.FalseStatement is IfElseStatement)"  is complex.
Complex Conditional,Bridge.Translator,EmptyLambdaFixer,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\EmptyLambdaFixer.cs,VisitIfElseStatement,The conditional expression  "ifElseStatement.TrueStatement is BlockStatement && (!hasFalse || ifElseStatement.FalseStatement is BlockStatement || ifElseStatement.FalseStatement is IfElseStatement)"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The conditional expression  "namedType != null && namedType.IsGenericType && namedType.TypeArguments.Length > 0 && !namedType.TypeArguments.Any (SyntaxHelper.IsAnonymous)"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The conditional expression  "symbol != null && symbol.IsStatic && symbol.ContainingType != null && thisType != null && !thisType.InheritsFromOrEquals (symbol.ContainingType) && !(node.Parent is MemberAccessExpressionSyntax) && ((methodSymbol = symbol as IMethodSymbol) != null || symbol is IPropertySymbol || symbol is IFieldSymbol || symbol is IEventSymbol)"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitGenericName,The conditional expression  "methodSymbol != null && methodSymbol.IsGenericMethod && methodSymbol.TypeArguments.Length > 0 && !methodSymbol.TypeArguments.Any (SyntaxHelper.IsAnonymous)"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The conditional expression  "namedType != null && namedType.IsGenericType && namedType.TypeArguments.Length > 0 && !namedType.TypeArguments.Any (SyntaxHelper.IsAnonymous)"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The conditional expression  "symbol != null && symbol.IsStatic && symbol.ContainingType != null && thisType != null && !thisType.InheritsFromOrEquals (symbol.ContainingType) && !(node.Parent is MemberAccessExpressionSyntax) && ((methodSymbol = symbol as IMethodSymbol) != null || symbol is IPropertySymbol || symbol is IFieldSymbol || symbol is IEventSymbol)"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitIdentifierName,The conditional expression  "methodSymbol != null && methodSymbol.IsGenericMethod && methodSymbol.TypeArguments.Length > 0 && !methodSymbol.TypeArguments.Any (SyntaxHelper.IsAnonymous)"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitMemberAccessExpression,The conditional expression  "node.Expression is IdentifierNameSyntax && symbol != null && symbol.IsStatic && symbol.ContainingType != null && thisType != null && !thisType.InheritsFromOrEquals (symbol.ContainingType) && (symbol is IMethodSymbol || symbol is IPropertySymbol || symbol is IFieldSymbol || symbol is IEventSymbol)"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitParenthesizedLambdaExpression,The conditional expression  "ti.Type != null && ti.Type.IsExpressionOfT () || ti.ConvertedType != null && ti.ConvertedType.IsExpressionOfT ()"  is complex.
Complex Conditional,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitSimpleLambdaExpression,The conditional expression  "ti.Type != null && ti.Type.IsExpressionOfT () || ti.ConvertedType != null && ti.ConvertedType.IsExpressionOfT ()"  is complex.
Complex Conditional,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitTypeDeclaration,The conditional expression  "(ignored || this.HasIgnore (typeDeclaration) || this.IsNonScriptable (typeDeclaration)) && !this.IsObjectLiteral (typeDeclaration)"  is complex.
Complex Conditional,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitPropertyDeclaration,The conditional expression  "!propertyDeclaration.Getter.IsNull && !this.HasIgnore (propertyDeclaration) && !this.HasInline (propertyDeclaration.Getter) && propertyDeclaration.Getter.Body.IsNull && !this.HasScript (propertyDeclaration.Getter)"  is complex.
Complex Conditional,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadModuleInfo,The conditional expression  "(name == (Translator.Bridge_ASSEMBLY + ".Module")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".ModuleAttribute"))"  is complex.
Complex Conditional,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadFileNameInfo,The conditional expression  "(name == (Translator.Bridge_ASSEMBLY + ".FileName")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".FileNameAttribute"))"  is complex.
Complex Conditional,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadOutputPathInfo,The conditional expression  "(name == (Translator.Bridge_ASSEMBLY + ".Output")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".OutputPathAttribute"))"  is complex.
Complex Conditional,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadFileHierarchyInfo,The conditional expression  "(name == (Translator.Bridge_ASSEMBLY + ".FilesHierarchy")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".FilesHierarchyAttribute"))"  is complex.
Complex Conditional,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,ReadModuleDependency,The conditional expression  "(name == (Translator.Bridge_ASSEMBLY + ".ModuleDependency")) || (resolveResult != null && resolveResult.Type != null && resolveResult.Type.FullName == (Translator.Bridge_ASSEMBLY + ".ModuleDependencyAttribute"))"  is complex.
Complex Conditional,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,The conditional expression  "type.IsInterface && (type.HasMethods || type.HasProperties || type.HasEvents || type.HasFields)"  is complex.
Complex Conditional,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,The conditional expression  "objectCreateMode == 1 && baseType != null && baseType.FullName != "System.Object" && this.GetObjectCreateMode (baseType) == 0"  is complex.
Complex Conditional,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckProperties,The conditional expression  "(prop.GetMethod != null && prop.GetMethod.IsVirtual) || (prop.SetMethod != null && prop.SetMethod.IsVirtual)"  is complex.
Complex Conditional,Bridge.Translator.TypeScript,PropertyBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\TypeScript\PropertyBlock.cs,EmitPropertyMethod,The conditional expression  "memberResult != null && (memberResult.Member.Attributes.Any (a => a.AttributeType.FullName == "Bridge.FieldPropertyAttribute") || (propertyDeclaration.Getter.IsNull && propertyDeclaration.Setter.IsNull))"  is complex.
Empty Catch Block,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,GetResourceOutputPath,The method has an empty catch block.
Empty Catch Block,Bridge.Translator,Translator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Translator.Resources.cs,ValidateResourceSettings,The method has an empty catch block.
Empty Catch Block,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,The method has an empty catch block.
Empty Catch Block,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,CheckObjectLiteral,The method has an empty catch block.
Magic Number,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The following statement contains a magic number: foreach (var bridgeType in this.Emitter.BridgeTypes) {  	var result = false;  	var type = bridgeType.Value.Type;  	var thisAssembly = bridgeType.Value.TypeInfo != null;  	if (enable.HasValue && enable.Value && !hasSettings && thisAssembly) {  		result = true;  	}  	var typeDef = type.GetDefinition ();  	if (typeDef != null) {  		var isGlobal = typeDef.Attributes.Any (a => a.AttributeType.FullName == "Bridge.GlobalMethodsAttribute" || a.AttributeType.FullName == "Bridge.MixinAttribute");  		if (isGlobal) {  			continue;  		}  		var attr = typeDef.Attributes.FirstOrDefault (a => a.AttributeType.FullName == "Bridge.ReflectableAttribute");  		if (attr != null) {  			if (attr.PositionalArguments.Count == 0) {  				reflectTypes.Add (type);  				continue;  			}  			var value = attr.PositionalArguments.First ().ConstantValue;  			if (!(value is bool) || (bool)value) {  				reflectTypes.Add (type);  			}  			continue;  		}  	}  	if (typeAccessibility.HasValue) {  		result = false;  		if (typeAccessibility.Value.HasFlag (TypeAccessibility.All)) {  			result = true;  		}  		if (typeAccessibility.Value.HasFlag (TypeAccessibility.Anonymous) && type.Kind == TypeKind.Anonymous) {  			result = true;  		}  		if (typeAccessibility.Value.HasFlag (TypeAccessibility.NonAnonymous) && type.Kind != TypeKind.Anonymous) {  			result = true;  		}  		if (typeAccessibility.Value.HasFlag (TypeAccessibility.NonPrivate) && (typeDef == null || !typeDef.IsPrivate)) {  			result = true;  		}  		if (typeAccessibility.Value.HasFlag (TypeAccessibility.Public) && (typeDef == null || typeDef.IsPublic || typeDef.IsInternal)) {  			result = true;  		}  		if (typeAccessibility.Value.HasFlag (TypeAccessibility.None)) {  			continue;  		}  	}  	if (!string.IsNullOrEmpty (filter)) {  		var fullName = type.FullName;  		var parts = filter.Split (new char[] {  			';'  		}' StringSplitOptions.RemoveEmptyEntries);  		foreach (var part in parts) {  			string pattern;  			bool exclude = part.StartsWith ("!");  			if (part == "this") {  				result = !exclude && thisAssembly;  			}  			else {  				if (part.StartsWith ("regex:")) {  					pattern = part.Substring (6);  				}  				else {  					pattern = "^" + Regex.Escape (part).Replace ("\\*"' ".*").Replace ("\\?"' ".") + "$";  				}  				if (Regex.IsMatch (fullName' pattern)) {  					result = !exclude;  				}  			}  		}  		if (!result) {  			continue;  		}  	}  	if (result) {  		reflectTypes.Add (type);  	}  }  
Magic Number,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The following statement contains a magic number: if (!string.IsNullOrEmpty (filter)) {  	var fullName = type.FullName;  	var parts = filter.Split (new char[] {  		';'  	}' StringSplitOptions.RemoveEmptyEntries);  	foreach (var part in parts) {  		string pattern;  		bool exclude = part.StartsWith ("!");  		if (part == "this") {  			result = !exclude && thisAssembly;  		}  		else {  			if (part.StartsWith ("regex:")) {  				pattern = part.Substring (6);  			}  			else {  				pattern = "^" + Regex.Escape (part).Replace ("\\*"' ".*").Replace ("\\?"' ".") + "$";  			}  			if (Regex.IsMatch (fullName' pattern)) {  				result = !exclude;  			}  		}  	}  	if (!result) {  		continue;  	}  }  
Magic Number,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The following statement contains a magic number: foreach (var part in parts) {  	string pattern;  	bool exclude = part.StartsWith ("!");  	if (part == "this") {  		result = !exclude && thisAssembly;  	}  	else {  		if (part.StartsWith ("regex:")) {  			pattern = part.Substring (6);  		}  		else {  			pattern = "^" + Regex.Escape (part).Replace ("\\*"' ".*").Replace ("\\?"' ".") + "$";  		}  		if (Regex.IsMatch (fullName' pattern)) {  			result = !exclude;  		}  	}  }  
Magic Number,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The following statement contains a magic number: if (part == "this") {  	result = !exclude && thisAssembly;  }  else {  	if (part.StartsWith ("regex:")) {  		pattern = part.Substring (6);  	}  	else {  		pattern = "^" + Regex.Escape (part).Replace ("\\*"' ".*").Replace ("\\?"' ".") + "$";  	}  	if (Regex.IsMatch (fullName' pattern)) {  		result = !exclude;  	}  }  
Magic Number,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The following statement contains a magic number: if (part.StartsWith ("regex:")) {  	pattern = part.Substring (6);  }  else {  	pattern = "^" + Regex.Escape (part).Replace ("\\*"' ".*").Replace ("\\?"' ".") + "$";  }  
Magic Number,Bridge.Translator,EmitBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\EmitBlock.cs,GetReflectableTypes,The following statement contains a magic number: pattern = part.Substring (6);  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is TypeOfResolveResult) {  	block.Write (BridgeTypes.ToJsName (((TypeOfResolveResult)rr).ReferencedType' block.Emitter));  }  else if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is TypeOfResolveResult) {  	block.Write (BridgeTypes.ToJsName (((TypeOfResolveResult)rr).ReferencedType' block.Emitter));  }  else if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is TypeOfResolveResult) {  	block.Write (BridgeTypes.ToJsName (((TypeOfResolveResult)rr).ReferencedType' block.Emitter));  }  else if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is TypeOfResolveResult) {  	block.Write (BridgeTypes.ToJsName (((TypeOfResolveResult)rr).ReferencedType' block.Emitter));  }  else if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is TypeOfResolveResult) {  	block.Write (BridgeTypes.ToJsName (((TypeOfResolveResult)rr).ReferencedType' block.Emitter));  }  else if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is TypeOfResolveResult) {  	block.Write (BridgeTypes.ToJsName (((TypeOfResolveResult)rr).ReferencedType' block.Emitter));  }  else if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is TypeOfResolveResult) {  	block.Write (BridgeTypes.ToJsName (((TypeOfResolveResult)rr).ReferencedType' block.Emitter));  }  else if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is ArrayCreateResolveResult) {  	TypeSystemAstBuilder typeBuilder = new TypeSystemAstBuilder (new CSharpResolver (block.Emitter.Resolver.Compilation));  	var expression = typeBuilder.ConvertConstantValue (rr) as ArrayCreateExpression;  	new ArrayCreateBlock (block.Emitter' expression' (ArrayCreateResolveResult)rr).Emit ();  }  else if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (rr is MemberResolveResult) {  	var mrr = (MemberResolveResult)rr;  	if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  			if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				block.WriteScript (mrr.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = mrr.Member.Name;  				var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = block.Emitter.GetEntityName (mrr.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				block.WriteScript (enumStringName);  			}  			else {  				block.WriteScript (rr.ConstantValue);  			}  		}  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  		if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			block.WriteScript (mrr.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = mrr.Member.Name;  			var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = block.Emitter.GetEntityName (mrr.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			block.WriteScript (enumStringName);  		}  		else {  			block.WriteScript (rr.ConstantValue);  		}  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  		if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			block.WriteScript (mrr.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = mrr.Member.Name;  			var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = block.Emitter.GetEntityName (mrr.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			block.WriteScript (enumStringName);  		}  		else {  			block.WriteScript (rr.ConstantValue);  		}  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  		if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			block.WriteScript (mrr.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = mrr.Member.Name;  			var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = block.Emitter.GetEntityName (mrr.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			block.WriteScript (enumStringName);  		}  		else {  			block.WriteScript (rr.ConstantValue);  		}  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  		if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			block.WriteScript (mrr.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = mrr.Member.Name;  			var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = block.Emitter.GetEntityName (mrr.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			block.WriteScript (enumStringName);  		}  		else {  			block.WriteScript (rr.ConstantValue);  		}  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  		if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			block.WriteScript (mrr.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = mrr.Member.Name;  			var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = block.Emitter.GetEntityName (mrr.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			block.WriteScript (enumStringName);  		}  		else {  			block.WriteScript (rr.ConstantValue);  		}  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  		if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			block.WriteScript (mrr.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = mrr.Member.Name;  			var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = block.Emitter.GetEntityName (mrr.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			block.WriteScript (enumStringName);  		}  		else {  			block.WriteScript (rr.ConstantValue);  		}  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (mrr.IsCompileTimeConstant && mrr.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = mrr.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  		if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			block.WriteScript (mrr.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = mrr.Member.Name;  			var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = block.Emitter.GetEntityName (mrr.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			block.WriteScript (enumStringName);  		}  		else {  			block.WriteScript (rr.ConstantValue);  		}  	}  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  	if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		block.WriteScript (mrr.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = mrr.Member.Name;  		var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = block.Emitter.GetEntityName (mrr.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		block.WriteScript (enumStringName);  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  	if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		block.WriteScript (mrr.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = mrr.Member.Name;  		var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = block.Emitter.GetEntityName (mrr.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		block.WriteScript (enumStringName);  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  	if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		block.WriteScript (mrr.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = mrr.Member.Name;  		var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = block.Emitter.GetEntityName (mrr.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		block.WriteScript (enumStringName);  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  	if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		block.WriteScript (mrr.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = mrr.Member.Name;  		var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = block.Emitter.GetEntityName (mrr.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		block.WriteScript (enumStringName);  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  	if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		block.WriteScript (mrr.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = mrr.Member.Name;  		var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = block.Emitter.GetEntityName (mrr.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		block.WriteScript (enumStringName);  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  	if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		block.WriteScript (mrr.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = mrr.Member.Name;  		var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = block.Emitter.GetEntityName (mrr.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		block.WriteScript (enumStringName);  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = block.Emitter.Validator.EnumEmitMode (typeDef);  	if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		block.WriteScript (mrr.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = mrr.Member.Name;  		var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = block.Emitter.GetEntityName (mrr.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		block.WriteScript (enumStringName);  	}  	else {  		block.WriteScript (rr.ConstantValue);  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if ((block.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  	block.WriteScript (mrr.ConstantValue);  	return;  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = mrr.Member.Name;  	var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = block.Emitter.GetEntityName (mrr.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	block.WriteScript (enumStringName);  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = mrr.Member.Name;  	var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = block.Emitter.GetEntityName (mrr.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	block.WriteScript (enumStringName);  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = mrr.Member.Name;  	var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = block.Emitter.GetEntityName (mrr.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	block.WriteScript (enumStringName);  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = mrr.Member.Name;  	var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = block.Emitter.GetEntityName (mrr.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	block.WriteScript (enumStringName);  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = mrr.Member.Name;  	var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = block.Emitter.GetEntityName (mrr.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	block.WriteScript (enumStringName);  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = mrr.Member.Name;  	var attr = Helpers.GetInheritedAttribute (mrr.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = block.Emitter.GetEntityName (mrr.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	block.WriteScript (enumStringName);  }  else {  	block.WriteScript (rr.ConstantValue);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (attr != null) {  	enumStringName = block.Emitter.GetEntityName (mrr.Member);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (attr != null) {  	enumStringName = block.Emitter.GetEntityName (mrr.Member);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (attr != null) {  	enumStringName = block.Emitter.GetEntityName (mrr.Member);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: if (attr != null) {  	enumStringName = block.Emitter.GetEntityName (mrr.Member);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,GetInlineInit,The following statement contains a magic number: if (inlineCode != null) {  	bool oldIsAssignment = block.Emitter.IsAssignment;  	bool oldUnary = block.Emitter.IsUnaryAccessor;  	var oldWriter = block.SaveWriter ();  	block.NewWriter ();  	block.Emitter.IsAssignment = true;  	block.Emitter.IsUnaryAccessor = false;  	bool hasThis = inlineCode.Contains ("{this}");  	if (inlineCode.StartsWith ("<self>")) {  		hasThis = true;  		inlineCode = inlineCode.Substring (6);  	}  	if (hasThis) {  		inlineCode = inlineCode.Replace ("{this}"' "this");  		if (member is IProperty) {  			inlineCode = inlineCode.Replace ("{0}"' "[[0]]");  			AttributeCreateBlock.WriteResolveResult (item.Value' block);  			var value = block.Emitter.Output.ToString ();  			inlineCode = inlineCode.Replace ("{value}"' value);  			inlineCode = inlineCode.Replace ("[[0]]"' "{0}");  		}  	}  	else {  		if (member.SymbolKind == SymbolKind.Property) {  			var count = block.Emitter.Writers.Count;  			block.PushWriter ("this." + inlineCode);  			AttributeCreateBlock.WriteResolveResult (item.Value' block);  			if (block.Emitter.Writers.Count > count) {  				inlineCode = block.PopWriter (true);  			}  		}  		else {  			block.Write ("this." + inlineCode);  		}  	}  	block.Emitter.IsAssignment = oldIsAssignment;  	block.Emitter.IsUnaryAccessor = oldUnary;  	block.RestoreWriter (oldWriter);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,GetInlineInit,The following statement contains a magic number: if (inlineCode.StartsWith ("<self>")) {  	hasThis = true;  	inlineCode = inlineCode.Substring (6);  }  
Magic Number,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,GetInlineInit,The following statement contains a magic number: inlineCode = inlineCode.Substring (6);  
Magic Number,Bridge.Translator,DefaultValueBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\DefaultValueBlock.cs,DefaultValue,The following statement contains a magic number: if (resolveResult.Type.Kind == TypeKind.Enum) {  	var enumMode = emitter.Validator.EnumEmitMode (resolveResult.Type);  	var isString = enumMode >= 3 && enumMode <= 6;  	return isString ? "null" : "0";  }  
Magic Number,Bridge.Translator,DefaultValueBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\DefaultValueBlock.cs,DefaultValue,The following statement contains a magic number: if (resolveResult.Type.Kind == TypeKind.Enum) {  	var enumMode = emitter.Validator.EnumEmitMode (resolveResult.Type);  	var isString = enumMode >= 3 && enumMode <= 6;  	return isString ? "null" : "0";  }  
Magic Number,Bridge.Translator,CommentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CommentBlock.cs,WriteMultiLineComment,The following statement contains a magic number: if (needRemoveIndent) {  	text = AbstractEmitterBlock.RemoveIndentFromString (text' this.Comment.StartLocation.Column - (mode == 1 ? 5 : 1));  }  
Magic Number,Bridge.Translator,CommentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CommentBlock.cs,WriteMultiLineComment,The following statement contains a magic number: text = AbstractEmitterBlock.RemoveIndentFromString (text' this.Comment.StartLocation.Column - (mode == 1 ? 5 : 1));  
Magic Number,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitInlineIndexer,The following statement contains a magic number: if (inlineCode != null && inlineCode.StartsWith ("<self>")) {  	hasThis = true;  	inlineCode = inlineCode.Substring (6);  }  
Magic Number,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitInlineIndexer,The following statement contains a magic number: inlineCode = inlineCode.Substring (6);  
Magic Number,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,GetInlineInit,The following statement contains a magic number: if (expr != null && rr is MemberResolveResult) {  	var member = ((MemberResolveResult)rr).Member;  	if (member is IProperty) {  		var setter = ((IProperty)member).Setter;  		if (setter != null) {  			inlineCode = block.Emitter.GetInline (setter);  		}  	}  	else {  		inlineCode = block.Emitter.GetInline (member);  	}  	if (inlineCode != null) {  		bool oldIsAssignment = block.Emitter.IsAssignment;  		bool oldUnary = block.Emitter.IsUnaryAccessor;  		var oldWriter = block.SaveWriter ();  		block.NewWriter ();  		block.Emitter.IsAssignment = true;  		block.Emitter.IsUnaryAccessor = false;  		bool hasThis = inlineCode.Contains ("{this}");  		if (inlineCode.StartsWith ("<self>")) {  			hasThis = true;  			inlineCode = inlineCode.Substring (6);  		}  		if (hasThis) {  			inlineCode = inlineCode.Replace ("{this}"' "this");  			if (member is IProperty) {  				var argsInfo = new ArgumentsInfo (block.Emitter' item' rr);  				argsInfo.ArgumentsExpressions = new Expression[] {  					expr  				};  				argsInfo.ArgumentsNames = new string[] {  					"value"  				};  				argsInfo.ThisArgument = "this";  				argsInfo.NamedExpressions = argsInfo.CreateNamedExpressions (argsInfo.ArgumentsNames' argsInfo.ArgumentsExpressions);  				inlineCode = inlineCode.Replace ("{0}"' "[[0]]");  				new InlineArgumentsBlock (block.Emitter' argsInfo' inlineCode).Emit ();  				inlineCode = block.Emitter.Output.ToString ();  				inlineCode = inlineCode.Replace ("[[0]]"' "{0}");  			}  		}  		else {  			if (member.SymbolKind == SymbolKind.Property) {  				var count = block.Emitter.Writers.Count;  				block.PushWriter ("this." + inlineCode);  				expr.AcceptVisitor (block.Emitter);  				if (block.Emitter.Writers.Count > count) {  					inlineCode = block.PopWriter (true);  				}  			}  			else {  				block.Write ("this." + inlineCode);  			}  		}  		block.Emitter.IsAssignment = oldIsAssignment;  		block.Emitter.IsUnaryAccessor = oldUnary;  		block.RestoreWriter (oldWriter);  	}  }  
Magic Number,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,GetInlineInit,The following statement contains a magic number: if (inlineCode != null) {  	bool oldIsAssignment = block.Emitter.IsAssignment;  	bool oldUnary = block.Emitter.IsUnaryAccessor;  	var oldWriter = block.SaveWriter ();  	block.NewWriter ();  	block.Emitter.IsAssignment = true;  	block.Emitter.IsUnaryAccessor = false;  	bool hasThis = inlineCode.Contains ("{this}");  	if (inlineCode.StartsWith ("<self>")) {  		hasThis = true;  		inlineCode = inlineCode.Substring (6);  	}  	if (hasThis) {  		inlineCode = inlineCode.Replace ("{this}"' "this");  		if (member is IProperty) {  			var argsInfo = new ArgumentsInfo (block.Emitter' item' rr);  			argsInfo.ArgumentsExpressions = new Expression[] {  				expr  			};  			argsInfo.ArgumentsNames = new string[] {  				"value"  			};  			argsInfo.ThisArgument = "this";  			argsInfo.NamedExpressions = argsInfo.CreateNamedExpressions (argsInfo.ArgumentsNames' argsInfo.ArgumentsExpressions);  			inlineCode = inlineCode.Replace ("{0}"' "[[0]]");  			new InlineArgumentsBlock (block.Emitter' argsInfo' inlineCode).Emit ();  			inlineCode = block.Emitter.Output.ToString ();  			inlineCode = inlineCode.Replace ("[[0]]"' "{0}");  		}  	}  	else {  		if (member.SymbolKind == SymbolKind.Property) {  			var count = block.Emitter.Writers.Count;  			block.PushWriter ("this." + inlineCode);  			expr.AcceptVisitor (block.Emitter);  			if (block.Emitter.Writers.Count > count) {  				inlineCode = block.PopWriter (true);  			}  		}  		else {  			block.Write ("this." + inlineCode);  		}  	}  	block.Emitter.IsAssignment = oldIsAssignment;  	block.Emitter.IsUnaryAccessor = oldUnary;  	block.RestoreWriter (oldWriter);  }  
Magic Number,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,GetInlineInit,The following statement contains a magic number: if (inlineCode.StartsWith ("<self>")) {  	hasThis = true;  	inlineCode = inlineCode.Substring (6);  }  
Magic Number,Bridge.Translator,ObjectCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ObjectCreateBlock.cs,GetInlineInit,The following statement contains a magic number: inlineCode = inlineCode.Substring (6);  
Magic Number,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The following statement contains a magic number: if (inlineInfo != null) {  	bool isStaticMethod = inlineInfo.Item1;  	bool isInlineMethod = inlineInfo.Item2;  	string inlineScript = inlineInfo.Item3;  	if (isInlineMethod) {  		if (invocationExpression.Arguments.Count > 0) {  			var code = invocationExpression.Arguments.First ();  			var inlineExpression = code as PrimitiveExpression;  			if (inlineExpression == null) {  				throw new EmitterException (invocationExpression' "Only primitive expression can be inlined");  			}  			string value = inlineExpression.Value.ToString ().Trim ();  			if (value.Length > 0) {  				value = InlineArgumentsBlock.ReplaceInlineArgs (this' inlineExpression.Value.ToString ()' invocationExpression.Arguments.Skip (1).ToArray ());  				this.Write (value);  				value = value.Trim ();  				if (value [value.Length - 1] == ';' || value.EndsWith ("*/"' StringComparison.InvariantCulture) || value.StartsWith ("//")) {  					this.Emitter.EnableSemicolon = false;  					this.WriteNewLine ();  				}  			}  			else {  				// Empty string' emit nothing.  				this.Emitter.EnableSemicolon = false;  			}  			this.Emitter.ReplaceAwaiterByVar = oldValue;  			this.Emitter.AsyncExpressionHandling = oldAsyncExpressionHandling;  			return;  		}  	}  	else {  		MemberReferenceExpression targetMemberRef = invocationExpression.Target as MemberReferenceExpression;  		bool isBase = targetMemberRef != null && targetMemberRef.Target is BaseReferenceExpression;  		if (!String.IsNullOrEmpty (inlineScript) && (isBase || invocationExpression.Target is IdentifierExpression)) {  			argsInfo.ThisArgument = "this";  			bool noThis = !inlineScript.Contains ("{this}");  			if (inlineScript.StartsWith ("<self>")) {  				noThis = false;  				inlineScript = inlineScript.Substring (6);  			}  			if (!isStaticMethod && noThis) {  				this.WriteThis ();  				this.WriteDot ();  			}  			new InlineArgumentsBlock (this.Emitter' argsInfo' inlineScript).Emit ();  			this.Emitter.ReplaceAwaiterByVar = oldValue;  			this.Emitter.AsyncExpressionHandling = oldAsyncExpressionHandling;  			return;  		}  	}  }  
Magic Number,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The following statement contains a magic number: if (isInlineMethod) {  	if (invocationExpression.Arguments.Count > 0) {  		var code = invocationExpression.Arguments.First ();  		var inlineExpression = code as PrimitiveExpression;  		if (inlineExpression == null) {  			throw new EmitterException (invocationExpression' "Only primitive expression can be inlined");  		}  		string value = inlineExpression.Value.ToString ().Trim ();  		if (value.Length > 0) {  			value = InlineArgumentsBlock.ReplaceInlineArgs (this' inlineExpression.Value.ToString ()' invocationExpression.Arguments.Skip (1).ToArray ());  			this.Write (value);  			value = value.Trim ();  			if (value [value.Length - 1] == ';' || value.EndsWith ("*/"' StringComparison.InvariantCulture) || value.StartsWith ("//")) {  				this.Emitter.EnableSemicolon = false;  				this.WriteNewLine ();  			}  		}  		else {  			// Empty string' emit nothing.  			this.Emitter.EnableSemicolon = false;  		}  		this.Emitter.ReplaceAwaiterByVar = oldValue;  		this.Emitter.AsyncExpressionHandling = oldAsyncExpressionHandling;  		return;  	}  }  else {  	MemberReferenceExpression targetMemberRef = invocationExpression.Target as MemberReferenceExpression;  	bool isBase = targetMemberRef != null && targetMemberRef.Target is BaseReferenceExpression;  	if (!String.IsNullOrEmpty (inlineScript) && (isBase || invocationExpression.Target is IdentifierExpression)) {  		argsInfo.ThisArgument = "this";  		bool noThis = !inlineScript.Contains ("{this}");  		if (inlineScript.StartsWith ("<self>")) {  			noThis = false;  			inlineScript = inlineScript.Substring (6);  		}  		if (!isStaticMethod && noThis) {  			this.WriteThis ();  			this.WriteDot ();  		}  		new InlineArgumentsBlock (this.Emitter' argsInfo' inlineScript).Emit ();  		this.Emitter.ReplaceAwaiterByVar = oldValue;  		this.Emitter.AsyncExpressionHandling = oldAsyncExpressionHandling;  		return;  	}  }  
Magic Number,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The following statement contains a magic number: if (!String.IsNullOrEmpty (inlineScript) && (isBase || invocationExpression.Target is IdentifierExpression)) {  	argsInfo.ThisArgument = "this";  	bool noThis = !inlineScript.Contains ("{this}");  	if (inlineScript.StartsWith ("<self>")) {  		noThis = false;  		inlineScript = inlineScript.Substring (6);  	}  	if (!isStaticMethod && noThis) {  		this.WriteThis ();  		this.WriteDot ();  	}  	new InlineArgumentsBlock (this.Emitter' argsInfo' inlineScript).Emit ();  	this.Emitter.ReplaceAwaiterByVar = oldValue;  	this.Emitter.AsyncExpressionHandling = oldAsyncExpressionHandling;  	return;  }  
Magic Number,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The following statement contains a magic number: if (inlineScript.StartsWith ("<self>")) {  	noThis = false;  	inlineScript = inlineScript.Substring (6);  }  
Magic Number,Bridge.Translator,InvocationBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InvocationBlock.cs,VisitInvocationExpression,The following statement contains a magic number: inlineScript = inlineScript.Substring (6);  
Magic Number,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The following statement contains a magic number: if (memberResult != null && memberResult.Member is IMethod && isInvoke) {  	var i_rr = this.Emitter.Resolver.ResolveNode (identifierExpression.Parent' this.Emitter) as CSharpInvocationResolveResult;  	if (i_rr != null && !i_rr.IsExpandedForm) {  		var tpl = this.Emitter.GetAttribute (memberResult.Member.Attributes' JS.NS.BRIDGE + ".TemplateAttribute");  		if (tpl != null && tpl.PositionalArguments.Count == 2) {  			inlineCode = tpl.PositionalArguments [1].ConstantValue.ToString ();  		}  	}  }  
Magic Number,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The following statement contains a magic number: if (i_rr != null && !i_rr.IsExpandedForm) {  	var tpl = this.Emitter.GetAttribute (memberResult.Member.Attributes' JS.NS.BRIDGE + ".TemplateAttribute");  	if (tpl != null && tpl.PositionalArguments.Count == 2) {  		inlineCode = tpl.PositionalArguments [1].ConstantValue.ToString ();  	}  }  
Magic Number,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The following statement contains a magic number: if (tpl != null && tpl.PositionalArguments.Count == 2) {  	inlineCode = tpl.PositionalArguments [1].ConstantValue.ToString ();  }  
Magic Number,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The following statement contains a magic number: if (hasInline && inlineCode.StartsWith ("<self>")) {  	hasThis = true;  	inlineCode = inlineCode.Substring (6);  }  
Magic Number,Bridge.Translator,IdentifierBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IdentifierBlock.cs,VisitIdentifierExpression,The following statement contains a magic number: inlineCode = inlineCode.Substring (6);  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (memberTargetrr != null && memberTargetrr.Type.Kind == TypeKind.Enum && memberTargetrr.Member is DefaultResolvedField && this.Emitter.Validator.EnumEmitMode (memberTargetrr.Type) == 2) {  	isConstTarget = true;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.Member is IMethod && isInvoke) {  	var i_rr = this.Emitter.Resolver.ResolveNode (memberReferenceExpression.Parent' this.Emitter) as CSharpInvocationResolveResult;  	if (i_rr != null && !i_rr.IsExpandedForm) {  		var tpl = this.Emitter.GetAttribute (member.Member.Attributes' JS.NS.BRIDGE + ".TemplateAttribute");  		if (tpl != null && tpl.PositionalArguments.Count == 2) {  			inline = tpl.PositionalArguments [1].ConstantValue.ToString ();  		}  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (i_rr != null && !i_rr.IsExpandedForm) {  	var tpl = this.Emitter.GetAttribute (member.Member.Attributes' JS.NS.BRIDGE + ".TemplateAttribute");  	if (tpl != null && tpl.PositionalArguments.Count == 2) {  		inline = tpl.PositionalArguments [1].ConstantValue.ToString ();  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (tpl != null && tpl.PositionalArguments.Count == 2) {  	inline = tpl.PositionalArguments [1].ConstantValue.ToString ();  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasInline && inline.StartsWith ("<self>")) {  	hasThis = true;  	inline = inline.Substring (6);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: inline = inline.Substring (6);  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasThis) {  	this.Write ("");  	var oldBuilder = this.Emitter.Output;  	var oldInline = inline;  	string thisArg = null;  	bool isSimple = true;  	if (this.MemberReferenceExpression.Target is BaseReferenceExpression) {  		thisArg = "this";  	}  	else {  		this.Emitter.Output = new StringBuilder ();  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		this.WriteSimpleTarget (resolveResult);  		if (isConstTarget) {  			this.Write (")");  		}  		thisArg = this.Emitter.Output.ToString ();  		if (Regex.Matches (inline' @"\{(\*?)this(\:(\w+))?\}").Count > 1) {  			var mrr = resolveResult as MemberResolveResult;  			bool isField = mrr != null && mrr.Member is IField && (mrr.TargetResult is ThisResolveResult || mrr.TargetResult is LocalResolveResult);  			isSimple = (mrr != null && (mrr.TargetResult is ThisResolveResult || mrr.TargetResult is ConstantResolveResult || mrr.TargetResult is LocalResolveResult)) || isField;  		}  	}  	int thisIndex;  	if (!isSimple) {  		StringBuilder sb = new StringBuilder ();  		sb.Append ("(");  		var tempVar = this.GetTempVarName ();  		inline = inline.Replace ("{this}"' tempVar);  		thisIndex = tempVar.Length + 2;  		sb.Append (tempVar);  		sb.Append ("=");  		sb.Append (thisArg);  		sb.Append ("' ");  		sb.Append (inline);  		sb.Append (")");  		inline = sb.ToString ();  	}  	else {  		thisIndex = inline.IndexOf ("{this}"' StringComparison.Ordinal);  		inline = inline.Replace ("{this}"' thisArg);  	}  	if (member != null && member.Member is IProperty) {  		this.Emitter.Output = new StringBuilder ();  		inline = inline.Replace ("{0}"' "[[0]]");  		new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		inline = this.Emitter.Output.ToString ();  		inline = inline.Replace ("[[0]]"' "{0}");  	}  	this.Emitter.IsAssignment = oldIsAssignment;  	this.Emitter.IsUnaryAccessor = oldUnary;  	this.Emitter.Output = oldBuilder;  	int[] range = null;  	if (thisIndex > -1) {  		range = new[] {  			thisIndex'  			thisIndex + thisArg.Length  		};  	}  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline' null' thisArg' range);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' oldInline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			this.Write (inline);  		}  	}  	return;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (!isSimple) {  	StringBuilder sb = new StringBuilder ();  	sb.Append ("(");  	var tempVar = this.GetTempVarName ();  	inline = inline.Replace ("{this}"' tempVar);  	thisIndex = tempVar.Length + 2;  	sb.Append (tempVar);  	sb.Append ("=");  	sb.Append (thisArg);  	sb.Append ("' ");  	sb.Append (inline);  	sb.Append (")");  	inline = sb.ToString ();  }  else {  	thisIndex = inline.IndexOf ("{this}"' StringComparison.Ordinal);  	inline = inline.Replace ("{this}"' thisArg);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: thisIndex = tempVar.Length + 2;  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)) {  	var parentExpression = memberReferenceExpression.Parent as MemberReferenceExpression;  	bool wrap = false;  	if (parentExpression != null) {  		var ii = this.Emitter.GetInlineCode (parentExpression);  		if (string.IsNullOrEmpty (ii.Item3)) {  			wrap = true;  			this.WriteOpenParentheses ();  		}  	}  	this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  	if (wrap) {  		this.WriteCloseParentheses ();  	}  }  else if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)) {  	var parentExpression = memberReferenceExpression.Parent as MemberReferenceExpression;  	bool wrap = false;  	if (parentExpression != null) {  		var ii = this.Emitter.GetInlineCode (parentExpression);  		if (string.IsNullOrEmpty (ii.Item3)) {  			wrap = true;  			this.WriteOpenParentheses ();  		}  	}  	this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  	if (wrap) {  		this.WriteCloseParentheses ();  	}  }  else if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)) {  	var parentExpression = memberReferenceExpression.Parent as MemberReferenceExpression;  	bool wrap = false;  	if (parentExpression != null) {  		var ii = this.Emitter.GetInlineCode (parentExpression);  		if (string.IsNullOrEmpty (ii.Item3)) {  			wrap = true;  			this.WriteOpenParentheses ();  		}  	}  	this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  	if (wrap) {  		this.WriteCloseParentheses ();  	}  }  else if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)) {  	var parentExpression = memberReferenceExpression.Parent as MemberReferenceExpression;  	bool wrap = false;  	if (parentExpression != null) {  		var ii = this.Emitter.GetInlineCode (parentExpression);  		if (string.IsNullOrEmpty (ii.Item3)) {  			wrap = true;  			this.WriteOpenParentheses ();  		}  	}  	this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  	if (wrap) {  		this.WriteCloseParentheses ();  	}  }  else if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)) {  	var parentExpression = memberReferenceExpression.Parent as MemberReferenceExpression;  	bool wrap = false;  	if (parentExpression != null) {  		var ii = this.Emitter.GetInlineCode (parentExpression);  		if (string.IsNullOrEmpty (ii.Item3)) {  			wrap = true;  			this.WriteOpenParentheses ();  		}  	}  	this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  	if (wrap) {  		this.WriteCloseParentheses ();  	}  }  else if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)) {  	var parentExpression = memberReferenceExpression.Parent as MemberReferenceExpression;  	bool wrap = false;  	if (parentExpression != null) {  		var ii = this.Emitter.GetInlineCode (parentExpression);  		if (string.IsNullOrEmpty (ii.Item3)) {  			wrap = true;  			this.WriteOpenParentheses ();  		}  	}  	this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  	if (wrap) {  		this.WriteCloseParentheses ();  	}  }  else if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.Member.SymbolKind == SymbolKind.Field && this.Emitter.IsMemberConst (member.Member) && this.Emitter.IsInlineConst (member.Member)) {  	var parentExpression = memberReferenceExpression.Parent as MemberReferenceExpression;  	bool wrap = false;  	if (parentExpression != null) {  		var ii = this.Emitter.GetInlineCode (parentExpression);  		if (string.IsNullOrEmpty (ii.Item3)) {  			wrap = true;  			this.WriteOpenParentheses ();  		}  	}  	this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  	if (wrap) {  		this.WriteCloseParentheses ();  	}  }  else if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (hasInline && member.Member.IsStatic) {  	if (resolveResult is InvocationResolveResult) {  		this.PushWriter (inline);  	}  	else {  		if (member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline).Emit ();  		}  	}  }  else {  	if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  		var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  		if (typeDef != null) {  			var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  			if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  				this.WriteScript (member.ConstantValue);  				return;  			}  			if (enumMode >= 3 && enumMode < 7) {  				string enumStringName = member.Member.Name;  				var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  				if (attr != null) {  					enumStringName = this.Emitter.GetEntityName (member.Member);  				}  				else {  					switch (enumMode) {  					case 3:  						enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  						break;  					case 4:  						break;  					case 5:  						enumStringName = enumStringName.ToLowerInvariant ();  						break;  					case 6:  						enumStringName = enumStringName.ToUpperInvariant ();  						break;  					}  				}  				this.WriteScript (enumStringName);  				return;  			}  		}  	}  	if (resolveResult is TypeResolveResult) {  		TypeResolveResult typeResolveResult = (TypeResolveResult)resolveResult;  		this.Write (BridgeTypes.ToJsName (typeResolveResult.Type' this.Emitter));  		return;  	}  	else if (member != null && member.Member is IMethod && !(member is InvocationResolveResult) && !(memberReferenceExpression.Parent is InvocationExpression && memberReferenceExpression.NextSibling != null && memberReferenceExpression.NextSibling.Role is TokenRole && ((TokenRole)memberReferenceExpression.NextSibling.Role).Token == "(")) {  		if (!string.IsNullOrEmpty (inline)) {  			if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  				new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  			}  			else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  				this.PushWriter (inline);  			}  			else {  				this.Write (inline);  			}  		}  		else {  			var resolvedMethod = (IMethod)member.Member;  			bool isStatic = resolvedMethod != null && resolvedMethod.IsStatic;  			var isExtensionMethod = resolvedMethod.IsExtensionMethod;  			this.Emitter.IsAssignment = false;  			this.Emitter.IsUnaryAccessor = false;  			if (!isStatic) {  				this.Write (isExtensionMethod ? JS.Funcs.BRIDGE_BIND_SCOPE : JS.Funcs.BRIDGE_BIND);  				this.WriteOpenParentheses ();  				if (memberReferenceExpression.Target is BaseReferenceExpression) {  					this.WriteThis ();  				}  				else {  					interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' false);  				}  				this.Write ("' ");  			}  			this.Emitter.IsAssignment = oldIsAssignment;  			this.Emitter.IsUnaryAccessor = oldUnary;  			if (isExtensionMethod) {  				this.Write (BridgeTypes.ToJsName (resolvedMethod.DeclaringType' this.Emitter));  			}  			else {  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				if (isConstTarget) {  					this.Write ("(");  				}  				if (interfaceTempVar != null) {  					this.Write (interfaceTempVar);  				}  				else {  					this.WriteSimpleTarget (resolveResult);  				}  				if (isConstTarget) {  					this.Write (")");  				}  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  			}  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar' member' false);  			}  			else {  				this.WriteDot ();  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  			if (!isStatic) {  				this.Write (")");  			}  		}  		return;  	}  	else {  		bool isProperty = false;  		if (member != null && member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			isProperty = true;  			bool writeTargetVar = false;  			if (this.Emitter.IsAssignment && this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  				writeTargetVar = true;  			}  			else if (this.Emitter.IsUnaryAccessor) {  				writeTargetVar = true;  				isStatement = memberReferenceExpression.Parent is UnaryOperatorExpression && memberReferenceExpression.Parent.Parent is ExpressionStatement;  				if (NullableType.IsNullable (member.Type)) {  					isStatement = false;  				}  				if (!isStatement) {  					this.WriteOpenParentheses ();  				}  			}  			if (writeTargetVar) {  				bool isField = memberTargetrr != null && memberTargetrr.Member is IField && (memberTargetrr.TargetResult is ThisResolveResult || memberTargetrr.TargetResult is LocalResolveResult);  				if (!(targetrr is ThisResolveResult || targetrr is TypeResolveResult || targetrr is LocalResolveResult || isField)) {  					targetVar = this.GetTempVarName ();  					this.Write (targetVar);  					this.Write (" = ");  				}  			}  		}  		if (isProperty && this.Emitter.IsUnaryAccessor && !isStatement && targetVar == null) {  			valueVar = this.GetTempVarName ();  			this.Write (valueVar);  			this.Write (" = ");  		}  		this.Emitter.IsAssignment = false;  		this.Emitter.IsUnaryAccessor = false;  		if (isConstTarget) {  			this.Write ("(");  		}  		if (targetVar == null && isInterfaceMember) {  			interfaceTempVar = this.WriteTarget (resolveResult' isInterfaceMember' memberTargetrr' targetrr' true);  		}  		else {  			this.WriteSimpleTarget (resolveResult);  		}  		if (member != null && targetrr != null && targetrr.Type.Kind == TypeKind.Delegate && (member.Member.Name == "Invoke")) {  			var method = member.Member as IMethod;  			if (!(method != null && method.IsExtensionMethod)) {  				return;  			}  		}  		if (isConstTarget) {  			this.Write (")");  		}  		this.Emitter.IsAssignment = oldIsAssignment;  		this.Emitter.IsUnaryAccessor = oldUnary;  		if (targetVar != null) {  			if (this.Emitter.IsUnaryAccessor && !isStatement) {  				this.WriteComma (false);  				valueVar = this.GetTempVarName ();  				this.Write (valueVar);  				this.Write (" = ");  				this.Write (targetVar);  			}  			else {  				this.WriteSemiColon ();  				this.WriteNewLine ();  				this.Write (targetVar);  			}  		}  	}  	var targetResolveResult = targetrr as MemberResolveResult;  	if (targetResolveResult == null || this.Emitter.IsGlobalTarget (targetResolveResult.Member) == null) {  		if (isRefArg) {  			this.WriteComma ();  		}  		else if (!isInterfaceMember) {  			this.WriteDot ();  		}  	}  	if (member == null) {  		if (targetrr != null && targetrr.Type.Kind == TypeKind.Dynamic) {  			this.Write (memberReferenceExpression.MemberName);  		}  		else {  			this.Write (memberReferenceExpression.MemberName.ToLowerCamelCase ());  		}  	}  	else if (!string.IsNullOrEmpty (inline)) {  		if (!(resolveResult is InvocationResolveResult) && member != null && member.Member is IMethod) {  			new InlineArgumentsBlock (this.Emitter' new ArgumentsInfo (this.Emitter' memberReferenceExpression' resolveResult)' inline' (IMethod)member.Member' targetrr).EmitFunctionReference ();  		}  		else if (resolveResult is InvocationResolveResult || (member.Member.SymbolKind == SymbolKind.Property && this.Emitter.IsAssignment)) {  			this.PushWriter (inline);  		}  		else {  			this.Write (inline);  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Property && member.TargetResult.Type.Kind != TypeKind.Anonymous && (!this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition) || member.Member.IsStatic)) {  		var proto = false;  		if (this.MemberReferenceExpression.Target is BaseReferenceExpression && member != null) {  			var prop = member.Member as IProperty;  			if (prop != null && (prop.IsVirtual || prop.IsOverride)) {  				proto = true;  			}  		}  		bool isFieldProperty = Helpers.IsFieldProperty (member.Member' this.Emitter);  		if (isFieldProperty) {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && !member.Member.ImplementedInterfaceMembers.All (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is marked as FieldProperty but implemented interface member has no such attribute"' member.Member.ToString ()));  			}  		}  		else {  			if (member.Member.ImplementedInterfaceMembers.Count > 0 && member.Member.ImplementedInterfaceMembers.Any (m => Helpers.IsFieldProperty (m' this.Emitter))) {  				throw new EmitterException (memberReferenceExpression' string.Format ("The property {0} is not marked as FieldProperty but implemented interface member has such attribute"' member.Member.ToString ()));  			}  		}  		if (member.Member is IProperty && targetrr != null && targetrr.Type.GetDefinition () != null && this.Emitter.Validator.IsObjectLiteral (targetrr.Type.GetDefinition ()) && !this.Emitter.Validator.IsObjectLiteral (member.Member.DeclaringTypeDefinition)) {  			this.Write (this.Emitter.GetEntityName (member.Member));  		}  		else if (isFieldProperty) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation));  			}  		}  		else if (!this.Emitter.IsAssignment) {  			if (this.Emitter.IsUnaryAccessor) {  				bool isNullable = NullableType.IsNullable (member.Member.ReturnType);  				bool isDecimal = Helpers.IsDecimalType (member.Member.ReturnType' this.Emitter.Resolver);  				bool isLong = Helpers.Is64Type (member.Member.ReturnType' this.Emitter.Resolver);  				if (isStatement) {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							if (targetVar != null) {  								this.Write (targetVar);  							}  							else if (interfaceTempVar != null) {  								this.Write (interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteCloseParentheses ();  						}  						else {  							if (targetVar != null || interfaceTempVar != null) {  								this.Write (targetVar ?? interfaceTempVar);  							}  							else {  								this.WriteSimpleTarget (resolveResult);  							}  							if (isInterfaceMember) {  								this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  							}  							else {  								this.WriteDot ();  								this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  							}  							if (proto) {  								this.WriteCall ();  								this.WriteOpenParentheses ();  								this.WriteThis ();  								this.WriteCloseParentheses ();  							}  							else {  								this.WriteOpenParentheses ();  								this.WriteCloseParentheses ();  							}  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							if (isConstTarget) {  								this.Write ("(");  							}  							this.WriteSimpleTarget (resolveResult);  							if (isConstTarget) {  								this.Write (")");  							}  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						if (proto) {  							this.WriteCall ();  							this.WriteOpenParentheses ();  							this.WriteThis ();  							this.WriteCloseParentheses ();  						}  						else {  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  						this.WriteCloseParentheses ();  					}  				}  				else {  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  					}  					else {  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteCloseParentheses ();  					}  					else {  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					this.WriteComma ();  					if (targetVar != null || interfaceTempVar != null) {  						this.Write (targetVar ?? interfaceTempVar);  					}  					else {  						if (isConstTarget) {  							this.Write ("(");  						}  						this.WriteSimpleTarget (resolveResult);  						if (isConstTarget) {  							this.Write (")");  						}  					}  					if (isInterfaceMember) {  						this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  					}  					else {  						this.WriteDot ();  						this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation));  					}  					if (proto) {  						this.WriteCall ();  						this.WriteOpenParentheses ();  						this.WriteThis ();  						this.WriteComma ();  					}  					else {  						this.WriteOpenParentheses ();  					}  					if (isDecimal || isLong) {  						if (isNullable) {  							this.Write (JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1);  							this.WriteOpenParentheses ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.WriteScript (JS.Funcs.Math.INC);  							}  							else {  								this.WriteScript (JS.Funcs.Math.DEC);  							}  							this.WriteComma ();  							this.Write (valueVar);  							this.WriteCloseParentheses ();  						}  						else {  							this.Write (valueVar);  							this.WriteDot ();  							if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  								this.Write (JS.Funcs.Math.INC);  							}  							else {  								this.Write (JS.Funcs.Math.DEC);  							}  							this.WriteOpenParentheses ();  							this.WriteCloseParentheses ();  						}  					}  					else {  						this.Write (valueVar);  						if (this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.PostIncrement) {  							this.Write ("+");  						}  						else {  							this.Write ("-");  						}  						this.Write ("1");  					}  					this.WriteCloseParentheses ();  					this.WriteComma ();  					bool isPreOp = this.Emitter.UnaryOperatorType == UnaryOperatorType.Increment || this.Emitter.UnaryOperatorType == UnaryOperatorType.Decrement;  					if (isPreOp) {  						if (targetVar != null || interfaceTempVar != null) {  							this.Write (targetVar ?? interfaceTempVar);  						}  						else {  							this.WriteSimpleTarget (resolveResult);  						}  						if (isInterfaceMember) {  							this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  						}  						else {  							this.WriteDot ();  							this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation));  						}  						this.WriteOpenParentheses ();  						this.WriteCloseParentheses ();  					}  					else {  						this.Write (valueVar);  					}  					this.WriteCloseParentheses ();  					if (valueVar != null) {  						this.RemoveTempVar (valueVar);  					}  				}  				if (targetVar != null) {  					this.RemoveTempVar (targetVar);  				}  			}  			else {  				if (isInterfaceMember) {  					this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				}  				else {  					this.Write (Helpers.GetPropertyRef (member.Member' this.Emitter' ignoreInterface: !nativeImplementation));  				}  				if (proto) {  					this.WriteCall ();  					this.WriteOpenParentheses ();  					this.WriteThis ();  					this.WriteCloseParentheses ();  				}  				else {  					this.WriteOpenParentheses ();  					this.WriteCloseParentheses ();  				}  			}  		}  		else if (this.Emitter.AssignmentType != AssignmentOperatorType.Assign) {  			string memberStr;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				memberStr = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				memberStr = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			string getterMember;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false' JS.Funcs.Property.GET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				getterMember = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				getterMember = "." + Helpers.GetPropertyRef (member.Member' this.Emitter' false' ignoreInterface: !nativeImplementation);  			}  			if (targetVar != null) {  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' targetVar' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})")' () =>  {  					this.RemoveTempVar (targetVar);  				});  			}  			else {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteSimpleTarget (resolveResult);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				var trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  				this.PushWriter (string.Concat (memberStr' proto ? "." + JS.Funcs.CALL + "(this' " : "("' trg' getterMember' proto ? "." + JS.Funcs.CALL + "(this)" : "()"' "{0})"));  			}  		}  		else {  			string trg;  			if (isInterfaceMember) {  				var oldWriter = this.SaveWriter ();  				this.NewWriter ();  				this.Emitter.IsAssignment = false;  				this.Emitter.IsUnaryAccessor = false;  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' true' JS.Funcs.Property.SET);  				this.Emitter.IsAssignment = oldIsAssignment;  				this.Emitter.IsUnaryAccessor = oldUnary;  				trg = this.Emitter.Output.ToString ();  				this.RestoreWriter (oldWriter);  			}  			else {  				trg = Helpers.GetPropertyRef (member.Member' this.Emitter' true' ignoreInterface: !nativeImplementation);  			}  			this.PushWriter (trg + (proto ? ".call(this' {0})" : "({0})"));  		}  	}  	else if (member.Member.SymbolKind == SymbolKind.Field) {  		bool isConst = this.Emitter.IsMemberConst (member.Member);  		if (isConst && this.Emitter.IsInlineConst (member.Member)) {  			this.WriteScript (Bridge.Translator.Emitter.ConvertConstant (member.ConstantValue' memberReferenceExpression' this.Emitter));  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				var fieldName = OverloadsCollection.Create (this.Emitter' member.Member).GetOverloadName (!nativeImplementation);  				if (isRefArg) {  					this.WriteScript (fieldName);  				}  				else {  					this.Write (fieldName);  				}  			}  		}  	}  	else if (resolveResult is InvocationResolveResult) {  		InvocationResolveResult invocationResult = (InvocationResolveResult)resolveResult;  		CSharpInvocationResolveResult cInvocationResult = (CSharpInvocationResolveResult)resolveResult;  		var expresssionMember = expressionResolveResult as MemberResolveResult;  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else if (expresssionMember != null && cInvocationResult != null && cInvocationResult.IsDelegateInvocation && invocationResult.Member != expresssionMember.Member) {  			this.Write (OverloadsCollection.Create (this.Emitter' expresssionMember.Member).GetOverloadName (!nativeImplementation));  		}  		else {  			this.Write (OverloadsCollection.Create (this.Emitter' invocationResult.Member).GetOverloadName (!nativeImplementation));  		}  	}  	else if (member.Member is DefaultResolvedEvent) {  		if (this.Emitter.IsAssignment && (this.Emitter.AssignmentType == AssignmentOperatorType.Add || this.Emitter.AssignmentType == AssignmentOperatorType.Subtract)) {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' this.Emitter.AssignmentType == AssignmentOperatorType.Subtract' Helpers.GetAddOrRemove (this.Emitter.AssignmentType == AssignmentOperatorType.Add));  			}  			else {  				this.Write (Helpers.GetEventRef (member.Member' this.Emitter' this.Emitter.AssignmentType != AssignmentOperatorType.Add' ignoreInterface: !nativeImplementation));  			}  			this.WriteOpenParentheses ();  		}  		else {  			if (isInterfaceMember) {  				this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  			}  			else {  				this.Write (this.Emitter.GetEntityName (member.Member' true' ignoreInterface: !nativeImplementation));  			}  		}  	}  	else {  		if (isInterfaceMember) {  			this.WriteInterfaceMember (interfaceTempVar ?? targetVar' member' false);  		}  		else {  			this.Write (this.Emitter.GetEntityName (member.Member' ignoreInterface: !nativeImplementation));  		}  	}  	Helpers.CheckValueTypeClone (resolveResult' memberReferenceExpression' this' pos);  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  		if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			this.WriteScript (member.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = member.Member.Name;  			var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = this.Emitter.GetEntityName (member.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			this.WriteScript (enumStringName);  			return;  		}  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  		if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			this.WriteScript (member.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = member.Member.Name;  			var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = this.Emitter.GetEntityName (member.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			this.WriteScript (enumStringName);  			return;  		}  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  		if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			this.WriteScript (member.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = member.Member.Name;  			var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = this.Emitter.GetEntityName (member.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			this.WriteScript (enumStringName);  			return;  		}  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  		if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			this.WriteScript (member.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = member.Member.Name;  			var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = this.Emitter.GetEntityName (member.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			this.WriteScript (enumStringName);  			return;  		}  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  		if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			this.WriteScript (member.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = member.Member.Name;  			var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = this.Emitter.GetEntityName (member.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			this.WriteScript (enumStringName);  			return;  		}  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  		if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			this.WriteScript (member.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = member.Member.Name;  			var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = this.Emitter.GetEntityName (member.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			this.WriteScript (enumStringName);  			return;  		}  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (member != null && member.IsCompileTimeConstant && member.Member.DeclaringType.Kind == TypeKind.Enum) {  	var typeDef = member.Member.DeclaringType as DefaultResolvedTypeDefinition;  	if (typeDef != null) {  		var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  		if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  			this.WriteScript (member.ConstantValue);  			return;  		}  		if (enumMode >= 3 && enumMode < 7) {  			string enumStringName = member.Member.Name;  			var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  			if (attr != null) {  				enumStringName = this.Emitter.GetEntityName (member.Member);  			}  			else {  				switch (enumMode) {  				case 3:  					enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  					break;  				case 4:  					break;  				case 5:  					enumStringName = enumStringName.ToLowerInvariant ();  					break;  				case 6:  					enumStringName = enumStringName.ToUpperInvariant ();  					break;  				}  			}  			this.WriteScript (enumStringName);  			return;  		}  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  	if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		this.WriteScript (member.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = this.Emitter.GetEntityName (member.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		this.WriteScript (enumStringName);  		return;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  	if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		this.WriteScript (member.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = this.Emitter.GetEntityName (member.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		this.WriteScript (enumStringName);  		return;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  	if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		this.WriteScript (member.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = this.Emitter.GetEntityName (member.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		this.WriteScript (enumStringName);  		return;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  	if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		this.WriteScript (member.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = this.Emitter.GetEntityName (member.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		this.WriteScript (enumStringName);  		return;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  	if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		this.WriteScript (member.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = this.Emitter.GetEntityName (member.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		this.WriteScript (enumStringName);  		return;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  	if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		this.WriteScript (member.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = this.Emitter.GetEntityName (member.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		this.WriteScript (enumStringName);  		return;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (typeDef != null) {  	var enumMode = this.Emitter.Validator.EnumEmitMode (typeDef);  	if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  		this.WriteScript (member.ConstantValue);  		return;  	}  	if (enumMode >= 3 && enumMode < 7) {  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			enumStringName = this.Emitter.GetEntityName (member.Member);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  		}  		this.WriteScript (enumStringName);  		return;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if ((this.Emitter.Validator.IsIgnoreType (typeDef) && enumMode == -1) || enumMode == 2) {  	this.WriteScript (member.ConstantValue);  	return;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = this.Emitter.GetEntityName (member.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	this.WriteScript (enumStringName);  	return;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = this.Emitter.GetEntityName (member.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	this.WriteScript (enumStringName);  	return;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = this.Emitter.GetEntityName (member.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	this.WriteScript (enumStringName);  	return;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = this.Emitter.GetEntityName (member.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	this.WriteScript (enumStringName);  	return;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = this.Emitter.GetEntityName (member.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	this.WriteScript (enumStringName);  	return;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		enumStringName = this.Emitter.GetEntityName (member.Member);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  	}  	this.WriteScript (enumStringName);  	return;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (attr != null) {  	enumStringName = this.Emitter.GetEntityName (member.Member);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (attr != null) {  	enumStringName = this.Emitter.GetEntityName (member.Member);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (attr != null) {  	enumStringName = this.Emitter.GetEntityName (member.Member);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: if (attr != null) {  	enumStringName = this.Emitter.GetEntityName (member.Member);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,ConvertVarianceToInt,The following statement contains a magic number: switch (variance) {  case VarianceModifier.Covariant:  	return 1;  case VarianceModifier.Contravariant:  	return 2;  default:  	return 0;  }  
Magic Number,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,ConvertVarianceToInt,The following statement contains a magic number: return 2;  
Magic Number,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,EmitInstantiableBlock,The following statement contains a magic number: if (this.TypeInfo.IsEnum) {  	if (this.Emitter.GetTypeDefinition (this.TypeInfo.Type).CustomAttributes.Any (attr => attr.AttributeType.FullName == "System.FlagsAttribute")) {  		this.EnsureComma ();  		this.Write (JS.Fields.FLAGS + ": true");  		this.Emitter.Comma = true;  	}  	var etype = this.TypeInfo.Type.GetDefinition ().EnumUnderlyingType;  	var enumMode = this.Emitter.Validator.EnumEmitMode (this.TypeInfo.Type);  	var isString = enumMode >= 3 && enumMode <= 6;  	if (!etype.IsKnownType (KnownTypeCode.Int32) || isString) {  		this.EnsureComma ();  		this.Write (JS.Fields.UNDERLYINGTYPE + ": ");  		this.Write (isString ? "System.String" : BridgeTypes.ToJsName (etype' this.Emitter));  		this.Emitter.Comma = true;  	}  }  
Magic Number,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,EmitInstantiableBlock,The following statement contains a magic number: if (this.TypeInfo.IsEnum) {  	if (this.Emitter.GetTypeDefinition (this.TypeInfo.Type).CustomAttributes.Any (attr => attr.AttributeType.FullName == "System.FlagsAttribute")) {  		this.EnsureComma ();  		this.Write (JS.Fields.FLAGS + ": true");  		this.Emitter.Comma = true;  	}  	var etype = this.TypeInfo.Type.GetDefinition ().EnumUnderlyingType;  	var enumMode = this.Emitter.Validator.EnumEmitMode (this.TypeInfo.Type);  	var isString = enumMode >= 3 && enumMode <= 6;  	if (!etype.IsKnownType (KnownTypeCode.Int32) || isString) {  		this.EnsureComma ();  		this.Write (JS.Fields.UNDERLYINGTYPE + ": ");  		this.Write (isString ? "System.String" : BridgeTypes.ToJsName (etype' this.Emitter));  		this.Emitter.Comma = true;  	}  }  
Magic Number,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,GetDefineMethods,The following statement contains a magic number: switch (prefix) {  case "After":  	value = 0;  	break;  case "Before":  	value = 1;  	break;  case "Top":  	value = 2;  	break;  case "Bottom":  	value = 3;  	break;  }  
Magic Number,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,GetDefineMethods,The following statement contains a magic number: switch (prefix) {  case "After":  	value = 0;  	break;  case "Before":  	value = 1;  	break;  case "Top":  	value = 2;  	break;  case "Bottom":  	value = 3;  	break;  }  
Magic Number,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,GetDefineMethods,The following statement contains a magic number: value = 2;  
Magic Number,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,GetDefineMethods,The following statement contains a magic number: value = 3;  
Magic Number,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The following statement contains a magic number: if (castToEnum) {  	itype = enumType.GetDefinition ().EnumUnderlyingType;  	var enumMode = this.Emitter.Validator.EnumEmitMode (enumType);  	if (enumMode >= 3 && enumMode < 7) {  		itype = this.Emitter.Resolver.Compilation.FindType (KnownTypeCode.String);  	}  }  
Magic Number,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The following statement contains a magic number: if (castToEnum) {  	itype = enumType.GetDefinition ().EnumUnderlyingType;  	var enumMode = this.Emitter.Validator.EnumEmitMode (enumType);  	if (enumMode >= 3 && enumMode < 7) {  		itype = this.Emitter.Resolver.Compilation.FindType (KnownTypeCode.String);  	}  }  
Magic Number,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	itype = this.Emitter.Resolver.Compilation.FindType (KnownTypeCode.String);  }  
Magic Number,Bridge.Translator,CastBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\CastBlock.cs,EmitCastExpression,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	itype = this.Emitter.Resolver.Compilation.FindType (KnownTypeCode.String);  }  
Magic Number,Bridge.Translator,ExpressionListBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionListBlock.cs,EmitExpressionList,The following statement contains a magic number: if (paramArg != null && expandParams) {  	var resolveResult = this.Emitter.Resolver.ResolveNode (paramArg' this.Emitter);  	if (resolveResult.Type.Kind == TypeKind.Array && !(paramArg is ArrayCreateExpression) && expressions.Last () == paramArg) {  		bool needConcat = expressions.Count () > 1;  		if (this.InvocationExpression is ObjectCreateExpression) {  			if (needConcat) {  				this.Write ("[");  			}  		}  		else {  			var scope = "null";  			if (this.InvocationExpression != null) {  				var rr = this.Emitter.Resolver.ResolveNode (this.InvocationExpression' this.Emitter) as MemberResolveResult;  				if (rr != null && !rr.Member.IsStatic && this.InvocationExpression is InvocationExpression) {  					var oldWriter = this.SaveWriter ();  					var sb = this.NewWriter ();  					var target = ((InvocationExpression)this.InvocationExpression).Target;  					if (target is MemberReferenceExpression) {  						target = ((MemberReferenceExpression)target).Target;  					}  					else if (target is IdentifierExpression) {  						target = new ThisReferenceExpression ();  					}  					target.AcceptVisitor (this.Emitter);  					scope = sb.ToString ();  					this.RestoreWriter (oldWriter);  				}  			}  			var pos = this.OpenBracketPosition;  			this.Emitter.Output.Insert (pos' "." + JS.Funcs.APPLY);  			pos += 7;  			this.Emitter.Output.Insert (pos' scope + "' " + (needConcat ? "[" : ""));  		}  		isApply = needConcat;  	}  }  
Magic Number,Bridge.Translator,ExpressionListBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionListBlock.cs,EmitExpressionList,The following statement contains a magic number: if (resolveResult.Type.Kind == TypeKind.Array && !(paramArg is ArrayCreateExpression) && expressions.Last () == paramArg) {  	bool needConcat = expressions.Count () > 1;  	if (this.InvocationExpression is ObjectCreateExpression) {  		if (needConcat) {  			this.Write ("[");  		}  	}  	else {  		var scope = "null";  		if (this.InvocationExpression != null) {  			var rr = this.Emitter.Resolver.ResolveNode (this.InvocationExpression' this.Emitter) as MemberResolveResult;  			if (rr != null && !rr.Member.IsStatic && this.InvocationExpression is InvocationExpression) {  				var oldWriter = this.SaveWriter ();  				var sb = this.NewWriter ();  				var target = ((InvocationExpression)this.InvocationExpression).Target;  				if (target is MemberReferenceExpression) {  					target = ((MemberReferenceExpression)target).Target;  				}  				else if (target is IdentifierExpression) {  					target = new ThisReferenceExpression ();  				}  				target.AcceptVisitor (this.Emitter);  				scope = sb.ToString ();  				this.RestoreWriter (oldWriter);  			}  		}  		var pos = this.OpenBracketPosition;  		this.Emitter.Output.Insert (pos' "." + JS.Funcs.APPLY);  		pos += 7;  		this.Emitter.Output.Insert (pos' scope + "' " + (needConcat ? "[" : ""));  	}  	isApply = needConcat;  }  
Magic Number,Bridge.Translator,ExpressionListBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionListBlock.cs,EmitExpressionList,The following statement contains a magic number: if (this.InvocationExpression is ObjectCreateExpression) {  	if (needConcat) {  		this.Write ("[");  	}  }  else {  	var scope = "null";  	if (this.InvocationExpression != null) {  		var rr = this.Emitter.Resolver.ResolveNode (this.InvocationExpression' this.Emitter) as MemberResolveResult;  		if (rr != null && !rr.Member.IsStatic && this.InvocationExpression is InvocationExpression) {  			var oldWriter = this.SaveWriter ();  			var sb = this.NewWriter ();  			var target = ((InvocationExpression)this.InvocationExpression).Target;  			if (target is MemberReferenceExpression) {  				target = ((MemberReferenceExpression)target).Target;  			}  			else if (target is IdentifierExpression) {  				target = new ThisReferenceExpression ();  			}  			target.AcceptVisitor (this.Emitter);  			scope = sb.ToString ();  			this.RestoreWriter (oldWriter);  		}  	}  	var pos = this.OpenBracketPosition;  	this.Emitter.Output.Insert (pos' "." + JS.Funcs.APPLY);  	pos += 7;  	this.Emitter.Output.Insert (pos' scope + "' " + (needConcat ? "[" : ""));  }  
Magic Number,Bridge.Translator,ExpressionListBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ExpressionListBlock.cs,EmitExpressionList,The following statement contains a magic number: pos += 7;  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,ReplaceInlineArgs,The following statement contains a magic number: inline = _formatArg.Replace (inline' delegate (Match m) {  	int count = emitter.Writers.Count;  	string key = m.Groups [2].Value;  	string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  	StringBuilder oldSb = emitter.Output;  	emitter.Output = new StringBuilder ();  	Expression expr = null;  	if (Regex.IsMatch (key' "^\\d+$")) {  		expr = args.Skip (int.Parse (key)).FirstOrDefault ();  	}  	else {  		expr = args.FirstOrDefault (e => e.ToString () == key);  	}  	string s = "";  	if (expr != null) {  		var writer = block.SaveWriter ();  		block.NewWriter ();  		expr.AcceptVisitor (emitter);  		s = emitter.Output.ToString ();  		block.RestoreWriter (writer);  		if (modifier == "raw") {  			s = s.Trim ('"');  		}  	}  	block.Write (block.WriteIndentToString (s));  	if (emitter.Writers.Count != count) {  		block.PopWriter ();  	}  	string replacement = emitter.Output.ToString ();  	emitter.Output = oldSb;  	return replacement;  });  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,ReplaceInlineArgs,The following statement contains a magic number: inline = _formatArg.Replace (inline' delegate (Match m) {  	int count = emitter.Writers.Count;  	string key = m.Groups [2].Value;  	string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  	StringBuilder oldSb = emitter.Output;  	emitter.Output = new StringBuilder ();  	Expression expr = null;  	if (Regex.IsMatch (key' "^\\d+$")) {  		expr = args.Skip (int.Parse (key)).FirstOrDefault ();  	}  	else {  		expr = args.FirstOrDefault (e => e.ToString () == key);  	}  	string s = "";  	if (expr != null) {  		var writer = block.SaveWriter ();  		block.NewWriter ();  		expr.AcceptVisitor (emitter);  		s = emitter.Output.ToString ();  		block.RestoreWriter (writer);  		if (modifier == "raw") {  			s = s.Trim ('"');  		}  	}  	block.Write (block.WriteIndentToString (s));  	if (emitter.Writers.Count != count) {  		block.PopWriter ();  	}  	string replacement = emitter.Output.ToString ();  	emitter.Output = oldSb;  	return replacement;  });  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (paramsName != null) {  	var matches = _formatArg.Matches (inline);  	bool ignoreArray = false;  	foreach (Match m in matches) {  		if (m.Groups [2].Value == paramsName) {  			bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  			ignoreArray = isRaw || argsInfo.ParamsExpression == null;  			string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  			if (modifier == "array") {  				ignoreArray = false;  			}  			break;  		}  	}  	if (expandParams) {  		ignoreArray = true;  	}  	if (argsInfo.ResolveResult is CSharpInvocationResolveResult) {  		needExpand = !((CSharpInvocationResolveResult)argsInfo.ResolveResult).IsExpandedForm;  	}  	if (needExpand && ignoreArray && !asRef) {  		IList<Expression> exprs = this.GetExpressionsByKey (expressions' paramsName);  		if (exprs.Count == 1 && exprs [0] != null && exprs [0].Parent != null) {  			var exprrr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  			if (exprrr.Type.Kind == TypeKind.Array) {  				var match = _inlineMethod.Match (inline);  				if (match.Success) {  					string target = null;  					var methodName = match.Groups [1].Value;  					if (methodName.Contains (".")) {  						target = methodName.LeftOfRightmostOf ('.');  					}  					string args = match.Groups [2].Value;  					StringBuilder sb = new StringBuilder ();  					sb.Append (methodName);  					sb.Append (".");  					sb.Append (JS.Funcs.APPLY);  					sb.Append ("(");  					sb.Append (target ?? "null");  					if (args.Contains ("'")) {  						sb.Append ("' [");  						sb.Append (args.LeftOfRightmostOf (''').Trim ());  						sb.Append ("].concat(");  						sb.Append (args.RightOfRightmostOf (''').Trim ());  						sb.Append (")");  					}  					else {  						sb.Append ("'");  						sb.Append (args);  					}  					sb.Append (")");  					inline = inline.Remove (match.Index' match.Length);  					inline = inline.Insert (match.Index' sb.ToString ());  				}  			}  		}  	}  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (paramsName != null) {  	var matches = _formatArg.Matches (inline);  	bool ignoreArray = false;  	foreach (Match m in matches) {  		if (m.Groups [2].Value == paramsName) {  			bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  			ignoreArray = isRaw || argsInfo.ParamsExpression == null;  			string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  			if (modifier == "array") {  				ignoreArray = false;  			}  			break;  		}  	}  	if (expandParams) {  		ignoreArray = true;  	}  	if (argsInfo.ResolveResult is CSharpInvocationResolveResult) {  		needExpand = !((CSharpInvocationResolveResult)argsInfo.ResolveResult).IsExpandedForm;  	}  	if (needExpand && ignoreArray && !asRef) {  		IList<Expression> exprs = this.GetExpressionsByKey (expressions' paramsName);  		if (exprs.Count == 1 && exprs [0] != null && exprs [0].Parent != null) {  			var exprrr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  			if (exprrr.Type.Kind == TypeKind.Array) {  				var match = _inlineMethod.Match (inline);  				if (match.Success) {  					string target = null;  					var methodName = match.Groups [1].Value;  					if (methodName.Contains (".")) {  						target = methodName.LeftOfRightmostOf ('.');  					}  					string args = match.Groups [2].Value;  					StringBuilder sb = new StringBuilder ();  					sb.Append (methodName);  					sb.Append (".");  					sb.Append (JS.Funcs.APPLY);  					sb.Append ("(");  					sb.Append (target ?? "null");  					if (args.Contains ("'")) {  						sb.Append ("' [");  						sb.Append (args.LeftOfRightmostOf (''').Trim ());  						sb.Append ("].concat(");  						sb.Append (args.RightOfRightmostOf (''').Trim ());  						sb.Append (")");  					}  					else {  						sb.Append ("'");  						sb.Append (args);  					}  					sb.Append (")");  					inline = inline.Remove (match.Index' match.Length);  					inline = inline.Insert (match.Index' sb.ToString ());  				}  			}  		}  	}  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (paramsName != null) {  	var matches = _formatArg.Matches (inline);  	bool ignoreArray = false;  	foreach (Match m in matches) {  		if (m.Groups [2].Value == paramsName) {  			bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  			ignoreArray = isRaw || argsInfo.ParamsExpression == null;  			string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  			if (modifier == "array") {  				ignoreArray = false;  			}  			break;  		}  	}  	if (expandParams) {  		ignoreArray = true;  	}  	if (argsInfo.ResolveResult is CSharpInvocationResolveResult) {  		needExpand = !((CSharpInvocationResolveResult)argsInfo.ResolveResult).IsExpandedForm;  	}  	if (needExpand && ignoreArray && !asRef) {  		IList<Expression> exprs = this.GetExpressionsByKey (expressions' paramsName);  		if (exprs.Count == 1 && exprs [0] != null && exprs [0].Parent != null) {  			var exprrr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  			if (exprrr.Type.Kind == TypeKind.Array) {  				var match = _inlineMethod.Match (inline);  				if (match.Success) {  					string target = null;  					var methodName = match.Groups [1].Value;  					if (methodName.Contains (".")) {  						target = methodName.LeftOfRightmostOf ('.');  					}  					string args = match.Groups [2].Value;  					StringBuilder sb = new StringBuilder ();  					sb.Append (methodName);  					sb.Append (".");  					sb.Append (JS.Funcs.APPLY);  					sb.Append ("(");  					sb.Append (target ?? "null");  					if (args.Contains ("'")) {  						sb.Append ("' [");  						sb.Append (args.LeftOfRightmostOf (''').Trim ());  						sb.Append ("].concat(");  						sb.Append (args.RightOfRightmostOf (''').Trim ());  						sb.Append (")");  					}  					else {  						sb.Append ("'");  						sb.Append (args);  					}  					sb.Append (")");  					inline = inline.Remove (match.Index' match.Length);  					inline = inline.Insert (match.Index' sb.ToString ());  				}  			}  		}  	}  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: foreach (Match m in matches) {  	if (m.Groups [2].Value == paramsName) {  		bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  		ignoreArray = isRaw || argsInfo.ParamsExpression == null;  		string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  		if (modifier == "array") {  			ignoreArray = false;  		}  		break;  	}  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: foreach (Match m in matches) {  	if (m.Groups [2].Value == paramsName) {  		bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  		ignoreArray = isRaw || argsInfo.ParamsExpression == null;  		string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  		if (modifier == "array") {  			ignoreArray = false;  		}  		break;  	}  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (m.Groups [2].Value == paramsName) {  	bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  	ignoreArray = isRaw || argsInfo.ParamsExpression == null;  	string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  	if (modifier == "array") {  		ignoreArray = false;  	}  	break;  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (m.Groups [2].Value == paramsName) {  	bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  	ignoreArray = isRaw || argsInfo.ParamsExpression == null;  	string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  	if (modifier == "array") {  		ignoreArray = false;  	}  	break;  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (needExpand && ignoreArray && !asRef) {  	IList<Expression> exprs = this.GetExpressionsByKey (expressions' paramsName);  	if (exprs.Count == 1 && exprs [0] != null && exprs [0].Parent != null) {  		var exprrr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  		if (exprrr.Type.Kind == TypeKind.Array) {  			var match = _inlineMethod.Match (inline);  			if (match.Success) {  				string target = null;  				var methodName = match.Groups [1].Value;  				if (methodName.Contains (".")) {  					target = methodName.LeftOfRightmostOf ('.');  				}  				string args = match.Groups [2].Value;  				StringBuilder sb = new StringBuilder ();  				sb.Append (methodName);  				sb.Append (".");  				sb.Append (JS.Funcs.APPLY);  				sb.Append ("(");  				sb.Append (target ?? "null");  				if (args.Contains ("'")) {  					sb.Append ("' [");  					sb.Append (args.LeftOfRightmostOf (''').Trim ());  					sb.Append ("].concat(");  					sb.Append (args.RightOfRightmostOf (''').Trim ());  					sb.Append (")");  				}  				else {  					sb.Append ("'");  					sb.Append (args);  				}  				sb.Append (")");  				inline = inline.Remove (match.Index' match.Length);  				inline = inline.Insert (match.Index' sb.ToString ());  			}  		}  	}  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (exprs.Count == 1 && exprs [0] != null && exprs [0].Parent != null) {  	var exprrr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  	if (exprrr.Type.Kind == TypeKind.Array) {  		var match = _inlineMethod.Match (inline);  		if (match.Success) {  			string target = null;  			var methodName = match.Groups [1].Value;  			if (methodName.Contains (".")) {  				target = methodName.LeftOfRightmostOf ('.');  			}  			string args = match.Groups [2].Value;  			StringBuilder sb = new StringBuilder ();  			sb.Append (methodName);  			sb.Append (".");  			sb.Append (JS.Funcs.APPLY);  			sb.Append ("(");  			sb.Append (target ?? "null");  			if (args.Contains ("'")) {  				sb.Append ("' [");  				sb.Append (args.LeftOfRightmostOf (''').Trim ());  				sb.Append ("].concat(");  				sb.Append (args.RightOfRightmostOf (''').Trim ());  				sb.Append (")");  			}  			else {  				sb.Append ("'");  				sb.Append (args);  			}  			sb.Append (")");  			inline = inline.Remove (match.Index' match.Length);  			inline = inline.Insert (match.Index' sb.ToString ());  		}  	}  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (exprrr.Type.Kind == TypeKind.Array) {  	var match = _inlineMethod.Match (inline);  	if (match.Success) {  		string target = null;  		var methodName = match.Groups [1].Value;  		if (methodName.Contains (".")) {  			target = methodName.LeftOfRightmostOf ('.');  		}  		string args = match.Groups [2].Value;  		StringBuilder sb = new StringBuilder ();  		sb.Append (methodName);  		sb.Append (".");  		sb.Append (JS.Funcs.APPLY);  		sb.Append ("(");  		sb.Append (target ?? "null");  		if (args.Contains ("'")) {  			sb.Append ("' [");  			sb.Append (args.LeftOfRightmostOf (''').Trim ());  			sb.Append ("].concat(");  			sb.Append (args.RightOfRightmostOf (''').Trim ());  			sb.Append (")");  		}  		else {  			sb.Append ("'");  			sb.Append (args);  		}  		sb.Append (")");  		inline = inline.Remove (match.Index' match.Length);  		inline = inline.Insert (match.Index' sb.ToString ());  	}  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (match.Success) {  	string target = null;  	var methodName = match.Groups [1].Value;  	if (methodName.Contains (".")) {  		target = methodName.LeftOfRightmostOf ('.');  	}  	string args = match.Groups [2].Value;  	StringBuilder sb = new StringBuilder ();  	sb.Append (methodName);  	sb.Append (".");  	sb.Append (JS.Funcs.APPLY);  	sb.Append ("(");  	sb.Append (target ?? "null");  	if (args.Contains ("'")) {  		sb.Append ("' [");  		sb.Append (args.LeftOfRightmostOf (''').Trim ());  		sb.Append ("].concat(");  		sb.Append (args.RightOfRightmostOf (''').Trim ());  		sb.Append (")");  	}  	else {  		sb.Append ("'");  		sb.Append (args);  	}  	sb.Append (")");  	inline = inline.Remove (match.Index' match.Length);  	inline = inline.Insert (match.Index' sb.ToString ());  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: inline = _formatArg.Replace (inline' delegate (Match m) {  	if (this.IgnoreRange != null && m.Index >= this.IgnoreRange [0] && m.Index <= this.IgnoreRange [1]) {  		return m.Value;  	}  	int count = this.Emitter.Writers.Count;  	string key = m.Groups [2].Value;  	bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  	bool ignoreArray = isRaw || argsInfo.ParamsExpression == null;  	string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  	bool isSimple = false;  	var tempKey = key + ":" + modifier ?? "";  	if (tempMap.ContainsKey (tempKey)) {  		return tempMap [tempKey];  	}  	if (modifier == "array") {  		ignoreArray = false;  	}  	StringBuilder oldSb = this.Emitter.Output;  	this.Emitter.Output = new StringBuilder ();  	if (asRef) {  		if (Regex.IsMatch (key' "^\\d+$")) {  			var index = int.Parse (key);  			key = this.Method.Parameters [index].Name;  		}  		if (modifier == "type") {  			this.Write (JS.Funcs.BRIDGE_GET_TYPE + "(");  		}  		if (key == "this") {  			if (isNull) {  				isSimple = true;  				this.Write (JS.Vars.T);  			}  			else if (this.Method.IsExtensionMethod && this.TargetResolveResult is TypeResolveResult) {  				isSimple = true;  				this.WriteParamName (this.Method.Parameters.First ().Name);  			}  			else if (argsInfo.Expression is MemberReferenceExpression) {  				var trg = ((MemberReferenceExpression)argsInfo.Expression).Target;  				if (trg is BaseReferenceExpression) {  					isSimple = true;  					this.Write ("this");  				}  				else {  					isSimple = this.IsSimpleExpression (trg);  					trg.AcceptVisitor (this.Emitter);  				}  			}  			else {  				this.Write ("this");  			}  		}  		else if (this.Method.IsExtensionMethod && key == this.Method.Parameters.First ().Name) {  			if (this.TargetResolveResult is TypeResolveResult) {  				isSimple = true;  				this.WriteParamName (key);  			}  			else if (argsInfo.Expression is MemberReferenceExpression) {  				var trg = ((MemberReferenceExpression)argsInfo.Expression).Target;  				if (trg is BaseReferenceExpression) {  					isSimple = true;  					this.Write ("this");  				}  				else {  					isSimple = this.IsSimpleExpression (trg);  					trg.AcceptVisitor (this.Emitter);  				}  			}  			else {  				isSimple = true;  				this.WriteParamName (key);  			}  		}  		else if (paramsName == key && !ignoreArray) {  			isSimple = true;  			this.Write (JS.Types.ARRAY + "." + JS.Fields.PROTOTYPE + "." + JS.Funcs.SLICE);  			this.WriteCall ("(" + JS.Vars.ARGUMENTS + "' " + paramsIndex + ")");  		}  		else {  			isSimple = true;  			this.WriteParamName (key);  		}  		if (modifier == "type") {  			this.Write (")");  		}  	}  	else if (key == "this" || key == argsInfo.ThisName || (key == "0" && argsInfo.IsExtensionMethod)) {  		if (modifier == "type") {  			AstNode node = null;  			if (argsInfo.ThisArgument is AstNode) {  				node = (AstNode)argsInfo.ThisArgument;  			}  			else {  				node = argsInfo.Expression;  			}  			if (node != null) {  				var rr = this.Emitter.Resolver.ResolveNode (node' this.Emitter);  				var type = rr.Type;  				if (rr is MemberResolveResult) {  					type = ((MemberResolveResult)rr).TargetResult.Type;  				}  				bool needName = this.NeedName (type);  				if (needName) {  					isSimple = true;  					this.Write (BridgeTypes.ToJsName (type' this.Emitter));  				}  				else {  					string thisValue = argsInfo.GetThisValue ();  					if (thisValue != null) {  						this.Write (JS.Funcs.BRIDGE_GET_TYPE + "(" + thisValue + ")");  					}  				}  			}  		}  		else {  			string thisValue = argsInfo.GetThisValue ();  			if (thisValue != null) {  				isSimple = true;  				this.Write (thisValue);  			}  		}  	}  	else {  		IList<Expression> exprs = this.GetExpressionsByKey (expressions' key);  		if (exprs.Count > 0) {  			if (modifier == "type") {  				IType type = null;  				if (paramsName == key && paramsType != null) {  					type = paramsType;  				}  				else {  					var rr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  					type = rr.Type;  				}  				bool needName = this.NeedName (type);  				this.WriteGetType (needName' type' exprs [0]' modifier);  				isSimple = true;  			}  			else if (modifier == "tmp") {  				var tmpVarName = this.GetTempVarName ();  				var nameExpr = exprs [0] as PrimitiveExpression;  				if (nameExpr == null) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				Emitter.NamedTempVariables [nameExpr.LiteralValue] = tmpVarName;  				Write (tmpVarName);  				isSimple = true;  			}  			else if (modifier == "gettmp") {  				var nameExpr = exprs [0] as PrimitiveExpression;  				if (nameExpr == null) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				if (!Emitter.NamedTempVariables.ContainsKey (nameExpr.LiteralValue)) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				var tmpVarName = Emitter.NamedTempVariables [nameExpr.LiteralValue];  				Write (tmpVarName);  				isSimple = true;  			}  			else if (modifier == "body") {  				var lambdaExpr = exprs [0] as LambdaExpression;  				if (lambdaExpr == null) {  					throw new EmitterException (exprs [0]' "Lambda expression is required");  				}  				var writer = this.SaveWriter ();  				this.NewWriter ();  				lambdaExpr.Body.AcceptVisitor (this.Emitter);  				var s = this.Emitter.Output.ToString ();  				this.RestoreWriter (writer);  				this.Write (this.WriteIndentToString (s));  			}  			else if (exprs.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				if (exprs.Count == 1 && exprs [0] == null) {  					isSimple = true;  					this.Write ("null");  				}  				else {  					new ExpressionListBlock (this.Emitter' exprs' null' null' 0).Emit ();  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (exprs [0] != null) {  					var writer = this.SaveWriter ();  					this.NewWriter ();  					var directExpr = exprs [0] as DirectionExpression;  					if (directExpr != null) {  						var rr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter) as ByReferenceResolveResult;  						if (rr != null && !(rr.ElementResult is LocalResolveResult)) {  							this.Write (JS.Funcs.BRIDGE_REF + "(");  							this.Emitter.IsRefArg = true;  							exprs [0].AcceptVisitor (this.Emitter);  							this.Emitter.IsRefArg = false;  							if (this.Emitter.Writers.Count != count) {  								this.PopWriter ();  								count = this.Emitter.Writers.Count;  							}  							this.Write (")");  						}  						else {  							exprs [0].AcceptVisitor (this.Emitter);  						}  					}  					else if (modifier == "plain") {  						var an = exprs [0] as AnonymousTypeCreateExpression;  						if (an == null) {  							this.Write (JS.Funcs.BRIDGE_TOPLAIN);  							this.WriteOpenParentheses ();  							exprs [0].AcceptVisitor (this.Emitter);  							this.Write (")");  						}  						else {  							new AnonymousTypeCreateBlock (this.Emitter' an' true).Emit ();  						}  					}  					else {  						isSimple = this.IsSimpleExpression (exprs [0]);  						exprs [0].AcceptVisitor (this.Emitter);  					}  					s = this.Emitter.Output.ToString ();  					this.RestoreWriter (writer);  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					isSimple = true;  					s = "null";  				}  				this.Write (this.WriteIndentToString (s));  			}  		}  		else if (this.ArgumentsInfo.Attribute != null) {  			var results = this.GetResolveResultByKey (key);  			if (results.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				if (exprs.Count == 1 && results [0].IsCompileTimeConstant && results [0].ConstantValue == null) {  					isSimple = true;  					this.Write ("null");  				}  				else {  					bool needComma = false;  					foreach (ResolveResult item in results) {  						if (needComma) {  							this.WriteComma ();  						}  						needComma = true;  						isSimple = this.IsSimpleResolveResult (item);  						AttributeCreateBlock.WriteResolveResult (item' this);  					}  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (results [0] != null) {  					var writer = this.SaveWriter ();  					this.NewWriter ();  					isSimple = this.IsSimpleResolveResult (results [0]);  					AttributeCreateBlock.WriteResolveResult (results [0]' this);  					s = this.Emitter.Output.ToString ();  					this.RestoreWriter (writer);  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					s = "null";  				}  				this.Write (this.WriteIndentToString (s));  			}  		}  		else if (this.ArgumentsInfo.StringArguments != null) {  			var results = this.GetStringArgumentByKey (key);  			if (results.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				bool needComma = false;  				foreach (string item in results) {  					if (needComma) {  						this.WriteComma ();  					}  					needComma = true;  					this.Write (item);  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (results [0] != null) {  					s = results [0];  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					s = "null";  				}  				this.Write (s);  			}  		}  		else if (typeParams != null) {  			var type = this.GetAstTypeByKey (typeParams' key);  			if (type != null) {  				if (modifier == "default" || modifier == "defaultFn") {  					var def = Inspector.GetDefaultFieldValue (type' this.Emitter.Resolver);  					this.GetDefaultValue (def' modifier);  				}  				else {  					type.AcceptVisitor (this.Emitter);  				}  			}  			else {  				var iType = this.GetTypeByKey (typeParams' key);  				if (iType != null) {  					if (modifier == "default" || modifier == "defaultFn") {  						var def = Inspector.GetDefaultFieldValue (iType.IType' iType.AstType);  						this.GetDefaultValue (def' modifier);  					}  					else {  						new CastBlock (this.Emitter' iType.IType).Emit ();  					}  				}  			}  		}  	}  	if (this.Emitter.Writers.Count != count) {  		this.PopWriter ();  	}  	string replacement = this.Emitter.Output.ToString ();  	this.Emitter.Output = oldSb;  	if (!isSimple && keyMatches.Count (keyMatch =>  {  		string key1 = keyMatch.Groups [2].Value;  		string modifier1 = keyMatch.Groups [1].Success ? keyMatch.Groups [4].Value : null;  		return key == key1 && modifier1 == modifier;  	}) > 1) {  		var t = this.GetTempVarName ();  		tempVars.Add (t' replacement);  		tempMap [tempKey] = t;  		return t;  	}  	return replacement;  });  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: inline = _formatArg.Replace (inline' delegate (Match m) {  	if (this.IgnoreRange != null && m.Index >= this.IgnoreRange [0] && m.Index <= this.IgnoreRange [1]) {  		return m.Value;  	}  	int count = this.Emitter.Writers.Count;  	string key = m.Groups [2].Value;  	bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  	bool ignoreArray = isRaw || argsInfo.ParamsExpression == null;  	string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  	bool isSimple = false;  	var tempKey = key + ":" + modifier ?? "";  	if (tempMap.ContainsKey (tempKey)) {  		return tempMap [tempKey];  	}  	if (modifier == "array") {  		ignoreArray = false;  	}  	StringBuilder oldSb = this.Emitter.Output;  	this.Emitter.Output = new StringBuilder ();  	if (asRef) {  		if (Regex.IsMatch (key' "^\\d+$")) {  			var index = int.Parse (key);  			key = this.Method.Parameters [index].Name;  		}  		if (modifier == "type") {  			this.Write (JS.Funcs.BRIDGE_GET_TYPE + "(");  		}  		if (key == "this") {  			if (isNull) {  				isSimple = true;  				this.Write (JS.Vars.T);  			}  			else if (this.Method.IsExtensionMethod && this.TargetResolveResult is TypeResolveResult) {  				isSimple = true;  				this.WriteParamName (this.Method.Parameters.First ().Name);  			}  			else if (argsInfo.Expression is MemberReferenceExpression) {  				var trg = ((MemberReferenceExpression)argsInfo.Expression).Target;  				if (trg is BaseReferenceExpression) {  					isSimple = true;  					this.Write ("this");  				}  				else {  					isSimple = this.IsSimpleExpression (trg);  					trg.AcceptVisitor (this.Emitter);  				}  			}  			else {  				this.Write ("this");  			}  		}  		else if (this.Method.IsExtensionMethod && key == this.Method.Parameters.First ().Name) {  			if (this.TargetResolveResult is TypeResolveResult) {  				isSimple = true;  				this.WriteParamName (key);  			}  			else if (argsInfo.Expression is MemberReferenceExpression) {  				var trg = ((MemberReferenceExpression)argsInfo.Expression).Target;  				if (trg is BaseReferenceExpression) {  					isSimple = true;  					this.Write ("this");  				}  				else {  					isSimple = this.IsSimpleExpression (trg);  					trg.AcceptVisitor (this.Emitter);  				}  			}  			else {  				isSimple = true;  				this.WriteParamName (key);  			}  		}  		else if (paramsName == key && !ignoreArray) {  			isSimple = true;  			this.Write (JS.Types.ARRAY + "." + JS.Fields.PROTOTYPE + "." + JS.Funcs.SLICE);  			this.WriteCall ("(" + JS.Vars.ARGUMENTS + "' " + paramsIndex + ")");  		}  		else {  			isSimple = true;  			this.WriteParamName (key);  		}  		if (modifier == "type") {  			this.Write (")");  		}  	}  	else if (key == "this" || key == argsInfo.ThisName || (key == "0" && argsInfo.IsExtensionMethod)) {  		if (modifier == "type") {  			AstNode node = null;  			if (argsInfo.ThisArgument is AstNode) {  				node = (AstNode)argsInfo.ThisArgument;  			}  			else {  				node = argsInfo.Expression;  			}  			if (node != null) {  				var rr = this.Emitter.Resolver.ResolveNode (node' this.Emitter);  				var type = rr.Type;  				if (rr is MemberResolveResult) {  					type = ((MemberResolveResult)rr).TargetResult.Type;  				}  				bool needName = this.NeedName (type);  				if (needName) {  					isSimple = true;  					this.Write (BridgeTypes.ToJsName (type' this.Emitter));  				}  				else {  					string thisValue = argsInfo.GetThisValue ();  					if (thisValue != null) {  						this.Write (JS.Funcs.BRIDGE_GET_TYPE + "(" + thisValue + ")");  					}  				}  			}  		}  		else {  			string thisValue = argsInfo.GetThisValue ();  			if (thisValue != null) {  				isSimple = true;  				this.Write (thisValue);  			}  		}  	}  	else {  		IList<Expression> exprs = this.GetExpressionsByKey (expressions' key);  		if (exprs.Count > 0) {  			if (modifier == "type") {  				IType type = null;  				if (paramsName == key && paramsType != null) {  					type = paramsType;  				}  				else {  					var rr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  					type = rr.Type;  				}  				bool needName = this.NeedName (type);  				this.WriteGetType (needName' type' exprs [0]' modifier);  				isSimple = true;  			}  			else if (modifier == "tmp") {  				var tmpVarName = this.GetTempVarName ();  				var nameExpr = exprs [0] as PrimitiveExpression;  				if (nameExpr == null) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				Emitter.NamedTempVariables [nameExpr.LiteralValue] = tmpVarName;  				Write (tmpVarName);  				isSimple = true;  			}  			else if (modifier == "gettmp") {  				var nameExpr = exprs [0] as PrimitiveExpression;  				if (nameExpr == null) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				if (!Emitter.NamedTempVariables.ContainsKey (nameExpr.LiteralValue)) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				var tmpVarName = Emitter.NamedTempVariables [nameExpr.LiteralValue];  				Write (tmpVarName);  				isSimple = true;  			}  			else if (modifier == "body") {  				var lambdaExpr = exprs [0] as LambdaExpression;  				if (lambdaExpr == null) {  					throw new EmitterException (exprs [0]' "Lambda expression is required");  				}  				var writer = this.SaveWriter ();  				this.NewWriter ();  				lambdaExpr.Body.AcceptVisitor (this.Emitter);  				var s = this.Emitter.Output.ToString ();  				this.RestoreWriter (writer);  				this.Write (this.WriteIndentToString (s));  			}  			else if (exprs.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				if (exprs.Count == 1 && exprs [0] == null) {  					isSimple = true;  					this.Write ("null");  				}  				else {  					new ExpressionListBlock (this.Emitter' exprs' null' null' 0).Emit ();  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (exprs [0] != null) {  					var writer = this.SaveWriter ();  					this.NewWriter ();  					var directExpr = exprs [0] as DirectionExpression;  					if (directExpr != null) {  						var rr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter) as ByReferenceResolveResult;  						if (rr != null && !(rr.ElementResult is LocalResolveResult)) {  							this.Write (JS.Funcs.BRIDGE_REF + "(");  							this.Emitter.IsRefArg = true;  							exprs [0].AcceptVisitor (this.Emitter);  							this.Emitter.IsRefArg = false;  							if (this.Emitter.Writers.Count != count) {  								this.PopWriter ();  								count = this.Emitter.Writers.Count;  							}  							this.Write (")");  						}  						else {  							exprs [0].AcceptVisitor (this.Emitter);  						}  					}  					else if (modifier == "plain") {  						var an = exprs [0] as AnonymousTypeCreateExpression;  						if (an == null) {  							this.Write (JS.Funcs.BRIDGE_TOPLAIN);  							this.WriteOpenParentheses ();  							exprs [0].AcceptVisitor (this.Emitter);  							this.Write (")");  						}  						else {  							new AnonymousTypeCreateBlock (this.Emitter' an' true).Emit ();  						}  					}  					else {  						isSimple = this.IsSimpleExpression (exprs [0]);  						exprs [0].AcceptVisitor (this.Emitter);  					}  					s = this.Emitter.Output.ToString ();  					this.RestoreWriter (writer);  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					isSimple = true;  					s = "null";  				}  				this.Write (this.WriteIndentToString (s));  			}  		}  		else if (this.ArgumentsInfo.Attribute != null) {  			var results = this.GetResolveResultByKey (key);  			if (results.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				if (exprs.Count == 1 && results [0].IsCompileTimeConstant && results [0].ConstantValue == null) {  					isSimple = true;  					this.Write ("null");  				}  				else {  					bool needComma = false;  					foreach (ResolveResult item in results) {  						if (needComma) {  							this.WriteComma ();  						}  						needComma = true;  						isSimple = this.IsSimpleResolveResult (item);  						AttributeCreateBlock.WriteResolveResult (item' this);  					}  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (results [0] != null) {  					var writer = this.SaveWriter ();  					this.NewWriter ();  					isSimple = this.IsSimpleResolveResult (results [0]);  					AttributeCreateBlock.WriteResolveResult (results [0]' this);  					s = this.Emitter.Output.ToString ();  					this.RestoreWriter (writer);  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					s = "null";  				}  				this.Write (this.WriteIndentToString (s));  			}  		}  		else if (this.ArgumentsInfo.StringArguments != null) {  			var results = this.GetStringArgumentByKey (key);  			if (results.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				bool needComma = false;  				foreach (string item in results) {  					if (needComma) {  						this.WriteComma ();  					}  					needComma = true;  					this.Write (item);  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (results [0] != null) {  					s = results [0];  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					s = "null";  				}  				this.Write (s);  			}  		}  		else if (typeParams != null) {  			var type = this.GetAstTypeByKey (typeParams' key);  			if (type != null) {  				if (modifier == "default" || modifier == "defaultFn") {  					var def = Inspector.GetDefaultFieldValue (type' this.Emitter.Resolver);  					this.GetDefaultValue (def' modifier);  				}  				else {  					type.AcceptVisitor (this.Emitter);  				}  			}  			else {  				var iType = this.GetTypeByKey (typeParams' key);  				if (iType != null) {  					if (modifier == "default" || modifier == "defaultFn") {  						var def = Inspector.GetDefaultFieldValue (iType.IType' iType.AstType);  						this.GetDefaultValue (def' modifier);  					}  					else {  						new CastBlock (this.Emitter' iType.IType).Emit ();  					}  				}  			}  		}  	}  	if (this.Emitter.Writers.Count != count) {  		this.PopWriter ();  	}  	string replacement = this.Emitter.Output.ToString ();  	this.Emitter.Output = oldSb;  	if (!isSimple && keyMatches.Count (keyMatch =>  {  		string key1 = keyMatch.Groups [2].Value;  		string modifier1 = keyMatch.Groups [1].Success ? keyMatch.Groups [4].Value : null;  		return key == key1 && modifier1 == modifier;  	}) > 1) {  		var t = this.GetTempVarName ();  		tempVars.Add (t' replacement);  		tempMap [tempKey] = t;  		return t;  	}  	return replacement;  });  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: inline = _formatArg.Replace (inline' delegate (Match m) {  	if (this.IgnoreRange != null && m.Index >= this.IgnoreRange [0] && m.Index <= this.IgnoreRange [1]) {  		return m.Value;  	}  	int count = this.Emitter.Writers.Count;  	string key = m.Groups [2].Value;  	bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  	bool ignoreArray = isRaw || argsInfo.ParamsExpression == null;  	string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  	bool isSimple = false;  	var tempKey = key + ":" + modifier ?? "";  	if (tempMap.ContainsKey (tempKey)) {  		return tempMap [tempKey];  	}  	if (modifier == "array") {  		ignoreArray = false;  	}  	StringBuilder oldSb = this.Emitter.Output;  	this.Emitter.Output = new StringBuilder ();  	if (asRef) {  		if (Regex.IsMatch (key' "^\\d+$")) {  			var index = int.Parse (key);  			key = this.Method.Parameters [index].Name;  		}  		if (modifier == "type") {  			this.Write (JS.Funcs.BRIDGE_GET_TYPE + "(");  		}  		if (key == "this") {  			if (isNull) {  				isSimple = true;  				this.Write (JS.Vars.T);  			}  			else if (this.Method.IsExtensionMethod && this.TargetResolveResult is TypeResolveResult) {  				isSimple = true;  				this.WriteParamName (this.Method.Parameters.First ().Name);  			}  			else if (argsInfo.Expression is MemberReferenceExpression) {  				var trg = ((MemberReferenceExpression)argsInfo.Expression).Target;  				if (trg is BaseReferenceExpression) {  					isSimple = true;  					this.Write ("this");  				}  				else {  					isSimple = this.IsSimpleExpression (trg);  					trg.AcceptVisitor (this.Emitter);  				}  			}  			else {  				this.Write ("this");  			}  		}  		else if (this.Method.IsExtensionMethod && key == this.Method.Parameters.First ().Name) {  			if (this.TargetResolveResult is TypeResolveResult) {  				isSimple = true;  				this.WriteParamName (key);  			}  			else if (argsInfo.Expression is MemberReferenceExpression) {  				var trg = ((MemberReferenceExpression)argsInfo.Expression).Target;  				if (trg is BaseReferenceExpression) {  					isSimple = true;  					this.Write ("this");  				}  				else {  					isSimple = this.IsSimpleExpression (trg);  					trg.AcceptVisitor (this.Emitter);  				}  			}  			else {  				isSimple = true;  				this.WriteParamName (key);  			}  		}  		else if (paramsName == key && !ignoreArray) {  			isSimple = true;  			this.Write (JS.Types.ARRAY + "." + JS.Fields.PROTOTYPE + "." + JS.Funcs.SLICE);  			this.WriteCall ("(" + JS.Vars.ARGUMENTS + "' " + paramsIndex + ")");  		}  		else {  			isSimple = true;  			this.WriteParamName (key);  		}  		if (modifier == "type") {  			this.Write (")");  		}  	}  	else if (key == "this" || key == argsInfo.ThisName || (key == "0" && argsInfo.IsExtensionMethod)) {  		if (modifier == "type") {  			AstNode node = null;  			if (argsInfo.ThisArgument is AstNode) {  				node = (AstNode)argsInfo.ThisArgument;  			}  			else {  				node = argsInfo.Expression;  			}  			if (node != null) {  				var rr = this.Emitter.Resolver.ResolveNode (node' this.Emitter);  				var type = rr.Type;  				if (rr is MemberResolveResult) {  					type = ((MemberResolveResult)rr).TargetResult.Type;  				}  				bool needName = this.NeedName (type);  				if (needName) {  					isSimple = true;  					this.Write (BridgeTypes.ToJsName (type' this.Emitter));  				}  				else {  					string thisValue = argsInfo.GetThisValue ();  					if (thisValue != null) {  						this.Write (JS.Funcs.BRIDGE_GET_TYPE + "(" + thisValue + ")");  					}  				}  			}  		}  		else {  			string thisValue = argsInfo.GetThisValue ();  			if (thisValue != null) {  				isSimple = true;  				this.Write (thisValue);  			}  		}  	}  	else {  		IList<Expression> exprs = this.GetExpressionsByKey (expressions' key);  		if (exprs.Count > 0) {  			if (modifier == "type") {  				IType type = null;  				if (paramsName == key && paramsType != null) {  					type = paramsType;  				}  				else {  					var rr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  					type = rr.Type;  				}  				bool needName = this.NeedName (type);  				this.WriteGetType (needName' type' exprs [0]' modifier);  				isSimple = true;  			}  			else if (modifier == "tmp") {  				var tmpVarName = this.GetTempVarName ();  				var nameExpr = exprs [0] as PrimitiveExpression;  				if (nameExpr == null) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				Emitter.NamedTempVariables [nameExpr.LiteralValue] = tmpVarName;  				Write (tmpVarName);  				isSimple = true;  			}  			else if (modifier == "gettmp") {  				var nameExpr = exprs [0] as PrimitiveExpression;  				if (nameExpr == null) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				if (!Emitter.NamedTempVariables.ContainsKey (nameExpr.LiteralValue)) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				var tmpVarName = Emitter.NamedTempVariables [nameExpr.LiteralValue];  				Write (tmpVarName);  				isSimple = true;  			}  			else if (modifier == "body") {  				var lambdaExpr = exprs [0] as LambdaExpression;  				if (lambdaExpr == null) {  					throw new EmitterException (exprs [0]' "Lambda expression is required");  				}  				var writer = this.SaveWriter ();  				this.NewWriter ();  				lambdaExpr.Body.AcceptVisitor (this.Emitter);  				var s = this.Emitter.Output.ToString ();  				this.RestoreWriter (writer);  				this.Write (this.WriteIndentToString (s));  			}  			else if (exprs.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				if (exprs.Count == 1 && exprs [0] == null) {  					isSimple = true;  					this.Write ("null");  				}  				else {  					new ExpressionListBlock (this.Emitter' exprs' null' null' 0).Emit ();  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (exprs [0] != null) {  					var writer = this.SaveWriter ();  					this.NewWriter ();  					var directExpr = exprs [0] as DirectionExpression;  					if (directExpr != null) {  						var rr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter) as ByReferenceResolveResult;  						if (rr != null && !(rr.ElementResult is LocalResolveResult)) {  							this.Write (JS.Funcs.BRIDGE_REF + "(");  							this.Emitter.IsRefArg = true;  							exprs [0].AcceptVisitor (this.Emitter);  							this.Emitter.IsRefArg = false;  							if (this.Emitter.Writers.Count != count) {  								this.PopWriter ();  								count = this.Emitter.Writers.Count;  							}  							this.Write (")");  						}  						else {  							exprs [0].AcceptVisitor (this.Emitter);  						}  					}  					else if (modifier == "plain") {  						var an = exprs [0] as AnonymousTypeCreateExpression;  						if (an == null) {  							this.Write (JS.Funcs.BRIDGE_TOPLAIN);  							this.WriteOpenParentheses ();  							exprs [0].AcceptVisitor (this.Emitter);  							this.Write (")");  						}  						else {  							new AnonymousTypeCreateBlock (this.Emitter' an' true).Emit ();  						}  					}  					else {  						isSimple = this.IsSimpleExpression (exprs [0]);  						exprs [0].AcceptVisitor (this.Emitter);  					}  					s = this.Emitter.Output.ToString ();  					this.RestoreWriter (writer);  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					isSimple = true;  					s = "null";  				}  				this.Write (this.WriteIndentToString (s));  			}  		}  		else if (this.ArgumentsInfo.Attribute != null) {  			var results = this.GetResolveResultByKey (key);  			if (results.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				if (exprs.Count == 1 && results [0].IsCompileTimeConstant && results [0].ConstantValue == null) {  					isSimple = true;  					this.Write ("null");  				}  				else {  					bool needComma = false;  					foreach (ResolveResult item in results) {  						if (needComma) {  							this.WriteComma ();  						}  						needComma = true;  						isSimple = this.IsSimpleResolveResult (item);  						AttributeCreateBlock.WriteResolveResult (item' this);  					}  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (results [0] != null) {  					var writer = this.SaveWriter ();  					this.NewWriter ();  					isSimple = this.IsSimpleResolveResult (results [0]);  					AttributeCreateBlock.WriteResolveResult (results [0]' this);  					s = this.Emitter.Output.ToString ();  					this.RestoreWriter (writer);  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					s = "null";  				}  				this.Write (this.WriteIndentToString (s));  			}  		}  		else if (this.ArgumentsInfo.StringArguments != null) {  			var results = this.GetStringArgumentByKey (key);  			if (results.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				bool needComma = false;  				foreach (string item in results) {  					if (needComma) {  						this.WriteComma ();  					}  					needComma = true;  					this.Write (item);  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (results [0] != null) {  					s = results [0];  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					s = "null";  				}  				this.Write (s);  			}  		}  		else if (typeParams != null) {  			var type = this.GetAstTypeByKey (typeParams' key);  			if (type != null) {  				if (modifier == "default" || modifier == "defaultFn") {  					var def = Inspector.GetDefaultFieldValue (type' this.Emitter.Resolver);  					this.GetDefaultValue (def' modifier);  				}  				else {  					type.AcceptVisitor (this.Emitter);  				}  			}  			else {  				var iType = this.GetTypeByKey (typeParams' key);  				if (iType != null) {  					if (modifier == "default" || modifier == "defaultFn") {  						var def = Inspector.GetDefaultFieldValue (iType.IType' iType.AstType);  						this.GetDefaultValue (def' modifier);  					}  					else {  						new CastBlock (this.Emitter' iType.IType).Emit ();  					}  				}  			}  		}  	}  	if (this.Emitter.Writers.Count != count) {  		this.PopWriter ();  	}  	string replacement = this.Emitter.Output.ToString ();  	this.Emitter.Output = oldSb;  	if (!isSimple && keyMatches.Count (keyMatch =>  {  		string key1 = keyMatch.Groups [2].Value;  		string modifier1 = keyMatch.Groups [1].Success ? keyMatch.Groups [4].Value : null;  		return key == key1 && modifier1 == modifier;  	}) > 1) {  		var t = this.GetTempVarName ();  		tempVars.Add (t' replacement);  		tempMap [tempKey] = t;  		return t;  	}  	return replacement;  });  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: inline = _formatArg.Replace (inline' delegate (Match m) {  	if (this.IgnoreRange != null && m.Index >= this.IgnoreRange [0] && m.Index <= this.IgnoreRange [1]) {  		return m.Value;  	}  	int count = this.Emitter.Writers.Count;  	string key = m.Groups [2].Value;  	bool isRaw = m.Groups [1].Success && m.Groups [1].Value == "*";  	bool ignoreArray = isRaw || argsInfo.ParamsExpression == null;  	string modifier = m.Groups [1].Success ? m.Groups [4].Value : null;  	bool isSimple = false;  	var tempKey = key + ":" + modifier ?? "";  	if (tempMap.ContainsKey (tempKey)) {  		return tempMap [tempKey];  	}  	if (modifier == "array") {  		ignoreArray = false;  	}  	StringBuilder oldSb = this.Emitter.Output;  	this.Emitter.Output = new StringBuilder ();  	if (asRef) {  		if (Regex.IsMatch (key' "^\\d+$")) {  			var index = int.Parse (key);  			key = this.Method.Parameters [index].Name;  		}  		if (modifier == "type") {  			this.Write (JS.Funcs.BRIDGE_GET_TYPE + "(");  		}  		if (key == "this") {  			if (isNull) {  				isSimple = true;  				this.Write (JS.Vars.T);  			}  			else if (this.Method.IsExtensionMethod && this.TargetResolveResult is TypeResolveResult) {  				isSimple = true;  				this.WriteParamName (this.Method.Parameters.First ().Name);  			}  			else if (argsInfo.Expression is MemberReferenceExpression) {  				var trg = ((MemberReferenceExpression)argsInfo.Expression).Target;  				if (trg is BaseReferenceExpression) {  					isSimple = true;  					this.Write ("this");  				}  				else {  					isSimple = this.IsSimpleExpression (trg);  					trg.AcceptVisitor (this.Emitter);  				}  			}  			else {  				this.Write ("this");  			}  		}  		else if (this.Method.IsExtensionMethod && key == this.Method.Parameters.First ().Name) {  			if (this.TargetResolveResult is TypeResolveResult) {  				isSimple = true;  				this.WriteParamName (key);  			}  			else if (argsInfo.Expression is MemberReferenceExpression) {  				var trg = ((MemberReferenceExpression)argsInfo.Expression).Target;  				if (trg is BaseReferenceExpression) {  					isSimple = true;  					this.Write ("this");  				}  				else {  					isSimple = this.IsSimpleExpression (trg);  					trg.AcceptVisitor (this.Emitter);  				}  			}  			else {  				isSimple = true;  				this.WriteParamName (key);  			}  		}  		else if (paramsName == key && !ignoreArray) {  			isSimple = true;  			this.Write (JS.Types.ARRAY + "." + JS.Fields.PROTOTYPE + "." + JS.Funcs.SLICE);  			this.WriteCall ("(" + JS.Vars.ARGUMENTS + "' " + paramsIndex + ")");  		}  		else {  			isSimple = true;  			this.WriteParamName (key);  		}  		if (modifier == "type") {  			this.Write (")");  		}  	}  	else if (key == "this" || key == argsInfo.ThisName || (key == "0" && argsInfo.IsExtensionMethod)) {  		if (modifier == "type") {  			AstNode node = null;  			if (argsInfo.ThisArgument is AstNode) {  				node = (AstNode)argsInfo.ThisArgument;  			}  			else {  				node = argsInfo.Expression;  			}  			if (node != null) {  				var rr = this.Emitter.Resolver.ResolveNode (node' this.Emitter);  				var type = rr.Type;  				if (rr is MemberResolveResult) {  					type = ((MemberResolveResult)rr).TargetResult.Type;  				}  				bool needName = this.NeedName (type);  				if (needName) {  					isSimple = true;  					this.Write (BridgeTypes.ToJsName (type' this.Emitter));  				}  				else {  					string thisValue = argsInfo.GetThisValue ();  					if (thisValue != null) {  						this.Write (JS.Funcs.BRIDGE_GET_TYPE + "(" + thisValue + ")");  					}  				}  			}  		}  		else {  			string thisValue = argsInfo.GetThisValue ();  			if (thisValue != null) {  				isSimple = true;  				this.Write (thisValue);  			}  		}  	}  	else {  		IList<Expression> exprs = this.GetExpressionsByKey (expressions' key);  		if (exprs.Count > 0) {  			if (modifier == "type") {  				IType type = null;  				if (paramsName == key && paramsType != null) {  					type = paramsType;  				}  				else {  					var rr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter);  					type = rr.Type;  				}  				bool needName = this.NeedName (type);  				this.WriteGetType (needName' type' exprs [0]' modifier);  				isSimple = true;  			}  			else if (modifier == "tmp") {  				var tmpVarName = this.GetTempVarName ();  				var nameExpr = exprs [0] as PrimitiveExpression;  				if (nameExpr == null) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				Emitter.NamedTempVariables [nameExpr.LiteralValue] = tmpVarName;  				Write (tmpVarName);  				isSimple = true;  			}  			else if (modifier == "gettmp") {  				var nameExpr = exprs [0] as PrimitiveExpression;  				if (nameExpr == null) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				if (!Emitter.NamedTempVariables.ContainsKey (nameExpr.LiteralValue)) {  					throw new EmitterException (exprs [0]' "Primitive expression is required");  				}  				var tmpVarName = Emitter.NamedTempVariables [nameExpr.LiteralValue];  				Write (tmpVarName);  				isSimple = true;  			}  			else if (modifier == "body") {  				var lambdaExpr = exprs [0] as LambdaExpression;  				if (lambdaExpr == null) {  					throw new EmitterException (exprs [0]' "Lambda expression is required");  				}  				var writer = this.SaveWriter ();  				this.NewWriter ();  				lambdaExpr.Body.AcceptVisitor (this.Emitter);  				var s = this.Emitter.Output.ToString ();  				this.RestoreWriter (writer);  				this.Write (this.WriteIndentToString (s));  			}  			else if (exprs.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				if (exprs.Count == 1 && exprs [0] == null) {  					isSimple = true;  					this.Write ("null");  				}  				else {  					new ExpressionListBlock (this.Emitter' exprs' null' null' 0).Emit ();  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (exprs [0] != null) {  					var writer = this.SaveWriter ();  					this.NewWriter ();  					var directExpr = exprs [0] as DirectionExpression;  					if (directExpr != null) {  						var rr = this.Emitter.Resolver.ResolveNode (exprs [0]' this.Emitter) as ByReferenceResolveResult;  						if (rr != null && !(rr.ElementResult is LocalResolveResult)) {  							this.Write (JS.Funcs.BRIDGE_REF + "(");  							this.Emitter.IsRefArg = true;  							exprs [0].AcceptVisitor (this.Emitter);  							this.Emitter.IsRefArg = false;  							if (this.Emitter.Writers.Count != count) {  								this.PopWriter ();  								count = this.Emitter.Writers.Count;  							}  							this.Write (")");  						}  						else {  							exprs [0].AcceptVisitor (this.Emitter);  						}  					}  					else if (modifier == "plain") {  						var an = exprs [0] as AnonymousTypeCreateExpression;  						if (an == null) {  							this.Write (JS.Funcs.BRIDGE_TOPLAIN);  							this.WriteOpenParentheses ();  							exprs [0].AcceptVisitor (this.Emitter);  							this.Write (")");  						}  						else {  							new AnonymousTypeCreateBlock (this.Emitter' an' true).Emit ();  						}  					}  					else {  						isSimple = this.IsSimpleExpression (exprs [0]);  						exprs [0].AcceptVisitor (this.Emitter);  					}  					s = this.Emitter.Output.ToString ();  					this.RestoreWriter (writer);  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					isSimple = true;  					s = "null";  				}  				this.Write (this.WriteIndentToString (s));  			}  		}  		else if (this.ArgumentsInfo.Attribute != null) {  			var results = this.GetResolveResultByKey (key);  			if (results.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				if (exprs.Count == 1 && results [0].IsCompileTimeConstant && results [0].ConstantValue == null) {  					isSimple = true;  					this.Write ("null");  				}  				else {  					bool needComma = false;  					foreach (ResolveResult item in results) {  						if (needComma) {  							this.WriteComma ();  						}  						needComma = true;  						isSimple = this.IsSimpleResolveResult (item);  						AttributeCreateBlock.WriteResolveResult (item' this);  					}  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (results [0] != null) {  					var writer = this.SaveWriter ();  					this.NewWriter ();  					isSimple = this.IsSimpleResolveResult (results [0]);  					AttributeCreateBlock.WriteResolveResult (results [0]' this);  					s = this.Emitter.Output.ToString ();  					this.RestoreWriter (writer);  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					s = "null";  				}  				this.Write (this.WriteIndentToString (s));  			}  		}  		else if (this.ArgumentsInfo.StringArguments != null) {  			var results = this.GetStringArgumentByKey (key);  			if (results.Count > 1 || paramsName == key) {  				if (needExpand) {  					ignoreArray = true;  				}  				if (!ignoreArray) {  					this.Write ("[");  				}  				bool needComma = false;  				foreach (string item in results) {  					if (needComma) {  						this.WriteComma ();  					}  					needComma = true;  					this.Write (item);  				}  				if (!ignoreArray) {  					this.Write ("]");  				}  			}  			else {  				string s;  				if (results [0] != null) {  					s = results [0];  					if (modifier == "raw") {  						s = s.Trim ('"');  					}  				}  				else {  					s = "null";  				}  				this.Write (s);  			}  		}  		else if (typeParams != null) {  			var type = this.GetAstTypeByKey (typeParams' key);  			if (type != null) {  				if (modifier == "default" || modifier == "defaultFn") {  					var def = Inspector.GetDefaultFieldValue (type' this.Emitter.Resolver);  					this.GetDefaultValue (def' modifier);  				}  				else {  					type.AcceptVisitor (this.Emitter);  				}  			}  			else {  				var iType = this.GetTypeByKey (typeParams' key);  				if (iType != null) {  					if (modifier == "default" || modifier == "defaultFn") {  						var def = Inspector.GetDefaultFieldValue (iType.IType' iType.AstType);  						this.GetDefaultValue (def' modifier);  					}  					else {  						new CastBlock (this.Emitter' iType.IType).Emit ();  					}  				}  			}  		}  	}  	if (this.Emitter.Writers.Count != count) {  		this.PopWriter ();  	}  	string replacement = this.Emitter.Output.ToString ();  	this.Emitter.Output = oldSb;  	if (!isSimple && keyMatches.Count (keyMatch =>  {  		string key1 = keyMatch.Groups [2].Value;  		string modifier1 = keyMatch.Groups [1].Success ? keyMatch.Groups [4].Value : null;  		return key == key1 && modifier1 == modifier;  	}) > 1) {  		var t = this.GetTempVarName ();  		tempVars.Add (t' replacement);  		tempMap [tempKey] = t;  		return t;  	}  	return replacement;  });  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (!isSimple && keyMatches.Count (keyMatch =>  {  	string key1 = keyMatch.Groups [2].Value;  	string modifier1 = keyMatch.Groups [1].Success ? keyMatch.Groups [4].Value : null;  	return key == key1 && modifier1 == modifier;  }) > 1) {  	var t = this.GetTempVarName ();  	tempVars.Add (t' replacement);  	tempMap [tempKey] = t;  	return t;  }  
Magic Number,Bridge.Translator,InlineArgumentsBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\InlineArgumentsBlock.cs,EmitInlineExpressionList,The following statement contains a magic number: if (!isSimple && keyMatches.Count (keyMatch =>  {  	string key1 = keyMatch.Groups [2].Value;  	string modifier1 = keyMatch.Groups [1].Success ? keyMatch.Groups [4].Value : null;  	return key == key1 && modifier1 == modifier;  }) > 1) {  	var t = this.GetTempVarName ();  	tempVars.Add (t' replacement);  	tempMap [tempKey] = t;  	return t;  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: foreach (var t in this.Types) {  	hitCounters [0]++;  	var parents = this.GetParents (t.Type);  	var tProcess = graph.Processes.FirstOrDefault (p => p.Name == t.Type.ReflectionName);  	if (tProcess == null) {  		hitCounters [1]++;  		tProcess = new TopologicalSorting.OrderedProcess (graph' t.Type.ReflectionName);  	}  	for (int i = parents.Count - 1; i > -1; i--) {  		hitCounters [2]++;  		var x = parents [i];  		if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  			hitCounters [3]++;  			var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  			if (dProcess == null) {  				hitCounters [4]++;  				dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  			}  			//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  			if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  				hitCounters [4]++;  				tProcess.After (dProcess);  			}  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: foreach (var t in this.Types) {  	hitCounters [0]++;  	var parents = this.GetParents (t.Type);  	var tProcess = graph.Processes.FirstOrDefault (p => p.Name == t.Type.ReflectionName);  	if (tProcess == null) {  		hitCounters [1]++;  		tProcess = new TopologicalSorting.OrderedProcess (graph' t.Type.ReflectionName);  	}  	for (int i = parents.Count - 1; i > -1; i--) {  		hitCounters [2]++;  		var x = parents [i];  		if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  			hitCounters [3]++;  			var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  			if (dProcess == null) {  				hitCounters [4]++;  				dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  			}  			//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  			if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  				hitCounters [4]++;  				tProcess.After (dProcess);  			}  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: foreach (var t in this.Types) {  	hitCounters [0]++;  	var parents = this.GetParents (t.Type);  	var tProcess = graph.Processes.FirstOrDefault (p => p.Name == t.Type.ReflectionName);  	if (tProcess == null) {  		hitCounters [1]++;  		tProcess = new TopologicalSorting.OrderedProcess (graph' t.Type.ReflectionName);  	}  	for (int i = parents.Count - 1; i > -1; i--) {  		hitCounters [2]++;  		var x = parents [i];  		if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  			hitCounters [3]++;  			var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  			if (dProcess == null) {  				hitCounters [4]++;  				dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  			}  			//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  			if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  				hitCounters [4]++;  				tProcess.After (dProcess);  			}  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: foreach (var t in this.Types) {  	hitCounters [0]++;  	var parents = this.GetParents (t.Type);  	var tProcess = graph.Processes.FirstOrDefault (p => p.Name == t.Type.ReflectionName);  	if (tProcess == null) {  		hitCounters [1]++;  		tProcess = new TopologicalSorting.OrderedProcess (graph' t.Type.ReflectionName);  	}  	for (int i = parents.Count - 1; i > -1; i--) {  		hitCounters [2]++;  		var x = parents [i];  		if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  			hitCounters [3]++;  			var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  			if (dProcess == null) {  				hitCounters [4]++;  				dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  			}  			//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  			if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  				hitCounters [4]++;  				tProcess.After (dProcess);  			}  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: for (int i = parents.Count - 1; i > -1; i--) {  	hitCounters [2]++;  	var x = parents [i];  	if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  		hitCounters [3]++;  		var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  		if (dProcess == null) {  			hitCounters [4]++;  			dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  		}  		//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  		if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  			hitCounters [4]++;  			tProcess.After (dProcess);  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: for (int i = parents.Count - 1; i > -1; i--) {  	hitCounters [2]++;  	var x = parents [i];  	if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  		hitCounters [3]++;  		var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  		if (dProcess == null) {  			hitCounters [4]++;  			dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  		}  		//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  		if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  			hitCounters [4]++;  			tProcess.After (dProcess);  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: for (int i = parents.Count - 1; i > -1; i--) {  	hitCounters [2]++;  	var x = parents [i];  	if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  		hitCounters [3]++;  		var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  		if (dProcess == null) {  			hitCounters [4]++;  			dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  		}  		//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  		if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  			hitCounters [4]++;  			tProcess.After (dProcess);  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: for (int i = parents.Count - 1; i > -1; i--) {  	hitCounters [2]++;  	var x = parents [i];  	if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  		hitCounters [3]++;  		var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  		if (dProcess == null) {  			hitCounters [4]++;  			dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  		}  		//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  		if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  			hitCounters [4]++;  			tProcess.After (dProcess);  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: hitCounters [2]++;  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  	hitCounters [3]++;  	var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  	if (dProcess == null) {  		hitCounters [4]++;  		dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  	}  	//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  	if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  		hitCounters [4]++;  		tProcess.After (dProcess);  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  	hitCounters [3]++;  	var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  	if (dProcess == null) {  		hitCounters [4]++;  		dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  	}  	//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  	if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  		hitCounters [4]++;  		tProcess.After (dProcess);  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: if (tProcess.Predecessors.All (p => p.Name != x.Type.ReflectionName)) {  	hitCounters [3]++;  	var dProcess = graph.Processes.FirstOrDefault (p => p.Name == x.Type.ReflectionName);  	if (dProcess == null) {  		hitCounters [4]++;  		dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  	}  	//var dProcess = new TopologicalSorting.OrderedProcess(graph' dependency.Type.FullName);  	if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  		hitCounters [4]++;  		tProcess.After (dProcess);  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: hitCounters [3]++;  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: if (dProcess == null) {  	hitCounters [4]++;  	dProcess = new TopologicalSorting.OrderedProcess (graph' x.Type.ReflectionName);  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: hitCounters [4]++;  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: if (dProcess.Predecessors.All (p => p.Name != tProcess.Name)) {  	hitCounters [4]++;  	tProcess.After (dProcess);  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: hitCounters [4]++;  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: if (graph.ProcessCount > 0) {  	ITypeInfo tInfo = null;  	try {  		this.Log.Trace ("\tTopological sorting third iteration...");  		System.Array.Clear (hitCounters' 0' hitCounters.Length);  		this.Log.Trace ("\t\tCalculate sorting...");  		IEnumerable<IEnumerable<OrderedProcess>> sorted = graph.CalculateSort ();  		this.Log.Trace ("\t\tCalculate sorting done");  		var list = new List<ITypeInfo> (this.Types.Count);  		foreach (var processes in sorted) {  			hitCounters [0]++;  			foreach (var process in processes) {  				hitCounters [1]++;  				tInfo = this.Types.First (ti => ti.Type.ReflectionName == process.Name);  				if (list.All (t => t.Type.ReflectionName != tInfo.Type.ReflectionName)) {  					hitCounters [2]++;  					list.Add (tInfo);  				}  			}  		}  		this.Types.Clear ();  		this.Types.AddRange (list);  		for (int i = 0; i < hitCounters.Length; i++) {  			this.Log.Trace ("\t\tHitCounter" + i + " = " + hitCounters [i]);  		}  		this.Log.Trace ("\tTopological sorting third iteration done");  	}  	catch (System.Exception ex) {  		this.LogWarning (string.Format ("Topological sort failed {0} with error {1}"' tInfo != null ? "at type " + tInfo.Type.ReflectionName : string.Empty' ex));  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: try {  	this.Log.Trace ("\tTopological sorting third iteration...");  	System.Array.Clear (hitCounters' 0' hitCounters.Length);  	this.Log.Trace ("\t\tCalculate sorting...");  	IEnumerable<IEnumerable<OrderedProcess>> sorted = graph.CalculateSort ();  	this.Log.Trace ("\t\tCalculate sorting done");  	var list = new List<ITypeInfo> (this.Types.Count);  	foreach (var processes in sorted) {  		hitCounters [0]++;  		foreach (var process in processes) {  			hitCounters [1]++;  			tInfo = this.Types.First (ti => ti.Type.ReflectionName == process.Name);  			if (list.All (t => t.Type.ReflectionName != tInfo.Type.ReflectionName)) {  				hitCounters [2]++;  				list.Add (tInfo);  			}  		}  	}  	this.Types.Clear ();  	this.Types.AddRange (list);  	for (int i = 0; i < hitCounters.Length; i++) {  		this.Log.Trace ("\t\tHitCounter" + i + " = " + hitCounters [i]);  	}  	this.Log.Trace ("\tTopological sorting third iteration done");  }  catch (System.Exception ex) {  	this.LogWarning (string.Format ("Topological sort failed {0} with error {1}"' tInfo != null ? "at type " + tInfo.Type.ReflectionName : string.Empty' ex));  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: foreach (var processes in sorted) {  	hitCounters [0]++;  	foreach (var process in processes) {  		hitCounters [1]++;  		tInfo = this.Types.First (ti => ti.Type.ReflectionName == process.Name);  		if (list.All (t => t.Type.ReflectionName != tInfo.Type.ReflectionName)) {  			hitCounters [2]++;  			list.Add (tInfo);  		}  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: foreach (var process in processes) {  	hitCounters [1]++;  	tInfo = this.Types.First (ti => ti.Type.ReflectionName == process.Name);  	if (list.All (t => t.Type.ReflectionName != tInfo.Type.ReflectionName)) {  		hitCounters [2]++;  		list.Add (tInfo);  	}  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: if (list.All (t => t.Type.ReflectionName != tInfo.Type.ReflectionName)) {  	hitCounters [2]++;  	list.Add (tInfo);  }  
Magic Number,Bridge.Translator,Emitter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Emitter.TypeHelpers.cs,TopologicalSort,The following statement contains a magic number: hitCounters [2]++;  
Magic Number,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitConversionResolveResult,The following statement contains a magic number: if (rr.Conversion.IsIdentityConversion) {  	return input;  }  else if (rr.Conversion.IsAnonymousFunctionConversion) {  	var result = input;  	if (rr.Type.Name == "Expression")  		result = CompileFactoryCall ("Quote"' new[] {  			typeof(Expression)  		}' new[] {  			result  		});  	return result;  }  else if (rr.Conversion.IsNullLiteralConversion) {  	return CompileFactoryCall ("Constant"' new[] {  		typeof(object)'  		typeof(Type)  	}' new[] {  		input'  		ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  	});  }  else if (rr.Conversion.IsMethodGroupConversion) {  	var methodInfo = _compilation.FindType (typeof(MethodInfo));  	return CompileFactoryCall ("Convert"' new[] {  		typeof(Expression)'  		typeof(Type)  	}' new[] {  		CompileFactoryCall ("Call"' new[] {  			typeof(Expression)'  			typeof(MethodInfo)'  			typeof(Expression[])  		}' new[] {  			CompileFactoryCall ("Constant"' new[] {  				typeof(object)'  				typeof(Type)  			}' new[] {  				this.GetMember (rr.Conversion.Method)'  				ExpressionTreeBuilder.GetTypeName (methodInfo' this._emitter)  			})'  			this.GetMember (methodInfo.GetMethods ().Single (m => m.Name == "CreateDelegate" && m.Parameters.Count == 2 && m.Parameters [0].Type.FullName == typeof(Type).FullName && m.Parameters [1].Type.FullName == typeof(object).FullName))'  			this._emitter.ToJavaScript (new[] {  				new JRaw (ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter))'  				new JRaw (rr.Conversion.Method.IsStatic ? "null" : VisitResolveResult (((MethodGroupResolveResult)rr.Input).TargetResult' null))  			})  		})'  		ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  	});  }  else {  	string methodName;  	if (rr.Conversion.IsTryCast)  		methodName = "TypeAs";  	else if (rr.CheckForOverflow)  		methodName = "ConvertChecked";  	else  		methodName = "Convert";  	if (rr.Conversion.IsUserDefined)  		return CompileFactoryCall (methodName' new[] {  			typeof(Expression)'  			typeof(Type)'  			typeof(MethodInfo)  		}' new[] {  			input'  			ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)'  			this.GetMember (rr.Conversion.Method)  		});  	else  		return CompileFactoryCall (methodName' new[] {  			typeof(Expression)'  			typeof(Type)  		}' new[] {  			input'  			ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  		});  }  
Magic Number,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitConversionResolveResult,The following statement contains a magic number: if (rr.Conversion.IsAnonymousFunctionConversion) {  	var result = input;  	if (rr.Type.Name == "Expression")  		result = CompileFactoryCall ("Quote"' new[] {  			typeof(Expression)  		}' new[] {  			result  		});  	return result;  }  else if (rr.Conversion.IsNullLiteralConversion) {  	return CompileFactoryCall ("Constant"' new[] {  		typeof(object)'  		typeof(Type)  	}' new[] {  		input'  		ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  	});  }  else if (rr.Conversion.IsMethodGroupConversion) {  	var methodInfo = _compilation.FindType (typeof(MethodInfo));  	return CompileFactoryCall ("Convert"' new[] {  		typeof(Expression)'  		typeof(Type)  	}' new[] {  		CompileFactoryCall ("Call"' new[] {  			typeof(Expression)'  			typeof(MethodInfo)'  			typeof(Expression[])  		}' new[] {  			CompileFactoryCall ("Constant"' new[] {  				typeof(object)'  				typeof(Type)  			}' new[] {  				this.GetMember (rr.Conversion.Method)'  				ExpressionTreeBuilder.GetTypeName (methodInfo' this._emitter)  			})'  			this.GetMember (methodInfo.GetMethods ().Single (m => m.Name == "CreateDelegate" && m.Parameters.Count == 2 && m.Parameters [0].Type.FullName == typeof(Type).FullName && m.Parameters [1].Type.FullName == typeof(object).FullName))'  			this._emitter.ToJavaScript (new[] {  				new JRaw (ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter))'  				new JRaw (rr.Conversion.Method.IsStatic ? "null" : VisitResolveResult (((MethodGroupResolveResult)rr.Input).TargetResult' null))  			})  		})'  		ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  	});  }  else {  	string methodName;  	if (rr.Conversion.IsTryCast)  		methodName = "TypeAs";  	else if (rr.CheckForOverflow)  		methodName = "ConvertChecked";  	else  		methodName = "Convert";  	if (rr.Conversion.IsUserDefined)  		return CompileFactoryCall (methodName' new[] {  			typeof(Expression)'  			typeof(Type)'  			typeof(MethodInfo)  		}' new[] {  			input'  			ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)'  			this.GetMember (rr.Conversion.Method)  		});  	else  		return CompileFactoryCall (methodName' new[] {  			typeof(Expression)'  			typeof(Type)  		}' new[] {  			input'  			ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  		});  }  
Magic Number,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitConversionResolveResult,The following statement contains a magic number: if (rr.Conversion.IsNullLiteralConversion) {  	return CompileFactoryCall ("Constant"' new[] {  		typeof(object)'  		typeof(Type)  	}' new[] {  		input'  		ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  	});  }  else if (rr.Conversion.IsMethodGroupConversion) {  	var methodInfo = _compilation.FindType (typeof(MethodInfo));  	return CompileFactoryCall ("Convert"' new[] {  		typeof(Expression)'  		typeof(Type)  	}' new[] {  		CompileFactoryCall ("Call"' new[] {  			typeof(Expression)'  			typeof(MethodInfo)'  			typeof(Expression[])  		}' new[] {  			CompileFactoryCall ("Constant"' new[] {  				typeof(object)'  				typeof(Type)  			}' new[] {  				this.GetMember (rr.Conversion.Method)'  				ExpressionTreeBuilder.GetTypeName (methodInfo' this._emitter)  			})'  			this.GetMember (methodInfo.GetMethods ().Single (m => m.Name == "CreateDelegate" && m.Parameters.Count == 2 && m.Parameters [0].Type.FullName == typeof(Type).FullName && m.Parameters [1].Type.FullName == typeof(object).FullName))'  			this._emitter.ToJavaScript (new[] {  				new JRaw (ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter))'  				new JRaw (rr.Conversion.Method.IsStatic ? "null" : VisitResolveResult (((MethodGroupResolveResult)rr.Input).TargetResult' null))  			})  		})'  		ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  	});  }  else {  	string methodName;  	if (rr.Conversion.IsTryCast)  		methodName = "TypeAs";  	else if (rr.CheckForOverflow)  		methodName = "ConvertChecked";  	else  		methodName = "Convert";  	if (rr.Conversion.IsUserDefined)  		return CompileFactoryCall (methodName' new[] {  			typeof(Expression)'  			typeof(Type)'  			typeof(MethodInfo)  		}' new[] {  			input'  			ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)'  			this.GetMember (rr.Conversion.Method)  		});  	else  		return CompileFactoryCall (methodName' new[] {  			typeof(Expression)'  			typeof(Type)  		}' new[] {  			input'  			ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  		});  }  
Magic Number,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitConversionResolveResult,The following statement contains a magic number: if (rr.Conversion.IsMethodGroupConversion) {  	var methodInfo = _compilation.FindType (typeof(MethodInfo));  	return CompileFactoryCall ("Convert"' new[] {  		typeof(Expression)'  		typeof(Type)  	}' new[] {  		CompileFactoryCall ("Call"' new[] {  			typeof(Expression)'  			typeof(MethodInfo)'  			typeof(Expression[])  		}' new[] {  			CompileFactoryCall ("Constant"' new[] {  				typeof(object)'  				typeof(Type)  			}' new[] {  				this.GetMember (rr.Conversion.Method)'  				ExpressionTreeBuilder.GetTypeName (methodInfo' this._emitter)  			})'  			this.GetMember (methodInfo.GetMethods ().Single (m => m.Name == "CreateDelegate" && m.Parameters.Count == 2 && m.Parameters [0].Type.FullName == typeof(Type).FullName && m.Parameters [1].Type.FullName == typeof(object).FullName))'  			this._emitter.ToJavaScript (new[] {  				new JRaw (ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter))'  				new JRaw (rr.Conversion.Method.IsStatic ? "null" : VisitResolveResult (((MethodGroupResolveResult)rr.Input).TargetResult' null))  			})  		})'  		ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  	});  }  else {  	string methodName;  	if (rr.Conversion.IsTryCast)  		methodName = "TypeAs";  	else if (rr.CheckForOverflow)  		methodName = "ConvertChecked";  	else  		methodName = "Convert";  	if (rr.Conversion.IsUserDefined)  		return CompileFactoryCall (methodName' new[] {  			typeof(Expression)'  			typeof(Type)'  			typeof(MethodInfo)  		}' new[] {  			input'  			ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)'  			this.GetMember (rr.Conversion.Method)  		});  	else  		return CompileFactoryCall (methodName' new[] {  			typeof(Expression)'  			typeof(Type)  		}' new[] {  			input'  			ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  		});  }  
Magic Number,Bridge.Translator,ExpressionTreeBuilder,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\ExpressionTreeBuilder.cs,VisitConversionResolveResult,The following statement contains a magic number: return CompileFactoryCall ("Convert"' new[] {  	typeof(Expression)'  	typeof(Type)  }' new[] {  	CompileFactoryCall ("Call"' new[] {  		typeof(Expression)'  		typeof(MethodInfo)'  		typeof(Expression[])  	}' new[] {  		CompileFactoryCall ("Constant"' new[] {  			typeof(object)'  			typeof(Type)  		}' new[] {  			this.GetMember (rr.Conversion.Method)'  			ExpressionTreeBuilder.GetTypeName (methodInfo' this._emitter)  		})'  		this.GetMember (methodInfo.GetMethods ().Single (m => m.Name == "CreateDelegate" && m.Parameters.Count == 2 && m.Parameters [0].Type.FullName == typeof(Type).FullName && m.Parameters [1].Type.FullName == typeof(object).FullName))'  		this._emitter.ToJavaScript (new[] {  			new JRaw (ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter))'  			new JRaw (rr.Conversion.Method.IsStatic ? "null" : VisitResolveResult (((MethodGroupResolveResult)rr.Input).TargetResult' null))  		})  	})'  	ExpressionTreeBuilder.GetTypeName (rr.Type' this._emitter)  });  
Magic Number,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,TrimResourceAssemblyName,The following statement contains a magic number: if (i >= 0) {  	trimmedName = trimmedName.Remove (i' 4);  }  
Magic Number,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,TrimResourceAssemblyName,The following statement contains a magic number: trimmedName = trimmedName.Remove (i' 4);  
Magic Number,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,TrimAssemblyName,The following statement contains a magic number: if (i >= 0) {  	trimmedName = trimmedName.Remove (i' 4);  }  
Magic Number,Bridge.Translator,Plugins,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Translator\Plugins.cs,TrimAssemblyName,The following statement contains a magic number: trimmedName = trimmedName.Remove (i' 4);  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The following statement contains a magic number: if (type.Kind == TypeKind.Class || type.Kind == TypeKind.Struct || type.Kind == TypeKind.Interface) {  	var members = type.Members.Where (m => MetadataUtils.IsReflectable (m' emitter' ifHasAttribute' tree)).OrderBy (m => m' MemberOrderer.Instance).Select (m => MetadataUtils.ConstructMemberInfo (m' emitter' false' false' tree)).ToList ();  	if (members.Count > 0) {  		properties.Add ("members"' new JArray (members));  	}  	var aua = type.Attributes.FirstOrDefault (a => a.AttributeType.FullName == "System.AttributeUsageAttribute");  	if (aua != null) {  		var inherited = true;  		var allowMultiple = false;  		if (aua.PositionalArguments.Count == 3) {  			allowMultiple = (bool)aua.PositionalArguments [1].ConstantValue;  			inherited = (bool)aua.PositionalArguments [2].ConstantValue;  		}  		if (aua.NamedArguments.Count > 0) {  			foreach (var arg in aua.NamedArguments) {  				if (arg.Key.Name == "AllowMultiple") {  					allowMultiple = (bool)arg.Value.ConstantValue;  				}  				else if (arg.Key.Name == "Inherited") {  					inherited = (bool)arg.Value.ConstantValue;  				}  			}  		}  		if (!inherited) {  			properties.Add ("attrNoInherit"' true);  		}  		if (allowMultiple) {  			properties.Add ("attrAllowMultiple"' true);  		}  	}  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The following statement contains a magic number: if (type.Kind == TypeKind.Class || type.Kind == TypeKind.Struct || type.Kind == TypeKind.Interface) {  	var members = type.Members.Where (m => MetadataUtils.IsReflectable (m' emitter' ifHasAttribute' tree)).OrderBy (m => m' MemberOrderer.Instance).Select (m => MetadataUtils.ConstructMemberInfo (m' emitter' false' false' tree)).ToList ();  	if (members.Count > 0) {  		properties.Add ("members"' new JArray (members));  	}  	var aua = type.Attributes.FirstOrDefault (a => a.AttributeType.FullName == "System.AttributeUsageAttribute");  	if (aua != null) {  		var inherited = true;  		var allowMultiple = false;  		if (aua.PositionalArguments.Count == 3) {  			allowMultiple = (bool)aua.PositionalArguments [1].ConstantValue;  			inherited = (bool)aua.PositionalArguments [2].ConstantValue;  		}  		if (aua.NamedArguments.Count > 0) {  			foreach (var arg in aua.NamedArguments) {  				if (arg.Key.Name == "AllowMultiple") {  					allowMultiple = (bool)arg.Value.ConstantValue;  				}  				else if (arg.Key.Name == "Inherited") {  					inherited = (bool)arg.Value.ConstantValue;  				}  			}  		}  		if (!inherited) {  			properties.Add ("attrNoInherit"' true);  		}  		if (allowMultiple) {  			properties.Add ("attrAllowMultiple"' true);  		}  	}  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The following statement contains a magic number: if (aua != null) {  	var inherited = true;  	var allowMultiple = false;  	if (aua.PositionalArguments.Count == 3) {  		allowMultiple = (bool)aua.PositionalArguments [1].ConstantValue;  		inherited = (bool)aua.PositionalArguments [2].ConstantValue;  	}  	if (aua.NamedArguments.Count > 0) {  		foreach (var arg in aua.NamedArguments) {  			if (arg.Key.Name == "AllowMultiple") {  				allowMultiple = (bool)arg.Value.ConstantValue;  			}  			else if (arg.Key.Name == "Inherited") {  				inherited = (bool)arg.Value.ConstantValue;  			}  		}  	}  	if (!inherited) {  		properties.Add ("attrNoInherit"' true);  	}  	if (allowMultiple) {  		properties.Add ("attrAllowMultiple"' true);  	}  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The following statement contains a magic number: if (aua != null) {  	var inherited = true;  	var allowMultiple = false;  	if (aua.PositionalArguments.Count == 3) {  		allowMultiple = (bool)aua.PositionalArguments [1].ConstantValue;  		inherited = (bool)aua.PositionalArguments [2].ConstantValue;  	}  	if (aua.NamedArguments.Count > 0) {  		foreach (var arg in aua.NamedArguments) {  			if (arg.Key.Name == "AllowMultiple") {  				allowMultiple = (bool)arg.Value.ConstantValue;  			}  			else if (arg.Key.Name == "Inherited") {  				inherited = (bool)arg.Value.ConstantValue;  			}  		}  	}  	if (!inherited) {  		properties.Add ("attrNoInherit"' true);  	}  	if (allowMultiple) {  		properties.Add ("attrAllowMultiple"' true);  	}  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The following statement contains a magic number: if (aua.PositionalArguments.Count == 3) {  	allowMultiple = (bool)aua.PositionalArguments [1].ConstantValue;  	inherited = (bool)aua.PositionalArguments [2].ConstantValue;  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The following statement contains a magic number: if (aua.PositionalArguments.Count == 3) {  	allowMultiple = (bool)aua.PositionalArguments [1].ConstantValue;  	inherited = (bool)aua.PositionalArguments [2].ConstantValue;  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructTypeMetadata,The following statement contains a magic number: inherited = (bool)aua.PositionalArguments [2].ConstantValue;  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The following statement contains a magic number: if (m is IMethod) {  	var method = (IMethod)m;  	var inline = emitter.GetInline (method);  	if (string.IsNullOrEmpty (inline) && method.Attributes.Any (a => a.AttributeType.FullName == "Bridge.ExpandParamsAttribute")) {  		properties.Add ("exp"' true);  	}  	properties.Add ("type"' (int)MemberTypes.Method);  	var parametersInfo = method.Parameters.Select (p => MetadataUtils.ConstructParameterInfo (p' emitter' false' false' tree)).ToList ();  	if (parametersInfo.Count > 0) {  		properties.Add ("paramsInfo"' new JArray (parametersInfo));  	}  	if (!string.IsNullOrEmpty (inline)) {  		if (inline.StartsWith ("<self>")) {  			inline = inline.Substring (6);  		}  		var block = new InlineArgumentsBlock (emitter' new ArgumentsInfo (emitter' method)' inline' method);  		var oldWriter = block.SaveWriter ();  		block.NewWriter ();  		block.EmitFunctionReference (true);  		var str = emitter.Output.ToString ();  		block.RestoreWriter (oldWriter);  		properties.Add ("tpcount"' method.TypeParameters.Count);  		properties.Add ("def"' new JRaw (str));  	}  	else {  		if (MetadataUtils.IsJsGeneric (method' emitter)) {  			properties.Add ("tpcount"' method.TypeParameters.Count);  		}  		string sname;  		if (method.IsAccessor) {  			if (method.AccessorOwner is IProperty) {  				sname = Helpers.GetPropertyRef (method.AccessorOwner' emitter' ((IProperty)method.AccessorOwner).Setter == method);  			}  			else if (method.AccessorOwner is IEvent) {  				sname = Helpers.GetEventRef (method.AccessorOwner' emitter' ((IEvent)method.AccessorOwner).RemoveAccessor == method);  			}  			else {  				sname = OverloadsCollection.Create (emitter' method).GetOverloadName ();  			}  		}  		else {  			sname = OverloadsCollection.Create (emitter' method).GetOverloadName ();  		}  		properties.Add ("sname"' sname);  	}  	properties.Add ("returnType"' new JRaw (MetadataUtils.GetTypeName (method.ReturnType' emitter' isGenericSpecialization)));  	var attr = MetadataUtils.GetScriptableAttributes (method.ReturnTypeAttributes' emitter' tree).ToList ();  	if (attr.Count > 0) {  		JArray attrArr = new JArray ();  		foreach (var a in attr) {  			attrArr.Add (MetadataUtils.ConstructAttribute (a' null' emitter));  		}  		properties.Add ("returnTypeAttributes"' attrArr);  	}  	if (method.Parameters.Count > 0) {  		properties.Add ("params"' new JArray (method.Parameters.Select (p => new JRaw (MetadataUtils.GetTypeName (p.Type' emitter' isGenericSpecialization)))));  	}  }  else if (m is IField) {  	var field = (IField)m;  	properties.Add ("type"' (int)MemberTypes.Field);  	properties.Add ("returnType"' new JRaw (MetadataUtils.GetTypeName (field.ReturnType' emitter' isGenericSpecialization)));  	properties.Add ("sname"' OverloadsCollection.Create (emitter' field).GetOverloadName ());  	properties.Add ("isReadOnly"' field.IsReadOnly);  }  else if (m is IProperty) {  	var prop = (IProperty)m;  	properties.Add ("type"' (int)MemberTypes.Property);  	properties.Add ("returnType"' new JRaw (MetadataUtils.GetTypeName (prop.ReturnType' emitter' isGenericSpecialization)));  	if (prop.Parameters.Count > 0) {  		properties.Add ("params"' new JArray (prop.Parameters.Select (p => new JRaw (MetadataUtils.GetTypeName (p.Type' emitter' isGenericSpecialization)))));  	}  	if (prop.IsIndexer) {  		properties.Add ("isIndexer"' true);  	}  	if (prop.IsIndexer) {  		if (prop.Getter != null) {  			var parametersInfo = prop.Getter.Parameters.Select (p => MetadataUtils.ConstructParameterInfo (p' emitter' false' false' tree)).ToList ();  			if (parametersInfo.Count > 0) {  				properties.Add ("indexParamsInfo"' new JArray (parametersInfo));  			}  		}  		else if (prop.Setter != null) {  			var parametersInfo = prop.Setter.Parameters.Take (prop.Setter.Parameters.Count - 1).Select (p => MetadataUtils.ConstructParameterInfo (p' emitter' false' false' tree)).ToList ();  			if (parametersInfo.Count > 0) {  				properties.Add ("indexParamsInfo"' new JArray (parametersInfo));  			}  		}  	}  	if (!Helpers.IsFieldProperty (prop' emitter)) {  		if (prop.CanGet) {  			properties.Add ("getter"' MetadataUtils.ConstructMemberInfo (prop.Getter' emitter' includeDeclaringType' isGenericSpecialization' tree));  		}  		if (prop.CanSet) {  			properties.Add ("setter"' MetadataUtils.ConstructMemberInfo (prop.Setter' emitter' includeDeclaringType' isGenericSpecialization' tree));  		}  	}  	else {  		var fieldName = OverloadsCollection.Create (emitter' prop).GetOverloadName ();  		if (prop.CanGet) {  			properties.Add ("getter"' MetadataUtils.ConstructFieldPropertyAccessor (prop.Getter' emitter' fieldName' true' includeDeclaringType' isGenericSpecialization' tree));  		}  		if (prop.CanSet) {  			properties.Add ("setter"' MetadataUtils.ConstructFieldPropertyAccessor (prop.Setter' emitter' fieldName' false' includeDeclaringType' isGenericSpecialization' tree));  		}  		properties.Add ("fname"' fieldName);  	}  }  else if (m is IEvent) {  	var evt = (IEvent)m;  	properties.Add ("type"' (int)MemberTypes.Event);  	properties.Add ("adder"' MetadataUtils.ConstructMemberInfo (evt.AddAccessor' emitter' includeDeclaringType' isGenericSpecialization' tree));  	properties.Add ("remover"' MetadataUtils.ConstructMemberInfo (evt.RemoveAccessor' emitter' includeDeclaringType' isGenericSpecialization' tree));  }  else {  	throw new ArgumentException ("Invalid member " + m);  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The following statement contains a magic number: if (!string.IsNullOrEmpty (inline)) {  	if (inline.StartsWith ("<self>")) {  		inline = inline.Substring (6);  	}  	var block = new InlineArgumentsBlock (emitter' new ArgumentsInfo (emitter' method)' inline' method);  	var oldWriter = block.SaveWriter ();  	block.NewWriter ();  	block.EmitFunctionReference (true);  	var str = emitter.Output.ToString ();  	block.RestoreWriter (oldWriter);  	properties.Add ("tpcount"' method.TypeParameters.Count);  	properties.Add ("def"' new JRaw (str));  }  else {  	if (MetadataUtils.IsJsGeneric (method' emitter)) {  		properties.Add ("tpcount"' method.TypeParameters.Count);  	}  	string sname;  	if (method.IsAccessor) {  		if (method.AccessorOwner is IProperty) {  			sname = Helpers.GetPropertyRef (method.AccessorOwner' emitter' ((IProperty)method.AccessorOwner).Setter == method);  		}  		else if (method.AccessorOwner is IEvent) {  			sname = Helpers.GetEventRef (method.AccessorOwner' emitter' ((IEvent)method.AccessorOwner).RemoveAccessor == method);  		}  		else {  			sname = OverloadsCollection.Create (emitter' method).GetOverloadName ();  		}  	}  	else {  		sname = OverloadsCollection.Create (emitter' method).GetOverloadName ();  	}  	properties.Add ("sname"' sname);  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The following statement contains a magic number: if (inline.StartsWith ("<self>")) {  	inline = inline.Substring (6);  }  
Magic Number,Bridge.Translator,MetadataUtils,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\MetadataUtils.cs,ConstructMemberInfo,The following statement contains a magic number: inline = inline.Substring (6);  
Magic Number,Bridge.Translator,SharpSixRewriter,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SharpSixRewriter.cs,VisitObjectCreationExpression,The following statement contains a magic number: if (needRewrite) {  	if (this.IsExpressionOfT) {  		if (isImplicitElementAccessSyntax) {  			var mapped = this.semanticModel.SyntaxTree.GetLineSpan (node.Span);  			throw new Exception (string.Format (CultureInfo.InvariantCulture' "{2} - {3}({0}'{1}): {4}"' mapped.StartLinePosition.Line + 1' mapped.StartLinePosition.Character + 1' "Index collection initializer is not supported inside Expression<T>"' this.semanticModel.SyntaxTree.FilePath' node.ToString ()));  		}  		if (extensionMethodExists) {  			var mapped = this.semanticModel.SyntaxTree.GetLineSpan (node.Span);  			throw new Exception (string.Format (CultureInfo.InvariantCulture' "{2} - {3}({0}'{1}): {4}"' mapped.StartLinePosition.Line + 1' mapped.StartLinePosition.Character + 1' "Extension method for collection initializer is not supported inside Expression<T>"' this.semanticModel.SyntaxTree.FilePath' node.ToString ()));  		}  		return node;  	}  	var initializers = node.Initializer.Expressions;  	ExpressionSyntax[] args = new ExpressionSyntax[2];  	var target = node.WithInitializer (null).WithoutTrivia ();  	if (target.ArgumentList == null) {  		target = target.WithArgumentList (SyntaxFactory.ArgumentList ());  	}  	args [0] = target;  	List<StatementSyntax> statements = new List<StatementSyntax> ();  	var parent = node.Parent;  	while (parent != null && !(parent is MethodDeclarationSyntax) && !(parent is ClassDeclarationSyntax)) {  		parent = parent.Parent;  	}  	string instance = "_o" + ++indexInstance;  	if (parent != null) {  		var info = LocalUsageGatherer.GatherInfo (this.semanticModel' parent);  		while (info.DirectlyOrIndirectlyUsedLocals.Any (s => s.Name == instance)) {  			instance = "_o" + ++indexInstance;  		}  	}  	SharpSixRewriter.ConvertInitializers (initializers' instance' statements' initializerInfos);  	statements.Add (SyntaxFactory.ReturnStatement (SyntaxFactory.IdentifierName (instance).WithLeadingTrivia (SyntaxFactory.Space)));  	var body = SyntaxFactory.Block (statements);  	var lambda = SyntaxFactory.ParenthesizedLambdaExpression (SyntaxFactory.ParameterList (SyntaxFactory.SeparatedList (new[] {  		SyntaxFactory.Parameter (SyntaxFactory.Identifier (instance))  	}))' body);  	args [1] = lambda;  	var methodIdentifier = SyntaxFactory.IdentifierName ("Bridge.Script.CallFor");  	var invocation = SyntaxFactory.InvocationExpression (methodIdentifier' SyntaxFactory.ArgumentList (SyntaxFactory.SeparatedList (args.Select (SyntaxFactory.Argument))));  	return invocation;  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (symbol != null && symbol.Kind != SymbolKind.Namespace) {  	bool preserveMemberChange = !(symbol.Kind == SymbolKind.Method || symbol.Kind == SymbolKind.Property);  	int enumMode = -1;  	if (symbol.ContainingType != null && symbol.ContainingType.TypeKind == TypeKind.Enum && symbol is IFieldSymbol) {  		string enumAttr = Translator.Bridge_ASSEMBLY + ".EnumAttribute";  		enumMode = 7;  		foreach (var attr in symbol.ContainingType.GetAttributes ()) {  			if (attr.AttributeClass != null && attr.AttributeClass.FullyQualifiedName () == enumAttr && attr.ConstructorArguments.Any ()) {  				enumMode = (int)attr.ConstructorArguments.First ().Value;  				break;  			}  		}  	}  	if (symbol is IFieldSymbol && ((IFieldSymbol)symbol).IsConst) {  		preserveMemberChange = true;  	}  	var nameAttr = SyntaxHelper.GetInheritedAttribute (symbol' Bridge.Translator.Translator.Bridge_ASSEMBLY + ".NameAttribute");  	bool isIgnore = symbol.ContainingType != null && SyntaxHelper.IsIgnoreType (symbol.ContainingType);  	name = symbol.Name;  	if (nameAttr != null) {  		var value = nameAttr.ConstructorArguments.First ().Value;  		if (value is string) {  			name = value.ToString ();  			if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			return name;  		}  		preserveMemberChange = !(bool)value;  		enumMode = -1;  	}  	if (enumMode > 6) {  		switch (enumMode) {  		case 7:  			break;  		case 8:  			name = name.ToLowerInvariant ();  			break;  		case 9:  			name = name.ToUpperInvariant ();  			break;  		}  	}  	else {  		name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  	}  	if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (symbol != null && symbol.Kind != SymbolKind.Namespace) {  	bool preserveMemberChange = !(symbol.Kind == SymbolKind.Method || symbol.Kind == SymbolKind.Property);  	int enumMode = -1;  	if (symbol.ContainingType != null && symbol.ContainingType.TypeKind == TypeKind.Enum && symbol is IFieldSymbol) {  		string enumAttr = Translator.Bridge_ASSEMBLY + ".EnumAttribute";  		enumMode = 7;  		foreach (var attr in symbol.ContainingType.GetAttributes ()) {  			if (attr.AttributeClass != null && attr.AttributeClass.FullyQualifiedName () == enumAttr && attr.ConstructorArguments.Any ()) {  				enumMode = (int)attr.ConstructorArguments.First ().Value;  				break;  			}  		}  	}  	if (symbol is IFieldSymbol && ((IFieldSymbol)symbol).IsConst) {  		preserveMemberChange = true;  	}  	var nameAttr = SyntaxHelper.GetInheritedAttribute (symbol' Bridge.Translator.Translator.Bridge_ASSEMBLY + ".NameAttribute");  	bool isIgnore = symbol.ContainingType != null && SyntaxHelper.IsIgnoreType (symbol.ContainingType);  	name = symbol.Name;  	if (nameAttr != null) {  		var value = nameAttr.ConstructorArguments.First ().Value;  		if (value is string) {  			name = value.ToString ();  			if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			return name;  		}  		preserveMemberChange = !(bool)value;  		enumMode = -1;  	}  	if (enumMode > 6) {  		switch (enumMode) {  		case 7:  			break;  		case 8:  			name = name.ToLowerInvariant ();  			break;  		case 9:  			name = name.ToUpperInvariant ();  			break;  		}  	}  	else {  		name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  	}  	if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (symbol != null && symbol.Kind != SymbolKind.Namespace) {  	bool preserveMemberChange = !(symbol.Kind == SymbolKind.Method || symbol.Kind == SymbolKind.Property);  	int enumMode = -1;  	if (symbol.ContainingType != null && symbol.ContainingType.TypeKind == TypeKind.Enum && symbol is IFieldSymbol) {  		string enumAttr = Translator.Bridge_ASSEMBLY + ".EnumAttribute";  		enumMode = 7;  		foreach (var attr in symbol.ContainingType.GetAttributes ()) {  			if (attr.AttributeClass != null && attr.AttributeClass.FullyQualifiedName () == enumAttr && attr.ConstructorArguments.Any ()) {  				enumMode = (int)attr.ConstructorArguments.First ().Value;  				break;  			}  		}  	}  	if (symbol is IFieldSymbol && ((IFieldSymbol)symbol).IsConst) {  		preserveMemberChange = true;  	}  	var nameAttr = SyntaxHelper.GetInheritedAttribute (symbol' Bridge.Translator.Translator.Bridge_ASSEMBLY + ".NameAttribute");  	bool isIgnore = symbol.ContainingType != null && SyntaxHelper.IsIgnoreType (symbol.ContainingType);  	name = symbol.Name;  	if (nameAttr != null) {  		var value = nameAttr.ConstructorArguments.First ().Value;  		if (value is string) {  			name = value.ToString ();  			if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			return name;  		}  		preserveMemberChange = !(bool)value;  		enumMode = -1;  	}  	if (enumMode > 6) {  		switch (enumMode) {  		case 7:  			break;  		case 8:  			name = name.ToLowerInvariant ();  			break;  		case 9:  			name = name.ToUpperInvariant ();  			break;  		}  	}  	else {  		name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  	}  	if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (symbol != null && symbol.Kind != SymbolKind.Namespace) {  	bool preserveMemberChange = !(symbol.Kind == SymbolKind.Method || symbol.Kind == SymbolKind.Property);  	int enumMode = -1;  	if (symbol.ContainingType != null && symbol.ContainingType.TypeKind == TypeKind.Enum && symbol is IFieldSymbol) {  		string enumAttr = Translator.Bridge_ASSEMBLY + ".EnumAttribute";  		enumMode = 7;  		foreach (var attr in symbol.ContainingType.GetAttributes ()) {  			if (attr.AttributeClass != null && attr.AttributeClass.FullyQualifiedName () == enumAttr && attr.ConstructorArguments.Any ()) {  				enumMode = (int)attr.ConstructorArguments.First ().Value;  				break;  			}  		}  	}  	if (symbol is IFieldSymbol && ((IFieldSymbol)symbol).IsConst) {  		preserveMemberChange = true;  	}  	var nameAttr = SyntaxHelper.GetInheritedAttribute (symbol' Bridge.Translator.Translator.Bridge_ASSEMBLY + ".NameAttribute");  	bool isIgnore = symbol.ContainingType != null && SyntaxHelper.IsIgnoreType (symbol.ContainingType);  	name = symbol.Name;  	if (nameAttr != null) {  		var value = nameAttr.ConstructorArguments.First ().Value;  		if (value is string) {  			name = value.ToString ();  			if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			return name;  		}  		preserveMemberChange = !(bool)value;  		enumMode = -1;  	}  	if (enumMode > 6) {  		switch (enumMode) {  		case 7:  			break;  		case 8:  			name = name.ToLowerInvariant ();  			break;  		case 9:  			name = name.ToUpperInvariant ();  			break;  		}  	}  	else {  		name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  	}  	if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (symbol != null && symbol.Kind != SymbolKind.Namespace) {  	bool preserveMemberChange = !(symbol.Kind == SymbolKind.Method || symbol.Kind == SymbolKind.Property);  	int enumMode = -1;  	if (symbol.ContainingType != null && symbol.ContainingType.TypeKind == TypeKind.Enum && symbol is IFieldSymbol) {  		string enumAttr = Translator.Bridge_ASSEMBLY + ".EnumAttribute";  		enumMode = 7;  		foreach (var attr in symbol.ContainingType.GetAttributes ()) {  			if (attr.AttributeClass != null && attr.AttributeClass.FullyQualifiedName () == enumAttr && attr.ConstructorArguments.Any ()) {  				enumMode = (int)attr.ConstructorArguments.First ().Value;  				break;  			}  		}  	}  	if (symbol is IFieldSymbol && ((IFieldSymbol)symbol).IsConst) {  		preserveMemberChange = true;  	}  	var nameAttr = SyntaxHelper.GetInheritedAttribute (symbol' Bridge.Translator.Translator.Bridge_ASSEMBLY + ".NameAttribute");  	bool isIgnore = symbol.ContainingType != null && SyntaxHelper.IsIgnoreType (symbol.ContainingType);  	name = symbol.Name;  	if (nameAttr != null) {  		var value = nameAttr.ConstructorArguments.First ().Value;  		if (value is string) {  			name = value.ToString ();  			if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			return name;  		}  		preserveMemberChange = !(bool)value;  		enumMode = -1;  	}  	if (enumMode > 6) {  		switch (enumMode) {  		case 7:  			break;  		case 8:  			name = name.ToLowerInvariant ();  			break;  		case 9:  			name = name.ToUpperInvariant ();  			break;  		}  	}  	else {  		name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  	}  	if (!isIgnore && symbol.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (symbol.ContainingType != null && symbol.ContainingType.TypeKind == TypeKind.Enum && symbol is IFieldSymbol) {  	string enumAttr = Translator.Bridge_ASSEMBLY + ".EnumAttribute";  	enumMode = 7;  	foreach (var attr in symbol.ContainingType.GetAttributes ()) {  		if (attr.AttributeClass != null && attr.AttributeClass.FullyQualifiedName () == enumAttr && attr.ConstructorArguments.Any ()) {  			enumMode = (int)attr.ConstructorArguments.First ().Value;  			break;  		}  	}  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: enumMode = 7;  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (enumMode > 6) {  	switch (enumMode) {  	case 7:  		break;  	case 8:  		name = name.ToLowerInvariant ();  		break;  	case 9:  		name = name.ToUpperInvariant ();  		break;  	}  }  else {  	name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (enumMode > 6) {  	switch (enumMode) {  	case 7:  		break;  	case 8:  		name = name.ToLowerInvariant ();  		break;  	case 9:  		name = name.ToUpperInvariant ();  		break;  	}  }  else {  	name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (enumMode > 6) {  	switch (enumMode) {  	case 7:  		break;  	case 8:  		name = name.ToLowerInvariant ();  		break;  	case 9:  		name = name.ToUpperInvariant ();  		break;  	}  }  else {  	name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: if (enumMode > 6) {  	switch (enumMode) {  	case 7:  		break;  	case 8:  		name = name.ToLowerInvariant ();  		break;  	case 9:  		name = name.ToUpperInvariant ();  		break;  	}  }  else {  	name = !preserveMemberChange ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (name) : name;  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: switch (enumMode) {  case 7:  	break;  case 8:  	name = name.ToLowerInvariant ();  	break;  case 9:  	name = name.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: switch (enumMode) {  case 7:  	break;  case 8:  	name = name.ToLowerInvariant ();  	break;  case 9:  	name = name.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following statement contains a magic number: switch (enumMode) {  case 7:  	break;  case 8:  	name = name.ToLowerInvariant ();  	break;  case 9:  	name = name.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (member != null) {  	var validator = new Validator ();  	var enumMode = validator.EnumEmitMode (member.Member.DeclaringTypeDefinition);  	if (enumMode >= 3 && enumMode < 7) {  		initializerIsString = true;  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			var value = attr.PositionalArguments.First ().ConstantValue;  			string name = null;  			if (value is string) {  				name = value.ToString ();  			}  			else if (value is bool) {  				name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  			}  			if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			initializer = new PrimitiveExpression (name);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  			initializer = new PrimitiveExpression (enumStringName);  		}  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (member != null) {  	var validator = new Validator ();  	var enumMode = validator.EnumEmitMode (member.Member.DeclaringTypeDefinition);  	if (enumMode >= 3 && enumMode < 7) {  		initializerIsString = true;  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			var value = attr.PositionalArguments.First ().ConstantValue;  			string name = null;  			if (value is string) {  				name = value.ToString ();  			}  			else if (value is bool) {  				name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  			}  			if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			initializer = new PrimitiveExpression (name);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  			initializer = new PrimitiveExpression (enumStringName);  		}  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (member != null) {  	var validator = new Validator ();  	var enumMode = validator.EnumEmitMode (member.Member.DeclaringTypeDefinition);  	if (enumMode >= 3 && enumMode < 7) {  		initializerIsString = true;  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			var value = attr.PositionalArguments.First ().ConstantValue;  			string name = null;  			if (value is string) {  				name = value.ToString ();  			}  			else if (value is bool) {  				name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  			}  			if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			initializer = new PrimitiveExpression (name);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  			initializer = new PrimitiveExpression (enumStringName);  		}  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (member != null) {  	var validator = new Validator ();  	var enumMode = validator.EnumEmitMode (member.Member.DeclaringTypeDefinition);  	if (enumMode >= 3 && enumMode < 7) {  		initializerIsString = true;  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			var value = attr.PositionalArguments.First ().ConstantValue;  			string name = null;  			if (value is string) {  				name = value.ToString ();  			}  			else if (value is bool) {  				name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  			}  			if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			initializer = new PrimitiveExpression (name);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  			initializer = new PrimitiveExpression (enumStringName);  		}  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (member != null) {  	var validator = new Validator ();  	var enumMode = validator.EnumEmitMode (member.Member.DeclaringTypeDefinition);  	if (enumMode >= 3 && enumMode < 7) {  		initializerIsString = true;  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			var value = attr.PositionalArguments.First ().ConstantValue;  			string name = null;  			if (value is string) {  				name = value.ToString ();  			}  			else if (value is bool) {  				name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  			}  			if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			initializer = new PrimitiveExpression (name);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  			initializer = new PrimitiveExpression (enumStringName);  		}  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (member != null) {  	var validator = new Validator ();  	var enumMode = validator.EnumEmitMode (member.Member.DeclaringTypeDefinition);  	if (enumMode >= 3 && enumMode < 7) {  		initializerIsString = true;  		string enumStringName = member.Member.Name;  		var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  		if (attr != null) {  			var value = attr.PositionalArguments.First ().ConstantValue;  			string name = null;  			if (value is string) {  				name = value.ToString ();  			}  			else if (value is bool) {  				name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  			}  			if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  				name = Helpers.ChangeReservedWord (name);  			}  			initializer = new PrimitiveExpression (name);  		}  		else {  			switch (enumMode) {  			case 3:  				enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  				break;  			case 4:  				break;  			case 5:  				enumStringName = enumStringName.ToLowerInvariant ();  				break;  			case 6:  				enumStringName = enumStringName.ToUpperInvariant ();  				break;  			}  			initializer = new PrimitiveExpression (enumStringName);  		}  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	initializerIsString = true;  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		var value = attr.PositionalArguments.First ().ConstantValue;  		string name = null;  		if (value is string) {  			name = value.ToString ();  		}  		else if (value is bool) {  			name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  		}  		if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  			name = Helpers.ChangeReservedWord (name);  		}  		initializer = new PrimitiveExpression (name);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  		initializer = new PrimitiveExpression (enumStringName);  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	initializerIsString = true;  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		var value = attr.PositionalArguments.First ().ConstantValue;  		string name = null;  		if (value is string) {  			name = value.ToString ();  		}  		else if (value is bool) {  			name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  		}  		if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  			name = Helpers.ChangeReservedWord (name);  		}  		initializer = new PrimitiveExpression (name);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  		initializer = new PrimitiveExpression (enumStringName);  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	initializerIsString = true;  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		var value = attr.PositionalArguments.First ().ConstantValue;  		string name = null;  		if (value is string) {  			name = value.ToString ();  		}  		else if (value is bool) {  			name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  		}  		if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  			name = Helpers.ChangeReservedWord (name);  		}  		initializer = new PrimitiveExpression (name);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  		initializer = new PrimitiveExpression (enumStringName);  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	initializerIsString = true;  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		var value = attr.PositionalArguments.First ().ConstantValue;  		string name = null;  		if (value is string) {  			name = value.ToString ();  		}  		else if (value is bool) {  			name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  		}  		if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  			name = Helpers.ChangeReservedWord (name);  		}  		initializer = new PrimitiveExpression (name);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  		initializer = new PrimitiveExpression (enumStringName);  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	initializerIsString = true;  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		var value = attr.PositionalArguments.First ().ConstantValue;  		string name = null;  		if (value is string) {  			name = value.ToString ();  		}  		else if (value is bool) {  			name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  		}  		if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  			name = Helpers.ChangeReservedWord (name);  		}  		initializer = new PrimitiveExpression (name);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  		initializer = new PrimitiveExpression (enumStringName);  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (enumMode >= 3 && enumMode < 7) {  	initializerIsString = true;  	string enumStringName = member.Member.Name;  	var attr = Helpers.GetInheritedAttribute (member.Member' Translator.Bridge_ASSEMBLY + ".NameAttribute");  	if (attr != null) {  		var value = attr.PositionalArguments.First ().ConstantValue;  		string name = null;  		if (value is string) {  			name = value.ToString ();  		}  		else if (value is bool) {  			name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  		}  		if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  			name = Helpers.ChangeReservedWord (name);  		}  		initializer = new PrimitiveExpression (name);  	}  	else {  		switch (enumMode) {  		case 3:  			enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  			break;  		case 4:  			break;  		case 5:  			enumStringName = enumStringName.ToLowerInvariant ();  			break;  		case 6:  			enumStringName = enumStringName.ToUpperInvariant ();  			break;  		}  		initializer = new PrimitiveExpression (enumStringName);  	}  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (attr != null) {  	var value = attr.PositionalArguments.First ().ConstantValue;  	string name = null;  	if (value is string) {  		name = value.ToString ();  	}  	else if (value is bool) {  		name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  	}  	if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  	initializer = new PrimitiveExpression (name);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  	initializer = new PrimitiveExpression (enumStringName);  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (attr != null) {  	var value = attr.PositionalArguments.First ().ConstantValue;  	string name = null;  	if (value is string) {  		name = value.ToString ();  	}  	else if (value is bool) {  		name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  	}  	if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  	initializer = new PrimitiveExpression (name);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  	initializer = new PrimitiveExpression (enumStringName);  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (attr != null) {  	var value = attr.PositionalArguments.First ().ConstantValue;  	string name = null;  	if (value is string) {  		name = value.ToString ();  	}  	else if (value is bool) {  		name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  	}  	if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  	initializer = new PrimitiveExpression (name);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  	initializer = new PrimitiveExpression (enumStringName);  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: if (attr != null) {  	var value = attr.PositionalArguments.First ().ConstantValue;  	string name = null;  	if (value is string) {  		name = value.ToString ();  	}  	else if (value is bool) {  		name = (bool)value ? Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name) : member.Member.Name;  	}  	if (member.Member.IsStatic && Emitter.IsReservedStaticName (name)) {  		name = Helpers.ChangeReservedWord (name);  	}  	initializer = new PrimitiveExpression (name);  }  else {  	switch (enumMode) {  	case 3:  		enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  		break;  	case 4:  		break;  	case 5:  		enumStringName = enumStringName.ToLowerInvariant ();  		break;  	case 6:  		enumStringName = enumStringName.ToUpperInvariant ();  		break;  	}  	initializer = new PrimitiveExpression (enumStringName);  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following statement contains a magic number: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Magic Number,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,IsValueEnum,The following statement contains a magic number: return this.EnumEmitMode (type) == 2;  
Magic Number,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,IsNameEnum,The following statement contains a magic number: return enumEmitMode == 1 || enumEmitMode > 6;  
Magic Number,Bridge.Translator,Validator,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Validator.cs,IsStringNameEnum,The following statement contains a magic number: return this.EnumEmitMode (type) == 3;  
Magic Number,Bridge.Translator,TypeInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\TypeInfo.cs,HasRealStatic,The following statement contains a magic number: if (this.StaticMethods.Any (group =>  {  	foreach (var method in group.Value) {  		if (Helpers.IsEntryPointMethod (emitter' method)) {  			return false;  		}  		if (method.Attributes.Count == 0) {  			return true;  		}  		foreach (var attrSection in method.Attributes) {  			foreach (var attr in attrSection.Attributes) {  				var rr = emitter.Resolver.ResolveNode (attr.Type' emitter);  				if (rr.Type.FullName == "Bridge.InitAttribute") {  					if (!attr.HasArgumentList) {  						return true;  					}  					var expr = attr.Arguments.First ();  					var argrr = emitter.Resolver.ResolveNode (expr' emitter);  					if (argrr.ConstantValue is int) {  						var value = (int)argrr.ConstantValue;  						if (value == 1 || value == 2) {  							return false;  						}  					}  					return true;  				}  				else {  					return true;  				}  			}  		}  	}  	return false;  })) {  	return true;  }  
Magic Number,Bridge.Translator,TypeInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\TypeInfo.cs,HasRealStatic,The following statement contains a magic number: foreach (var method in group.Value) {  	if (Helpers.IsEntryPointMethod (emitter' method)) {  		return false;  	}  	if (method.Attributes.Count == 0) {  		return true;  	}  	foreach (var attrSection in method.Attributes) {  		foreach (var attr in attrSection.Attributes) {  			var rr = emitter.Resolver.ResolveNode (attr.Type' emitter);  			if (rr.Type.FullName == "Bridge.InitAttribute") {  				if (!attr.HasArgumentList) {  					return true;  				}  				var expr = attr.Arguments.First ();  				var argrr = emitter.Resolver.ResolveNode (expr' emitter);  				if (argrr.ConstantValue is int) {  					var value = (int)argrr.ConstantValue;  					if (value == 1 || value == 2) {  						return false;  					}  				}  				return true;  			}  			else {  				return true;  			}  		}  	}  }  
Magic Number,Bridge.Translator,TypeInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\TypeInfo.cs,HasRealStatic,The following statement contains a magic number: foreach (var attrSection in method.Attributes) {  	foreach (var attr in attrSection.Attributes) {  		var rr = emitter.Resolver.ResolveNode (attr.Type' emitter);  		if (rr.Type.FullName == "Bridge.InitAttribute") {  			if (!attr.HasArgumentList) {  				return true;  			}  			var expr = attr.Arguments.First ();  			var argrr = emitter.Resolver.ResolveNode (expr' emitter);  			if (argrr.ConstantValue is int) {  				var value = (int)argrr.ConstantValue;  				if (value == 1 || value == 2) {  					return false;  				}  			}  			return true;  		}  		else {  			return true;  		}  	}  }  
Magic Number,Bridge.Translator,TypeInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\TypeInfo.cs,HasRealStatic,The following statement contains a magic number: foreach (var attr in attrSection.Attributes) {  	var rr = emitter.Resolver.ResolveNode (attr.Type' emitter);  	if (rr.Type.FullName == "Bridge.InitAttribute") {  		if (!attr.HasArgumentList) {  			return true;  		}  		var expr = attr.Arguments.First ();  		var argrr = emitter.Resolver.ResolveNode (expr' emitter);  		if (argrr.ConstantValue is int) {  			var value = (int)argrr.ConstantValue;  			if (value == 1 || value == 2) {  				return false;  			}  		}  		return true;  	}  	else {  		return true;  	}  }  
Magic Number,Bridge.Translator,TypeInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\TypeInfo.cs,HasRealStatic,The following statement contains a magic number: if (rr.Type.FullName == "Bridge.InitAttribute") {  	if (!attr.HasArgumentList) {  		return true;  	}  	var expr = attr.Arguments.First ();  	var argrr = emitter.Resolver.ResolveNode (expr' emitter);  	if (argrr.ConstantValue is int) {  		var value = (int)argrr.ConstantValue;  		if (value == 1 || value == 2) {  			return false;  		}  	}  	return true;  }  else {  	return true;  }  
Magic Number,Bridge.Translator,TypeInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\TypeInfo.cs,HasRealStatic,The following statement contains a magic number: if (argrr.ConstantValue is int) {  	var value = (int)argrr.ConstantValue;  	if (value == 1 || value == 2) {  		return false;  	}  }  
Magic Number,Bridge.Translator,TypeInfo,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\TypeInfo.cs,HasRealStatic,The following statement contains a magic number: if (value == 1 || value == 2) {  	return false;  }  
Duplicate Code,Bridge.Translator,AssignmentBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AssignmentBlock.cs,HandleType,The method contains a code clone-set at the following line numbers (starting from the method definition): ((23' 43)' (68' 88))
Duplicate Code,Bridge.Translator,IndexerBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\IndexerBlock.cs,EmitMultiDimArrayAccess,The method contains a code clone-set at the following line numbers (starting from the method definition): ((94' 127)' (184' 217))
Duplicate Code,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The method contains a code clone-set at the following line numbers (starting from the method definition): ((501' 522)' (662' 683))
Duplicate Code,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The method contains a code clone-set at the following line numbers (starting from the method definition): ((528' 548)' (554' 574))
Missing Default,Bridge.Translator,AttributeCreateBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\AttributeCreateBlock.cs,WriteResolveResult,The following switch statement is missing a default case: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (mrr.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Missing Default,Bridge.Translator,BinaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\BinaryOperatorBlock.cs,ResolveOperator,The following switch statement is missing a default case: switch (this.BinaryOperatorExpression.Operator) {  case BinaryOperatorType.GreaterThan:  	action = JS.Funcs.Math.LIFTCMP;  	break;  case BinaryOperatorType.GreaterThanOrEqual:  	action = JS.Funcs.Math.LIFTCMP;  	break;  case BinaryOperatorType.Equality:  	action = JS.Funcs.Math.LIFTEQ;  	break;  case BinaryOperatorType.InEquality:  	action = JS.Funcs.Math.LIFTNE;  	break;  case BinaryOperatorType.LessThan:  	action = JS.Funcs.Math.LIFTCMP;  	break;  case BinaryOperatorType.LessThanOrEqual:  	action = JS.Funcs.Math.LIFTCMP;  	break;  }  
Missing Default,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The following switch statement is missing a default case: switch (this.UnaryOperatorExpression.Operator) {  case UnaryOperatorType.Minus:  	op_name = JS.Funcs.Math.NEG;  	break;  case UnaryOperatorType.Plus:  	op_name = "clone";  	break;  case UnaryOperatorType.BitNot:  	op_name = "not";  	break;  case UnaryOperatorType.Increment:  case UnaryOperatorType.Decrement:  	this.Write (JS.Funcs.BRIDGE_HASVALUE);  	this.WriteOpenParentheses ();  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.Write (") ? ");  	this.WriteOpenParentheses ();  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.Write (" = " + JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1 + "('" + (op == UnaryOperatorType.Decrement ? JS.Funcs.Math.DEC : JS.Funcs.Math.INC) + "'' ");  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.AddOveflowFlag (typeCode' JS.Funcs.Math.DEC' true);  	this.Write (")");  	this.WriteCloseParentheses ();  	this.Write (" : null");  	break;  case UnaryOperatorType.PostIncrement:  case UnaryOperatorType.PostDecrement:  	this.Write (JS.Funcs.BRIDGE_HASVALUE);  	this.WriteOpenParentheses ();  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.Write (") ? ");  	this.WriteOpenParentheses ();  	var valueVar = this.GetTempVarName ();  	this.Write (valueVar);  	this.Write (" = ");  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.WriteComma ();  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.Write (" = " + JS.Types.SYSTEM_NULLABLE + "." + JS.Funcs.Math.LIFT1 + "('" + (op == UnaryOperatorType.PostDecrement ? JS.Funcs.Math.DEC : JS.Funcs.Math.INC) + "'' ");  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.AddOveflowFlag (typeCode' JS.Funcs.Math.DEC' true);  	this.Write (")");  	this.WriteComma ();  	this.Write (valueVar);  	this.WriteCloseParentheses ();  	this.RemoveTempVar (valueVar);  	this.Write (" : null");  	break;  }  
Missing Default,Bridge.Translator,UnaryOperatorBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\UnaryOperatorBlock.cs,HandleDecimal,The following switch statement is missing a default case: switch (op) {  case UnaryOperatorType.Minus:  	op_name = JS.Funcs.Math.NEG;  	break;  case UnaryOperatorType.Plus:  	op_name = "clone";  	break;  case UnaryOperatorType.BitNot:  	op_name = "not";  	break;  case UnaryOperatorType.Increment:  case UnaryOperatorType.Decrement:  	if (!isStatement) {  		this.WriteOpenParentheses ();  	}  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.Write (" = ");  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.Write ("." + (op == UnaryOperatorType.Decrement ? JS.Funcs.Math.DEC : JS.Funcs.Math.INC) + "(");  	this.AddOveflowFlag (typeCode' JS.Funcs.Math.DEC' false);  	this.Write (")");  	if (!isStatement) {  		this.WriteCloseParentheses ();  	}  	break;  case UnaryOperatorType.PostIncrement:  case UnaryOperatorType.PostDecrement:  	this.WriteOpenParentheses ();  	var valueVar = this.GetTempVarName ();  	this.Write (valueVar);  	this.Write (" = ");  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.WriteComma ();  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.Write (" = ");  	this.UnaryOperatorExpression.Expression.AcceptVisitor (this.Emitter);  	this.Write ("." + (op == UnaryOperatorType.PostDecrement ? JS.Funcs.Math.DEC : JS.Funcs.Math.INC) + "(");  	this.AddOveflowFlag (typeCode' JS.Funcs.Math.DEC' false);  	this.Write (")' ");  	this.Write (valueVar);  	this.WriteCloseParentheses ();  	this.RemoveTempVar (valueVar);  	break;  }  
Missing Default,Bridge.Translator,MemberReferenceBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\MemberReferenceBlock.cs,VisitMemberReferenceExpression,The following switch statement is missing a default case: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
Missing Default,Bridge.Translator,ClassBlock,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Emitter\Blocks\ClassBlock.cs,GetDefineMethods,The following switch statement is missing a default case: switch (prefix) {  case "After":  	value = 0;  	break;  case "Before":  	value = 1;  	break;  case "Top":  	value = 2;  	break;  case "Bottom":  	value = 3;  	break;  }  
Missing Default,Bridge.Translator,SyntaxHelper,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Utils\Roslyn\SyntaxHelper.cs,GetSymbolName,The following switch statement is missing a default case: switch (enumMode) {  case 7:  	break;  case 8:  	name = name.ToLowerInvariant ();  	break;  case 9:  	name = name.ToUpperInvariant ();  	break;  }  
Missing Default,Bridge.Translator,Inspector,C:\repos\bridgedotnet_Bridge\Compiler\Translator\Inspector\Inspector.Visitor.cs,VisitEnumMemberDeclaration,The following switch statement is missing a default case: switch (enumMode) {  case 3:  	enumStringName = Object.Net.Utilities.StringUtils.ToLowerCamelCase (member.Member.Name);  	break;  case 4:  	break;  case 5:  	enumStringName = enumStringName.ToLowerInvariant ();  	break;  case 6:  	enumStringName = enumStringName.ToUpperInvariant ();  	break;  }  
