Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToJsName,The method has 123 lines of code.
Long Method,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,The method has 101 lines of code.
Long Method,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ReadComment,The method has 141 lines of code.
Long Method,Bridge.Contract,JsDocComment,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ToString,The method has 148 lines of code.
Complex Method,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToJsName,Cyclomatic complexity of the method is 32
Complex Method,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,Cyclomatic complexity of the method is 24
Complex Method,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,GetTsPrimitivie,Cyclomatic complexity of the method is 16
Complex Method,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,GetNamespaceFilename,Cyclomatic complexity of the method is 14
Complex Method,Bridge.Contract,MemberOrderer,C:\repos\bridgedotnet_Bridge\Compiler\Contract\MemberOrderer.cs,CompareMethods,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Contract,MemberOrderer,C:\repos\bridgedotnet_Bridge\Compiler\Contract\MemberOrderer.cs,Compare,Cyclomatic complexity of the method is 13
Complex Method,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,Cyclomatic complexity of the method is 21
Complex Method,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetOverloadName,Cyclomatic complexity of the method is 15
Complex Method,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,EmitComment,Cyclomatic complexity of the method is 8
Complex Method,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ReadComment,Cyclomatic complexity of the method is 34
Complex Method,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,InitMember,Cyclomatic complexity of the method is 13
Complex Method,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,GetPrimitivie,Cyclomatic complexity of the method is 16
Complex Method,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ToJavascriptName,Cyclomatic complexity of the method is 20
Complex Method,Bridge.Contract,JsDocComment,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ToString,Cyclomatic complexity of the method is 38
Long Parameter List,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToJsName,The method has 6 parameters.
Long Parameter List,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,The method has 6 parameters.
Long Parameter List,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetPropertyOverloads,The method has 6 parameters.
Long Parameter List,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetInterfaceMemberName,The method has 6 parameters.
Long Parameter List,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetOverloadName,The method has 8 parameters.
Long Parameter List,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ReadComment,The method has 7 parameters.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,Get,The length of the statement  "		type = ((ParameterizedTypeReference)type.ToTypeReference ()).GenericType.Resolve (this.Emitter.Resolver.Resolver.TypeResolveContext); " is 133.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,GetGlobalTarget,The length of the statement  "	var globalMethods = typeDefinition.Attributes.FirstOrDefault (a => a.AttributeType.FullName == "Bridge.GlobalMethodsAttribute"); " is 128.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,GetGlobalTarget,The length of the statement  "				throw new EmitterException (node' string.Format ("The argument to the [MixinAttribute] for the type {0} must not be null or empty."' typeDefinition.FullName)); " is 159.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToJsName,The length of the statement  "		throw new EmitterException (emitter.Translator.EmitNode' "Type " + type.FullName + " is marked as not usable from script"); " is 123.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToJsName,The length of the statement  "	return BridgeTypes.ToJsName (ReflectionHelper.ParseReflectionName (BridgeTypes.GetTypeDefinitionKey (type)).Resolve (emitter.Resolver.Resolver.TypeResolveContext)' emitter' asDefinition); " is 187.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToJsName,The length of the statement  "	return BridgeTypes.ToJsName (resolveResult.Type' emitter' astType.Parent is TypeOfExpression && symbol != null && symbol.SymbolKind == SymbolKind.TypeDefinition); " is 162.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,AddModule,The length of the statement  "		if (typeInfo.Module != null && currentTypeInfo.Module != typeInfo.Module && !emitter.CurrentDependencies.Any (d => d.DependencyName == typeInfo.Module)) { " is 154.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ConvertName,The length of the statement  "		BridgeTypes.convRegex = new Regex ("(\\" + String.Join ("|\\"' replacements.Keys.ToArray ()) + ")"' RegexOptions.Compiled | RegexOptions.Singleline); " is 149.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,The length of the statement  "		return BridgeTypes.ToTypeScriptName (composedType.BaseType' emitter) + string.Concat (Enumerable.Repeat ("[]"' composedType.ArraySpecifiers.Count)); " is 148.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,The length of the statement  "	return BridgeTypes.ToTypeScriptName (resolveResult.Type' emitter' asDefinition: asDefinition' ignoreDependency: ignoreDependency); " is 130.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,The length of the statement  "	if (type.IsKnownType (KnownTypeCode.Byte) || type.IsKnownType (KnownTypeCode.Char) || type.IsKnownType (KnownTypeCode.Decimal) || type.IsKnownType (KnownTypeCode.Double) || type.IsKnownType (KnownTypeCode.Int16) || type.IsKnownType (KnownTypeCode.Int32) || type.IsKnownType (KnownTypeCode.Int64) || type.IsKnownType (KnownTypeCode.SByte) || type.IsKnownType (KnownTypeCode.Single) || type.IsKnownType (KnownTypeCode.UInt16) || type.IsKnownType (KnownTypeCode.UInt32) || type.IsKnownType (KnownTypeCode.UInt64)) { " is 512.
Long Statement,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,The length of the statement  "		if (!ignoreDependency && emitter.AssemblyInfo.OutputBy != OutputBy.Project && bridgeType.TypeInfo != null && bridgeType.TypeInfo.Namespace != emitter.TypeInfo.Namespace) { " is 171.
Long Statement,Bridge.Contract,TypeConfigItem,C:\repos\bridgedotnet_Bridge\Compiler\Contract\TypeConfigInfo.cs,GetName,The length of the statement  "		fieldName = OverloadsCollection.Create (emitter' (PropertyDeclaration)this.Entity).GetOverloadName (false' null' withoutTypeParams); " is 132.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,Create,The length of the statement  "	string key = (member.MemberDefinition != null ? member.MemberDefinition.GetHashCode ().ToString () : member.GetHashCode ().ToString ()) + isSetter.GetHashCode ().ToString (); " is 174.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetMethodOverloads,The length of the statement  "			if ((name == this.JsName || name == this.AltJsName || name == this.FieldJsName) && m.IsStatic == this.Static && ((m.IsConstructor && this.JsName == JS.Funcs.CONSTRUCTOR) || m.IsConstructor == this.Constructor)) { " is 212.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetMethodOverloads,The length of the statement  "				if (m.IsConstructor != this.Constructor && (m.Parameters.Count > 0 || m.DeclaringTypeDefinition != this.TypeDefinition)) { " is 122.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetMethodOverloads,The length of the statement  "			var baseTypeDefinitions = typeDef.DirectBaseTypes.Where (t => t.Kind == typeDef.Kind || (typeDef.Kind == TypeKind.Struct && t.Kind == TypeKind.Class)); " is 151.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetPropertyOverloads,The length of the statement  "				if (!getterIgnore && getterName != null && (getterName == this.JsName || getterName == this.AltJsName || getterName == this.FieldJsName)) { " is 139.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetPropertyOverloads,The length of the statement  "				else if (!setterIgnore && setterName != null && (setterName == this.JsName || setterName == this.AltJsName || setterName == this.FieldJsName)) { " is 144.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetPropertyOverloads,The length of the statement  "				else if (fieldName != null && (fieldName == this.JsName || fieldName == this.AltJsName || fieldName == this.FieldJsName)) { " is 123.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetPropertyOverloads,The length of the statement  "			var baseTypeDefinitions = typeDef.DirectBaseTypes.Where (t => t.Kind == typeDef.Kind || (typeDef.Kind == TypeKind.Struct && t.Kind == TypeKind.Class)); " is 151.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetFieldOverloads,The length of the statement  "			var baseTypeDefinitions = typeDef.DirectBaseTypes.Where (t => t.Kind == typeDef.Kind || (typeDef.Kind == TypeKind.Struct && t.Kind == TypeKind.Class)); " is 151.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetEventOverloads,The length of the statement  "				var removeName = e.RemoveAccessor != null && e.CanRemove ? Helpers.GetEventRef (e' this.Emitter' true' true' true) : null; " is 122.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetEventOverloads,The length of the statement  "				else if (removeName != null && (removeName == this.JsName || removeName == this.AltJsName || removeName == this.FieldJsName)) { " is 127.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetEventOverloads,The length of the statement  "				else if (fieldName != null && (fieldName == this.JsName || fieldName == this.AltJsName || fieldName == this.FieldJsName)) { " is 123.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetEventOverloads,The length of the statement  "			var baseTypeDefinitions = typeDef.DirectBaseTypes.Where (t => t.Kind == typeDef.Kind || (typeDef.Kind == TypeKind.Struct && t.Kind == TypeKind.Class)); " is 151.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetInterfaceMemberName,The length of the statement  "	var interfaceMemberName = name ?? OverloadsCollection.Create (emitter' interfaceMember' isSetter).GetOverloadName (true' prefix); " is 129.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetInterfaceMemberName,The length of the statement  "	return interfaceName + (interfaceName.EndsWith (JS.Vars.D.ToString ()) ? "" : JS.Vars.D.ToString ()) + interfaceMemberName; " is 123.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,NeedCreateAlias,The length of the statement  "		return typeDef != null && !Helpers.IsIgnoreGeneric (typeDef) && type != null && type.TypeArguments.Count > 0 && Helpers.IsTypeParameterType (type); " is 147.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetOverloadName,The length of the statement  "		return OverloadsCollection.GetInterfaceMemberName (this.Emitter' interfaceMember' null' prefix' withoutTypeParams' this.IsSetter); " is 130.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetOverloadName,The length of the statement  "		if (this.Members.Where (member => member.ImplementedInterfaceMembers.Count > 0).Any (member => definition.ImplementedInterfaceMembers.Any (implementedInterfaceMember => member.ImplementedInterfaceMembers.Any (m => m.DeclaringTypeDefinition == implementedInterfaceMember.DeclaringTypeDefinition)))) { " is 299.
Long Statement,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetOverloadName,The length of the statement  "	if (attr != null || (definition.DeclaringTypeDefinition != null && definition.DeclaringTypeDefinition.Kind != TypeKind.Interface && this.Emitter.Validator.IsIgnoreType (definition.DeclaringTypeDefinition))) { " is 208.
Long Statement,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,EmitComment,The length of the statement  "	if (block.Emitter.AssemblyInfo.GenerateDocumentation == Bridge.Contract.DocumentationMode.None || node.Parent == null) { " is 120.
Long Statement,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,EmitComment,The length of the statement  "	if (block.Emitter.AssemblyInfo.GenerateDocumentation == Bridge.Contract.DocumentationMode.Basic && visitor.Comments.Count == 0) { " is 129.
Long Statement,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,HandleNode,The length of the statement  "	list = node.SelectNodes ("paramref").Cast<XmlNode> ().Concat<XmlNode> (node.SelectNodes ("typeparamref").Cast<XmlNode> ()); " is 123.
Long Statement,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ToJavascriptName,The length of the statement  "	if (type.IsKnownType (KnownTypeCode.Byte) || type.IsKnownType (KnownTypeCode.Char) || type.IsKnownType (KnownTypeCode.Decimal) || type.IsKnownType (KnownTypeCode.Double) || type.IsKnownType (KnownTypeCode.Int16) || type.IsKnownType (KnownTypeCode.Int32) || type.IsKnownType (KnownTypeCode.Int64) || type.IsKnownType (KnownTypeCode.SByte) || type.IsKnownType (KnownTypeCode.Single) || type.IsKnownType (KnownTypeCode.UInt16) || type.IsKnownType (KnownTypeCode.UInt32) || type.IsKnownType (KnownTypeCode.UInt64)) { " is 512.
Complex Conditional,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,The conditional expression  "type.IsKnownType (KnownTypeCode.Byte) || type.IsKnownType (KnownTypeCode.Char) || type.IsKnownType (KnownTypeCode.Decimal) || type.IsKnownType (KnownTypeCode.Double) || type.IsKnownType (KnownTypeCode.Int16) || type.IsKnownType (KnownTypeCode.Int32) || type.IsKnownType (KnownTypeCode.Int64) || type.IsKnownType (KnownTypeCode.SByte) || type.IsKnownType (KnownTypeCode.Single) || type.IsKnownType (KnownTypeCode.UInt16) || type.IsKnownType (KnownTypeCode.UInt32) || type.IsKnownType (KnownTypeCode.UInt64)"  is complex.
Complex Conditional,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ToTypeScriptName,The conditional expression  "!ignoreDependency && emitter.AssemblyInfo.OutputBy != OutputBy.Project && bridgeType.TypeInfo != null && bridgeType.TypeInfo.Namespace != emitter.TypeInfo.Namespace"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The conditional expression  "(method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The conditional expression  "(method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The conditional expression  "(method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetMethodOverloads,The conditional expression  "(name == this.JsName || name == this.AltJsName || name == this.FieldJsName) && m.IsStatic == this.Static && ((m.IsConstructor && this.JsName == JS.Funcs.CONSTRUCTOR) || m.IsConstructor == this.Constructor)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetPropertyOverloads,The conditional expression  "!getterIgnore && getterName != null && (getterName == this.JsName || getterName == this.AltJsName || getterName == this.FieldJsName)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetPropertyOverloads,The conditional expression  "!setterIgnore && setterName != null && (setterName == this.JsName || setterName == this.AltJsName || setterName == this.FieldJsName)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetPropertyOverloads,The conditional expression  "fieldName != null && (fieldName == this.JsName || fieldName == this.AltJsName || fieldName == this.FieldJsName)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetFieldOverloads,The conditional expression  "(name == this.JsName || name == this.AltJsName || name == this.FieldJsName) && f.IsStatic == this.Static"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetEventOverloads,The conditional expression  "addName != null && (addName == this.JsName || addName == this.AltJsName || addName == this.FieldJsName)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetEventOverloads,The conditional expression  "removeName != null && (removeName == this.JsName || removeName == this.AltJsName || removeName == this.FieldJsName)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetEventOverloads,The conditional expression  "fieldName != null && (fieldName == this.JsName || fieldName == this.AltJsName || fieldName == this.FieldJsName)"  is complex.
Complex Conditional,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetOverloadName,The conditional expression  "attr != null || (definition.DeclaringTypeDefinition != null && definition.DeclaringTypeDefinition.Kind != TypeKind.Interface && this.Emitter.Validator.IsIgnoreType (definition.DeclaringTypeDefinition))"  is complex.
Complex Conditional,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ToJavascriptName,The conditional expression  "type.IsKnownType (KnownTypeCode.Byte) || type.IsKnownType (KnownTypeCode.Char) || type.IsKnownType (KnownTypeCode.Decimal) || type.IsKnownType (KnownTypeCode.Double) || type.IsKnownType (KnownTypeCode.Int16) || type.IsKnownType (KnownTypeCode.Int32) || type.IsKnownType (KnownTypeCode.Int64) || type.IsKnownType (KnownTypeCode.SByte) || type.IsKnownType (KnownTypeCode.Single) || type.IsKnownType (KnownTypeCode.UInt16) || type.IsKnownType (KnownTypeCode.UInt32) || type.IsKnownType (KnownTypeCode.UInt64)"  is complex.
Empty Catch Block,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ReadComment,The method has an empty catch block.
Magic Number,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ConvertName,The following statement contains a magic number: if (BridgeTypes.convRegex == null) {  	replacements = new System.Collections.Generic.Dictionary<string' string> (4);  	replacements.Add ("`"' JS.Vars.D.ToString ());  	replacements.Add ("/"' ".");  	replacements.Add ("+"' ".");  	replacements.Add ("["' "");  	replacements.Add ("]"' "");  	BridgeTypes.convRegex = new Regex ("(\\" + String.Join ("|\\"' replacements.Keys.ToArray ()) + ")"' RegexOptions.Compiled | RegexOptions.Singleline);  }  
Magic Number,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,ConvertName,The following statement contains a magic number: replacements = new System.Collections.Generic.Dictionary<string' string> (4);  
Magic Number,Bridge.Contract,HashHelper,C:\repos\bridgedotnet_Bridge\Compiler\Contract\HashHelper.cs,GetDeterministicHash,The following statement contains a magic number: while (true) {  	j = i + 4;  	if (j > l) {  		j = l;  	}  	c = s.Substring (i' j - i).ToCharArray ();  	mult = 1;  	for (int k = 0; k < c.Length; k++) {  		sum += c [k] * mult;  		mult *= 256;  	}  	i += 4;  	if (i >= l) {  		break;  	}  }  
Magic Number,Bridge.Contract,HashHelper,C:\repos\bridgedotnet_Bridge\Compiler\Contract\HashHelper.cs,GetDeterministicHash,The following statement contains a magic number: while (true) {  	j = i + 4;  	if (j > l) {  		j = l;  	}  	c = s.Substring (i' j - i).ToCharArray ();  	mult = 1;  	for (int k = 0; k < c.Length; k++) {  		sum += c [k] * mult;  		mult *= 256;  	}  	i += 4;  	if (i >= l) {  		break;  	}  }  
Magic Number,Bridge.Contract,HashHelper,C:\repos\bridgedotnet_Bridge\Compiler\Contract\HashHelper.cs,GetDeterministicHash,The following statement contains a magic number: while (true) {  	j = i + 4;  	if (j > l) {  		j = l;  	}  	c = s.Substring (i' j - i).ToCharArray ();  	mult = 1;  	for (int k = 0; k < c.Length; k++) {  		sum += c [k] * mult;  		mult *= 256;  	}  	i += 4;  	if (i >= l) {  		break;  	}  }  
Magic Number,Bridge.Contract,HashHelper,C:\repos\bridgedotnet_Bridge\Compiler\Contract\HashHelper.cs,GetDeterministicHash,The following statement contains a magic number: j = i + 4;  
Magic Number,Bridge.Contract,HashHelper,C:\repos\bridgedotnet_Bridge\Compiler\Contract\HashHelper.cs,GetDeterministicHash,The following statement contains a magic number: for (int k = 0; k < c.Length; k++) {  	sum += c [k] * mult;  	mult *= 256;  }  
Magic Number,Bridge.Contract,HashHelper,C:\repos\bridgedotnet_Bridge\Compiler\Contract\HashHelper.cs,GetDeterministicHash,The following statement contains a magic number: mult *= 256;  
Magic Number,Bridge.Contract,HashHelper,C:\repos\bridgedotnet_Bridge\Compiler\Contract\HashHelper.cs,GetDeterministicHash,The following statement contains a magic number: i += 4;  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The following statement contains a magic number: this.Members.Sort ((m1' m2) =>  {  	if (m1.DeclaringType != m2.DeclaringType) {  		return m1.DeclaringTypeDefinition.IsDerivedFrom (m2.DeclaringTypeDefinition) ? 1 : -1;  	}  	var iCount1 = m1.ImplementedInterfaceMembers.Count;  	var iCount2 = m2.ImplementedInterfaceMembers.Count;  	if (iCount1 > 0 && iCount2 == 0) {  		return -1;  	}  	if (iCount2 > 0 && iCount1 == 0) {  		return 1;  	}  	if (iCount1 > 0 && iCount2 > 0) {  		foreach (var im1 in m1.ImplementedInterfaceMembers) {  			foreach (var im2 in m2.ImplementedInterfaceMembers) {  				if (im1.DeclaringType != im2.DeclaringType) {  					if (im1.DeclaringTypeDefinition.IsDerivedFrom (im2.DeclaringTypeDefinition)) {  						return 1;  					}  					if (im2.DeclaringTypeDefinition.IsDerivedFrom (im1.DeclaringTypeDefinition)) {  						return -1;  					}  				}  			}  		}  	}  	var method1 = m1 as IMethod;  	var method2 = m2 as IMethod;  	if ((method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)) {  		return -1;  	}  	if ((method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)) {  		return 1;  	}  	if ((method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)) {  		return string.Compare (this.MemberToString (m1)' this.MemberToString (m2));  	}  	var a1 = this.GetAccessibilityWeight (m1.Accessibility);  	var a2 = this.GetAccessibilityWeight (m2.Accessibility);  	if (a1 != a2) {  		return a1.CompareTo (a2);  	}  	var v1 = m1 is IField ? 1 : (m1 is IEvent ? 2 : (m1 is IProperty ? 3 : (m1 is IMethod ? 4 : 5)));  	var v2 = m2 is IField ? 1 : (m2 is IEvent ? 2 : (m2 is IProperty ? 3 : (m2 is IMethod ? 4 : 5)));  	if (v1 != v2) {  		return v1.CompareTo (v2);  	}  	var name1 = this.MemberToString (m1);  	var name2 = this.MemberToString (m2);  	return string.Compare (name1' name2);  });  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The following statement contains a magic number: this.Members.Sort ((m1' m2) =>  {  	if (m1.DeclaringType != m2.DeclaringType) {  		return m1.DeclaringTypeDefinition.IsDerivedFrom (m2.DeclaringTypeDefinition) ? 1 : -1;  	}  	var iCount1 = m1.ImplementedInterfaceMembers.Count;  	var iCount2 = m2.ImplementedInterfaceMembers.Count;  	if (iCount1 > 0 && iCount2 == 0) {  		return -1;  	}  	if (iCount2 > 0 && iCount1 == 0) {  		return 1;  	}  	if (iCount1 > 0 && iCount2 > 0) {  		foreach (var im1 in m1.ImplementedInterfaceMembers) {  			foreach (var im2 in m2.ImplementedInterfaceMembers) {  				if (im1.DeclaringType != im2.DeclaringType) {  					if (im1.DeclaringTypeDefinition.IsDerivedFrom (im2.DeclaringTypeDefinition)) {  						return 1;  					}  					if (im2.DeclaringTypeDefinition.IsDerivedFrom (im1.DeclaringTypeDefinition)) {  						return -1;  					}  				}  			}  		}  	}  	var method1 = m1 as IMethod;  	var method2 = m2 as IMethod;  	if ((method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)) {  		return -1;  	}  	if ((method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)) {  		return 1;  	}  	if ((method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)) {  		return string.Compare (this.MemberToString (m1)' this.MemberToString (m2));  	}  	var a1 = this.GetAccessibilityWeight (m1.Accessibility);  	var a2 = this.GetAccessibilityWeight (m2.Accessibility);  	if (a1 != a2) {  		return a1.CompareTo (a2);  	}  	var v1 = m1 is IField ? 1 : (m1 is IEvent ? 2 : (m1 is IProperty ? 3 : (m1 is IMethod ? 4 : 5)));  	var v2 = m2 is IField ? 1 : (m2 is IEvent ? 2 : (m2 is IProperty ? 3 : (m2 is IMethod ? 4 : 5)));  	if (v1 != v2) {  		return v1.CompareTo (v2);  	}  	var name1 = this.MemberToString (m1);  	var name2 = this.MemberToString (m2);  	return string.Compare (name1' name2);  });  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The following statement contains a magic number: this.Members.Sort ((m1' m2) =>  {  	if (m1.DeclaringType != m2.DeclaringType) {  		return m1.DeclaringTypeDefinition.IsDerivedFrom (m2.DeclaringTypeDefinition) ? 1 : -1;  	}  	var iCount1 = m1.ImplementedInterfaceMembers.Count;  	var iCount2 = m2.ImplementedInterfaceMembers.Count;  	if (iCount1 > 0 && iCount2 == 0) {  		return -1;  	}  	if (iCount2 > 0 && iCount1 == 0) {  		return 1;  	}  	if (iCount1 > 0 && iCount2 > 0) {  		foreach (var im1 in m1.ImplementedInterfaceMembers) {  			foreach (var im2 in m2.ImplementedInterfaceMembers) {  				if (im1.DeclaringType != im2.DeclaringType) {  					if (im1.DeclaringTypeDefinition.IsDerivedFrom (im2.DeclaringTypeDefinition)) {  						return 1;  					}  					if (im2.DeclaringTypeDefinition.IsDerivedFrom (im1.DeclaringTypeDefinition)) {  						return -1;  					}  				}  			}  		}  	}  	var method1 = m1 as IMethod;  	var method2 = m2 as IMethod;  	if ((method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)) {  		return -1;  	}  	if ((method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)) {  		return 1;  	}  	if ((method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)) {  		return string.Compare (this.MemberToString (m1)' this.MemberToString (m2));  	}  	var a1 = this.GetAccessibilityWeight (m1.Accessibility);  	var a2 = this.GetAccessibilityWeight (m2.Accessibility);  	if (a1 != a2) {  		return a1.CompareTo (a2);  	}  	var v1 = m1 is IField ? 1 : (m1 is IEvent ? 2 : (m1 is IProperty ? 3 : (m1 is IMethod ? 4 : 5)));  	var v2 = m2 is IField ? 1 : (m2 is IEvent ? 2 : (m2 is IProperty ? 3 : (m2 is IMethod ? 4 : 5)));  	if (v1 != v2) {  		return v1.CompareTo (v2);  	}  	var name1 = this.MemberToString (m1);  	var name2 = this.MemberToString (m2);  	return string.Compare (name1' name2);  });  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The following statement contains a magic number: this.Members.Sort ((m1' m2) =>  {  	if (m1.DeclaringType != m2.DeclaringType) {  		return m1.DeclaringTypeDefinition.IsDerivedFrom (m2.DeclaringTypeDefinition) ? 1 : -1;  	}  	var iCount1 = m1.ImplementedInterfaceMembers.Count;  	var iCount2 = m2.ImplementedInterfaceMembers.Count;  	if (iCount1 > 0 && iCount2 == 0) {  		return -1;  	}  	if (iCount2 > 0 && iCount1 == 0) {  		return 1;  	}  	if (iCount1 > 0 && iCount2 > 0) {  		foreach (var im1 in m1.ImplementedInterfaceMembers) {  			foreach (var im2 in m2.ImplementedInterfaceMembers) {  				if (im1.DeclaringType != im2.DeclaringType) {  					if (im1.DeclaringTypeDefinition.IsDerivedFrom (im2.DeclaringTypeDefinition)) {  						return 1;  					}  					if (im2.DeclaringTypeDefinition.IsDerivedFrom (im1.DeclaringTypeDefinition)) {  						return -1;  					}  				}  			}  		}  	}  	var method1 = m1 as IMethod;  	var method2 = m2 as IMethod;  	if ((method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)) {  		return -1;  	}  	if ((method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)) {  		return 1;  	}  	if ((method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)) {  		return string.Compare (this.MemberToString (m1)' this.MemberToString (m2));  	}  	var a1 = this.GetAccessibilityWeight (m1.Accessibility);  	var a2 = this.GetAccessibilityWeight (m2.Accessibility);  	if (a1 != a2) {  		return a1.CompareTo (a2);  	}  	var v1 = m1 is IField ? 1 : (m1 is IEvent ? 2 : (m1 is IProperty ? 3 : (m1 is IMethod ? 4 : 5)));  	var v2 = m2 is IField ? 1 : (m2 is IEvent ? 2 : (m2 is IProperty ? 3 : (m2 is IMethod ? 4 : 5)));  	if (v1 != v2) {  		return v1.CompareTo (v2);  	}  	var name1 = this.MemberToString (m1);  	var name2 = this.MemberToString (m2);  	return string.Compare (name1' name2);  });  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The following statement contains a magic number: this.Members.Sort ((m1' m2) =>  {  	if (m1.DeclaringType != m2.DeclaringType) {  		return m1.DeclaringTypeDefinition.IsDerivedFrom (m2.DeclaringTypeDefinition) ? 1 : -1;  	}  	var iCount1 = m1.ImplementedInterfaceMembers.Count;  	var iCount2 = m2.ImplementedInterfaceMembers.Count;  	if (iCount1 > 0 && iCount2 == 0) {  		return -1;  	}  	if (iCount2 > 0 && iCount1 == 0) {  		return 1;  	}  	if (iCount1 > 0 && iCount2 > 0) {  		foreach (var im1 in m1.ImplementedInterfaceMembers) {  			foreach (var im2 in m2.ImplementedInterfaceMembers) {  				if (im1.DeclaringType != im2.DeclaringType) {  					if (im1.DeclaringTypeDefinition.IsDerivedFrom (im2.DeclaringTypeDefinition)) {  						return 1;  					}  					if (im2.DeclaringTypeDefinition.IsDerivedFrom (im1.DeclaringTypeDefinition)) {  						return -1;  					}  				}  			}  		}  	}  	var method1 = m1 as IMethod;  	var method2 = m2 as IMethod;  	if ((method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)) {  		return -1;  	}  	if ((method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)) {  		return 1;  	}  	if ((method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)) {  		return string.Compare (this.MemberToString (m1)' this.MemberToString (m2));  	}  	var a1 = this.GetAccessibilityWeight (m1.Accessibility);  	var a2 = this.GetAccessibilityWeight (m2.Accessibility);  	if (a1 != a2) {  		return a1.CompareTo (a2);  	}  	var v1 = m1 is IField ? 1 : (m1 is IEvent ? 2 : (m1 is IProperty ? 3 : (m1 is IMethod ? 4 : 5)));  	var v2 = m2 is IField ? 1 : (m2 is IEvent ? 2 : (m2 is IProperty ? 3 : (m2 is IMethod ? 4 : 5)));  	if (v1 != v2) {  		return v1.CompareTo (v2);  	}  	var name1 = this.MemberToString (m1);  	var name2 = this.MemberToString (m2);  	return string.Compare (name1' name2);  });  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The following statement contains a magic number: this.Members.Sort ((m1' m2) =>  {  	if (m1.DeclaringType != m2.DeclaringType) {  		return m1.DeclaringTypeDefinition.IsDerivedFrom (m2.DeclaringTypeDefinition) ? 1 : -1;  	}  	var iCount1 = m1.ImplementedInterfaceMembers.Count;  	var iCount2 = m2.ImplementedInterfaceMembers.Count;  	if (iCount1 > 0 && iCount2 == 0) {  		return -1;  	}  	if (iCount2 > 0 && iCount1 == 0) {  		return 1;  	}  	if (iCount1 > 0 && iCount2 > 0) {  		foreach (var im1 in m1.ImplementedInterfaceMembers) {  			foreach (var im2 in m2.ImplementedInterfaceMembers) {  				if (im1.DeclaringType != im2.DeclaringType) {  					if (im1.DeclaringTypeDefinition.IsDerivedFrom (im2.DeclaringTypeDefinition)) {  						return 1;  					}  					if (im2.DeclaringTypeDefinition.IsDerivedFrom (im1.DeclaringTypeDefinition)) {  						return -1;  					}  				}  			}  		}  	}  	var method1 = m1 as IMethod;  	var method2 = m2 as IMethod;  	if ((method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)) {  		return -1;  	}  	if ((method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)) {  		return 1;  	}  	if ((method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)) {  		return string.Compare (this.MemberToString (m1)' this.MemberToString (m2));  	}  	var a1 = this.GetAccessibilityWeight (m1.Accessibility);  	var a2 = this.GetAccessibilityWeight (m2.Accessibility);  	if (a1 != a2) {  		return a1.CompareTo (a2);  	}  	var v1 = m1 is IField ? 1 : (m1 is IEvent ? 2 : (m1 is IProperty ? 3 : (m1 is IMethod ? 4 : 5)));  	var v2 = m2 is IField ? 1 : (m2 is IEvent ? 2 : (m2 is IProperty ? 3 : (m2 is IMethod ? 4 : 5)));  	if (v1 != v2) {  		return v1.CompareTo (v2);  	}  	var name1 = this.MemberToString (m1);  	var name2 = this.MemberToString (m2);  	return string.Compare (name1' name2);  });  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The following statement contains a magic number: this.Members.Sort ((m1' m2) =>  {  	if (m1.DeclaringType != m2.DeclaringType) {  		return m1.DeclaringTypeDefinition.IsDerivedFrom (m2.DeclaringTypeDefinition) ? 1 : -1;  	}  	var iCount1 = m1.ImplementedInterfaceMembers.Count;  	var iCount2 = m2.ImplementedInterfaceMembers.Count;  	if (iCount1 > 0 && iCount2 == 0) {  		return -1;  	}  	if (iCount2 > 0 && iCount1 == 0) {  		return 1;  	}  	if (iCount1 > 0 && iCount2 > 0) {  		foreach (var im1 in m1.ImplementedInterfaceMembers) {  			foreach (var im2 in m2.ImplementedInterfaceMembers) {  				if (im1.DeclaringType != im2.DeclaringType) {  					if (im1.DeclaringTypeDefinition.IsDerivedFrom (im2.DeclaringTypeDefinition)) {  						return 1;  					}  					if (im2.DeclaringTypeDefinition.IsDerivedFrom (im1.DeclaringTypeDefinition)) {  						return -1;  					}  				}  			}  		}  	}  	var method1 = m1 as IMethod;  	var method2 = m2 as IMethod;  	if ((method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)) {  		return -1;  	}  	if ((method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)) {  		return 1;  	}  	if ((method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)) {  		return string.Compare (this.MemberToString (m1)' this.MemberToString (m2));  	}  	var a1 = this.GetAccessibilityWeight (m1.Accessibility);  	var a2 = this.GetAccessibilityWeight (m2.Accessibility);  	if (a1 != a2) {  		return a1.CompareTo (a2);  	}  	var v1 = m1 is IField ? 1 : (m1 is IEvent ? 2 : (m1 is IProperty ? 3 : (m1 is IMethod ? 4 : 5)));  	var v2 = m2 is IField ? 1 : (m2 is IEvent ? 2 : (m2 is IProperty ? 3 : (m2 is IMethod ? 4 : 5)));  	if (v1 != v2) {  		return v1.CompareTo (v2);  	}  	var name1 = this.MemberToString (m1);  	var name2 = this.MemberToString (m2);  	return string.Compare (name1' name2);  });  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,SortMembersOverloads,The following statement contains a magic number: this.Members.Sort ((m1' m2) =>  {  	if (m1.DeclaringType != m2.DeclaringType) {  		return m1.DeclaringTypeDefinition.IsDerivedFrom (m2.DeclaringTypeDefinition) ? 1 : -1;  	}  	var iCount1 = m1.ImplementedInterfaceMembers.Count;  	var iCount2 = m2.ImplementedInterfaceMembers.Count;  	if (iCount1 > 0 && iCount2 == 0) {  		return -1;  	}  	if (iCount2 > 0 && iCount1 == 0) {  		return 1;  	}  	if (iCount1 > 0 && iCount2 > 0) {  		foreach (var im1 in m1.ImplementedInterfaceMembers) {  			foreach (var im2 in m2.ImplementedInterfaceMembers) {  				if (im1.DeclaringType != im2.DeclaringType) {  					if (im1.DeclaringTypeDefinition.IsDerivedFrom (im2.DeclaringTypeDefinition)) {  						return 1;  					}  					if (im2.DeclaringTypeDefinition.IsDerivedFrom (im1.DeclaringTypeDefinition)) {  						return -1;  					}  				}  			}  		}  	}  	var method1 = m1 as IMethod;  	var method2 = m2 as IMethod;  	if ((method1 != null && method1.IsConstructor) && (method2 == null || !method2.IsConstructor)) {  		return -1;  	}  	if ((method2 != null && method2.IsConstructor) && (method1 == null || !method1.IsConstructor)) {  		return 1;  	}  	if ((method1 != null && method1.IsConstructor) && (method2 != null && method2.IsConstructor)) {  		return string.Compare (this.MemberToString (m1)' this.MemberToString (m2));  	}  	var a1 = this.GetAccessibilityWeight (m1.Accessibility);  	var a2 = this.GetAccessibilityWeight (m2.Accessibility);  	if (a1 != a2) {  		return a1.CompareTo (a2);  	}  	var v1 = m1 is IField ? 1 : (m1 is IEvent ? 2 : (m1 is IProperty ? 3 : (m1 is IMethod ? 4 : 5)));  	var v2 = m2 is IField ? 1 : (m2 is IEvent ? 2 : (m2 is IProperty ? 3 : (m2 is IMethod ? 4 : 5)));  	if (v1 != v2) {  		return v1.CompareTo (v2);  	}  	var name1 = this.MemberToString (m1);  	var name2 = this.MemberToString (m2);  	return string.Compare (name1' name2);  });  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: switch (a) {  case Accessibility.None:  	w = 4;  	break;  case Accessibility.Private:  	w = 4;  	break;  case Accessibility.Public:  	w = 1;  	break;  case Accessibility.Protected:  	w = 3;  	break;  case Accessibility.Internal:  	w = 2;  	break;  case Accessibility.ProtectedOrInternal:  	w = 2;  	break;  case Accessibility.ProtectedAndInternal:  	w = 3;  	break;  }  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: switch (a) {  case Accessibility.None:  	w = 4;  	break;  case Accessibility.Private:  	w = 4;  	break;  case Accessibility.Public:  	w = 1;  	break;  case Accessibility.Protected:  	w = 3;  	break;  case Accessibility.Internal:  	w = 2;  	break;  case Accessibility.ProtectedOrInternal:  	w = 2;  	break;  case Accessibility.ProtectedAndInternal:  	w = 3;  	break;  }  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: switch (a) {  case Accessibility.None:  	w = 4;  	break;  case Accessibility.Private:  	w = 4;  	break;  case Accessibility.Public:  	w = 1;  	break;  case Accessibility.Protected:  	w = 3;  	break;  case Accessibility.Internal:  	w = 2;  	break;  case Accessibility.ProtectedOrInternal:  	w = 2;  	break;  case Accessibility.ProtectedAndInternal:  	w = 3;  	break;  }  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: switch (a) {  case Accessibility.None:  	w = 4;  	break;  case Accessibility.Private:  	w = 4;  	break;  case Accessibility.Public:  	w = 1;  	break;  case Accessibility.Protected:  	w = 3;  	break;  case Accessibility.Internal:  	w = 2;  	break;  case Accessibility.ProtectedOrInternal:  	w = 2;  	break;  case Accessibility.ProtectedAndInternal:  	w = 3;  	break;  }  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: switch (a) {  case Accessibility.None:  	w = 4;  	break;  case Accessibility.Private:  	w = 4;  	break;  case Accessibility.Public:  	w = 1;  	break;  case Accessibility.Protected:  	w = 3;  	break;  case Accessibility.Internal:  	w = 2;  	break;  case Accessibility.ProtectedOrInternal:  	w = 2;  	break;  case Accessibility.ProtectedAndInternal:  	w = 3;  	break;  }  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: switch (a) {  case Accessibility.None:  	w = 4;  	break;  case Accessibility.Private:  	w = 4;  	break;  case Accessibility.Public:  	w = 1;  	break;  case Accessibility.Protected:  	w = 3;  	break;  case Accessibility.Internal:  	w = 2;  	break;  case Accessibility.ProtectedOrInternal:  	w = 2;  	break;  case Accessibility.ProtectedAndInternal:  	w = 3;  	break;  }  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: w = 4;  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: w = 4;  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: w = 3;  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: w = 2;  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: w = 2;  
Magic Number,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following statement contains a magic number: w = 3;  
Magic Number,Bridge.Contract,JsDocComment,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ToString,The following statement contains a magic number: typeColumnWidth += 4;  
Magic Number,Bridge.Contract,JsDocComment,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,ToString,The following statement contains a magic number: nameColumnWidth += 4;  
Missing Default,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,GetTsPrimitivie,The following switch statement is missing a default case: switch (primitive.KnownTypeCode) {  case KnownTypeCode.Void:  	return "void";  case KnownTypeCode.Boolean:  	return "boolean";  case KnownTypeCode.String:  	return "string";  case KnownTypeCode.Decimal:  case KnownTypeCode.Double:  case KnownTypeCode.Byte:  case KnownTypeCode.Char:  case KnownTypeCode.Int16:  case KnownTypeCode.Int32:  case KnownTypeCode.Int64:  case KnownTypeCode.SByte:  case KnownTypeCode.Single:  case KnownTypeCode.UInt16:  case KnownTypeCode.UInt32:  case KnownTypeCode.UInt64:  	return "number";  }  
Missing Default,Bridge.Contract,BridgeTypes,C:\repos\bridgedotnet_Bridge\Compiler\Contract\BridgeType.cs,GetNamespaceFilename,The following switch statement is missing a default case: switch (emitter.AssemblyInfo.FileNameCasing) {  case FileNameCaseConvert.Lowercase:  	fileName = fileName.ToLower ();  	break;  case FileNameCaseConvert.CamelCase:  	var sepList = new string[] {  		"."'  		System.IO.Path.DirectorySeparatorChar.ToString ()'  		"\\"'  		"/"  	};  	// Populate list only with needed separators' as usually we will never have all four of them  	var neededSepList = new List<string> ();  	foreach (var separator in sepList) {  		if (fileName.Contains (separator.ToString ()) && !neededSepList.Contains (separator)) {  			neededSepList.Add (separator);  		}  	}  	// now' separating the filename string only by the used separators' apply lowerCamelCase  	if (neededSepList.Count > 0) {  		foreach (var separator in neededSepList) {  			var stringList = new List<string> ();  			foreach (var str in fileName.Split (separator [0])) {  				stringList.Add (str.ToLowerCamelCase ());  			}  			fileName = stringList.Join (separator);  		}  	}  	else {  		fileName = fileName.ToLowerCamelCase ();  	}  	break;  }  
Missing Default,Bridge.Contract,OverloadsCollection,C:\repos\bridgedotnet_Bridge\Compiler\Contract\OverloadsCollection.cs,GetAccessibilityWeight,The following switch statement is missing a default case: switch (a) {  case Accessibility.None:  	w = 4;  	break;  case Accessibility.Private:  	w = 4;  	break;  case Accessibility.Public:  	w = 1;  	break;  case Accessibility.Protected:  	w = 3;  	break;  case Accessibility.Internal:  	w = 2;  	break;  case Accessibility.ProtectedOrInternal:  	w = 2;  	break;  case Accessibility.ProtectedAndInternal:  	w = 3;  	break;  }  
Missing Default,Bridge.Contract,XmlToJsDoc,C:\repos\bridgedotnet_Bridge\Compiler\Contract\XmlToJsDoc.cs,GetPrimitivie,The following switch statement is missing a default case: switch (primitive.KnownTypeCode) {  case KnownTypeCode.Void:  	return "void";  case KnownTypeCode.Boolean:  	return "boolean";  case KnownTypeCode.String:  	return "string";  case KnownTypeCode.Decimal:  case KnownTypeCode.Double:  case KnownTypeCode.Byte:  case KnownTypeCode.Char:  case KnownTypeCode.Int16:  case KnownTypeCode.Int32:  case KnownTypeCode.Int64:  case KnownTypeCode.SByte:  case KnownTypeCode.Single:  case KnownTypeCode.UInt16:  case KnownTypeCode.UInt32:  case KnownTypeCode.UInt64:  	return "number";  }  
