Implementation smell,Namespace,Class,File,Method,Description
Long Method,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The method has 109 lines of code.
Complex Method,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,FunctionEmitter,Cyclomatic complexity of the method is 8
Complex Method,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,EmitConvert,Cyclomatic complexity of the method is 15
Complex Method,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,Cyclomatic complexity of the method is 14
Complex Method,McCli.Compiler,FunctionTable,C:\repos\Sable_McCli\McCli.Compiler\FunctionTable.cs,Lookup,Cyclomatic complexity of the method is 8
Complex Method,McCli.Compiler,FunctionTable,C:\repos\Sable_McCli\McCli.Compiler\FunctionTable.cs,GetCoercion,Cyclomatic complexity of the method is 8
Complex Method,McCli.Compiler.IR,TamerXmlReader,C:\repos\Sable_McCli\McCli.Compiler\IR\TamerXmlReader.cs,ReadStatement,Cyclomatic complexity of the method is 13
Long Parameter List,McCli.Compiler.CodeGen,AssemblyEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\AssemblyEmitter.cs,Emit,The method has 5 parameters.
Long Parameter List,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,FunctionEmitter,The method has 6 parameters.
Long Parameter List,McCli.Compiler.CodeGen,MethodFactories,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\MethodFactories.cs,FromTypeBuilder,The method has 6 parameters.
Long Parameter List,McCli.Compiler.IR,RangeFor,C:\repos\Sable_McCli\McCli.Compiler\IR\RangeFor.cs,RangeFor,The method has 5 parameters.
Long Parameter List,McCli.Compiler.IR,RangeFor,C:\repos\Sable_McCli\McCli.Compiler\IR\RangeFor.cs,RangeFor,The method has 5 parameters.
Long Statement,McCli.Compiler.CodeGen,AssemblyEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\AssemblyEmitter.cs,Emit,The length of the statement  "	var assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly (new AssemblyName (assemblyName)' AssemblyBuilderAccess.Save' Path.GetDirectoryName (filePath)); " is 164.
Long Statement,McCli.Compiler.CodeGen,AssemblyEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\AssemblyEmitter.cs,Emit,The length of the statement  "	var typeBuilder = moduleBuilder.DefineType (assemblyName' TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Class); " is 128.
Long Statement,McCli.Compiler.CodeGen,AssemblyEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\AssemblyEmitter.cs,Emit,The length of the statement  "		return compilationUnit.Functions.TryGetValue (name' out function) ? functionEmitters [function].Method : builtinLookup (name' inputReprs); " is 138.
Long Statement,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,IsByRef,The length of the statement  "	return declaration.Outputs.Length >= 2 && declaration.Outputs.Contains (variable) && !declaration.Inputs.Contains (variable); " is 125.
Long Statement,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,EmitConvert,The length of the statement  "		if (source.StructuralClass == MStructuralClass.Scalar && (target.StructuralClass == MStructuralClass.Array || target.StructuralClass == MStructuralClass.FullArray || target.IsAny)) { " is 182.
Long Statement,McCli.Compiler.CodeGen,MethodFactories,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\MethodFactories.cs,FromTypeBuilder,The length of the statement  "	return delegate (string name' IReadOnlyList<ParameterDescriptor> parameters' Type returnType' out ILGenerator ilGenerator) { " is 124.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The length of the statement  "	var comDescriptorVirtualAddress = optionalHeader.DataDirectory [IMAGE_DATA_DIRECTORY.IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress; " is 138.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.TypeReference].BytesPerRow = GetIndexSize (CodedIndex.ResolutionScope' tables) + stringIndexSize * 2; " is 120.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.Type].BytesPerRow = 4 + stringIndexSize * 2 + GetIndexSize (CodedIndex.TypeDefOrRef' tables) + GetIndexSize (Table.Field' tables) + GetIndexSize (Table.Method' tables); " is 187.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.InterfaceImplementation].BytesPerRow = GetIndexSize (Table.Type' tables) + GetIndexSize (CodedIndex.TypeDefOrRef' tables); " is 141.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.MemberReference].BytesPerRow = GetIndexSize (CodedIndex.MemberRefParent' tables) + stringIndexSize + blobIndexSize; " is 134.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.CustomAttribute].BytesPerRow = GetIndexSize (CodedIndex.HasCustomAttribute' tables) + GetIndexSize (CodedIndex.CustomAttributeType' tables) + blobIndexSize; " is 175.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.DeclarativeSecurity].BytesPerRow = 2 + GetIndexSize (CodedIndex.HasDeclSecurity' tables) + blobIndexSize; " is 124.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.PropertyMap].BytesPerRow = GetIndexSize (Table.Type' tables) + GetIndexSize (Table.Property' tables); " is 120.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.MethodSemantics].BytesPerRow = 2 + GetIndexSize (Table.Method' tables) + GetIndexSize (CodedIndex.HasSemantics' tables); " is 139.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.MethodImplementation].BytesPerRow = GetIndexSize (Table.Type' tables) + GetIndexSize (CodedIndex.MethodDefOrRef' tables) * 2; " is 144.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.ImplementationMap].BytesPerRow = 2 + GetIndexSize (CodedIndex.MemberForwarded' tables) + stringIndexSize + GetIndexSize (Table.ModuleReference' tables); " is 171.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.ExportedType].BytesPerRow = 8 + stringIndexSize * 2 + GetIndexSize (CodedIndex.Implementation' tables); " is 122.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.ManifestResource].BytesPerRow = 8 + stringIndexSize + GetIndexSize (CodedIndex.Implementation' tables); " is 122.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.GenericParameter].BytesPerRow = 4 + GetIndexSize (CodedIndex.TypeOrMethodDef' tables) + stringIndexSize; " is 123.
Long Statement,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The length of the statement  "	tables [(int)Table.GenericParameterConstraint].BytesPerRow = GetIndexSize (Table.GenericParameter' tables) + GetIndexSize (CodedIndex.TypeDefOrRef' tables); " is 156.
Long Statement,McCli.Compiler,FunctionTable,C:\repos\Sable_McCli\McCli.Compiler\FunctionTable.cs,InstantiateGenericMethod,The length of the statement  "		var message = string.Format (CultureInfo.InvariantCulture' "Generic method {0} must have generic parameter attribute {1} for instantiation as MatLab functions."' method.Name' typeof(GenericMTypeAttribute).Name); " is 211.
Long Statement,McCli.Compiler.IR,RangeFor,C:\repos\Sable_McCli\McCli.Compiler\IR\RangeFor.cs,ToDebugString,The length of the statement  "	return string.Format ("for {0} = {1}{2}:{3} [{4} statements]"' Iterator.Name' From.Name' Step == null ? string.Empty : ':' + Step.Name' To.Name' Body.Length); " is 158.
Long Statement,McCli.Compiler.IR,Literal,C:\repos\Sable_McCli\McCli.Compiler\IR\Literal.cs,ToDebugString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "{0} = " + (Value is string || Value is char ? "'{1}'" : "{1}")' Target.Name' Value); " is 137.
Complex Conditional,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,EmitConvert,The conditional expression  "source.StructuralClass == MStructuralClass.Scalar && (target.StructuralClass == MStructuralClass.Array || target.StructuralClass == MStructuralClass.FullArray || target.IsAny)"  is complex.
Virtual Method Call from Constructor,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,FunctionEmitter,The constructor "FunctionEmitter" calls a virtual method "DeclareLocal".
Magic Number,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,FunctionEmitter,The following statement contains a magic number: if (function.Outputs.Length == 1) {  	returnType = function.Outputs [0].StaticCliType;  	// 1 output' use return value  }  else if (function.Outputs.Length >= 2) {  	// 2 or more outputs' use 'out' parameters  	foreach (var output in function.Outputs) {  		string name = output.Name;  		if (locals.ContainsKey (output)) {  			// inout parameter' rename not to clash with input  			name += "$out";  		}  		else {  			locals.Add (output' VariableLocation.Parameter (parameterDescriptors.Count));  		}  		var parameterType = output.StaticCliType.MakeByRefType ();  		parameterDescriptors.Add (new ParameterDescriptor (parameterType' ParameterAttributes.Out' name));  	}  }  
Magic Number,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,FunctionEmitter,The following statement contains a magic number: if (function.Outputs.Length >= 2) {  	// 2 or more outputs' use 'out' parameters  	foreach (var output in function.Outputs) {  		string name = output.Name;  		if (locals.ContainsKey (output)) {  			// inout parameter' rename not to clash with input  			name += "$out";  		}  		else {  			locals.Add (output' VariableLocation.Parameter (parameterDescriptors.Count));  		}  		var parameterType = output.StaticCliType.MakeByRefType ();  		parameterDescriptors.Add (new ParameterDescriptor (parameterType' ParameterAttributes.Out' name));  	}  }  
Magic Number,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,EmitBody,The following statement contains a magic number: if (declaration.Outputs.Length == 1) {  	// Load the return value  	EmitLoad (declaration.Outputs [0]);  }  else if (declaration.Outputs.Length >= 2) {  	// Copy inout parameters from their input to their outputs (since we operate only on the input)  	for (int inputIndex = 0; inputIndex < declaration.Inputs.Length; ++inputIndex) {  		var input = declaration.Inputs [inputIndex];  		int outputIndex = declaration.Outputs.IndexOf (input);  		if (outputIndex > -1) {  			cil.LoadLocal (declaration.Inputs.Length + outputIndex);  			cil.LoadLocal (inputIndex);  			cil.StoreIndirect (input.StaticCliType);  		}  	}  }  
Magic Number,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,EmitBody,The following statement contains a magic number: if (declaration.Outputs.Length >= 2) {  	// Copy inout parameters from their input to their outputs (since we operate only on the input)  	for (int inputIndex = 0; inputIndex < declaration.Inputs.Length; ++inputIndex) {  		var input = declaration.Inputs [inputIndex];  		int outputIndex = declaration.Outputs.IndexOf (input);  		if (outputIndex > -1) {  			cil.LoadLocal (declaration.Inputs.Length + outputIndex);  			cil.LoadLocal (inputIndex);  			cil.StoreIndirect (input.StaticCliType);  		}  	}  }  
Magic Number,McCli.Compiler.CodeGen,FunctionEmitter,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\FunctionEmitter.cs,IsByRef,The following statement contains a magic number: return declaration.Outputs.Length >= 2 && declaration.Outputs.Contains (variable) && !declaration.Inputs.Contains (variable);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The following statement contains a magic number: Contract.Assert (optionalHeader.MajorOperatingSystemVersion == 4);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The following statement contains a magic number: Contract.Assert (optionalHeader.Subsystem == 3);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The following statement contains a magic number: for (int i = 0; i < metadataRootPart2.Streams; ++i) {  	var metadataStreamHeader = stream.ReadStruct<StreamHeader> ();  	var metadataStreamName = stream.ReadPaddedNullTerminatedString (4);  	metadataStreamHeaders.Add (metadataStreamName' metadataStreamHeader);  }  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The following statement contains a magic number: if (metadataTablesStreamHeader.MajorVersion != 2 || metadataTablesStreamHeader.MinorVersion != 0)  	throw new InvalidDataException ("Unsupported metadata tables stream version.");  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The following statement contains a magic number: for (uint i = 0; i < assemblyReferenceTableInfo.RowCount; ++i) {  	var rowPosition = stream.Position;  	ushort majorVersion = stream.ReadStruct<ushort> ();  	ushort minorVersion = stream.ReadStruct<ushort> ();  	ushort buildNumber = stream.ReadStruct<ushort> ();  	ushort revisionNumber = stream.ReadStruct<ushort> ();  	var version = new Version (majorVersion' minorVersion' buildNumber' revisionNumber);  	uint flags = stream.ReadStruct<uint> ();  	uint publicKeyOrTokenIndex = blobIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint nameIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint cultureIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint hashValueIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	var nextRowPosition = stream.Position;  	if (version == nonportableMscorlibVersion && flags == nonportableMscorlibFlags) {  		// Looks like mscorlib' let's make sure  		long nameStringPosition = metadataHeaderPosition + metadataStreamHeaders ["#Strings"].Offset + nameIndex;  		long publicKeyBlobPosition = metadataHeaderPosition + metadataStreamHeaders ["#Blob"].Offset + publicKeyOrTokenIndex;  		stream.Position = nameStringPosition;  		var name = stream.ReadPaddedNullTerminatedString (1);  		stream.Position = publicKeyBlobPosition;  		var publicKeyBlob = stream.ReadBytes (nonportableMscorlibPublicKeyBlob.Length);  		if (name == "mscorlib" && Equals (publicKeyBlob' nonportableMscorlibPublicKeyBlob)) {  			// It is indeed the mscorlib we want to patch!  			// Patch the version number and assembly flags  			stream.Position = rowPosition;  			stream.WriteStruct ((ushort)portableMscorlibVersion.Major);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Minor);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Build);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Revision);  			stream.WriteStruct<uint> (portableMscorlibFlags);  			// Update the public key token  			stream.Position = publicKeyBlobPosition;  			stream.Write (portableMscorlibPublicKeyBlob' 0' portableMscorlibPublicKeyBlob.Length);  			// Done!  			return;  		}  		else {  			stream.Position = nextRowPosition;  		}  	}  }  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The following statement contains a magic number: for (uint i = 0; i < assemblyReferenceTableInfo.RowCount; ++i) {  	var rowPosition = stream.Position;  	ushort majorVersion = stream.ReadStruct<ushort> ();  	ushort minorVersion = stream.ReadStruct<ushort> ();  	ushort buildNumber = stream.ReadStruct<ushort> ();  	ushort revisionNumber = stream.ReadStruct<ushort> ();  	var version = new Version (majorVersion' minorVersion' buildNumber' revisionNumber);  	uint flags = stream.ReadStruct<uint> ();  	uint publicKeyOrTokenIndex = blobIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint nameIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint cultureIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint hashValueIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	var nextRowPosition = stream.Position;  	if (version == nonportableMscorlibVersion && flags == nonportableMscorlibFlags) {  		// Looks like mscorlib' let's make sure  		long nameStringPosition = metadataHeaderPosition + metadataStreamHeaders ["#Strings"].Offset + nameIndex;  		long publicKeyBlobPosition = metadataHeaderPosition + metadataStreamHeaders ["#Blob"].Offset + publicKeyOrTokenIndex;  		stream.Position = nameStringPosition;  		var name = stream.ReadPaddedNullTerminatedString (1);  		stream.Position = publicKeyBlobPosition;  		var publicKeyBlob = stream.ReadBytes (nonportableMscorlibPublicKeyBlob.Length);  		if (name == "mscorlib" && Equals (publicKeyBlob' nonportableMscorlibPublicKeyBlob)) {  			// It is indeed the mscorlib we want to patch!  			// Patch the version number and assembly flags  			stream.Position = rowPosition;  			stream.WriteStruct ((ushort)portableMscorlibVersion.Major);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Minor);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Build);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Revision);  			stream.WriteStruct<uint> (portableMscorlibFlags);  			// Update the public key token  			stream.Position = publicKeyBlobPosition;  			stream.Write (portableMscorlibPublicKeyBlob' 0' portableMscorlibPublicKeyBlob.Length);  			// Done!  			return;  		}  		else {  			stream.Position = nextRowPosition;  		}  	}  }  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The following statement contains a magic number: for (uint i = 0; i < assemblyReferenceTableInfo.RowCount; ++i) {  	var rowPosition = stream.Position;  	ushort majorVersion = stream.ReadStruct<ushort> ();  	ushort minorVersion = stream.ReadStruct<ushort> ();  	ushort buildNumber = stream.ReadStruct<ushort> ();  	ushort revisionNumber = stream.ReadStruct<ushort> ();  	var version = new Version (majorVersion' minorVersion' buildNumber' revisionNumber);  	uint flags = stream.ReadStruct<uint> ();  	uint publicKeyOrTokenIndex = blobIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint nameIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint cultureIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint hashValueIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	var nextRowPosition = stream.Position;  	if (version == nonportableMscorlibVersion && flags == nonportableMscorlibFlags) {  		// Looks like mscorlib' let's make sure  		long nameStringPosition = metadataHeaderPosition + metadataStreamHeaders ["#Strings"].Offset + nameIndex;  		long publicKeyBlobPosition = metadataHeaderPosition + metadataStreamHeaders ["#Blob"].Offset + publicKeyOrTokenIndex;  		stream.Position = nameStringPosition;  		var name = stream.ReadPaddedNullTerminatedString (1);  		stream.Position = publicKeyBlobPosition;  		var publicKeyBlob = stream.ReadBytes (nonportableMscorlibPublicKeyBlob.Length);  		if (name == "mscorlib" && Equals (publicKeyBlob' nonportableMscorlibPublicKeyBlob)) {  			// It is indeed the mscorlib we want to patch!  			// Patch the version number and assembly flags  			stream.Position = rowPosition;  			stream.WriteStruct ((ushort)portableMscorlibVersion.Major);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Minor);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Build);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Revision);  			stream.WriteStruct<uint> (portableMscorlibFlags);  			// Update the public key token  			stream.Position = publicKeyBlobPosition;  			stream.Write (portableMscorlibPublicKeyBlob' 0' portableMscorlibPublicKeyBlob.Length);  			// Done!  			return;  		}  		else {  			stream.Position = nextRowPosition;  		}  	}  }  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,PatchReflectionEmitAssembly,The following statement contains a magic number: for (uint i = 0; i < assemblyReferenceTableInfo.RowCount; ++i) {  	var rowPosition = stream.Position;  	ushort majorVersion = stream.ReadStruct<ushort> ();  	ushort minorVersion = stream.ReadStruct<ushort> ();  	ushort buildNumber = stream.ReadStruct<ushort> ();  	ushort revisionNumber = stream.ReadStruct<ushort> ();  	var version = new Version (majorVersion' minorVersion' buildNumber' revisionNumber);  	uint flags = stream.ReadStruct<uint> ();  	uint publicKeyOrTokenIndex = blobIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint nameIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint cultureIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	uint hashValueIndex = stringIndexSize == 2 ? stream.ReadStruct<ushort> () : stream.ReadStruct<uint> ();  	var nextRowPosition = stream.Position;  	if (version == nonportableMscorlibVersion && flags == nonportableMscorlibFlags) {  		// Looks like mscorlib' let's make sure  		long nameStringPosition = metadataHeaderPosition + metadataStreamHeaders ["#Strings"].Offset + nameIndex;  		long publicKeyBlobPosition = metadataHeaderPosition + metadataStreamHeaders ["#Blob"].Offset + publicKeyOrTokenIndex;  		stream.Position = nameStringPosition;  		var name = stream.ReadPaddedNullTerminatedString (1);  		stream.Position = publicKeyBlobPosition;  		var publicKeyBlob = stream.ReadBytes (nonportableMscorlibPublicKeyBlob.Length);  		if (name == "mscorlib" && Equals (publicKeyBlob' nonportableMscorlibPublicKeyBlob)) {  			// It is indeed the mscorlib we want to patch!  			// Patch the version number and assembly flags  			stream.Position = rowPosition;  			stream.WriteStruct ((ushort)portableMscorlibVersion.Major);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Minor);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Build);  			stream.WriteStruct ((ushort)portableMscorlibVersion.Revision);  			stream.WriteStruct<uint> (portableMscorlibFlags);  			// Update the public key token  			stream.Position = publicKeyBlobPosition;  			stream.Write (portableMscorlibPublicKeyBlob' 0' portableMscorlibPublicKeyBlob.Length);  			// Done!  			return;  		}  		else {  			stream.Position = nextRowPosition;  		}  	}  }  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Module].BytesPerRow = 2 + stringIndexSize + guidIndexSize * 3;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Module].BytesPerRow = 2 + stringIndexSize + guidIndexSize * 3;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.TypeReference].BytesPerRow = GetIndexSize (CodedIndex.ResolutionScope' tables) + stringIndexSize * 2;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Type].BytesPerRow = 4 + stringIndexSize * 2 + GetIndexSize (CodedIndex.TypeDefOrRef' tables) + GetIndexSize (Table.Field' tables) + GetIndexSize (Table.Method' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Type].BytesPerRow = 4 + stringIndexSize * 2 + GetIndexSize (CodedIndex.TypeDefOrRef' tables) + GetIndexSize (Table.Field' tables) + GetIndexSize (Table.Method' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Field].BytesPerRow = 2 + stringIndexSize + blobIndexSize;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Method].BytesPerRow = 8 + stringIndexSize + blobIndexSize + GetIndexSize (Table.Parameter' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Parameter].BytesPerRow = 4 + stringIndexSize;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Constant].BytesPerRow = 2 + GetIndexSize (CodedIndex.HasConstant' tables) + blobIndexSize;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.DeclarativeSecurity].BytesPerRow = 2 + GetIndexSize (CodedIndex.HasDeclSecurity' tables) + blobIndexSize;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.ClassLayout].BytesPerRow = 6 + GetIndexSize (Table.Type' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.FieldLayout].BytesPerRow = 4 + GetIndexSize (Table.Field' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Event].BytesPerRow = 2 + stringIndexSize + GetIndexSize (CodedIndex.TypeDefOrRef' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Property].BytesPerRow = 2 + stringIndexSize + blobIndexSize;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.MethodSemantics].BytesPerRow = 2 + GetIndexSize (Table.Method' tables) + GetIndexSize (CodedIndex.HasSemantics' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.MethodImplementation].BytesPerRow = GetIndexSize (Table.Type' tables) + GetIndexSize (CodedIndex.MethodDefOrRef' tables) * 2;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.ImplementationMap].BytesPerRow = 2 + GetIndexSize (CodedIndex.MemberForwarded' tables) + stringIndexSize + GetIndexSize (Table.ModuleReference' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.FieldRva].BytesPerRow = 4 + GetIndexSize (Table.Field' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Assembly].BytesPerRow = 16 + blobIndexSize + stringIndexSize * 2;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.Assembly].BytesPerRow = 16 + blobIndexSize + stringIndexSize * 2;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.AssemblyProcessor].BytesPerRow = 4;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.AssemblyOS].BytesPerRow = 12;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.AssemblyReference].BytesPerRow = 12 + blobIndexSize * 2 + stringIndexSize * 2;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.AssemblyReference].BytesPerRow = 12 + blobIndexSize * 2 + stringIndexSize * 2;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.AssemblyReference].BytesPerRow = 12 + blobIndexSize * 2 + stringIndexSize * 2;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.AssemblyReferenceProcessor].BytesPerRow = 4 + GetIndexSize (Table.AssemblyReference' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.AssemblyReferenceOS].BytesPerRow = 12 + GetIndexSize (Table.AssemblyReference' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.File].BytesPerRow = 4 + stringIndexSize + blobIndexSize;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.ExportedType].BytesPerRow = 8 + stringIndexSize * 2 + GetIndexSize (CodedIndex.Implementation' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.ExportedType].BytesPerRow = 8 + stringIndexSize * 2 + GetIndexSize (CodedIndex.Implementation' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.ManifestResource].BytesPerRow = 8 + stringIndexSize + GetIndexSize (CodedIndex.Implementation' tables);  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.NestedClass].BytesPerRow = GetIndexSize (Table.NestedClass' tables) * 2;  
Magic Number,McCli.Compiler.CodeGen,PortableClassLibrary,C:\repos\Sable_McCli\McCli.Compiler\CodeGen\PortableClassLibrary.cs,FillMetadataTableInfos,The following statement contains a magic number: tables [(int)Table.GenericParameter].BytesPerRow = 4 + GetIndexSize (CodedIndex.TypeOrMethodDef' tables) + stringIndexSize;  
Magic Number,McCli.Compiler.IR,LoadParenthesized,C:\repos\Sable_McCli\McCli.Compiler\IR\LoadParenthesized.cs,ToDebugString,The following statement contains a magic number: if (Targets.Length == 1)  	format += "{0} = ";  else if (Targets.Length >= 2)  	format += "[{0}] = ";  
Magic Number,McCli.Compiler.IR,LoadParenthesized,C:\repos\Sable_McCli\McCli.Compiler\IR\LoadParenthesized.cs,ToDebugString,The following statement contains a magic number: if (Targets.Length >= 2)  	format += "[{0}] = ";  
Magic Number,McCli.Compiler.IR,StaticCall,C:\repos\Sable_McCli\McCli.Compiler\IR\StaticCall.cs,ToDebugString,The following statement contains a magic number: if (Targets.Length == 1)  	format += "{0} = ";  else if (Targets.Length >= 2)  	format += "[{0}] = ";  
Magic Number,McCli.Compiler.IR,StaticCall,C:\repos\Sable_McCli\McCli.Compiler\IR\StaticCall.cs,ToDebugString,The following statement contains a magic number: if (Targets.Length >= 2)  	format += "[{0}] = ";  
