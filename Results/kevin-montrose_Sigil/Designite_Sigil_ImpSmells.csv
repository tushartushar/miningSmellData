Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,Disassemble,The method has 140 lines of code.
Long Method,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,GetOperations,The method has 155 lines of code.
Long Method,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,CheckForExceptionOperations,The method has 138 lines of code.
Long Method,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The method has 2512 lines of code.
Long Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The method has 104 lines of code.
Long Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadElement,The method has 132 lines of code.
Long Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadIndirect,The method has 172 lines of code.
Long Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,DeclareLocal,The method has 138 lines of code.
Long Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreIndirect,The method has 117 lines of code.
Complex Method,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,Disassemble,Cyclomatic complexity of the method is 14
Complex Method,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,GetOperations,Cyclomatic complexity of the method is 22
Complex Method,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,CheckForExceptionOperations,Cyclomatic complexity of the method is 13
Complex Method,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,Cyclomatic complexity of the method is 210
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,Cyclomatic complexity of the method is 16
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,InjectTailCall,Cyclomatic complexity of the method is 12
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,Cyclomatic complexity of the method is 10
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallVirtual,Cyclomatic complexity of the method is 9
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Convert,Cyclomatic complexity of the method is 15
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,ConvertOverflow,Cyclomatic complexity of the method is 15
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,UnsignedConvertOverflow,Cyclomatic complexity of the method is 15
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,RemoveInstruction,Cyclomatic complexity of the method is 14
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,InsertInstruction,Cyclomatic complexity of the method is 14
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Jump,Cyclomatic complexity of the method is 10
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,PatchBranches,Cyclomatic complexity of the method is 19
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadElement,Cyclomatic complexity of the method is 14
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadField,Cyclomatic complexity of the method is 8
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadIndirect,Cyclomatic complexity of the method is 19
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreElement,Cyclomatic complexity of the method is 11
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreField,Cyclomatic complexity of the method is 8
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreIndirect,Cyclomatic complexity of the method is 13
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Switch,Cyclomatic complexity of the method is 9
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,EndExceptionBlock,Cyclomatic complexity of the method is 13
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BeginCatchBlock,Cyclomatic complexity of the method is 9
Complex Method,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,ValidateTryCatchFinallyBranches,Cyclomatic complexity of the method is 9
Complex Method,Sigil,Operation<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Operation.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,Sigil,SigilVerificationException,C:\repos\kevin-montrose_Sigil\Sigil\SigilVerificationException.cs,GetMessage,Cyclomatic complexity of the method is 9
Complex Method,Sigil,SigilVerificationException,C:\repos\kevin-montrose_Sigil\Sigil\SigilVerificationException.cs,GetDebugInfo,Cyclomatic complexity of the method is 11
Complex Method,Sigil.Impl,ReturnTracer,C:\repos\kevin-montrose_Sigil\Sigil\Impl\ReturnTracer.cs,TraceFrom,Cyclomatic complexity of the method is 8
Complex Method,Sigil.Impl,RollingVerifier,C:\repos\kevin-montrose_Sigil\Sigil\Impl\RollingVerifier.cs,CompareStacks,Cyclomatic complexity of the method is 9
Complex Method,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,UpdateStack,Cyclomatic complexity of the method is 8
Complex Method,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,GetLegalTransitions,Cyclomatic complexity of the method is 13
Complex Method,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,CollapseAndVerify,Cyclomatic complexity of the method is 14
Complex Method,Sigil.Impl,ExtensionMethods,C:\repos\kevin-montrose_Sigil\Sigil\Impl\ExtensionMethods.cs,IsAssignableFrom,Cyclomatic complexity of the method is 23
Complex Method,Sigil.Impl,ExtensionMethods,C:\repos\kevin-montrose_Sigil\Sigil\Impl\ExtensionMethods.cs,ReallyIsAssignableFrom,Cyclomatic complexity of the method is 12
Complex Method,Sigil.Impl,TypeOnStack,C:\repos\kevin-montrose_Sigil\Sigil\Impl\TypeOnStack.cs,ToString,Cyclomatic complexity of the method is 10
Long Parameter List,Sigil,DisassembledOperations<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\DisassembledOperations.cs,DisassembledOperations,The method has 5 parameters. Parameters: ops' ps' locs' labels' canEmit
Long Parameter List,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,InferTypes,The method has 5 parameters. Parameters: ops' infer' ps' ls' asLabels
Long Parameter List,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,GetOperations,The method has 8 parameters. Parameters: mod' cil' ps' ls' labels' exceptions' labelAccumulator' needsInference
Long Parameter List,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,CheckForExceptionOperations,The method has 11 parameters. Parameters: i' exceptionStart' exceptionEnd' catchStart' catchEnd' finallyStart' finallyEnd' activeExceptionBlocks' activeCatchBlocks' activeFinallyBlocks' ret
Long Parameter List,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOp,The method has 9 parameters. Parameters: mod' cil' ix' pLookup' lLookup' prefixes' labels' labelAccumulator' op
Long Parameter List,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The method has 6 parameters. Parameters: op' operands' prefixes' labels' labelAccumulator' locals
Long Parameter List,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The method has 8 parameters. Parameters: mod' op' cil' instrStart' operandStart' pLookup' lLookup' advance
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Emit,The method has 6 parameters. Parameters: callConvention' returnType' parameterTypes' allowUnverifiable' doVerify' strictBranchVerification
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,MakeNonGenericEmit,The method has 6 parameters. Parameters: callConvention' returnType' parameterTypes' allowUnverifiable' doVerify' strictBranchVerification
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,DisassemblerDynamicMethod,The method has 5 parameters. Parameters: parameters' name' module' doVerify' strictBranchVerification
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BuildMethod,The method has 7 parameters. Parameters: type' name' attributes' callingConvention' allowUnverifiableCode' doVerify' strictBranchVerification
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BuildStaticMethod,The method has 5 parameters. Parameters: type' name' attributes' allowUnverifiableCode' doVerify
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BuildInstanceMethod,The method has 5 parameters. Parameters: type' name' attributes' allowUnverifiableCode' doVerify
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BuildConstructor,The method has 6 parameters. Parameters: type' attributes' callingConvention' allowUnverifiableCode' doVerify' strictBranchVerification
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,UpdateState,The method has 6 parameters. Parameters: instr' method' parameterTypes' transitions' firstParamIsThis' arglist
Long Parameter List,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,UpdateState,The method has 6 parameters. Parameters: instr' callConventions' returnType' parameterTypes' transitions' arglist
Long Parameter List,Sigil,Local,C:\repos\kevin-montrose_Sigil\Sigil\Local.cs,Local,The method has 7 parameters. Parameters: owner' index' localType' local' name' reusable' declaredAt
Long Parameter List,Sigil.Impl,LinqAlternative,C:\repos\kevin-montrose_Sigil\Sigil\Impl\LinqAlternative.cs,_Partition,The method has 6 parameters. Parameters: ixs' keys' left' right' pivot' c
Long Parameter List,Sigil.Impl,VerificationResult,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerificationResult.cs,FailureTypeMismatch,The method has 5 parameters. Parameters: verifier' transitionIndex' stackIndex' expectedTypes' stack
Long Parameter List,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewDynamicMethod,The method has 6 parameters. Parameters: returnType' parameterTypes' name' module' doVerify' strictBranchVerification
Long Parameter List,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildMethod,The method has 9 parameters. Parameters: returnType' parameterTypes' type' name' attributes' callingConvention' allowUnverifiableCode' doVerify' strictBranchVerification
Long Parameter List,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildInstanceMethod,The method has 8 parameters. Parameters: returnType' parameterTypes' type' name' attributes' allowUnverifiableCode' doVerify' strictBranchVerification
Long Parameter List,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildStaticMethod,The method has 8 parameters. Parameters: returnType' parameterTypes' type' name' attributes' allowUnverifiableCode' doVerify' strictBranchVerification
Long Parameter List,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildConstructor,The method has 7 parameters. Parameters: parameterTypes' type' attributes' callingConvention' allowUnverifiableCode' doVerify' strictBranchVerification
Long Statement,Sigil,DisassembledOperations<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\DisassembledOperations.cs,EmitFrom,The length of the statement  "                throw new InvalidOperationException("from + length must be less than " + Operations.Count + "; found " + (from + length)); " is 122.
Long Statement,Sigil,DisassembledOperations<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\DisassembledOperations.cs,Emit,The length of the statement  "                throw new InvalidOperationException("Cannot emit this DisassembledOperations object' check CanEmit before calling any Emit methods"); " is 133.
Long Statement,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,Disassemble,The length of the statement  "                needsInference = new List<SigilTuple<int' Operation<DelegateType>>>(LinqAlternative.Where(ops' w => w.Item2.IsOpCode && w.Item2.Parameters == null).AsEnumerable());" is 164.
Long Statement,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,Disassemble,The length of the statement  "                    new List<Operation<DelegateType>>(new LinqList<SigilTuple<int' Operation<DelegateType>>>(ops).Select(d => d.Item2).AsEnumerable())' " is 131.
Long Statement,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,InferTypes,The length of the statement  "                    new List<Operation<DelegateType>>(new LinqList<SigilTuple<int' Operation<DelegateType>>>(ops).Select(d => d.Item2).AsEnumerable())'" is 131.
Long Statement,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,GetOperations,The length of the statement  "            CheckForExceptionOperations(0' exceptionStart' exceptionEnd' catchStart' catchEnd' finallyStart' finallyEnd' activeExceptionBlocks' activeCatchBlocks' activeFinallyBlocks' ret);" is 177.
Long Statement,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,GetOperations,The length of the statement  "                CheckForExceptionOperations(i' exceptionStart' exceptionEnd' catchStart' catchEnd' finallyStart' finallyEnd' activeExceptionBlocks' activeCatchBlocks' activeFinallyBlocks' ret);" is 177.
Long Statement,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The length of the statement  "            if (op == OpCodes.Prefix1 || op == OpCodes.Prefix2 || op == OpCodes.Prefix3 || op == OpCodes.Prefix4 || op == OpCodes.Prefix5 || op == OpCodes.Prefix6 || op == OpCodes.Prefix7 || op == OpCodes.Prefixref)" is 203.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)); " is 129.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)); " is 153.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)); " is 177.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)); " is 201.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)); " is 225.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)); " is 249.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)); " is 273.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)); " is 298.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)); " is 323.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)); " is 348.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)' typeof(ParameterType13)); " is 373.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)' typeof(ParameterType13)' typeof(ParameterType14)); " is 398.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)' typeof(ParameterType13)' typeof(ParameterType14)' typeof(ParameterType15)); " is 423.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            return CallIndirect(callConventions' typeof(ReturnType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)' typeof(ParameterType13)' typeof(ParameterType14)' typeof(ParameterType15)' typeof(ParameterType16)); " is 448.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            var known = CallingConventions.Any | CallingConventions.ExplicitThis | CallingConventions.HasThis | CallingConventions.Standard | CallingConventions.VarArgs; " is 157.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "                        throw new SigilVerificationException("CallIndirect expects method calling conventions to match' found " + funcPtr.CallingConvention + " on the stack"' IL.Instructions(AllLocals)); " is 179.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "                            throw new SigilVerificationException("CallIndirect expects a 'this' value assignable to " + funcPtr.InstanceType + "' found " + thisRef' IL.Instructions(AllLocals)); " is 165.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "                        throw new SigilVerificationException("CallIndirect expects method return types to match' found " + funcPtr.ReturnType + " on the stack"' IL.Instructions(AllLocals)); " is 165.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "            if (HasFlag(emit.CallingConventions' CallingConventions.VarArgs) && !HasFlag(emit.CallingConventions' CallingConventions.Standard))" is 131.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "            UpdateState(OpCodes.Call' methodInfo' emit.ParameterTypes' Wrap(transitions' "Call")' firstParamIsThis: firstParamIsThis' arglist: arglist);" is 140.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "            if (HasFlag(method.CallingConvention' CallingConventions.VarArgs) && !HasFlag(method.CallingConvention' CallingConventions.Standard))" is 133.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "            var expectedParams = ((LinqArray<ParameterInfo>)method.GetParameters()).Select(s => TypeOnStack.Get(s.ParameterType)).ToList();" is 127.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "            UpdateState(OpCodes.Call' method' ((LinqArray<ParameterInfo>)method.GetParameters()).Select(s => s.ParameterType).AsEnumerable()' Wrap(transitions' "Call")' firstParamIsThis: firstParamIsThis' arglist: arglist);" is 211.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "            if (HasFlag(cons.CallingConvention' CallingConventions.VarArgs) && !HasFlag(cons.CallingConvention' CallingConventions.Standard))" is 129.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "                throw new SigilVerificationException("Constructors may only be called directly from within a constructor' use NewObject to allocate a new object with a specific constructor."' IL.Instructions(AllLocals));" is 204.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "                throw new SigilVerificationException("Only constructors defined in the current class or it's base class may be called"' IL.Instructions(AllLocals));" is 148.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "            var expectedParams = ((LinqArray<ParameterInfo>)cons.GetParameters()).Select(s => TypeOnStack.Get(s.ParameterType)).ToList();" is 125.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Call,The length of the statement  "            UpdateState(OpCodes.Call' cons' ((LinqArray<ParameterInfo>)cons.GetParameters()).Select(s => s.ParameterType).AsEnumerable()' Wrap(transitions' "Call"));" is 153.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallVirtual,The length of the statement  "            if (HasFlag(method.CallingConvention' CallingConventions.VarArgs) && !HasFlag(method.CallingConvention' CallingConventions.Standard)) " is 133.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallVirtual,The length of the statement  "            var expectedParams = ((LinqArray<ParameterInfo>)method.GetParameters()).Select(s => TypeOnStack.Get(s.ParameterType)).ToList(); " is 127.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CallVirtual,The length of the statement  "            UpdateState(OpCodes.Callvirt' method' ((LinqArray<ParameterInfo>)method.GetParameters()).Select(s => s.ParameterType).AsEnumerable()' Wrap(transitions' "CallVirtual")' arglist: arglist); " is 186.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CopyBlock,The length of the statement  "                    new StackTransition(new[] { typeof(int)' typeof(byte).MakeByRefType()' typeof(NativeIntType) }' TypeHelpers.EmptyTypes)' " is 120.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CopyBlock,The length of the statement  "                    new StackTransition(new[] { typeof(int)' typeof(NativeIntType)' typeof(byte).MakeByRefType() }' TypeHelpers.EmptyTypes)' " is 120.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CopyBlock,The length of the statement  "                    new StackTransition(new[] { typeof(int)' typeof(byte).MakeByRefType()' typeof(byte).MakeByRefType() }' TypeHelpers.EmptyTypes) " is 126.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,MakeNonGenericEmit,The length of the statement  "            return new Emit<NonGenericPlaceholderDelegate>(callConvention' returnType' parameterTypes' allowUnverifiable' doVerify' strictBranchVerification); " is 146.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,TraceOperationResultUsage,The length of the statement  "                var allUsage = new LinqList<InstructionAndTransitions>(r.Value.SelectMany(k => k.UsedBy.Select(u => u.Item1)).AsEnumerable()); " is 126.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,TraceOperationResultUsage,The length of the statement  "                var usedBy = new List<Operation<DelegateType>>(allUsage.Select(u => IL.Operations[u.InstructionIndex.Value]).Distinct().AsEnumerable()); " is 136.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CreateDelegate,The length of the statement  "                throw new InvalidOperationException("Emit was not created to build a DynamicMethod' thus CreateDelegate cannot be called"); " is 123.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CreateDelegate,The length of the statement  "            CreatedDelegate = (DelegateType)(object)InnerCreateDelegate(typeof(DelegateType)' out instructions' optimizationOptions); " is 121.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CreateConstructor,The length of the statement  "                throw new InvalidOperationException("Emit was not created to build a constructor' thus CreateConstructor cannot be called"); " is 124.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CreateTypeInitializer,The length of the statement  "                throw new InvalidOperationException("Emit was not created to build a type initializer' thus CreateTypeInitializer cannot be called"); " is 133.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewDynamicMethod,The length of the statement  "            return DisassemblerDynamicMethod(name: name' module: module' doVerify: doVerify' strictBranchVerification: strictBranchVerification); " is 133.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,DisassemblerDynamicMethod,The length of the statement  "            var ret = new Emit<DelegateType>(dynMethod.CallingConvention' returnType' parameterTypes' AllowsUnverifiableCode(module)' doVerify' strictBranchVerification); " is 158.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewDynamicMethod,The length of the statement  "            var ret = new Emit<DelegateType>(dynMethod.CallingConvention' returnType' parameterTypes' allowUnverifiable' doVerify' strictBranchVerification); " is 145.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CheckAttributesAndConventions,The length of the statement  "            if ((attributes & ~(MethodAttributes.Abstract | MethodAttributes.Assembly | MethodAttributes.CheckAccessOnOverride | MethodAttributes.FamANDAssem | MethodAttributes.Family | MethodAttributes.FamORAssem | MethodAttributes.Final | MethodAttributes.HasSecurity | MethodAttributes.HideBySig | MethodAttributes.MemberAccessMask | MethodAttributes.NewSlot | MethodAttributes.PinvokeImpl | MethodAttributes.Private | MethodAttributes.PrivateScope | MethodAttributes.Public | MethodAttributes.RequireSecObject | MethodAttributes.ReuseSlot | MethodAttributes.RTSpecialName | MethodAttributes.SpecialName | MethodAttributes.Static | MethodAttributes.UnmanagedExport | MethodAttributes.Virtual | MethodAttributes.VtableLayoutMask)) != 0) " is 726.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CheckAttributesAndConventions,The length of the statement  "            if ((callingConvention & ~(CallingConventions.Any | CallingConventions.ExplicitThis | CallingConventions.HasThis | CallingConventions.Standard | CallingConventions.VarArgs)) != 0) " is 179.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BuildMethod,The length of the statement  "            var ret = new Emit<DelegateType>(callingConvention' returnType' parameterTypes' allowUnverifiableCode' doVerify' strictBranchVerification); " is 139.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BuildStaticMethod,The length of the statement  "            return BuildMethod(type' name' attributes | MethodAttributes.Static' CallingConventions.Standard' allowUnverifiableCode' doVerify); " is 131.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BuildConstructor,The length of the statement  "            var ret = new Emit<DelegateType>(callingConvention' typeof(void)' parameterTypes' allowUnverifiableCode' doVerify' strictBranchVerification); " is 141.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BuildTypeInitializer,The length of the statement  "            var ret = new Emit<DelegateType>(CallingConventions.Standard' typeof(void)' TypeHelpers.EmptyTypes' allowUnverifiableCode' doVerify' strictBranchVerification); " is 159.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,InitializeBlock,The length of the statement  "                    new StackTransition(new [] { typeof(int)' typeof(NativeIntType)' typeof(byte).MakeByRefType() }' TypeHelpers.EmptyTypes) " is 120.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Jump,The length of the statement  "                throw new ArgumentException("Jump expected a calling convention of " + CallingConventions + "' found " + method.CallingConvention); " is 131.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Jump,The length of the statement  "                throw new ArgumentException("Jump expected a method with " + ParameterTypes.Length + " parameters' found " + paras.Length); " is 123.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Jump,The length of the statement  "                    throw new SigilVerificationException("Jump expected the #" + i + " parameter to be assignable from " + actuallyIs + "' but found " + shouldBe' IL.Instructions(AllLocals)); " is 171.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,MarkLabel,The length of the statement  "                throw new InvalidOperationException("label [" + label.Name + "] has already been marked' and cannot be marked a second time"); " is 126.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Leave,The length of the statement  "            UpdateState(OpCodes.Leave' label' Wrap(new[] { new StackTransition(new [] { typeof(PopAllType) }' TypeHelpers.EmptyTypes) }' "Leave")' out update); " is 147.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadArgumentAddress,The length of the statement  "                UpdateState(OpCodes.Ldarga_S' asByte' Wrap(StackTransition.Push(ParameterTypes[index].MakePointerType())' "LoadArgumentAddress")); " is 130.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadArgumentAddress,The length of the statement  "            UpdateState(OpCodes.Ldarga' asShort' Wrap(StackTransition.Push(ParameterTypes[index].MakePointerType())' "LoadArgumentAddress")); " is 129.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The length of the statement  "            UpdateState(OpCodes.Ldtoken' method' TypeHelpers.EmptyTypes' Wrap(StackTransition.Push<RuntimeMethodHandle>()' "LoadConstant")); " is 128.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,InnerLoadFunctionPointer,The length of the statement  "            UpdateState(OpCodes.Ldftn' method' parameterTypes' Wrap(new[] { new StackTransition(new TypeOnStack[0]' new[] { type }) }' "LoadFunctionPointer")); " is 147.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadIndirect,The length of the statement  "                throw new InvalidOperationException("LoadIndirect cannot be used with " + type + "' LoadObject may be more appropriate"); " is 121.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4));" is 136.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5));" is 160.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6));" is 184.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7));" is 208.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8));" is 232.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9));" is 256.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10));" is 281.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11));" is 306.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12));" is 331.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)' typeof(ParameterType13));" is 356.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)' typeof(ParameterType13)' typeof(ParameterType14));" is 381.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)' typeof(ParameterType13)' typeof(ParameterType14)' typeof(ParameterType15));" is 406.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "            return NewObject(typeof(ReferenceType)' typeof(ParameterType1)' typeof(ParameterType2)' typeof(ParameterType3)' typeof(ParameterType4)' typeof(ParameterType5)' typeof(ParameterType6)' typeof(ParameterType7)' typeof(ParameterType8)' typeof(ParameterType9)' typeof(ParameterType10)' typeof(ParameterType11)' typeof(ParameterType12)' typeof(ParameterType13)' typeof(ParameterType14)' typeof(ParameterType15)' typeof(ParameterType16));" is 431.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "                            LinqAlternative.Select(c.GetParameters()' (p' i) => p.ParameterType == parameterTypes[i]).Aggregate(true' (a' b) => a && b)" is 123.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,NewObject,The length of the statement  "                throw new InvalidOperationException("Type " + type + " must have a constructor that matches parameters [" + BufferedILGenerator<DelegateType>.Join("' "' ((LinqArray<Type>)parameterTypes).AsEnumerable()) + "]");" is 210.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreIndirect,The length of the statement  "                var transition = new[] { new StackTransition(new[] { typeof(NativeIntType)' typeof(NativeIntType) }' TypeHelpers.EmptyTypes) }; " is 127.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreIndirect,The length of the statement  "            throw new InvalidOperationException("StoreIndirect cannot be used with " + type + "' StoreObject may be more appropriate"); " is 123.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,EndExceptionBlock,The length of the statement  "                throw new InvalidOperationException("Cannot end outer ExceptionBlock " + forTry + " while inner EmitExceptionBlock " + CurrentExceptionBlock.Peek() + " is open"); " is 162.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,EndExceptionBlock,The length of the statement  "                throw new InvalidOperationException("Cannot end ExceptionBlock without defining at least one of a catch or finally block"); " is 123.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BeginCatchBlock,The length of the statement  "                throw new InvalidOperationException("Cannot start CatchBlock on " + forTry + " while inner ExceptionBlock is still open"); " is 122.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BeginCatchBlock,The length of the statement  "                throw new ArgumentException("BeginCatchBlock expects a type descending from Exception' found " + exceptionType' "exceptionType"); " is 129.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BeginCatchBlock,The length of the statement  "            var currentlyOpen = CatchBlocks.Where(c => c.Key.ExceptionBlock == forTry && c.Value.Item2 == -1).Select(s => s.Key).SingleOrDefault(); " is 135.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BeginCatchBlock,The length of the statement  "                throw new SigilVerificationException("BeginCatchBlock expects an unclosed exception block' but " + forTry + " is already closed"' IL.Instructions(AllLocals)); " is 158.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BeginFinallyBlock,The length of the statement  "                throw new InvalidOperationException("BeginFinallyBlock expects an unclosed exception block' but " + forTry + " is already closed"); " is 131.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BeginFinallyBlock,The length of the statement  "                throw new InvalidOperationException("Cannot begin FinallyBlock on " + forTry + " while inner ExceptionBlock " + CurrentExceptionBlock.Peek() + " is still open"); " is 161.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,BeginFinallyBlock,The length of the statement  "                throw new InvalidOperationException("There can only be one finally block per ExceptionBlock' and one is already defined for " + forTry); " is 136.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,EndFinallyBlock,The length of the statement  "                throw new InvalidOperationException("EndFinallyBlock expects an unclosed finally block' but " + forFinally + " is already closed"); " is 131.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,FailStackUnderflow,The length of the statement  "                throw new SigilVerificationException(method + " expects a value on the stack' but it was empty"' IL.Instructions(AllLocals)); " is 125.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,FailStackUnderflow,The length of the statement  "            throw new SigilVerificationException(method + " expects " + expected + " values on the stack"' IL.Instructions(AllLocals)); " is 123.
Long Statement,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,ValidateTryCatchFinallyBranches,The length of the statement  "                if (fromTryBlock == null && fromCatchBlock == null && fromFinallyBlock == null && toTryBlock == null && toCatchBlock == null && toFinallyBlock == null) " is 151.
Long Statement,Sigil,SigilVerificationException,C:\repos\kevin-montrose_Sigil\Sigil\SigilVerificationException.cs,GetMessage,The length of the statement  "                    return method + " expected " + (ExtensionMethods.StartsWithVowel(expected) ? "an " : "a ") + expected + "; found " + found; " is 123.
Long Statement,Sigil,SigilVerificationException,C:\repos\kevin-montrose_Sigil\Sigil\SigilVerificationException.cs,GetDebugInfo,The length of the statement  "                if ((VerificationFailure.IsStackUnderflow || VerificationFailure.IsStackSizeFailure) && VerificationFailure.Stack != null) " is 122.
Long Statement,Sigil,SigilVerificationException,C:\repos\kevin-montrose_Sigil\Sigil\SigilVerificationException.cs,GetDebugInfo,The length of the statement  "            var instrIx = VerificationFailure != null && VerificationFailure.TransitionIndex != null ? VerificationFailure.Verifier.GetInstructionIndex(VerificationFailure.TransitionIndex.Value) : -1; " is 188.
Long Statement,Sigil.Impl,InstructionAndTransitions,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionAndTransitions.cs,ToString,The length of the statement  "            return "[" + Instruction + " @" + InstructionIndex + "] " + string.Join("' "' Transitions.Select(t => t.ToString()).ToArray()); " is 127.
Long Statement,Sigil.Impl,RollingVerifier,C:\repos\kevin-montrose_Sigil\Sigil\Impl\RollingVerifier.cs,RemoveUnnecessaryVerifiers,The length of the statement  "            // if anything's rooted' we only need one of them (since the IL stream being currently valid means they must in the future) " is 123.
Long Statement,Sigil.Impl,RollingVerifier,C:\repos\kevin-montrose_Sigil\Sigil\Impl\RollingVerifier.cs,RemoveUnnecessaryVerifiers,The length of the statement  "            // remove any verifiers that have duplicate terminal stack states; we know that another verifier will do just as well' no need to verify the whole instruction stream again " is 171.
Long Statement,Sigil.Impl,StackTransition,C:\repos\kevin-montrose_Sigil\Sigil\Impl\StackTransition.cs,ToString,The length of the statement  "            return "(" + string.Join("' "' ((LinqArray<TypeOnStack>)PoppedFromStack).Select(p => p.ToString()).ToArray()) + ") => (" + string.Join("' "' ((LinqArray<TypeOnStack>)PushedToStack).Select(p => p.ToString()).ToArray()) + ")"; " is 224.
Long Statement,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,Concat,The length of the statement  "            var branchTo = BranchesAtTransitions.ContainsKey(other.BeganAt) ? BranchesAtTransitions[other.BeganAt] : Transitions.Count; " is 123.
Long Statement,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,Concat,The length of the statement  "                    CachedVerifyStack = canReuseCache ? new LinqStack<LinqList<TypeOnStack>>(CachedVerifyStack.Reverse().AsEnumerable()) : null' " is 124.
Long Statement,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,GetInstructionIndex,The length of the statement  "            if (ix < 0 || ix >= Transitions.Count) throw new Exception("ix must be between 0 and " + (Transitions.Count - 1) + "; found " + ix); " is 132.
Long Statement,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,GetLegalTransitions,The length of the statement  "                    var shouldBePointer = LinqAlternative.SelectMany(onStack' p => p.Where(x => x.IsPointer || x == TypeOnStack.Get<WildcardType>()).AsEnumerable()).Distinct().ToList(); " is 165.
Long Statement,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,GetLegalTransitions,The length of the statement  "                    var shouldBeByRef = LinqAlternative.SelectMany(onStack' p => p.Where(x => x.IsReference || x == TypeOnStack.Get<WildcardType>()).AsEnumerable()).Distinct().ToList(); " is 165.
Long Statement,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,CollapseAndVerify,The length of the statement  "                    var toPush = runningStack.Count > 0 ? runningStack.Peek() : new LinqList<TypeOnStack>(new[] { TypeOnStack.Get<WildcardType>() }); " is 129.
Long Statement,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,CollapseAndVerify,The length of the statement  "                    UpdateStack(runningStack' new InstructionAndTransitions(wrapped.Instruction' wrapped.InstructionIndex' new LinqList<StackTransition>(new[] { new StackTransition(new TypeOnStack[0]' toPush.AsEnumerable()) }))' IsBaseless); " is 221.
Long Statement,Sigil.Impl,VerifiableTracker,C:\repos\kevin-montrose_Sigil\Sigil\Impl\VerifiableTracker.cs,CollapseAndVerify,The length of the statement  "                    UpdateStack(runningStack' new InstructionAndTransitions(wrapped.Instruction' wrapped.InstructionIndex' legal)' IsBaseless); " is 123.
Long Statement,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,Emit,The length of the statement  "            TraversableBuffer.Add(new BufferedILInstruction { IsInstruction = op' MethodReturnType = method.ReturnType' MethodParameterTypes = parameters }); " is 145.
Long Statement,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,Emit,The length of the statement  "            TraversableBuffer.Add(new BufferedILInstruction { IsInstruction = op' MethodReturnType = typeof(void)' MethodParameterTypes = parameters }); " is 140.
Long Statement,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,Emit,The length of the statement  "                    log.AppendLine(op + " " + callConventions + " " + returnType + " " + Join(" "' ((LinqArray<Type>)parameterTypes).AsEnumerable())); " is 130.
Long Statement,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,Emit,The length of the statement  "            TraversableBuffer.Add(new BufferedILInstruction { IsInstruction = op' MethodReturnType = returnType' MethodParameterTypes = (LinqArray<Type>)parameterTypes  }); " is 160.
Long Statement,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,EmitCall,The length of the statement  "            TraversableBuffer.Add(new BufferedILInstruction { IsInstruction = op' MethodReturnType = method.ReturnType' MethodParameterTypes = parameters }); " is 145.
Long Statement,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,EmitCalli,The length of the statement  "                    log.AppendLine(OpCodes.Calli + " " + callingConvention + " " + returnType + " " + Join(" "' (IEnumerable<Type>)parameterTypes) + " __arglist(" + Join("' "' arglist) + ")"); " is 172.
Long Statement,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,EmitCalli,The length of the statement  "            TraversableBuffer.Add(new BufferedILInstruction { IsInstruction = OpCodes.Calli' MethodReturnType = returnType' MethodParameterTypes = ps }); " is 141.
Long Statement,Sigil.Impl,ExtensionMethods,C:\repos\kevin-montrose_Sigil\Sigil\Impl\ExtensionMethods.cs,IsAssignableFrom,The length of the statement  "                if (type1.Type.GetElementType() == typeof(WildcardType) || type2.Type.GetElementType() == typeof(WildcardType)) return true;" is 124.
Long Statement,Sigil.Impl,ExtensionMethods,C:\repos\kevin-montrose_Sigil\Sigil\Impl\ExtensionMethods.cs,IsAssignableFrom,The length of the statement  "                if (type1.Type.GetElementType() == typeof(WildcardType) || type2.Type.GetElementType() == typeof(WildcardType)) return true;" is 124.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,Call,The length of the statement  "                var dynMethod = new System.Reflection.Emit.DynamicMethod(emit.Name' emit.ReturnType' emit.ParameterTypes' emit.Module' skipVisibility: true);" is 141.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5>(callConventions); " is 132.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6>(callConventions); " is 148.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7>(callConventions); " is 164.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8>(callConventions); " is 180.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9>(callConventions); " is 196.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10>(callConventions); " is 213.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11>(callConventions); " is 230.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12>(callConventions); " is 247.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12' ParameterType13>(callConventions); " is 264.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12' ParameterType13' ParameterType14>(callConventions); " is 281.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12' ParameterType13' ParameterType14' ParameterType15>(callConventions); " is 298.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CallIndirect,The length of the statement  "            InnerEmit.CallIndirect<ReturnType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12' ParameterType13' ParameterType14' ParameterType15' ParameterType16>(callConventions); " is 315.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewDynamicMethod,The length of the statement  "            var innerEmit = Emit<NonGenericPlaceholderDelegate>.MakeNonGenericEmit(CallingConventions.Standard' returnType' parameterTypes' Emit<NonGenericPlaceholderDelegate>.AllowsUnverifiableCode(module)' doVerify' strictBranchVerification); " is 232.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,ValidateDelegateType,The length of the statement  "                throw new ArgumentException("Expected delegateType to take " + ParameterTypes.Length + " parameters' found " + parameterTypes.Length); " is 134.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,ValidateDelegateType,The length of the statement  "                    throw new ArgumentException("Expected delegateType's parameter at index " + i + " to be a " + expectedType + "' found " + actualType); " is 134.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CreateDelegate,The length of the statement  "                throw new InvalidOperationException("Emit was not created to build a DynamicMethod' thus CreateDelegate cannot be called"); " is 123.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildMethod,The length of the statement  "            var innerEmit = Emit<NonGenericPlaceholderDelegate>.MakeNonGenericEmit(callingConvention' returnType' parameterTypes' allowUnverifiableCode' doVerify' strictBranchVerification); " is 177.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildInstanceMethod,The length of the statement  "            return BuildMethod(returnType' parameterTypes' type' name' attributes' CallingConventions.HasThis' allowUnverifiableCode' doVerify' strictBranchVerification); " is 158.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildStaticMethod,The length of the statement  "            return BuildMethod(returnType' parameterTypes' type' name' attributes | MethodAttributes.Static' CallingConventions.Standard' allowUnverifiableCode' doVerify' strictBranchVerification); " is 185.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildConstructor,The length of the statement  "            var innerEmit = Emit<NonGenericPlaceholderDelegate>.MakeNonGenericEmit(callingConvention' typeof(void)' parameterTypes' allowUnverifiableCode' doVerify' strictBranchVerification); " is 179.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,BuildTypeInitializer,The length of the statement  "            var innerEmit = Emit<NonGenericPlaceholderDelegate>.MakeNonGenericEmit(CallingConventions.Standard' typeof(void)' TypeHelpers.EmptyTypes' allowUnverifiableCode' doVerify' strictBranchVerification); " is 197.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CreateConstructor,The length of the statement  "                throw new InvalidOperationException("Emit was not created to build a constructor' thus CreateConstructor cannot be called"); " is 124.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,CreateTypeInitializer,The length of the statement  "                throw new InvalidOperationException("Emit was not created to build a type initializer' thus CreateTypeInitializer cannot be called"); " is 133.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6>();" is 133.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7>();" is 149.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8>();" is 165.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9>();" is 181.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10>();" is 198.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11>();" is 215.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12>();" is 232.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12' ParameterType13>();" is 249.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12' ParameterType13' ParameterType14>();" is 266.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12' ParameterType13' ParameterType14' ParameterType15>();" is 283.
Long Statement,Sigil.NonGeneric,Emit,C:\repos\kevin-montrose_Sigil\Sigil\NonGeneric\Emit.ArgumentList.cs,NewObject,The length of the statement  "            InnerEmit.NewObject<ReferenceType' ParameterType1' ParameterType2' ParameterType3' ParameterType4' ParameterType5' ParameterType6' ParameterType7' ParameterType8' ParameterType9' ParameterType10' ParameterType11' ParameterType12' ParameterType13' ParameterType14' ParameterType15' ParameterType16>();" is 300.
Complex Conditional,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The conditional expression  "op == OpCodes.Prefix1 || op == OpCodes.Prefix2 || op == OpCodes.Prefix3 || op == OpCodes.Prefix4 || op == OpCodes.Prefix5 || op == OpCodes.Prefix6 || op == OpCodes.Prefix7 || op == OpCodes.Prefixref"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CopyBlock,The conditional expression  "unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4)"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,InitializeBlock,The conditional expression  "unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4)"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadField,The conditional expression  "unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4)"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadIndirect,The conditional expression  "unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4)"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadObject,The conditional expression  "unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4)"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreField,The conditional expression  "unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4)"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreIndirect,The conditional expression  "unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4)"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreObject,The conditional expression  "unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4)"  is complex.
Complex Conditional,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,ValidateTryCatchFinallyBranches,The conditional expression  "fromTryBlock == null && fromCatchBlock == null && fromFinallyBlock == null && toTryBlock == null && toCatchBlock == null && toFinallyBlock == null"  is complex.
Complex Conditional,Sigil.Impl,RollingVerifier,C:\repos\kevin-montrose_Sigil\Sigil\Impl\RollingVerifier.cs,GetCurrentStack,The conditional expression  "ret == null || (innerRet.Item1 && !ret.Item1) || innerRet.Item2.Count > ret.Item2.Count"  is complex.
Complex Conditional,Sigil.Impl,ExtensionMethods,C:\repos\kevin-montrose_Sigil\Sigil\Impl\ExtensionMethods.cs,IsAssignableFrom,The conditional expression  "(type1.IsPointer || type1.IsReference) && !(type2.IsPointer || type2.IsReference)"  is complex.
Complex Conditional,Sigil.Impl,ExtensionMethods,C:\repos\kevin-montrose_Sigil\Sigil\Impl\ExtensionMethods.cs,IsAssignableFrom,The conditional expression  "(type2.IsPointer || type2.IsReference) && !(type1.IsPointer || type1.IsReference)"  is complex.
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,Disassembler,The following statement contains a magic number: foreach(var field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))             {                 var op = (OpCode)field.GetValue(null);                  if (op.Size == 1)                 {                     oneByte.Add(op);                     continue;                 }                  if (op.Size == 2)                 {                     twoByte.Add(op);                     continue;                 }                  throw new Exception("Unexpected op size for " + op);             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,OrderOperations,The following statement contains a magic number: foreach (var group in grouped.OrderBy(o => o.Key).AsEnumerable())             {                 var inOrder =                      LinqAlternative.OrderBy<Operation<DelegateType>' int>(                         LinqAlternative.Select(group' _ => _.Item2).AsEnumerable()'                         op =>                         {                             if (op.IsCatchBlockEnd) return -1000000;                             if (op.IsFinallyBlockEnd) return -10000;                             if (op.IsExceptionBlockEnd) return -1000;                              if (op.IsExceptionBlockStart) return -100;                             if (op.IsCatchBlockStart) return -10;                             if (op.IsFinallyBlockStart) return -1;                                                          if (op.IsMarkLabel) return 0;                              return 1;                         }                     ).AsEnumerable();                  foreach (var i in inOrder)                 {                     ret.Add(SigilTuple.Create(group.Key' i));                 }             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,OrderOperations,The following statement contains a magic number: foreach (var group in grouped.OrderBy(o => o.Key).AsEnumerable())             {                 var inOrder =                      LinqAlternative.OrderBy<Operation<DelegateType>' int>(                         LinqAlternative.Select(group' _ => _.Item2).AsEnumerable()'                         op =>                         {                             if (op.IsCatchBlockEnd) return -1000000;                             if (op.IsFinallyBlockEnd) return -10000;                             if (op.IsExceptionBlockEnd) return -1000;                              if (op.IsExceptionBlockStart) return -100;                             if (op.IsCatchBlockStart) return -10;                             if (op.IsFinallyBlockStart) return -1;                                                          if (op.IsMarkLabel) return 0;                              return 1;                         }                     ).AsEnumerable();                  foreach (var i in inOrder)                 {                     ret.Add(SigilTuple.Create(group.Key' i));                 }             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,OrderOperations,The following statement contains a magic number: foreach (var group in grouped.OrderBy(o => o.Key).AsEnumerable())             {                 var inOrder =                      LinqAlternative.OrderBy<Operation<DelegateType>' int>(                         LinqAlternative.Select(group' _ => _.Item2).AsEnumerable()'                         op =>                         {                             if (op.IsCatchBlockEnd) return -1000000;                             if (op.IsFinallyBlockEnd) return -10000;                             if (op.IsExceptionBlockEnd) return -1000;                              if (op.IsExceptionBlockStart) return -100;                             if (op.IsCatchBlockStart) return -10;                             if (op.IsFinallyBlockStart) return -1;                                                          if (op.IsMarkLabel) return 0;                              return 1;                         }                     ).AsEnumerable();                  foreach (var i in inOrder)                 {                     ret.Add(SigilTuple.Create(group.Key' i));                 }             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,OrderOperations,The following statement contains a magic number: foreach (var group in grouped.OrderBy(o => o.Key).AsEnumerable())             {                 var inOrder =                      LinqAlternative.OrderBy<Operation<DelegateType>' int>(                         LinqAlternative.Select(group' _ => _.Item2).AsEnumerable()'                         op =>                         {                             if (op.IsCatchBlockEnd) return -1000000;                             if (op.IsFinallyBlockEnd) return -10000;                             if (op.IsExceptionBlockEnd) return -1000;                              if (op.IsExceptionBlockStart) return -100;                             if (op.IsCatchBlockStart) return -10;                             if (op.IsFinallyBlockStart) return -1;                                                          if (op.IsMarkLabel) return 0;                              return 1;                         }                     ).AsEnumerable();                  foreach (var i in inOrder)                 {                     ret.Add(SigilTuple.Create(group.Key' i));                 }             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,OrderOperations,The following statement contains a magic number: foreach (var group in grouped.OrderBy(o => o.Key).AsEnumerable())             {                 var inOrder =                      LinqAlternative.OrderBy<Operation<DelegateType>' int>(                         LinqAlternative.Select(group' _ => _.Item2).AsEnumerable()'                         op =>                         {                             if (op.IsCatchBlockEnd) return -1000000;                             if (op.IsFinallyBlockEnd) return -10000;                             if (op.IsExceptionBlockEnd) return -1000;                              if (op.IsExceptionBlockStart) return -100;                             if (op.IsCatchBlockStart) return -10;                             if (op.IsFinallyBlockStart) return -1;                                                          if (op.IsMarkLabel) return 0;                              return 1;                         }                     ).AsEnumerable();                  foreach (var i in inOrder)                 {                     ret.Add(SigilTuple.Create(group.Key' i));                 }             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOp,The following statement contains a magic number: if (first == ContinueOpcode)             {                 var next = cil[ix + 1];                  opcode = TwoByteOps[next];                 advance += 2;             }             else             {                 opcode = OneByteOps[first];                 advance++;             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldarg_2)             {                 ushort ix = 2;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { ix }'                         Replay = emit => emit.LoadArgument(ix)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldarg_3)             {                 ushort ix = 3;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { ix }'                         Replay = emit => emit.LoadArgument(ix)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldc_I4_2)             {                 int c = 2;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { c }'                         Replay = emit => emit.LoadConstant(c)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldc_I4_3)             {                 int c = 3;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { c }'                         Replay = emit => emit.LoadConstant(c)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldc_I4_4)             {                 int c = 4;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { c }'                         Replay = emit => emit.LoadConstant(c)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldc_I4_5)             {                 int c = 5;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { c }'                         Replay = emit => emit.LoadConstant(c)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldc_I4_6)             {                 int c = 6;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { c }'                         Replay = emit => emit.LoadConstant(c)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldc_I4_7)             {                 int c = 7;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { c }'                         Replay = emit => emit.LoadConstant(c)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldc_I4_8)             {                 int c = 8;                 return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { c }'                         Replay = emit => emit.LoadConstant(c)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldloc_2)             {                 ushort ix = 2;                 var loc = locals[ix];                  return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { loc }'                         Replay = emit => emit.LoadLocal(loc)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Ldloc_3)             {                 ushort ix = 3;                 var loc = locals[ix];                  return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { loc }'                         Replay = emit => emit.LoadLocal(loc)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Stloc_2)             {                 ushort ix = 2;                 var loc = locals[ix];                  return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { loc }'                         Replay = emit => emit.StoreLocal(loc)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,MakeReplayableOperation,The following statement contains a magic number: if (op == OpCodes.Stloc_3)             {                 ushort ix = 3;                 var loc = locals[ix];                  return                     new Operation<DelegateType>                     {                         OpCode = op'                         Parameters = new object[] { loc }'                         Replay = emit => emit.StoreLocal(loc)                     };             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var a = (uint)(cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var a = (uint)(cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var a = (uint)(cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var a = (uint)(cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var a = (uint)(cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var b = (uint)(cil[at+4] | (cil[at + 5] << 8) | (cil[at + 6] << 16) | (cil[at + 7] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var b = (uint)(cil[at+4] | (cil[at + 5] << 8) | (cil[at + 6] << 16) | (cil[at + 7] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var b = (uint)(cil[at+4] | (cil[at + 5] << 8) | (cil[at + 6] << 16) | (cil[at + 7] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var b = (uint)(cil[at+4] | (cil[at + 5] << 8) | (cil[at + 6] << 16) | (cil[at + 7] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var b = (uint)(cil[at+4] | (cil[at + 5] << 8) | (cil[at + 6] << 16) | (cil[at + 7] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var b = (uint)(cil[at+4] | (cil[at + 5] << 8) | (cil[at + 6] << 16) | (cil[at + 7] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: var b = (uint)(cil[at+4] | (cil[at + 5] << 8) | (cil[at + 6] << 16) | (cil[at + 7] << 24));
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadLong,The following statement contains a magic number: return (((long)b) << 32) | a;
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadInt,The following statement contains a magic number: return cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24);
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadInt,The following statement contains a magic number: return cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24);
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadInt,The following statement contains a magic number: return cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24);
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadInt,The following statement contains a magic number: return cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24);
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadInt,The following statement contains a magic number: return cil[at] | (cil[at + 1] << 8) | (cil[at + 2] << 16) | (cil[at + 3] << 24);
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadFloat,The following statement contains a magic number: var arr = new byte[4];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadFloat,The following statement contains a magic number: arr[2] = cil[at + 2];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadFloat,The following statement contains a magic number: arr[2] = cil[at + 2];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadFloat,The following statement contains a magic number: arr[3] = cil[at + 3];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadFloat,The following statement contains a magic number: arr[3] = cil[at + 3];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: var arr = new byte[8];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[2] = cil[at + 2];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[2] = cil[at + 2];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[3] = cil[at + 3];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[3] = cil[at + 3];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[4] = cil[at + 4];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[4] = cil[at + 4];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[5] = cil[at + 5];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[5] = cil[at + 5];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[6] = cil[at + 6];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[6] = cil[at + 6];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[7] = cil[at + 7];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadDouble,The following statement contains a magic number: arr[7] = cil[at + 7];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadSingle,The following statement contains a magic number: var arr = new byte[4];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadSingle,The following statement contains a magic number: arr[2] = cil[at + 2];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadSingle,The following statement contains a magic number: arr[2] = cil[at + 2];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadSingle,The following statement contains a magic number: arr[3] = cil[at + 3];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadSingle,The following statement contains a magic number: arr[3] = cil[at + 3];
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Disassembler<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Disassembler.cs,ReadOperands,The following statement contains a magic number: switch (op.OperandType)             {                 case OperandType.InlineBrTarget:                     advance += 4;                     var offset = ReadInt(cil' operandStart);                     var jumpTarget = instrStart + advance + offset;                     return new object[] { jumpTarget };                  case OperandType.InlineSwitch:                     advance += 4;                     var len = ReadInt(cil' operandStart);                     var offset1 = instrStart + len * 4;                     var ret = new object[len];                     for (var i = 0; i < len; i++)                     {                         var step = ReadInt(cil' operandStart + advance);                         advance += 4;                         ret[i] = offset1 + step;                     }                     return ret;                  case OperandType.ShortInlineBrTarget:                     advance += 1;                     var offset2 = (sbyte)cil[operandStart];                     var jumpTarget2 = instrStart + advance + offset2;                     return new object[] { jumpTarget2 };                  case OperandType.InlineField:                 case OperandType.InlineTok:                 case OperandType.InlineType:                 case OperandType.InlineMethod:                     advance += 4;                     var mem = mod.ResolveMember(ReadInt(cil' operandStart));                     return new object[] { mem };                  case OperandType.InlineI:                     advance += 4;                     return new object[] { ReadInt(cil' operandStart) };                  case OperandType.InlineI8:                     advance += 8;                     return new object[] { ReadLong(cil' operandStart) };                                  case OperandType.InlineNone:                      return new object[0];                                  case OperandType.InlineR:                     advance += 8;                     return new object[] { ReadDouble(cil' operandStart) };                  case OperandType.InlineSig:                     advance += 4;                     var sig = mod.ResolveSignature(ReadInt(cil' operandStart));                     return new object[] { sig };                  case OperandType.InlineString:                     advance += 4;                     var str = mod.ResolveString(ReadInt(cil' operandStart));                     return new object[] { str };                                   case OperandType.InlineVar:                     advance += 2;                     return new object[] { ReadShort(cil' operandStart) };                                  case OperandType.ShortInlineI:                     advance += 1;                     if (op == OpCodes.Ldc_I4_S)                     {                         return new object[] { (sbyte)cil[operandStart] };                     }                     else                     {                         return new object[] { cil[operandStart] };                     }                  case OperandType.ShortInlineR:                     advance += 4;                     if (op == OpCodes.Ldc_R4)                     {                         return new object[] { ReadSingle(cil' operandStart) };                     }                     else                     {                         return new object[] { ReadShort(cil' operandStart) };                     }                   case OperandType.ShortInlineVar:                     advance += 1;                     return new object[] { cil[operandStart] };                                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");             }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CopyBlock,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4"' "unaligned");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,CopyBlock,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4"' "unaligned");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,Instructions,The following statement contains a magic number: foreach (var line in ((LinqArray<string>)IL.Instructions(AllLocals)).Skip(2).AsEnumerable())              {                  ret.AppendLine(line);              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,AllowsUnverifiableCode,The following statement contains a magic number: il.Emit(OpCodes.Ldc_I4' 1024);
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,InitializeBlock,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,InitializeBlock,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadArgument,The following statement contains a magic number: switch (index)              {                  case 0: UpdateState(OpCodes.Ldarg_0' transitions); return this;                  case 1: UpdateState(OpCodes.Ldarg_1' transitions); return this;                  case 2: UpdateState(OpCodes.Ldarg_2' transitions); return this;                  case 3: UpdateState(OpCodes.Ldarg_3' transitions); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadArgument,The following statement contains a magic number: switch (index)              {                  case 0: UpdateState(OpCodes.Ldarg_0' transitions); return this;                  case 1: UpdateState(OpCodes.Ldarg_1' transitions); return this;                  case 2: UpdateState(OpCodes.Ldarg_2' transitions); return this;                  case 3: UpdateState(OpCodes.Ldarg_3' transitions); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case -1: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case -1: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case -1: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case -1: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case -1: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case -1: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case -1: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case uint.MaxValue: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case uint.MaxValue: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case uint.MaxValue: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case uint.MaxValue: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case uint.MaxValue: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case uint.MaxValue: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following statement contains a magic number: switch (i)              {                  case uint.MaxValue: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadField,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadField,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadIndirect,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadIndirect,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadObject,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadObject,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreField,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreField,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreIndirect,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreIndirect,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreLocal,The following statement contains a magic number: switch (local.Index)              {                  case 0: UpdateState(OpCodes.Stloc_0' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 1: UpdateState(OpCodes.Stloc_1' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 2: UpdateState(OpCodes.Stloc_2' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 3: UpdateState(OpCodes.Stloc_3' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreLocal,The following statement contains a magic number: switch (local.Index)              {                  case 0: UpdateState(OpCodes.Stloc_0' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 1: UpdateState(OpCodes.Stloc_1' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 2: UpdateState(OpCodes.Stloc_2' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 3: UpdateState(OpCodes.Stloc_3' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreObject,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreObject,The following statement contains a magic number: if (unaligned.HasValue && (unaligned != 1 && unaligned != 2 && unaligned != 4))              {                  throw new ArgumentException("unaligned must be null' 1' 2' or 4");              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadLocal,The following statement contains a magic number: switch (local.Index)              {                  case 0: UpdateState(OpCodes.Ldloc_0' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 1: UpdateState(OpCodes.Ldloc_1' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 2: UpdateState(OpCodes.Ldloc_2' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 3: UpdateState(OpCodes.Ldloc_3' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;              }
Magic Number,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadLocal,The following statement contains a magic number: switch (local.Index)              {                  case 0: UpdateState(OpCodes.Ldloc_0' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 1: UpdateState(OpCodes.Ldloc_1' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 2: UpdateState(OpCodes.Ldloc_2' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 3: UpdateState(OpCodes.Ldloc_3' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;              }
Magic Number,Sigil,SigilVerificationException,C:\repos\kevin-montrose_Sigil\Sigil\SigilVerificationException.cs,GetDebugInfo,The following statement contains a magic number: for (var i = 2; i < Instructions.Length; i++)              {                  var line = Instructions[i];                    if (i == instrIx) line = line + "  // relevant instruction";                    if (!string.IsNullOrEmpty(line))                  {                      ret.AppendLine(line);                  }              }
Magic Number,Sigil.Impl,LinqAlternative,C:\repos\kevin-montrose_Sigil\Sigil\Impl\LinqAlternative.cs,_QuickSort,The following statement contains a magic number: while (stack.Count > 0)              {                  var leftRight = stack.Pop();                  var left = leftRight.Item1;                  var right = leftRight.Item2;                  if (right > left)                  {                      int pivot = left + (right - left) / 2;                      int pivotPosition = _Partition(ixs' keys' left' right' pivot' c);                      stack.Push(SigilTuple.Create(pivotPosition + 1' right));                      stack.Push(SigilTuple.Create(left' pivotPosition - 1));                  }                  else                  {                      while (nextYield <= right)                      {                          yield return data[ixs[nextYield]];                          nextYield++;                      }                  }              }
Magic Number,Sigil.Impl,RollingVerifier,C:\repos\kevin-montrose_Sigil\Sigil\Impl\RollingVerifier.cs,RemoveUnnecessaryVerifiers,The following statement contains a magic number: if (rooted.Count >= 2)              {                  for (var i = 1; i < rooted.Count; i++)                  {                      var toRemove = rooted[i];                      var ix = CurrentlyInScope.IndexOf(toRemove);                        RemoveAt(ix);                  }              }
Magic Number,Sigil.Impl,SigilTuple<T1;T2>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: var hash = 13;
Magic Number,Sigil.Impl,SigilTuple<T1;T2>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T1>.Default.GetHashCode(this.item1);
Magic Number,Sigil.Impl,SigilTuple<T1;T2>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T2>.Default.GetHashCode(this.item2);
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: var hash = 13;
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T1>.Default.GetHashCode(this.item1);
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T2>.Default.GetHashCode(this.item2);
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T3>.Default.GetHashCode(this.item3);
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3;T4>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: var hash = 13;
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3;T4>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T1>.Default.GetHashCode(this.item1);
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3;T4>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T2>.Default.GetHashCode(this.item2);
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3;T4>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T3>.Default.GetHashCode(this.item3);
Magic Number,Sigil.Impl,SigilTuple<T1;T2;T3;T4>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\SigilTuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash * -17) + EqualityComparer<T4>.Default.GetHashCode(this.item4);
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,InstructionSize,C:\repos\kevin-montrose_Sigil\Sigil\Impl\InstructionSize.cs,Get,The following statement contains a magic number: switch (op.OperandType)              {                  case OperandType.InlineBrTarget: operandSize = 4; break;                  case OperandType.InlineField: operandSize = 4; break;                  case OperandType.InlineI: operandSize = 4; break;                  case OperandType.InlineI8: operandSize = 8; break;                  case OperandType.InlineMethod: operandSize = 4; break;                  case OperandType.InlineNone: operandSize = 0; break;                  case OperandType.InlineR: operandSize = 8; break;                  case OperandType.InlineSig: operandSize = 4; break;                  case OperandType.InlineString: operandSize = 4; break;                  case OperandType.InlineSwitch: operandSize = 4 + labels.Length * 4; break;                  case OperandType.InlineTok: operandSize = 4; break;                  case OperandType.InlineType: operandSize = 4; break;                  case OperandType.InlineVar: operandSize = 2; break;                  case OperandType.ShortInlineBrTarget: operandSize = 1; break;                  case OperandType.ShortInlineI: operandSize = 1; break;                  case OperandType.ShortInlineR: operandSize = 4; break;                  case OperandType.ShortInlineVar: operandSize = 1; break;                  default: throw new Exception("Unexpected operand type [" + op.OperandType + "]");              }
Magic Number,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,UnBuffer,The following statement contains a magic number: for(var i = 2; i < Buffer.Count; i++)              {                  var x = Buffer[i];                    x(il' false' log);              }
Magic Number,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,Instructions,The following statement contains a magic number: for(var i = 0; i < Buffer.Count; i++)              {                  var x = Buffer[i];                    x(il' true' instrs);                  var line = instrs.ToString().TrimEnd();                    if (line.StartsWith(OpCodes.Ldloc_0.ToString()) ||                      line.StartsWith(OpCodes.Stloc_0.ToString()))                  {                      line += " // " + GetInScopeAt(locals' i)[0];                  }                    if (line.StartsWith(OpCodes.Ldloc_1.ToString()) ||                      line.StartsWith(OpCodes.Stloc_1.ToString()))                  {                      line += " // " + GetInScopeAt(locals' i)[1];                  }                    if (line.StartsWith(OpCodes.Ldloc_2.ToString()) ||                      line.StartsWith(OpCodes.Stloc_2.ToString()))                  {                      line += " // " + GetInScopeAt(locals' i)[2];                  }                    if (line.StartsWith(OpCodes.Ldloc_3.ToString()) ||                      line.StartsWith(OpCodes.Stloc_3.ToString()))                  {                      line += " // " + GetInScopeAt(locals' i)[3];                  }                    if (line.StartsWith(OpCodes.Ldloc_S.ToString()) ||                      line.StartsWith(OpCodes.Stloc_S.ToString()))                  {                      line += " // " + ExtractLocal(line' locals' i);                  }                    ret.Add(line);                  instrs.Length = 0;              }
Magic Number,Sigil.Impl,BufferedILGenerator<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Impl\BufferedILGenerator.cs,Instructions,The following statement contains a magic number: for(var i = 0; i < Buffer.Count; i++)              {                  var x = Buffer[i];                    x(il' true' instrs);                  var line = instrs.ToString().TrimEnd();                    if (line.StartsWith(OpCodes.Ldloc_0.ToString()) ||                      line.StartsWith(OpCodes.Stloc_0.ToString()))                  {                      line += " // " + GetInScopeAt(locals' i)[0];                  }                    if (line.StartsWith(OpCodes.Ldloc_1.ToString()) ||                      line.StartsWith(OpCodes.Stloc_1.ToString()))                  {                      line += " // " + GetInScopeAt(locals' i)[1];                  }                    if (line.StartsWith(OpCodes.Ldloc_2.ToString()) ||                      line.StartsWith(OpCodes.Stloc_2.ToString()))                  {                      line += " // " + GetInScopeAt(locals' i)[2];                  }                    if (line.StartsWith(OpCodes.Ldloc_3.ToString()) ||                      line.StartsWith(OpCodes.Stloc_3.ToString()))                  {                      line += " // " + GetInScopeAt(locals' i)[3];                  }                    if (line.StartsWith(OpCodes.Ldloc_S.ToString()) ||                      line.StartsWith(OpCodes.Stloc_S.ToString()))                  {                      line += " // " + ExtractLocal(line' locals' i);                  }                    ret.Add(line);                  instrs.Length = 0;              }
Missing Default,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadArgument,The following switch statement is missing a default case: switch (index)              {                  case 0: UpdateState(OpCodes.Ldarg_0' transitions); return this;                  case 1: UpdateState(OpCodes.Ldarg_1' transitions); return this;                  case 2: UpdateState(OpCodes.Ldarg_2' transitions); return this;                  case 3: UpdateState(OpCodes.Ldarg_3' transitions); return this;              }
Missing Default,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following switch statement is missing a default case: switch (i)              {                  case -1: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Missing Default,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadConstant,The following switch statement is missing a default case: switch (i)              {                  case uint.MaxValue: UpdateState(OpCodes.Ldc_I4_M1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 0: UpdateState(OpCodes.Ldc_I4_0' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 1: UpdateState(OpCodes.Ldc_I4_1' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 2: UpdateState(OpCodes.Ldc_I4_2' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 3: UpdateState(OpCodes.Ldc_I4_3' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 4: UpdateState(OpCodes.Ldc_I4_4' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 5: UpdateState(OpCodes.Ldc_I4_5' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 6: UpdateState(OpCodes.Ldc_I4_6' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 7: UpdateState(OpCodes.Ldc_I4_7' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;                  case 8: UpdateState(OpCodes.Ldc_I4_8' Wrap(StackTransition.Push<int>()' "LoadConstant")); return this;              }
Missing Default,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,StoreLocal,The following switch statement is missing a default case: switch (local.Index)              {                  case 0: UpdateState(OpCodes.Stloc_0' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 1: UpdateState(OpCodes.Stloc_1' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 2: UpdateState(OpCodes.Stloc_2' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;                  case 3: UpdateState(OpCodes.Stloc_3' Wrap(StackTransition.Pop(local.StackType)' "StoreLocal")); return this;              }
Missing Default,Sigil,Emit<DelegateType>,C:\repos\kevin-montrose_Sigil\Sigil\Emit.ArgumentList.cs,LoadLocal,The following switch statement is missing a default case: switch (local.Index)              {                  case 0: UpdateState(OpCodes.Ldloc_0' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 1: UpdateState(OpCodes.Ldloc_1' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 2: UpdateState(OpCodes.Ldloc_2' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;                  case 3: UpdateState(OpCodes.Ldloc_3' Wrap(StackTransition.Push(local.StackType)' "LoadLocal")); return this;              }
