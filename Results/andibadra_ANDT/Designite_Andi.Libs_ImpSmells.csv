Implementation smell,Namespace,Class,File,Method,Description
Long Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAction,The method has 316 lines of code.
Long Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The method has 191 lines of code.
Long Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoDragDrop,The method has 141 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The method has 100 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 110 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The method has 167 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,RunUpdates,The method has 110 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The method has 130 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The method has 183 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Finish,The method has 102 lines of code.
Complex Method,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,DoAutocomplete,Cyclomatic complexity of the method is 10
Complex Method,Andi.Libs.FastColoredTextBox,InsertCharCommand,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Commands.cs,Undo,Cyclomatic complexity of the method is 23
Complex Method,Andi.Libs.FastColoredTextBox,InsertCharCommand,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Commands.cs,InsertChar,Cyclomatic complexity of the method is 29
Complex Method,Andi.Libs.FastColoredTextBox,DocumentMap,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\DocumentMap.cs,OnPaint,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,Cyclomatic complexity of the method is 26
Complex Method,Andi.Libs.FastColoredTextBox,ExportToHTML,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToHTML.cs,GetHtml,Cyclomatic complexity of the method is 30
Complex Method,Andi.Libs.FastColoredTextBox,ExportToHTML,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToHTML.cs,GetCss,Cyclomatic complexity of the method is 10
Complex Method,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,Cyclomatic complexity of the method is 26
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,RecalcWordWrap,Cyclomatic complexity of the method is 20
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcCutOffs,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoVisibleRectangle,Cyclomatic complexity of the method is 10
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAction,Cyclomatic complexity of the method is 280
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ProcessKey,Cyclomatic complexity of the method is 12
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutoIndentChars,Cyclomatic complexity of the method is 27
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutocompleteBrackets,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,IsInputKey,Cyclomatic complexity of the method is 12
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawText,Cyclomatic complexity of the method is 10
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,Cyclomatic complexity of the method is 43
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawFoldingLines,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnMouseDown,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnMouseMove,Cyclomatic complexity of the method is 11
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PointToPlace,Cyclomatic complexity of the method is 10
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnTextChanged,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,HighlightFoldings,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FindEndOfFoldingBlock,Cyclomatic complexity of the method is 16
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,RecalcFoldingLines,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,IncreaseIndent,Cyclomatic complexity of the method is 13
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndent,Cyclomatic complexity of the method is 11
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,HighlightBrackets1,Cyclomatic complexity of the method is 12
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,HighlightBrackets2,Cyclomatic complexity of the method is 15
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnSyntaxHighlight,Cyclomatic complexity of the method is 11
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoDragDrop_old,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoDragDrop,Cyclomatic complexity of the method is 16
Complex Method,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,Cyclomatic complexity of the method is 38
Complex Method,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,OpenFile,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,SaveToFile,Cyclomatic complexity of the method is 12
Complex Method,Andi.Libs.FastColoredTextBox,FindForm,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FindForm.cs,FindNext,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,Hints,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Clear,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,HotkeysEditorForm,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\HotkeysEditorForm.cs,dgv_RowsAdded,Cyclomatic complexity of the method is 10
Complex Method,Andi.Libs.FastColoredTextBox,HotkeysEditorForm,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\HotkeysEditorForm.cs,GetUnAssignedActions,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GoUp,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GoPageUp,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GoDown,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GoPageDown,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GetRangesByLinesReversed,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GetEnumerator,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GetFragment,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GetPlacesCyclic,Cyclomatic complexity of the method is 12
Complex Method,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetCSS,Cyclomatic complexity of the method is 9
Complex Method,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,HighlightSyntax,Cyclomatic complexity of the method is 26
Complex Method,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,AutoIndentNeeded,Cyclomatic complexity of the method is 26
Complex Method,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseXmlDescription,Cyclomatic complexity of the method is 10
Complex Method,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitStyleSchema,Cyclomatic complexity of the method is 65
Complex Method,Andi.Libs.HexBox,DynamicFileByteProvider,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\DynamicFileByteProvider.cs,WriteByte,Cyclomatic complexity of the method is 12
Complex Method,Andi.Libs.HexBox,DynamicFileByteProvider,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\DynamicFileByteProvider.cs,InsertBytes,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.HexBox,DynamicFileByteProvider,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\DynamicFileByteProvider.cs,ApplyChanges,Cyclomatic complexity of the method is 8
Complex Method,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,_vScrollBar_Scroll,Cyclomatic complexity of the method is 33
Complex Method,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,Find,Cyclomatic complexity of the method is 13
Complex Method,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,OnPaintBackground,Cyclomatic complexity of the method is 10
Complex Method,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,Cyclomatic complexity of the method is 18
Complex Method,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Core,FileSystemScanner,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\FileSystemScanner.cs,ScanDir,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Core,NameFilter,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\NameFilter.cs,SplitQuoted,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,Deflate,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,Cyclomatic complexity of the method is 40
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Inflate,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,Cyclomatic complexity of the method is 53
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,CreateZip,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractZip,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractEntry,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\WindowsNameTransform.cs,MakeValidName,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntryFactory.cs,MakeFileEntry,Cyclomatic complexity of the method is 27
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetInputStream,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestArchive,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,BeginUpdate,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLocalEntryHeader,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CopyBytes,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetOutputStream,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,AddEntry,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,RunUpdates,Cyclomatic complexity of the method is 31
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,DiskArchiveStorage,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetTempFileName,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLocalHeader,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,InitialRead,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,Cyclomatic complexity of the method is 33
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Finish,Cyclomatic complexity of the method is 21
Complex Method,Andi.Libs.IniParser,FileIniDataParser,C:\repos\andibadra_ANDT\Andi.Libs\IniParser\FileIniParser.cs,WriteFile,Cyclomatic complexity of the method is 8
Long Parameter List,Andi.Libs.FastColoredTextBox,AutocompleteItem,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteItem.cs,AutocompleteItem,The method has 5 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteListView,The method has 15 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,ReplaceTextCommand,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Commands.cs,ReplaceTextCommand,The method has 5 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,AddHint,The method has 5 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,AddHint,The method has 5 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcCutOffs,The method has 6 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawLineChars,The method has 7 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,AutoIndentEventArgs,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,AutoIndentEventArgs,The method has 5 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,Hint,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Hint,The method has 5 parameters.
Long Parameter List,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,Range,The method has 5 parameters.
Long Parameter List,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintHexStringSelected,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\PathFilter.cs,ExtendedPathFilter,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,The method has 7 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,The method has 8 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicEncryptCryptoTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicDecryptCryptoTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,CreateZip,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,CreateZip,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractZip,The method has 7 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractZip,The method has 8 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CopyBytes,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CopyEntryDataDirect,The method has 5 parameters.
Long Identifier,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,IncreaseIndent,The length of the parameter newSelectionStartCharacterIndex is 31.
Long Identifier,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndent,The length of the parameter numberOfDeletedWhitespacesOfFirstLine is 37.
Long Identifier,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndent,The length of the parameter numberOfDeletetWhitespacesOfLastLine is 36.
Long Identifier,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndent,The length of the parameter newSelectionStartCharacterIndex is 31.
Long Identifier,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndentOfSingleLine,The length of the parameter currentLeftSelectionStartIndex is 30.
Long Identifier,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndentOfSingleLine,The length of the parameter whitespacesLeftOfSelectionStartMatch is 36.
Long Identifier,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndentOfSingleLine,The length of the parameter newSelectionStartCharacterIndex is 31.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,UpdateCommentOnly,The length of the parameter CentralHeaderCommentSizeOffset is 30.
Long Statement,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,DoAutocomplete,The length of the statement  "	if (forced || (text.Length >= Menu.MinFragmentLength && tb.Selection.IsEmpty /*pops up only if selected range is empty*/&& (tb.Selection.Start > fragment.Start || text.Length == 0/*pops up only if caret is after first letter*/))) { " is 231.
Long Statement,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,OnPaint,The length of the statement  "			using (var selectedBrush = new LinearGradientBrush (new Point (0' y - 3)' new Point (0' y + itemHeight)' Color.Transparent' SelectedColor)) " is 139.
Long Statement,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,DoSelectedVisible,The length of the statement  "		VerticalScroll.Value = Math.Min (VerticalScroll.Maximum' FocussedItemIndex * itemHeight - ClientSize.Height + itemHeight); " is 122.
Long Statement,Andi.Libs.FastColoredTextBox,InsertCharCommand,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Commands.cs,Execute,The length of the statement  "	ts.NeedRecalc (new TextSource.TextChangedEventArgs (ts.CurrentTB.Selection.Start.iLine' ts.CurrentTB.Selection.Start.iLine)); " is 125.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectTextFileEncoding,The length of the statement  "	byte[] sampleBytes = new byte[HeuristicSampleSize > InputFileStream.Length ? InputFileStream.Length : HeuristicSampleSize]; " is 123.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The length of the statement  "	if (((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6) " is 128.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The length of the statement  "	if (((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6) " is 128.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The length of the statement  "	Regex UTF8Validator = new Regex (@"\A(" + @"[\x09\x0A\x0D\x20-\x7E]" + @"|[\xC2-\xDF][\x80-\xBF]" + @"|\xE0[\xA0-\xBF][\x80-\xBF]" + @"|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" + @"|\xED[\x80-\x9F][\x80-\xBF]" + @"|\xF0[\x90-\xBF][\x80-\xBF]{2}" + @"|[\xF1-\xF3][\x80-\xBF]{3}" + @"|\xF4[\x80-\x8F][\x80-\xBF]{2}" + @")*\z"); " is 319.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The length of the statement  "		//If some of the characters were in the upper range (western accented characters)' however' they would likely be mangled to 2-byte by the UTF-8 encoding process. " is 161.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The length of the statement  "		SampleBytes.Length - suspiciousUTF8BytesTotal == 0 || likelyUSASCIIBytesInSample * 1.0 / (SampleBytes.Length - suspiciousUTF8BytesTotal) >= 0.8)) " is 145.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The length of the statement  "		if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F) " is 121.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The length of the statement  "		else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE) " is 126.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The length of the statement  "			if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A) " is 121.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The length of the statement  "			if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E) " is 121.
Long Statement,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The length of the statement  "			if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2) " is 121.
Long Statement,Andi.Libs.FastColoredTextBox,ExportToHTML,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToHTML.cs,GetHtml,The length of the statement  "		sb.AppendFormat ("<font style=\"font-family: {0}' monospace; font-size: {1}pt; line-height: {2}px;\">"' r.tb.Font.Name' r.tb.Font.SizeInPoints' r.tb.CharHeight); " is 161.
Long Statement,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The length of the statement  "		sb.Insert (0' string.Format (@"{{\fonttbl{{\f0\fmodern {0};}}}}{{\fs{1} "' tb.Font.Name' (int)(2 * tb.Font.SizeInPoints)' tb.CharHeight)); " is 138.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PrepareHtmlForClipboard,The length of the statement  "	string begin = "Version:0.9\r\nStartHTML:{0:000000}\r\nEndHTML:{1:000000}" + "\r\nStartFragment:{2:000000}\r\nEndFragment:{3:000000}\r\n"; " is 138.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PrepareHtmlForClipboard,The length of the statement  "	string html_begin = "<html>\r\n<head>\r\n" + "<meta http-equiv=\"Content-Type\"" + " content=\"text/html; charset=" + enc.WebName + "\">\r\n" + "<title>HTML clipboard</title>\r\n</head>\r\n<body>\r\n" + "<!--StartFragment-->"; " is 226.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PrepareHtmlForClipboard,The length of the statement  "	string html_total = String.Format (begin' count_begin' count_begin + count_html_begin + count_html + count_html_end' count_begin + count_html_begin' count_begin + count_html_begin + count_html) + html_begin + html + html_end; " is 225.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,RecalcWordWrap,The length of the statement  "					CalcCutOffs (li.CutOffPositions' maxCharsPerLine' maxCharsPerLine - li.wordWrapIndent' ImeAllowed' charWrap' lines [iLine]); " is 124.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,IsCJKLetter,The length of the statement  "	return (code >= 0x3300 && code <= 0x33FF) || (code >= 0xFE30 && code <= 0xFE4F) || (code >= 0xF900 && code <= 0xFAFF) || (code >= 0x2E80 && code <= 0x2EFF) || (code >= 0x31C0 && code <= 0x31EF) || (code >= 0x4E00 && code <= 0x9FFF) || (code >= 0x3400 && code <= 0x4DBF) || (code >= 0x3200 && code <= 0x32FF) || (code >= 0x2460 && code <= 0x24FF) || (code >= 0x3040 && code <= 0x309F) || (code >= 0x2F00 && code <= 0x2FDF) || (code >= 0x31A0 && code <= 0x31BF) || (code >= 0x4DC0 && code <= 0x4DFF) || (code >= 0x3100 && code <= 0x312F) || (code >= 0x30A0 && code <= 0x30FF) || (code >= 0x31F0 && code <= 0x31FF) || (code >= 0x2FF0 && code <= 0x2FFF) || (code >= 0x1100 && code <= 0x11FF) || (code >= 0xA960 && code <= 0xA97F) || (code >= 0xD7B0 && code <= 0xD7FF) || (code >= 0x3130 && code <= 0x318F) || (code >= 0xAC00 && code <= 0xD7AF); " is 840.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoSelectionVisible,The length of the statement  "	DoVisibleRectangle (new Rectangle (PlaceToPoint (new Place (0' Selection.End.iLine))' new Size (2 * CharWidth' 2 * CharHeight))); " is 129.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoRangeVisible,The length of the statement  "	range.End = new Place (range.End.iChar' Math.Min (range.End.iLine' range.Start.iLine + ClientSize.Height / CharHeight)); " is 120.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ProcessKey,The length of the statement  "		if (!HotkeysMapping.ContainsKey (keyData) || (HotkeysMapping [keyData] != FCTBAction.MacroExecute && HotkeysMapping [keyData] != FCTBAction.MacroRecord)) " is 153.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ProcessKey,The length of the statement  "	if (modifiers != Keys.None && modifiers != Keys.Shift && modifiers != (Keys.Control | Keys.Alt) && //ALT+CTRL is special chars (AltGr) " is 134.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcAutoIndent,The length of the statement  "	var a = new AutoIndentEventArgs (iLine' lines [iLine].Text' iLine > 0 ? lines [iLine - 1].Text : ""' TabLength' indent); " is 120.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcAutoIndentShiftByCodeFolding,The length of the statement  "	if (string.IsNullOrEmpty (lines [args.iLine].FoldingEndMarker) && !string.IsNullOrEmpty (lines [args.iLine].FoldingStartMarker)) { " is 130.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcAutoIndentShiftByCodeFolding,The length of the statement  "	if (!string.IsNullOrEmpty (lines [args.iLine].FoldingEndMarker) && string.IsNullOrEmpty (lines [args.iLine].FoldingStartMarker)) { " is 130.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "	Brush currentLineBrush = new SolidBrush (Color.FromArgb (CurrentLineColor.A == 255 ? 50 : CurrentLineColor.A' CurrentLineColor)); " is 129.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "		e.Graphics.FillRectangle (paddingBrush' LeftIndent - HorizontalScroll.Value - 2' 0' Math.Max (0' Paddings.Left - 1)' ClientSize.Height); " is 136.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "		e.Graphics.DrawLine (servicePen' new Point (LeftIndent + Paddings.Left + PreferredLineWidth * CharWidth - HorizontalScroll.Value + 1' textAreaRect.Top + 1)' new Point (LeftIndent + Paddings.Left + PreferredLineWidth * CharWidth - HorizontalScroll.Value + 1' textAreaRect.Bottom - 1)); " is 284.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "				e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount)); " is 150.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "			e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1)); " is 122.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "			bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)); " is 130.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "			OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle)); " is 156.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "				e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft)); " is 223.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "		if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker)) " is 149.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "			visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8))); " is 121.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "		if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker)) " is 149.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "			e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1); " is 173.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "				e.Graphics.DrawRectangle (pen' Rectangle.FromLTRB (Math.Min (p1.X' p2.X) - 1' Math.Min (p1.Y' p2.Y)' Math.Max (p1.X' p2.X)' Math.Max (p1.Y' p2.Y) + CharHeight)); " is 161.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "			int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2; " is 126.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The length of the statement  "			int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight; " is 207.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawLineChars,The length of the statement  "		FoldedBlockStyle.Draw (gr' new Point (startX + firstChar * CharWidth' y)' new Range (this' from + firstChar' iLine' from + lastChar + 1' iLine)); " is 145.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawLineChars,The length of the statement  "				FlushRendering (gr' currentStyleIndex' new Point (startX + (iLastFlushedChar + 1) * CharWidth' y)' new Range (this' from + iLastFlushedChar + 1' iLine' from + iChar' iLine)); " is 174.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawLineChars,The length of the statement  "		FlushRendering (gr' currentStyleIndex' new Point (startX + (iLastFlushedChar + 1) * CharWidth' y)' new Range (this' from + iLastFlushedChar + 1' iLine' from + lastChar + 1' iLine)); " is 181.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoScrollVertical,The length of the statement  "	var ea = new ScrollEventArgs (direction > 0 ? ScrollEventType.SmallDecrement : ScrollEventType.SmallIncrement' VerticalScroll.Value' newScrollPos' ScrollOrientation.VerticalScroll); " is 181.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PlaceToPosition,The length of the statement  "	if (point.iLine < 0 || point.iLine >= lines.Count || point.iChar >= lines [point.iLine].Count + Environment.NewLine.Length) " is 123.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,IncreaseIndent,The length of the statement  "		int newSelectionEndCharacterIndex = currentSelection.End.iChar + (currentSelection.End.iLine == to ? this.TabLength : 0); " is 121.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndent,The length of the statement  "		int newSelectionStartCharacterIndex = Math.Max (0' currentSelection.Start.iChar - numberOfDeletedWhitespacesOfFirstLine); " is 121.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndentOfSingleLine,The length of the statement  "	Match whitespacesLeftOfSelectionStartMatch = new Regex (@"\s*"' RegexOptions.RightToLeft).Match (lineText' currentLeftSelectionStartIndex); " is 139.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DecreaseIndentOfSingleLine,The length of the statement  "		numberOfCharactersToRemove = (remainder != 0) ? Math.Min (remainder' countOfWhitespaces) : Math.Min (this.TabLength' countOfWhitespaces); " is 137.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,HighlightBrackets2,The length of the statement  "		rightBracketPosition = new Range (this' range.Start.iChar - 1' range.Start.iLine' range.Start.iChar' range.Start.iLine); " is 120.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,Print,The length of the statement  "	HTML = "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=UTF-8\"><head><title>" + PrepareHtmlText (settings.Title) + "</title></head>" + HTML + "<br>" + SelectHTMLRangeScript (); " is 192.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoDragDrop_old,The length of the statement  "		insertRange = new Range (this' place' new Place (place.iChar' place.iLine + draggedRange.End.iLine - draggedRange.Start.iLine)) { " is 129.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoDragDrop_old,The length of the statement  "			Selection = new Range (this' place' new Place (place.iChar + draggedRange.End.iChar - draggedRange.Start.iChar' place.iLine + draggedRange.End.iLine - draggedRange.Start.iLine)) { " is 179.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoDragDrop,The length of the statement  "				insertRange = new Range (this' place' new Place (place.iChar' place.iLine + draggedRange.End.iLine - draggedRange.Start.iLine)) { " is 129.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoDragDrop,The length of the statement  "				if ((copyMode == false) && (place.iLine >= dR.Start.iLine) && (place.iLine <= dR.End.iLine) && (place.iChar >= dR.End.iChar)) { " is 127.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,RestoreScrollsAfterMiddleClickScrollingMode,The length of the statement  "	var xea = new ScrollEventArgs (ScrollEventType.ThumbPosition' HorizontalScroll.Value' middleClickScrollingOriginScroll.X' ScrollOrientation.HorizontalScroll); " is 158.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,RestoreScrollsAfterMiddleClickScrollingMode,The length of the statement  "	var yea = new ScrollEventArgs (ScrollEventType.ThumbPosition' VerticalScroll.Value' middleClickScrollingOriginScroll.Y' ScrollOrientation.VerticalScroll); " is 154.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The length of the statement  "	var xea = new ScrollEventArgs (xScrollOffset < 0 ? ScrollEventType.SmallIncrement : ScrollEventType.SmallDecrement' HorizontalScroll.Value' HorizontalScroll.Value + xScrollOffset' ScrollOrientation.HorizontalScroll); " is 216.
Long Statement,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The length of the statement  "	var yea = new ScrollEventArgs (yScrollOffset < 0 ? ScrollEventType.SmallDecrement : ScrollEventType.SmallIncrement' VerticalScroll.Value' VerticalScroll.Value + yScrollOffset' ScrollOrientation.VerticalScroll); " is 210.
Long Statement,Andi.Libs.FastColoredTextBox,Hints,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,LayoutHint,The length of the statement  "			hint.HostPanel.Top = tb.LineInfos [hint.Range.Start.iLine + 1].startY - hint.TopPadding - hint.HostPanel.Height - tb.VerticalScroll.Value; " is 138.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.C] = FCTBAction.CommentSelected; " is 134.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.U] = FCTBAction.LowerCase; " is 128.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.OemMinus] = FCTBAction.NavigateForward; " is 141.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.B] = FCTBAction.UnbookmarkLine; " is 133.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.N] = FCTBAction.GoPrevBookmark; " is 133.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.Left] = FCTBAction.GoWordLeftWithSelection; " is 145.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.Left] = FCTBAction.GoLeft_ColumnSelectionMode; " is 144.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.Right] = FCTBAction.GoWordRightWithSelection; " is 147.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.Right] = FCTBAction.GoRight_ColumnSelectionMode; " is 146.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.Up] = FCTBAction.GoUp_ColumnSelectionMode; " is 140.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.Down] = FCTBAction.GoDown_ColumnSelectionMode; " is 144.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.Home] = FCTBAction.GoFirstLineWithSelection; " is 146.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,InitDefault,The length of the statement  "	this [System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.End] = FCTBAction.GoLastLineWithSelection; " is 144.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysEditor,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,EditValue,The length of the statement  "	if ((provider != null) && (((IWindowsFormsEditorService)provider.GetService (typeof(IWindowsFormsEditorService))) != null)) { " is 125.
Long Statement,Andi.Libs.FastColoredTextBox,HotkeysEditorForm,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\HotkeysEditorForm.cs,HotkeysEditorForm_FormClosing,The length of the statement  "			if (MessageBox.Show ("Some actions are not assigned!\r\nActions: " + actions + "\r\nPress Yes to save and exit' press No to continue editing"' "Some actions is not assigned"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == System.Windows.Forms.DialogResult.No) " is 264.
Long Statement,Andi.Libs.FastColoredTextBox,PlatformType,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\PlatformType.cs,GetOperationSystemPlatform,The length of the statement  "	if (Environment.OSVersion.Version.Major > 5 || (Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor >= 1)) { " is 136.
Long Statement,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GoUp,The length of the statement  "		preferedPos = start.iChar - tb.LineInfos [start.iLine].GetWordWrapStringStartPosition (tb.LineInfos [start.iLine].GetWordWrapStringIndex (start.iChar)); " is 152.
Long Statement,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GoPageUp,The length of the statement  "		preferedPos = start.iChar - tb.LineInfos [start.iLine].GetWordWrapStringStartPosition (tb.LineInfos [start.iLine].GetWordWrapStringIndex (start.iChar)); " is 152.
Long Statement,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GoDown,The length of the statement  "		preferedPos = start.iChar - tb.LineInfos [start.iLine].GetWordWrapStringStartPosition (tb.LineInfos [start.iLine].GetWordWrapStringIndex (start.iChar)); " is 152.
Long Statement,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GoPageDown,The length of the statement  "		preferedPos = start.iChar - tb.LineInfos [start.iLine].GetWordWrapStringStartPosition (tb.LineInfos [start.iLine].GetWordWrapStringIndex (start.iChar)); " is 152.
Long Statement,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,GetIntersectionWith_ColumnSelectionMode,The length of the statement  "	return new Range (tb' rect.iStartChar' range.Start.iLine' rect.iEndChar' range.Start.iLine).GetIntersectionWith (range); " is 120.
Long Statement,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The length of the statement  "	e.Graphics.FillRectangle (new LinearGradientBrush (new Rectangle (0' 0' Width' Height)' BackColor' BackColor2' 270)' new Rectangle (0' 0' Width' Height)); " is 154.
Long Statement,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The length of the statement  "		gr.FillRectangle (BackgroundBrush' position.X' position.Y' (range.End.iChar - range.Start.iChar) * range.tb.CharWidth' range.tb.CharHeight); " is 140.
Long Statement,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The length of the statement  "		range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (firstNonSpaceSymbolX' position.Y' position.X + (range.End.iChar - range.Start.iChar) * range.tb.CharWidth - firstNonSpaceSymbolX' range.tb.CharHeight))); " is 235.
Long Statement,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The length of the statement  "		range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (range.tb.LeftIndent + 2' position.Y' 2 * range.tb.CharHeight' range.tb.CharHeight))); " is 167.
Long Statement,Andi.Libs.FastColoredTextBox,SelectionStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The length of the statement  "		var rect = new Rectangle (position.X' position.Y' (range.End.iChar - range.Start.iChar) * range.tb.CharWidth' range.tb.CharHeight); " is 131.
Long Statement,Andi.Libs.FastColoredTextBox,SelectionStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The length of the statement  "			var r = new Range (range.tb' range.Start.iChar' range.Start.iLine' Math.Min (range.tb [range.End.iLine].Count' range.End.iChar)' range.End.iLine); " is 146.
Long Statement,Andi.Libs.FastColoredTextBox,MarkerStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The length of the statement  "		Rectangle rect = new Rectangle (position.X' position.Y' (range.End.iChar - range.Start.iChar) * range.tb.CharWidth' range.tb.CharHeight); " is 137.
Long Statement,Andi.Libs.FastColoredTextBox,ShortcutStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The length of the statement  "	AddVisualMarker (range.tb' new StyleVisualMarker (new Rectangle (p.X - range.tb.CharWidth' p.Y' range.tb.CharWidth' range.tb.CharHeight)' this)); " is 145.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,VBAutoIndentNeeded,The length of the statement  "	if (Regex.IsMatch (args.LineText' @"\b(Class|Property|Enum|Structure|Sub|Function|Namespace|Interface|Get)\b|(Set\s*\()"' RegexOptions.IgnoreCase)) { " is 149.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseXmlDescription,The length of the statement  "		if (brackets.Attributes ["left"] == null || brackets.Attributes ["right"] == null || brackets.Attributes ["left"].Value == "" || brackets.Attributes ["right"].Value == "") { " is 173.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseXmlDescription,The length of the statement  "		if (brackets.Attributes ["left2"] == null || brackets.Attributes ["right2"] == null || brackets.Attributes ["left2"].Value == "" || brackets.Attributes ["right2"].Value == "") { " is 177.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseXmlDescription,The length of the statement  "			desc.bracketsHighlightStrategy = (BracketsHighlightStrategy)Enum.Parse (typeof(BracketsHighlightStrategy)' brackets.Attributes ["strategy"].Value); " is 147.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitCShaprRegex,The length of the statement  "	//CSharpStringRegex = new Regex( @"""""|@""""|''|@"".*?""|(?<!@)(?<range>"".*?[^\\]"")|'.*?[^\\]'"' RegexCompiledOption); " is 121.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitCShaprRegex,The length of the statement  "                        "' RegexOptions.ExplicitCapture | RegexOptions.Singleline | RegexOptions.IgnorePatternWhitespace | RegexCompiledOption); " is 120.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitCShaprRegex,The length of the statement  "	CSharpCommentRegex3 = new Regex (@"(/\*.*?\*/)|(.*\*/)"' RegexOptions.Singleline | RegexOptions.RightToLeft | RegexCompiledOption); " is 131.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitCShaprRegex,The length of the statement  "	CSharpKeywordRegex = new Regex (@"\b(abstract|as|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b|#region\b|#endregion\b"' RegexCompiledOption); " is 717.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitVBRegex,The length of the statement  "	VBClassNameRegex = new Regex (@"\b(Class|Structure|Enum|Interface)[ ]+(?<range>\w+?)\b"' RegexOptions.IgnoreCase | RegexCompiledOption); " is 136.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitVBRegex,The length of the statement  "	VBKeywordRegex = new Regex (@"\b(AddHandler|AddressOf|Alias|And|AndAlso|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|CBool|CByte|CChar|CDate|CDbl|CDec|Char|CInt|Class|CLng|CObj|Const|Continue|CSByte|CShort|CSng|CStr|CType|CUInt|CULng|CUShort|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else|ElseIf|End|EndIf|Enum|Erase|Error|Event|Exit|False|Finally|For|Friend|Function|Get|GetType|GetXMLNamespace|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|MustInherit|MustOverride|MyBase|MyClass|Namespace|Narrowing|New|Next|Not|Nothing|NotInheritable|NotOverridable|Object|Of|On|Operator|Option|Optional|Or|OrElse|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|REM|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|Short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|True|Try|TryCast|TypeOf|UInteger|ULong|UShort|Using|Variant|Wend|When|While|Widening|With|WithEvents|WriteOnly|Xor|Region)\b|(#Const|#Else|#ElseIf|#End|#If|#Region)\b"' RegexOptions.IgnoreCase | RegexCompiledOption); " is 1169.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,VBSyntaxHighlight,The length of the statement  "	range.SetFoldingMarkers (@"\b(Class|Property|Enum|Structure|Interface)[ \t]+\S+"' @"\bEnd (Class|Property|Enum|Structure|Interface)\b"' RegexOptions.IgnoreCase); " is 161.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,VBSyntaxHighlight,The length of the statement  "	range.SetFoldingMarkers (@"^\s*(?<range>While)[ \t]+\S+"' @"^\s*(?<range>End While)\b"' RegexOptions.Multiline | RegexOptions.IgnoreCase); " is 138.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,VBSyntaxHighlight,The length of the statement  "	range.SetFoldingMarkers (@"(\r|\n|^)[ \t]*(?<range>Get|Set)[ \t]*(\r|\n|$)"' @"\bEnd (Get|Set)\b"' RegexOptions.IgnoreCase); " is 124.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,VBSyntaxHighlight,The length of the statement  "	range.SetFoldingMarkers (@"^\s*(?<range>For|For\s+Each)\b"' @"^\s*(?<range>Next)\b"' RegexOptions.Multiline | RegexOptions.IgnoreCase); " is 135.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,VBSyntaxHighlight,The length of the statement  "	range.SetFoldingMarkers (@"^\s*(?<range>Do)\b"' @"^\s*(?<range>Loop)\b"' RegexOptions.Multiline | RegexOptions.IgnoreCase); " is 123.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitHTMLRegex,The length of the statement  "	HTMLCommentRegex2 = new Regex (@"(<!--.*?-->)|(.*-->)"' RegexOptions.Singleline | RegexOptions.RightToLeft | RegexCompiledOption); " is 130.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitHTMLRegex,The length of the statement  "	HTMLAttrRegex = new Regex (@"(?<range>[\w\d\-]{1'20}?)='[^']*'|(?<range>[\w\d\-]{1'20})=""[^""]*""|(?<range>[\w\d\-]{1'20})=[\w\d\-]{1'20}"' RegexCompiledOption); " is 162.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitHTMLRegex,The length of the statement  "	HTMLAttrValRegex = new Regex (@"[\w\d\-]{1'20}?=(?<range>'[^']*')|[\w\d\-]{1'20}=(?<range>""[^""]*"")|[\w\d\-]{1'20}=(?<range>[\w\d\-]{1'20})"' RegexCompiledOption); " is 165.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitHTMLRegex,The length of the statement  "	HTMLEntityRegex = new Regex (@"\&(amp|gt|lt|nbsp|quot|apos|copy|reg|#[0-9]{1'8}|#x[0-9a-f]{1'8});"' RegexCompiledOption | RegexOptions.IgnoreCase); " is 147.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitXMLRegex,The length of the statement  "	XMLCommentRegex2 = new Regex (@"(<!--.*?-->)|(.*-->)"' RegexOptions.Singleline | RegexOptions.RightToLeft | RegexCompiledOption); " is 129.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitXMLRegex,The length of the statement  "	XMLAttrRegex = new Regex (@"(?<range>[\w\d\-\:]+)[ ]*=[ ]*'[^']*'|(?<range>[\w\d\-\:]+)[ ]*=[ ]*""[^""]*""|(?<range>[\w\d\-\:]+)[ ]*=[ ]*[\w\d\-\:]+"' RegexCompiledOption); " is 172.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitXMLRegex,The length of the statement  "	XMLAttrValRegex = new Regex (@"[\w\d\-]+?=(?<range>'[^']*')|[\w\d\-]+[ ]*=[ ]*(?<range>""[^""]*"")|[\w\d\-]+[ ]*=[ ]*(?<range>[\w\d\-]+)"' RegexCompiledOption); " is 160.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitXMLRegex,The length of the statement  "	XMLEntityRegex = new Regex (@"\&(amp|gt|lt|nbsp|quot|apos|copy|reg|#[0-9]{1'8}|#x[0-9a-f]{1'8});"' RegexCompiledOption | RegexOptions.IgnoreCase); " is 146.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitXMLRegex,The length of the statement  "	XMLCDataRegex = new Regex (@"<!\s*\[CDATA\s*\[(?<text>(?>[^]]+|](?!]>))*)]]>"' RegexCompiledOption | RegexOptions.IgnoreCase); " is 126.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,XMLSyntaxHighlight,The length of the statement  "	range.ClearStyle (CommentStyle' XmlTagBracketStyle' XmlTagNameStyle' XmlAttributeStyle' XmlAttributeValueStyle' XmlEntityStyle' XmlCDataStyle); " is 143.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitSQLRegex,The length of the statement  "	SQLCommentRegex3 = new Regex (@"(/\*.*?\*/)|(.*\*/)"' RegexOptions.Singleline | RegexOptions.RightToLeft | RegexCompiledOption); " is 128.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitSQLRegex,The length of the statement  "	SQLStatementsRegex = new Regex (@"\b(ALTER APPLICATION ROLE|ALTER ASSEMBLY|ALTER ASYMMETRIC KEY|ALTER AUTHORIZATION|ALTER BROKER PRIORITY|ALTER CERTIFICATE|ALTER CREDENTIAL|ALTER CRYPTOGRAPHIC PROVIDER|ALTER DATABASE|ALTER DATABASE AUDIT SPECIFICATION|ALTER DATABASE ENCRYPTION KEY|ALTER ENDPOINT|ALTER EVENT SESSION|ALTER FULLTEXT CATALOG|ALTER FULLTEXT INDEX|ALTER FULLTEXT STOPLIST|ALTER FUNCTION|ALTER INDEX|ALTER LOGIN|ALTER MASTER KEY|ALTER MESSAGE TYPE|ALTER PARTITION FUNCTION|ALTER PARTITION SCHEME|ALTER PROCEDURE|ALTER QUEUE|ALTER REMOTE SERVICE BINDING|ALTER RESOURCE GOVERNOR|ALTER RESOURCE POOL|ALTER ROLE|ALTER ROUTE|ALTER SCHEMA|ALTER SERVER AUDIT|ALTER SERVER AUDIT SPECIFICATION|ALTER SERVICE|ALTER SERVICE MASTER KEY|ALTER SYMMETRIC KEY|ALTER TABLE|ALTER TRIGGER|ALTER USER|ALTER VIEW|ALTER WORKLOAD GROUP|ALTER XML SCHEMA COLLECTION|BULK INSERT|CREATE AGGREGATE|CREATE APPLICATION ROLE|CREATE ASSEMBLY|CREATE ASYMMETRIC KEY|CREATE BROKER PRIORITY|CREATE CERTIFICATE|CREATE CONTRACT|CREATE CREDENTIAL|CREATE CRYPTOGRAPHIC PROVIDER|CREATE DATABASE|CREATE DATABASE AUDIT SPECIFICATION|CREATE DATABASE ENCRYPTION KEY|CREATE DEFAULT|CREATE ENDPOINT|CREATE EVENT NOTIFICATION|CREATE EVENT SESSION|CREATE FULLTEXT CATALOG|CREATE FULLTEXT INDEX|CREATE FULLTEXT STOPLIST|CREATE FUNCTION|CREATE INDEX|CREATE LOGIN|CREATE MASTER KEY|CREATE MESSAGE TYPE|CREATE PARTITION FUNCTION|CREATE PARTITION SCHEME|CREATE PROCEDURE|CREATE QUEUE|CREATE REMOTE SERVICE BINDING|CREATE RESOURCE POOL|CREATE ROLE|CREATE ROUTE|CREATE RULE|CREATE SCHEMA|CREATE SERVER AUDIT|CREATE SERVER AUDIT SPECIFICATION|CREATE SERVICE|CREATE SPATIAL INDEX|CREATE STATISTICS|CREATE SYMMETRIC KEY|CREATE SYNONYM|CREATE TABLE|CREATE TRIGGER|CREATE TYPE|CREATE USER|CREATE VIEW|CREATE WORKLOAD GROUP|CREATE XML INDEX|CREATE XML SCHEMA COLLECTION|DELETE|DISABLE TRIGGER|DROP AGGREGATE|DROP APPLICATION ROLE|DROP ASSEMBLY|DROP ASYMMETRIC KEY|DROP BROKER PRIORITY|DROP CERTIFICATE|DROP CONTRACT|DROP CREDENTIAL|DROP CRYPTOGRAPHIC PROVIDER|DROP DATABASE|DROP DATABASE AUDIT SPECIFICATION|DROP DATABASE ENCRYPTION KEY|DROP DEFAULT|DROP ENDPOINT|DROP EVENT NOTIFICATION|DROP EVENT SESSION|DROP FULLTEXT CATALOG|DROP FULLTEXT INDEX|DROP FULLTEXT STOPLIST|DROP FUNCTION|DROP INDEX|DROP LOGIN|DROP MASTER KEY|DROP MESSAGE TYPE|DROP PARTITION FUNCTION|DROP PARTITION SCHEME|DROP PROCEDURE|DROP QUEUE|DROP REMOTE SERVICE BINDING|DROP RESOURCE POOL|DROP ROLE|DROP ROUTE|DROP RULE|DROP SCHEMA|DROP SERVER AUDIT|DROP SERVER AUDIT SPECIFICATION|DROP SERVICE|DROP SIGNATURE|DROP STATISTICS|DROP SYMMETRIC KEY|DROP SYNONYM|DROP TABLE|DROP TRIGGER|DROP TYPE|DROP USER|DROP VIEW|DROP WORKLOAD GROUP|DROP XML SCHEMA COLLECTION|ENABLE TRIGGER|EXEC|EXECUTE|REPLACE|FROM|INSERT|MERGE|OPTION|OUTPUT|SELECT|TOP|TRUNCATE TABLE|UPDATE|UPDATE STATISTICS|WHERE|WITH|INTO|IN|SET)\b"' RegexOptions.IgnoreCase | RegexCompiledOption); " is 2875.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitSQLRegex,The length of the statement  "	SQLKeywordsRegex = new Regex (@"\b(ADD|ALL|AND|ANY|AS|ASC|AUTHORIZATION|BACKUP|BEGIN|BETWEEN|BREAK|BROWSE|BY|CASCADE|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COLLATE|COLUMN|COMMIT|COMPUTE|CONSTRAINT|CONTAINS|CONTINUE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURSOR|DATABASE|DBCC|DEALLOCATE|DECLARE|DEFAULT|DENY|DESC|DISK|DISTINCT|DISTRIBUTED|DOUBLE|DUMP|ELSE|END|ERRLVL|ESCAPE|EXCEPT|EXISTS|EXIT|EXTERNAL|FETCH|FILE|FILLFACTOR|FOR|FOREIGN|FREETEXT|FULL|FUNCTION|GOTO|GRANT|GROUP|HAVING|HOLDLOCK|IDENTITY|IDENTITY_INSERT|IDENTITYCOL|IF|INDEX|INNER|INTERSECT|IS|JOIN|KEY|KILL|LIKE|LINENO|LOAD|NATIONAL|NOCHECK|NONCLUSTERED|NOT|NULL|OF|OFF|OFFSETS|ON|OPEN|OR|ORDER|OUTER|OVER|PERCENT|PIVOT|PLAN|PRECISION|PRIMARY|PRINT|PROC|PROCEDURE|PUBLIC|RAISERROR|READ|READTEXT|RECONFIGURE|REFERENCES|REPLICATION|RESTORE|RESTRICT|RETURN|REVERT|REVOKE|ROLLBACK|ROWCOUNT|ROWGUIDCOL|RULE|SAVE|SCHEMA|SECURITYAUDIT|SHUTDOWN|SOME|STATISTICS|TABLE|TABLESAMPLE|TEXTSIZE|THEN|TO|TRAN|TRANSACTION|TRIGGER|TSEQUAL|UNION|UNIQUE|UNPIVOT|UPDATETEXT|USE|USER|VALUES|VARYING|VIEW|WAITFOR|WHEN|WHILE|WRITETEXT)\b"' RegexOptions.IgnoreCase | RegexCompiledOption); " is 1121.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitSQLRegex,The length of the statement  "	SQLFunctionsRegex = new Regex (@"(@@CONNECTIONS|@@CPU_BUSY|@@CURSOR_ROWS|@@DATEFIRST|@@DATEFIRST|@@DBTS|@@ERROR|@@FETCH_STATUS|@@IDENTITY|@@IDLE|@@IO_BUSY|@@LANGID|@@LANGUAGE|@@LOCK_TIMEOUT|@@MAX_CONNECTIONS|@@MAX_PRECISION|@@NESTLEVEL|@@OPTIONS|@@PACKET_ERRORS|@@PROCID|@@REMSERVER|@@ROWCOUNT|@@SERVERNAME|@@SERVICENAME|@@SPID|@@TEXTSIZE|@@TRANCOUNT|@@VERSION)\b|\b(ABS|ACOS|APP_NAME|ASCII|ASIN|ASSEMBLYPROPERTY|AsymKey_ID|ASYMKEY_ID|asymkeyproperty|ASYMKEYPROPERTY|ATAN|ATN2|AVG|CASE|CAST|CEILING|Cert_ID|Cert_ID|CertProperty|CHAR|CHARINDEX|CHECKSUM_AGG|COALESCE|COL_LENGTH|COL_NAME|COLLATIONPROPERTY|COLLATIONPROPERTY|COLUMNPROPERTY|COLUMNS_UPDATED|COLUMNS_UPDATED|CONTAINSTABLE|CONVERT|COS|COT|COUNT|COUNT_BIG|CRYPT_GEN_RANDOM|CURRENT_TIMESTAMP|CURRENT_TIMESTAMP|CURRENT_USER|CURRENT_USER|CURSOR_STATUS|DATABASE_PRINCIPAL_ID|DATABASE_PRINCIPAL_ID|DATABASEPROPERTY|DATABASEPROPERTYEX|DATALENGTH|DATALENGTH|DATEADD|DATEDIFF|DATENAME|DATEPART|DAY|DB_ID|DB_NAME|DECRYPTBYASYMKEY|DECRYPTBYCERT|DECRYPTBYKEY|DECRYPTBYKEYAUTOASYMKEY|DECRYPTBYKEYAUTOCERT|DECRYPTBYPASSPHRASE|DEGREES|DENSE_RANK|DIFFERENCE|ENCRYPTBYASYMKEY|ENCRYPTBYCERT|ENCRYPTBYKEY|ENCRYPTBYPASSPHRASE|ERROR_LINE|ERROR_MESSAGE|ERROR_NUMBER|ERROR_PROCEDURE|ERROR_SEVERITY|ERROR_STATE|EVENTDATA|EXP|FILE_ID|FILE_IDEX|FILE_NAME|FILEGROUP_ID|FILEGROUP_NAME|FILEGROUPPROPERTY|FILEPROPERTY|FLOOR|fn_helpcollations|fn_listextendedproperty|fn_servershareddrives|fn_virtualfilestats|fn_virtualfilestats|FORMATMESSAGE|FREETEXTTABLE|FULLTEXTCATALOGPROPERTY|FULLTEXTSERVICEPROPERTY|GETANSINULL|GETDATE|GETUTCDATE|GROUPING|HAS_PERMS_BY_NAME|HOST_ID|HOST_NAME|IDENT_CURRENT|IDENT_CURRENT|IDENT_INCR|IDENT_INCR|IDENT_SEED|IDENTITY\(|INDEX_COL|INDEXKEY_PROPERTY|INDEXPROPERTY|IS_MEMBER|IS_OBJECTSIGNED|IS_SRVROLEMEMBER|ISDATE|ISDATE|ISNULL|ISNUMERIC|Key_GUID|Key_GUID|Key_ID|Key_ID|KEY_NAME|KEY_NAME|LEFT|LEN|LOG|LOG10|LOWER|LTRIM|MAX|MIN|MONTH|NCHAR|NEWID|NTILE|NULLIF|OBJECT_DEFINITION|OBJECT_ID|OBJECT_NAME|OBJECT_SCHEMA_NAME|OBJECTPROPERTY|OBJECTPROPERTYEX|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPENXML|ORIGINAL_LOGIN|ORIGINAL_LOGIN|PARSENAME|PATINDEX|PATINDEX|PERMISSIONS|PI|POWER|PUBLISHINGSERVERNAME|PWDCOMPARE|PWDENCRYPT|QUOTENAME|RADIANS|RAND|RANK|REPLICATE|REVERSE|RIGHT|ROUND|ROW_NUMBER|ROWCOUNT_BIG|RTRIM|SCHEMA_ID|SCHEMA_ID|SCHEMA_NAME|SCHEMA_NAME|SCOPE_IDENTITY|SERVERPROPERTY|SESSION_USER|SESSION_USER|SESSIONPROPERTY|SETUSER|SIGN|SignByAsymKey|SignByCert|SIN|SOUNDEX|SPACE|SQL_VARIANT_PROPERTY|SQRT|SQUARE|STATS_DATE|STDEV|STDEVP|STR|STUFF|SUBSTRING|SUM|SUSER_ID|SUSER_NAME|SUSER_SID|SUSER_SNAME|SWITCHOFFSET|SYMKEYPROPERTY|symkeyproperty|sys\.dm_db_index_physical_stats|sys\.fn_builtin_permissions|sys\.fn_my_permissions|SYSDATETIME|SYSDATETIMEOFFSET|SYSTEM_USER|SYSTEM_USER|SYSUTCDATETIME|TAN|TERTIARY_WEIGHTS|TEXTPTR|TODATETIMEOFFSET|TRIGGER_NESTLEVEL|TYPE_ID|TYPE_NAME|TYPEPROPERTY|UNICODE|UPDATE\(|UPPER|USER_ID|USER_NAME|USER_NAME|VAR|VARP|VerifySignedByAsymKey|VerifySignedByCert|XACT_STATE|YEAR)\b"' RegexOptions.IgnoreCase | RegexCompiledOption); " is 3016.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitSQLRegex,The length of the statement  "	SQLTypesRegex = new Regex (@"\b(BIGINT|NUMERIC|BIT|SMALLINT|DECIMAL|SMALLMONEY|INT|TINYINT|MONEY|FLOAT|REAL|DATE|DATETIMEOFFSET|DATETIME2|SMALLDATETIME|DATETIME|TIME|CHAR|VARCHAR|TEXT|NCHAR|NVARCHAR|NTEXT|BINARY|VARBINARY|IMAGE|TIMESTAMP|HIERARCHYID|TABLE|UNIQUEIDENTIFIER|SQL_VARIANT|XML)\b"' RegexOptions.IgnoreCase | RegexCompiledOption); " is 341.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,SQLSyntaxHighlight,The length of the statement  "	range.ClearStyle (CommentStyle' StringStyle' NumberStyle' VariableStyle' StatementsStyle' KeywordStyle' FunctionsStyle' TypesStyle); " is 132.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitPHPRegex,The length of the statement  "	PHPCommentRegex3 = new Regex (@"(/\*.*?\*/)|(.*\*/)"' RegexOptions.Singleline | RegexOptions.RightToLeft | RegexCompiledOption); " is 128.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitPHPRegex,The length of the statement  "	PHPKeywordRegex1 = new Regex (@"\b(die|echo|empty|exit|eval|include|include_once|isset|list|require|require_once|return|print|unset)\b"' RegexCompiledOption); " is 158.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitPHPRegex,The length of the statement  "	PHPKeywordRegex2 = new Regex (@"\b(abstract|and|array|as|break|case|catch|cfunction|class|clone|const|continue|declare|default|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|final|for|foreach|function|global|goto|if|implements|instanceof|interface|namespace|new|or|private|protected|public|static|switch|throw|try|use|var|while|xor)\b"' RegexCompiledOption); " is 388.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitPHPRegex,The length of the statement  "	PHPKeywordRegex3 = new Regex (@"__CLASS__|__DIR__|__FILE__|__LINE__|__FUNCTION__|__METHOD__|__NAMESPACE__"' RegexCompiledOption); " is 129.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitJScriptRegex,The length of the statement  "	JScriptCommentRegex3 = new Regex (@"(/\*.*?\*/)|(.*\*/)"' RegexOptions.Singleline | RegexOptions.RightToLeft | RegexCompiledOption); " is 132.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitJScriptRegex,The length of the statement  "	JScriptKeywordRegex = new Regex (@"\b(true|false|break|case|catch|const|continue|default|delete|do|else|export|for|function|if|in|instanceof|new|null|return|switch|this|throw|try|var|void|while|with|typeof)\b"' RegexCompiledOption); " is 232.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitLuaRegex,The length of the statement  "	LuaCommentRegex3 = new Regex (@"(--\[\[.*?\]\])|(.*\]\])"' RegexOptions.Singleline | RegexOptions.RightToLeft | RegexCompiledOption); " is 133.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitLuaRegex,The length of the statement  "	LuaKeywordRegex = new Regex (@"\b(and|break|do|else|elseif|end|false|for|function|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b"' RegexCompiledOption); " is 167.
Long Statement,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitLuaRegex,The length of the statement  "	LuaFunctionsRegex = new Regex (@"\b(assert|collectgarbage|dofile|error|getfenv|getmetatable|ipairs|load|loadfile|loadstring|module|next|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|tonumber|tostring|type|unpack|xpcall)\b"' RegexCompiledOption); " is 276.
Long Statement,Andi.Libs.FastColoredTextBox,CollapseFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The length of the statement  "	gr.DrawLine (pen' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2); " is 135.
Long Statement,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The length of the statement  "	gr.DrawLine (Pens.Red' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2); " is 140.
Long Statement,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The length of the statement  "	gr.DrawLine (Pens.Red' rectangle.Left + rectangle.Width / 2' rectangle.Top + 2' rectangle.Left + rectangle.Width / 2' rectangle.Bottom - 2); " is 140.
Long Statement,Andi.Libs.HexBox,BuiltInContextMenu,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\BuiltInContextMenu.cs,CheckBuiltInContextMenu,The length of the statement  "		_cutToolStripMenuItem = new ToolStripMenuItem (CutMenuItemTextInternal' CutMenuItemImage' new EventHandler (CutMenuItem_Click)); " is 128.
Long Statement,Andi.Libs.HexBox,BuiltInContextMenu,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\BuiltInContextMenu.cs,CheckBuiltInContextMenu,The length of the statement  "		_copyToolStripMenuItem = new ToolStripMenuItem (CopyMenuItemTextInternal' CopyMenuItemImage' new EventHandler (CopyMenuItem_Click)); " is 132.
Long Statement,Andi.Libs.HexBox,BuiltInContextMenu,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\BuiltInContextMenu.cs,CheckBuiltInContextMenu,The length of the statement  "		_pasteToolStripMenuItem = new ToolStripMenuItem (PasteMenuItemTextInternal' PasteMenuItemImage' new EventHandler (PasteMenuItem_Click)); " is 136.
Long Statement,Andi.Libs.HexBox,BuiltInContextMenu,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\BuiltInContextMenu.cs,CheckBuiltInContextMenu,The length of the statement  "		_selectAllToolStripMenuItem = new ToolStripMenuItem (SelectAllMenuItemTextInternal' SelectAllMenuItemImage' new EventHandler (SelectAllMenuItem_Click)); " is 152.
Long Statement,Andi.Libs.HexBox,DynamicFileByteProvider,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\DynamicFileByteProvider.cs,WriteByte,The length of the statement  "			suffixBlock = new FileDataBlock (fileBlock.FileOffset + index - blockOffset + 1' fileBlock.Length - (index - blockOffset + 1)); " is 127.
Long Statement,Andi.Libs.HexBox,DynamicFileByteProvider,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\DynamicFileByteProvider.cs,InsertBytes,The length of the statement  "		// If the insertion point is at the start of a file block' and the previous block is a memory block' append it to that block. " is 125.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateScrollSize,The length of the statement  "		long scrollmax = (long)Math.Ceiling ((double)(_byteProvider.Length + 1) / (double)_iHexMaxHBytes - (double)_iHexMaxVBytes); " is 123.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,Find,The length of the statement  "			throw new ArgumentException ("FindBufferUpperCase and FindBufferUpperCase must have the same size when Type is Text and MatchCase is true"); " is 140.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintColumnSeparator,The length of the statement  "			g.DrawLine (pen' new PointF (byteStringPointF.X' byteStringPointF.Y)' new PointF (byteStringPointF.X' byteStringPointF.Y + _recHex.Height)); " is 140.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintHexAndStringView,The length of the statement  "	bool isStringKeyInterpreterActive = _keyInterpreter != null && _keyInterpreter.GetType () == typeof(StringKeyInterpreter); " is 122.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height); " is 167.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height); " is 180.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "						Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1))); " is 174.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height); " is 158.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height); " is 171.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height); " is 177.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "						Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1))); " is 178.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height); " is 148.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The length of the statement  "		_recLineInfo = new Rectangle (_recContent.X + marginLeft' _recContent.Y' (int)(_charSize.Width * 10)' _recContent.Height); " is 122.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The length of the statement  "	_recColumnInfo = new Rectangle (_recLineInfo.X + _recLineInfo.Width' _recContent.Y' _recContent.Width - _recLineInfo.Width' (int)charSize.Height + 4); " is 150.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The length of the statement  "	_recHex = new Rectangle (_recLineInfo.X + _recLineInfo.Width' _recLineInfo.Y' _recContent.Width - _recLineInfo.Width' _recContent.Height - _recColumnInfo.Height); " is 162.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The length of the statement  "		_recStringView = new Rectangle (_recHex.X + _recHex.Width' _recHex.Y' (int)(_charSize.Width * _iHexMaxHBytes)' _recHex.Height); " is 127.
Long Statement,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,ConvertHexToByte,The length of the statement  "	bool isByte = byte.TryParse (hex' System.Globalization.NumberStyles.HexNumber' System.Threading.Thread.CurrentThread.CurrentCulture' out b); " is 140.
Long Statement,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\PathFilter.cs,IsMatch,The length of the statement  "		result = (MinSize <= fileInfo.Length) && (MaxSize >= fileInfo.Length) && (MinDate <= fileInfo.LastWriteTime) && (MaxDate >= fileInfo.LastWriteTime); " is 148.
Long Statement,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESStream.cs,Read,The length of the statement  "					throw new Exception ("AES Authentication Code does not match. This is a super-CRC check on the data in the file after compression and encryption. \r\n" + "The file may be damaged."); " is 182.
Long Statement,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,TransformBlock,The length of the statement  "			/* encrypt the nonce to form next xor buffer    */_encryptor.TransformBlock (_counterNonce' 0' _blockSize' _encryptBuffer' 0); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "		if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) { " is 180.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) { " is 339.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The length of the statement  "		if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 175.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "			if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "				if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The length of the statement  "	int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength () + literalTree.GetEncodedLength () + distTree.GetEncodedLength () + extra_bits; " is 142.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The length of the statement  "	return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]); " is 172.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractZip,The length of the statement  "	ExtractZip (inputStream' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime' true); " is 122.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The length of the statement  "						StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size); " is 148.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,HasDosAttributes,The length of the statement  "		if (((HostSystem == (int)HostSystemID.Msdos) || (HostSystem == (int)HostSystemID.WindowsNT)) && (ExternalFileAttributes & attributes) == attributes) { " is 150.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The length of the statement  "		if (((versionToExtract & 0xff) >= ZipConstants.VersionZip64) && ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The length of the statement  "			DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 124.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntryFactory.cs,MakeFileEntry,The length of the statement  "	ZipEntry result = new ZipEntry (nameTransform_.TransformFile (entryName != null && entryName.Length > 0 ? entryName : fileName)); " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 124.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 120.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) { " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) { " is 127.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) { " is 158.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) { " is 363.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) { " is 135.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "					throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size)); " is 125.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize)); " is 156.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,UpdateCommentOnly,The length of the statement  "		long locatedCentralDirOffset = updateFile.LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff); " is 174.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The length of the statement  "	long locatedEndOfCentralDir = LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseStream_.Length' ZipConstants.EndOfCentralRecordBaseSize' 0xffff); " is 170.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The length of the statement  "	if ((thisDiskNumber == 0xffff) || (startCentralDirDisk == 0xffff) || (entriesForThisDisk == 0xffff) || (entriesForWholeCentralDir == 0xffff) || (centralDirSize == 0xffffffff) || (offsetOfCentralDir == 0xffffffff)) { " is 215.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The length of the statement  "		long offset = LocateBlockWithSignature (ZipConstants.Zip64CentralDirLocatorSignature' locatedEndOfCentralDir' 0' 0x1000); " is 121.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The length of the statement  "	if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The length of the statement  "	if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The length of the statement  "		result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write); " is 132.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The length of the statement  "	if (header == ZipConstants.CentralHeaderSignature || header == ZipConstants.EndOfCentralDirectorySignature || header == ZipConstants.CentralHeaderDigitalSignature || header == ZipConstants.ArchiveExtraDataSignature || header == ZipConstants.Zip64CentralFileHeaderSignature) { " is 275.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The length of the statement  "	if (method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))) { " is 143.
Long Statement,Andi.Libs.IniParser.Model.Formatting,DefaultIniDataFormatter,C:\repos\andibadra_ANDT\Andi.Libs\IniParser\Model\Formatting\DefaultIniDataFormatter.cs,WriteSection,The length of the statement  "	sb.AppendLine (string.Format ("{0}{1}{2}"' Configuration.SectionStartChar' section.SectionName' Configuration.SectionEndChar)); " is 127.
Long Statement,Andi.Libs.IniParser.Model.Formatting,DefaultIniDataFormatter,C:\repos\andibadra_ANDT\Andi.Libs\IniParser\Model\Formatting\DefaultIniDataFormatter.cs,WriteKeyValueData,The length of the statement  "		sb.AppendLine (string.Format ("{0}{3}{1}{3}{2}"' keyData.KeyName' Configuration.KeyValueAssigmentChar' keyData.Value' Configuration.AssigmentSpacer)); " is 150.
Complex Conditional,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,DoAutocomplete,The conditional expression  "forced || (text.Length >= Menu.MinFragmentLength && tb.Selection.IsEmpty /*pops up only if selected range is empty*/&& (tb.Selection.Start > fragment.Start || text.Length == 0/*pops up only if caret is after first letter*/))"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The conditional expression  "BOMBytes [0] == 0xff && BOMBytes [1] == 0xfe && (BOMBytes.Length < 4 || BOMBytes [2] != 0 || BOMBytes [3] != 0)"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The conditional expression  "BOMBytes [0] == 0xff && BOMBytes [1] == 0xfe && BOMBytes [2] == 0 && BOMBytes [3] == 0"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The conditional expression  "BOMBytes [0] == 0 && BOMBytes [1] == 0 && BOMBytes [2] == 0xfe && BOMBytes [3] == 0xff"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,IsCommonUSASCIIByte,The conditional expression  "testByte == 0x0A //lf  || testByte == 0x0D //cr  || testByte == 0x09 //tab  || (testByte >= 0x20 && testByte <= 0x2F) //common punctuation  || (testByte >= 0x30 && testByte <= 0x39) //digits  || (testByte >= 0x3A && testByte <= 0x40) //common punctuation  || (testByte >= 0x41 && testByte <= 0x5A) //capital letters  || (testByte >= 0x5B && testByte <= 0x60) //common punctuation  || (testByte >= 0x61 && testByte <= 0x7A) //lowercase letters  || (testByte >= 0x7B && testByte <= 0x7E)"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ProcessKey,The conditional expression  "c == '\b' && (modifiers == Keys.None || modifiers == Keys.Shift || (modifiers & Keys.Alt) != 0)"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ProcessKey,The conditional expression  "modifiers != Keys.None && modifiers != Keys.Shift && modifiers != (Keys.Control | Keys.Alt) && //ALT+CTRL is special chars (AltGr)  modifiers != (Keys.Shift | Keys.Control | Keys.Alt) && //SHIFT + ALT + CTRL is special chars (AltGr)  (modifiers != (Keys.Alt) || char.IsLetterOrDigit (c))"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The conditional expression  "(Focused || IsDragDrop) && car.X >= LeftIndent && CaretVisible"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnMouseDown,The conditional expression  "Selection.IsEmpty || !Selection.Contains (p) || this [p.iLine].Count <= p.iChar || ReadOnly"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoDragDrop,The conditional expression  "(copyMode == false) && (place.iLine >= dR.Start.iLine) && (place.iLine <= dR.End.iLine) && (place.iChar >= dR.End.iChar)"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The conditional expression  "signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The conditional expression  "signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF"  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseXmlDescription,The conditional expression  "brackets.Attributes ["left"] == null || brackets.Attributes ["right"] == null || brackets.Attributes ["left"].Value == "" || brackets.Attributes ["right"].Value == """  is complex.
Complex Conditional,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseXmlDescription,The conditional expression  "brackets.Attributes ["left2"] == null || brackets.Attributes ["right2"] == null || brackets.Attributes ["left2"].Value == "" || brackets.Attributes ["right2"].Value == """  is complex.
Complex Conditional,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateScrollSize,The conditional expression  "VScrollBarVisible && _byteProvider != null && _byteProvider.Length > 0 && _iHexMaxHBytes != 0"  is complex.
Complex Conditional,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,CreateCaret,The conditional expression  "_byteProvider == null || _keyInterpreter == null || _caretVisible || !this.Focused"  is complex.
Complex Conditional,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentByteSign,The conditional expression  "rec.Top < 0 || rec.Left < 0 || rec.Width <= 0 || rec.Height <= 0"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full  (blockStart < WSIZE && storedLength >= MAX_DIST) || // Block may move out of window  flush"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The conditional expression  "(extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The conditional expression  "(thisDiskNumber == 0xffff) || (startCentralDirDisk == 0xffff) || (entriesForThisDisk == 0xffff) || (entriesForWholeCentralDir == 0xffff) || (centralDirSize == 0xffffffff) || (offsetOfCentralDir == 0xffffffff)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "header == ZipConstants.CentralHeaderSignature || header == ZipConstants.EndOfCentralDirectorySignature || header == ZipConstants.CentralHeaderDigitalSignature || header == ZipConstants.ArchiveExtraDataSignature || header == ZipConstants.Zip64CentralFileHeaderSignature"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The conditional expression  "(flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)"  is complex.
Complex Conditional,Andi.Libs.IniParser.Model.Configuration,BaseIniParserConfiguration,C:\repos\andibadra_ANDT\Andi.Libs\IniParser\Model\Configuration\BaseIniParserConfiguration.cs,RecreateSectionRegex,The conditional expression  "char.IsControl (value) || char.IsWhiteSpace (value) || CommentString.Contains (new string (new[] {  	value  })) || value == KeyValueAssigmentChar"  is complex.
Virtual Method Call from Constructor,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The constructor "FastColoredTextBox" calls a virtual method "CreateTextSource".
Virtual Method Call from Constructor,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The constructor "FastColoredTextBox" calls a virtual method "InsertLine".
Virtual Method Call from Constructor,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The constructor "FastColoredTextBox" calls a virtual method "CreateLine".
Virtual Method Call from Constructor,Andi.Libs.FastColoredTextBox,Hint,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Hint,The constructor "Hint" calls a virtual method "Init".
Virtual Method Call from Constructor,Andi.Libs.FastColoredTextBox,TextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\TextSource.cs,TextSource,The constructor "TextSource" calls a virtual method "InitDefaultStyle".
Empty Catch Block,Andi.Libs.FastColoredTextBox,MultiRangeCommand,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Commands.cs,Execute,The method has an empty catch block.
Empty Catch Block,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,SetClipboard,The method has an empty catch block.
Empty Catch Block,Andi.Libs,MemoryManager,C:\repos\andibadra_ANDT\Andi.Libs\MemoryMan.cs,SetWorkingSet,The method has an empty catch block.
Empty Catch Block,Andi.Libs,MemoryManager,C:\repos\andibadra_ANDT\Andi.Libs\MemoryMan.cs,TimerSet,The method has an empty catch block.
Empty Catch Block,Andi.Libs,MemoryManager,C:\repos\andibadra_ANDT\Andi.Libs\MemoryMan.cs,AttachApp,The method has an empty catch block.
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteMenu,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteMenu,The following statement contains a magic number: host.Margin = new Padding (2' 2' 2' 2);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteMenu,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteMenu,The following statement contains a magic number: host.Margin = new Padding (2' 2' 2' 2);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteMenu,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteMenu,The following statement contains a magic number: host.Margin = new Padding (2' 2' 2' 2);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteMenu,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteMenu,The following statement contains a magic number: host.Margin = new Padding (2' 2' 2' 2);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteMenu,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteMenu,The following statement contains a magic number: MinFragmentLength = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteMenu,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,CalcSize,The following statement contains a magic number: Size = new System.Drawing.Size (listView.Size.Width + 4' listView.Size.Height + 4);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteMenu,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,CalcSize,The following statement contains a magic number: Size = new System.Drawing.Size (listView.Size.Width + 4' listView.Size.Height + 4);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteListView,The following statement contains a magic number: base.Font = new Font (FontFamily.GenericSansSerif' 9);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteListView,The following statement contains a magic number: itemHeight = Font.Height + 2;  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteListView,The following statement contains a magic number: MaximumSize = new Size (Size.Width' 180);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteListView,The following statement contains a magic number: AppearInterval = 500;  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,AutocompleteListView,The following statement contains a magic number: ToolTipDuration = 3000;  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,DoAutocomplete,The following statement contains a magic number: point.Offset (2' tb.CharHeight);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,OnPaint,The following statement contains a magic number: for (int i = startI; i < finishI; i++) {  	y = i * itemHeight - VerticalScroll.Value;  	var item = visibleItems [i];  	if (item.BackColor != Color.Transparent)  		using (var brush = new SolidBrush (item.BackColor))  			e.Graphics.FillRectangle (brush' 1' y' ClientSize.Width - 1 - 1' itemHeight - 1);  	if (ImageList != null && visibleItems [i].ImageIndex >= 0)  		e.Graphics.DrawImage (ImageList.Images [item.ImageIndex]' 1' y);  	if (i == FocussedItemIndex)  		using (var selectedBrush = new LinearGradientBrush (new Point (0' y - 3)' new Point (0' y + itemHeight)' Color.Transparent' SelectedColor))  			using (var pen = new Pen (SelectedColor)) {  				e.Graphics.FillRectangle (selectedBrush' leftPadding' y' ClientSize.Width - 1 - leftPadding' itemHeight - 1);  				e.Graphics.DrawRectangle (pen' leftPadding' y' ClientSize.Width - 1 - leftPadding' itemHeight - 1);  			}  	if (i == hoveredItemIndex)  		using (var pen = new Pen (HoveredColor))  			e.Graphics.DrawRectangle (pen' leftPadding' y' ClientSize.Width - 1 - leftPadding' itemHeight - 1);  	using (var brush = new SolidBrush (item.ForeColor != Color.Transparent ? item.ForeColor : ForeColor))  		e.Graphics.DrawString (item.ToString ()' Font' brush' leftPadding' y);  }  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,OnPaint,The following statement contains a magic number: if (i == FocussedItemIndex)  	using (var selectedBrush = new LinearGradientBrush (new Point (0' y - 3)' new Point (0' y + itemHeight)' Color.Transparent' SelectedColor))  		using (var pen = new Pen (SelectedColor)) {  			e.Graphics.FillRectangle (selectedBrush' leftPadding' y' ClientSize.Width - 1 - leftPadding' itemHeight - 1);  			e.Graphics.DrawRectangle (pen' leftPadding' y' ClientSize.Width - 1 - leftPadding' itemHeight - 1);  		}  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,OnPaint,The following statement contains a magic number: using (var selectedBrush = new LinearGradientBrush (new Point (0' y - 3)' new Point (0' y + itemHeight)' Color.Transparent' SelectedColor))  	using (var pen = new Pen (SelectedColor)) {  		e.Graphics.FillRectangle (selectedBrush' leftPadding' y' ClientSize.Width - 1 - leftPadding' itemHeight - 1);  		e.Graphics.DrawRectangle (pen' leftPadding' y' ClientSize.Width - 1 - leftPadding' itemHeight - 1);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,ProcessKey,The following statement contains a magic number: if (keyModifiers == Keys.None)  	switch (keyData) {  	case Keys.Down:  		SelectNext (+1);  		return true;  	case Keys.PageDown:  		SelectNext (+10);  		return true;  	case Keys.Up:  		SelectNext (-1);  		return true;  	case Keys.PageUp:  		SelectNext (-10);  		return true;  	case Keys.Enter:  		OnSelecting ();  		return true;  	case Keys.Tab:  		if (!AllowTabKey)  			break;  		OnSelecting ();  		return true;  	case Keys.Escape:  		Menu.Close ();  		return true;  	}  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,ProcessKey,The following statement contains a magic number: if (keyModifiers == Keys.None)  	switch (keyData) {  	case Keys.Down:  		SelectNext (+1);  		return true;  	case Keys.PageDown:  		SelectNext (+10);  		return true;  	case Keys.Up:  		SelectNext (-1);  		return true;  	case Keys.PageUp:  		SelectNext (-10);  		return true;  	case Keys.Enter:  		OnSelecting ();  		return true;  	case Keys.Tab:  		if (!AllowTabKey)  			break;  		OnSelecting ();  		return true;  	case Keys.Escape:  		Menu.Close ();  		return true;  	}  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,ProcessKey,The following statement contains a magic number: switch (keyData) {  case Keys.Down:  	SelectNext (+1);  	return true;  case Keys.PageDown:  	SelectNext (+10);  	return true;  case Keys.Up:  	SelectNext (-1);  	return true;  case Keys.PageUp:  	SelectNext (-10);  	return true;  case Keys.Enter:  	OnSelecting ();  	return true;  case Keys.Tab:  	if (!AllowTabKey)  		break;  	OnSelecting ();  	return true;  case Keys.Escape:  	Menu.Close ();  	return true;  }  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,ProcessKey,The following statement contains a magic number: switch (keyData) {  case Keys.Down:  	SelectNext (+1);  	return true;  case Keys.PageDown:  	SelectNext (+10);  	return true;  case Keys.Up:  	SelectNext (-1);  	return true;  case Keys.PageUp:  	SelectNext (-10);  	return true;  case Keys.Enter:  	OnSelecting ();  	return true;  case Keys.Tab:  	if (!AllowTabKey)  		break;  	OnSelecting ();  	return true;  case Keys.Escape:  	Menu.Close ();  	return true;  }  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,ProcessKey,The following statement contains a magic number: SelectNext (+10);  
Magic Number,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,ProcessKey,The following statement contains a magic number: SelectNext (-10);  
Magic Number,Andi.Libs.FastColoredTextBox,Bookmark,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Bookmarks.cs,Paint,The following statement contains a magic number: using (var brush = new LinearGradientBrush (new Rectangle (0' lineRect.Top' size' size)' Color.White' Color' 45))  	gr.FillEllipse (brush' 0' lineRect.Top' size' size);  
Magic Number,Andi.Libs.FastColoredTextBox,DocumentMap,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\DocumentMap.cs,OnPaint,The following statement contains a magic number: using (var brush = new SolidBrush (Color.FromArgb (50' ForeColor)))  	using (var pen = new Pen (brush' 1 / zoom)) {  		var rect = new Rectangle (0' y1' (int)((ClientSize.Width - 1) / zoom)' y2 - y1);  		e.Graphics.FillRectangle (brush' rect);  		e.Graphics.DrawRectangle (pen' rect);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,DocumentMap,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\DocumentMap.cs,OnPaint,The following statement contains a magic number: if (scrollbarVisible) {  	e.Graphics.ResetTransform ();  	e.Graphics.SmoothingMode = SmoothingMode.None;  	using (var brush = new SolidBrush (Color.FromArgb (200' ForeColor))) {  		var rect = new RectangleF (ClientSize.Width - 3' ClientSize.Height * sp1' 2' ClientSize.Height * (sp2 - sp1));  		e.Graphics.FillRectangle (brush' rect);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,DocumentMap,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\DocumentMap.cs,OnPaint,The following statement contains a magic number: if (scrollbarVisible) {  	e.Graphics.ResetTransform ();  	e.Graphics.SmoothingMode = SmoothingMode.None;  	using (var brush = new SolidBrush (Color.FromArgb (200' ForeColor))) {  		var rect = new RectangleF (ClientSize.Width - 3' ClientSize.Height * sp1' 2' ClientSize.Height * (sp2 - sp1));  		e.Graphics.FillRectangle (brush' rect);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,DocumentMap,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\DocumentMap.cs,OnPaint,The following statement contains a magic number: if (scrollbarVisible) {  	e.Graphics.ResetTransform ();  	e.Graphics.SmoothingMode = SmoothingMode.None;  	using (var brush = new SolidBrush (Color.FromArgb (200' ForeColor))) {  		var rect = new RectangleF (ClientSize.Width - 3' ClientSize.Height * sp1' 2' ClientSize.Height * (sp2 - sp1));  		e.Graphics.FillRectangle (brush' rect);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,DocumentMap,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\DocumentMap.cs,OnPaint,The following statement contains a magic number: using (var brush = new SolidBrush (Color.FromArgb (200' ForeColor))) {  	var rect = new RectangleF (ClientSize.Width - 3' ClientSize.Height * sp1' 2' ClientSize.Height * (sp2 - sp1));  	e.Graphics.FillRectangle (brush' rect);  }  
Magic Number,Andi.Libs.FastColoredTextBox,DocumentMap,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\DocumentMap.cs,OnPaint,The following statement contains a magic number: using (var brush = new SolidBrush (Color.FromArgb (200' ForeColor))) {  	var rect = new RectangleF (ClientSize.Width - 3' ClientSize.Height * sp1' 2' ClientSize.Height * (sp2 - sp1));  	e.Graphics.FillRectangle (brush' rect);  }  
Magic Number,Andi.Libs.FastColoredTextBox,DocumentMap,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\DocumentMap.cs,OnPaint,The following statement contains a magic number: using (var brush = new SolidBrush (Color.FromArgb (200' ForeColor))) {  	var rect = new RectangleF (ClientSize.Width - 3' ClientSize.Height * sp1' 2' ClientSize.Height * (sp2 - sp1));  	e.Graphics.FillRectangle (brush' rect);  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes.Length < 2)  	return null;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0xff && BOMBytes [1] == 0xfe && (BOMBytes.Length < 4 || BOMBytes [2] != 0 || BOMBytes [3] != 0))  	return Encoding.Unicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0xff && BOMBytes [1] == 0xfe && (BOMBytes.Length < 4 || BOMBytes [2] != 0 || BOMBytes [3] != 0))  	return Encoding.Unicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0xff && BOMBytes [1] == 0xfe && (BOMBytes.Length < 4 || BOMBytes [2] != 0 || BOMBytes [3] != 0))  	return Encoding.Unicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes.Length < 3)  	return null;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0xef && BOMBytes [1] == 0xbb && BOMBytes [2] == 0xbf)  	return Encoding.UTF8;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0x2b && BOMBytes [1] == 0x2f && BOMBytes [2] == 0x76)  	return Encoding.UTF7;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes.Length < 4)  	return null;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0xff && BOMBytes [1] == 0xfe && BOMBytes [2] == 0 && BOMBytes [3] == 0)  	return Encoding.UTF32;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0xff && BOMBytes [1] == 0xfe && BOMBytes [2] == 0 && BOMBytes [3] == 0)  	return Encoding.UTF32;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0 && BOMBytes [1] == 0 && BOMBytes [2] == 0xfe && BOMBytes [3] == 0xff)  	return Encoding.GetEncoding (12001);  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0 && BOMBytes [1] == 0 && BOMBytes [2] == 0xfe && BOMBytes [3] == 0xff)  	return Encoding.GetEncoding (12001);  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: if (BOMBytes [0] == 0 && BOMBytes [1] == 0 && BOMBytes [2] == 0xfe && BOMBytes [3] == 0xff)  	return Encoding.GetEncoding (12001);  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectBOMBytes,The following statement contains a magic number: return Encoding.GetEncoding (12001);  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: while (currentPos < SampleBytes.Length) {  	//binary null distribution  	if (SampleBytes [currentPos] == 0) {  		if (currentPos % 2 == 0)  			evenBinaryNullsInSample++;  		else  			oddBinaryNullsInSample++;  	}  	//likely US-ASCII characters  	if (IsCommonUSASCIIByte (SampleBytes [currentPos]))  		likelyUSASCIIBytesInSample++;  	//suspicious sequences (look like UTF-8)  	if (skipUTF8Bytes == 0) {  		int lengthFound = DetectSuspiciousUTF8SequenceLength (SampleBytes' currentPos);  		if (lengthFound > 0) {  			suspiciousUTF8SequenceCount++;  			suspiciousUTF8BytesTotal += lengthFound;  			skipUTF8Bytes = lengthFound - 1;  		}  	}  	else {  		skipUTF8Bytes--;  	}  	currentPos++;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (SampleBytes [currentPos] == 0) {  	if (currentPos % 2 == 0)  		evenBinaryNullsInSample++;  	else  		oddBinaryNullsInSample++;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (currentPos % 2 == 0)  	evenBinaryNullsInSample++;  else  	oddBinaryNullsInSample++;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6)  	return Encoding.Unicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6)  	return Encoding.Unicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6)  	return Encoding.Unicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6)  	return Encoding.Unicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6)  	return Encoding.BigEndianUnicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6)  	return Encoding.BigEndianUnicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6)  	return Encoding.BigEndianUnicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (((oddBinaryNullsInSample * 2.0) / SampleBytes.Length) < 0.2 && ((evenBinaryNullsInSample * 2.0) / SampleBytes.Length) > 0.6)  	return Encoding.BigEndianUnicode;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (UTF8Validator.IsMatch (potentiallyMangledString)) {  	//Unfortunately' just the fact that it CAN be UTF-8 doesn't tell you much about probabilities.  	//If all the characters are in the 0-127 range' no harm done' most western charsets are same as UTF-8 in these ranges.  	//If some of the characters were in the upper range (western accented characters)' however' they would likely be mangled to 2-byte by the UTF-8 encoding process.  	// So' we need to play stats.  	// The "Random" likelihood of any pair of randomly generated characters being one   	//   of these "suspicious" character sequences is:  	//     128 / (256 * 256) = 0.2%.  	//  	// In western text data' that is SIGNIFICANTLY reduced - most text data stays in the <127   	//   character range' so we assume that more than 1 in 500'000 of these character   	//   sequences indicates UTF-8. The number 500'000 is completely arbitrary - so sue me.  	//  	// We can only assume these character sequences will be rare if we ALSO assume that this  	//   IS in fact western text - in which case the bulk of the UTF-8 encoded data (that is   	//   not already suspicious sequences) should be plain US-ASCII bytes. This' I   	//   arbitrarily decided' should be 80% (a random distribution' eg binary data' would yield   	//   approx 40%' so the chances of hitting this threshold by accident in random data are   	//   VERY low).   	if ((suspiciousUTF8SequenceCount * 500000.0 / SampleBytes.Length >= 1) //suspicious sequences  	&& (//all suspicious' so cannot evaluate proportion of US-Ascii  	SampleBytes.Length - suspiciousUTF8BytesTotal == 0 || likelyUSASCIIBytesInSample * 1.0 / (SampleBytes.Length - suspiciousUTF8BytesTotal) >= 0.8))  		return Encoding.UTF8;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if (UTF8Validator.IsMatch (potentiallyMangledString)) {  	//Unfortunately' just the fact that it CAN be UTF-8 doesn't tell you much about probabilities.  	//If all the characters are in the 0-127 range' no harm done' most western charsets are same as UTF-8 in these ranges.  	//If some of the characters were in the upper range (western accented characters)' however' they would likely be mangled to 2-byte by the UTF-8 encoding process.  	// So' we need to play stats.  	// The "Random" likelihood of any pair of randomly generated characters being one   	//   of these "suspicious" character sequences is:  	//     128 / (256 * 256) = 0.2%.  	//  	// In western text data' that is SIGNIFICANTLY reduced - most text data stays in the <127   	//   character range' so we assume that more than 1 in 500'000 of these character   	//   sequences indicates UTF-8. The number 500'000 is completely arbitrary - so sue me.  	//  	// We can only assume these character sequences will be rare if we ALSO assume that this  	//   IS in fact western text - in which case the bulk of the UTF-8 encoded data (that is   	//   not already suspicious sequences) should be plain US-ASCII bytes. This' I   	//   arbitrarily decided' should be 80% (a random distribution' eg binary data' would yield   	//   approx 40%' so the chances of hitting this threshold by accident in random data are   	//   VERY low).   	if ((suspiciousUTF8SequenceCount * 500000.0 / SampleBytes.Length >= 1) //suspicious sequences  	&& (//all suspicious' so cannot evaluate proportion of US-Ascii  	SampleBytes.Length - suspiciousUTF8BytesTotal == 0 || likelyUSASCIIBytesInSample * 1.0 / (SampleBytes.Length - suspiciousUTF8BytesTotal) >= 0.8))  		return Encoding.UTF8;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if ((suspiciousUTF8SequenceCount * 500000.0 / SampleBytes.Length >= 1) //suspicious sequences  && (//all suspicious' so cannot evaluate proportion of US-Ascii  SampleBytes.Length - suspiciousUTF8BytesTotal == 0 || likelyUSASCIIBytesInSample * 1.0 / (SampleBytes.Length - suspiciousUTF8BytesTotal) >= 0.8))  	return Encoding.UTF8;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectUnicodeInByteSampleByHeuristics,The following statement contains a magic number: if ((suspiciousUTF8SequenceCount * 500000.0 / SampleBytes.Length >= 1) //suspicious sequences  && (//all suspicious' so cannot evaluate proportion of US-Ascii  SampleBytes.Length - suspiciousUTF8BytesTotal == 0 || likelyUSASCIIBytesInSample * 1.0 / (SampleBytes.Length - suspiciousUTF8BytesTotal) >= 0.8))  	return Encoding.UTF8;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC2) {  	if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x81 || SampleBytes [currentPos + 1] == 0x8D || SampleBytes [currentPos + 1] == 0x8F)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x90 || SampleBytes [currentPos + 1] == 0x9D)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] >= 0xA0 && SampleBytes [currentPos + 1] <= 0xBF)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC3) {  	if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] >= 0x80 && SampleBytes [currentPos + 1] <= 0xBF)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC5) {  	if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  		lengthFound = 2;  	else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x92 || SampleBytes [currentPos + 1] == 0x93)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0xA0 || SampleBytes [currentPos + 1] == 0xA1)  	lengthFound = 2;  else if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0xB8 || SampleBytes [currentPos + 1] == 0xBD || SampleBytes [currentPos + 1] == 0xBE)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xC6) {  	if (SampleBytes [currentPos + 1] == 0x92)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x92)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 1 && SampleBytes [currentPos] == 0xCB) {  	if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  		lengthFound = 2;  }  else if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x86 || SampleBytes [currentPos + 1] == 0x9C)  	lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes.Length >= currentPos + 2 && SampleBytes [currentPos] == 0xE2) {  	if (SampleBytes [currentPos + 1] == 0x80) {  		if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xA6)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB0)  			lengthFound = 3;  		if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  			lengthFound = 3;  	}  	else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  		lengthFound = 3;  	else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  }  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x80) {  	if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xA6)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB0)  		lengthFound = 3;  	if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  		lengthFound = 3;  }  else if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x93 || SampleBytes [currentPos + 2] == 0x94)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x98 || SampleBytes [currentPos + 2] == 0x99 || SampleBytes [currentPos + 2] == 0x9A)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0x9C || SampleBytes [currentPos + 2] == 0x9D || SampleBytes [currentPos + 2] == 0x9E)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xA0 || SampleBytes [currentPos + 2] == 0xA1 || SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xA6)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xA6)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xB0)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xB0)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 2] == 0xB9 || SampleBytes [currentPos + 2] == 0xBA)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x82 && SampleBytes [currentPos + 2] == 0xAC)  	lengthFound = 3;  else if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: if (SampleBytes [currentPos + 1] == 0x84 && SampleBytes [currentPos + 2] == 0xA2)  	lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,EncodingDetector,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\EncodingDetector.cs,DetectSuspiciousUTF8SequenceLength,The following statement contains a magic number: lengthFound = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToHTML,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToHTML.cs,GetHtml,The following statement contains a magic number: foreach (Place p in r) {  	Char c = r.tb [p.iLine] [p.iChar];  	if (c.style != currentStyleId) {  		Flush (sb' tempSB' currentStyleId);  		currentStyleId = c.style;  		styles [currentStyleId] = null;  	}  	if (p.iLine != currentLine) {  		for (int i = currentLine; i < p.iLine; i++) {  			tempSB.Append (UseBr ? "<br>" : "");  			if (IncludeLineNumbers)  				tempSB.AppendFormat ("<span class=lineNumber>{0}</span>  "' i + 2);  		}  		currentLine = p.iLine;  		hasNonSpace = false;  	}  	switch (c.c) {  	case ' ':  		if ((hasNonSpace || !UseForwardNbsp) && !UseNbsp)  			goto default;  		tempSB.Append ("&nbsp;");  		break;  	case '<':  		tempSB.Append ("&lt;");  		break;  	case '>':  		tempSB.Append ("&gt;");  		break;  	case '&':  		tempSB.Append ("&amp;");  		break;  	default:  		hasNonSpace = true;  		tempSB.Append (c.c);  		break;  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToHTML,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToHTML.cs,GetHtml,The following statement contains a magic number: if (p.iLine != currentLine) {  	for (int i = currentLine; i < p.iLine; i++) {  		tempSB.Append (UseBr ? "<br>" : "");  		if (IncludeLineNumbers)  			tempSB.AppendFormat ("<span class=lineNumber>{0}</span>  "' i + 2);  	}  	currentLine = p.iLine;  	hasNonSpace = false;  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToHTML,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToHTML.cs,GetHtml,The following statement contains a magic number: for (int i = currentLine; i < p.iLine; i++) {  	tempSB.Append (UseBr ? "<br>" : "");  	if (IncludeLineNumbers)  		tempSB.AppendFormat ("<span class=lineNumber>{0}</span>  "' i + 2);  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToHTML,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToHTML.cs,GetHtml,The following statement contains a magic number: if (IncludeLineNumbers)  	tempSB.AppendFormat ("<span class=lineNumber>{0}</span>  "' i + 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToHTML,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToHTML.cs,GetHtml,The following statement contains a magic number: tempSB.AppendFormat ("<span class=lineNumber>{0}</span>  "' i + 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: foreach (Place p in r) {  	Char c = r.tb [p.iLine] [p.iChar];  	if (c.style != currentStyleId) {  		Flush (sb' tempSB' currentStyleId);  		currentStyleId = c.style;  		styles [currentStyleId] = null;  	}  	if (p.iLine != currentLine) {  		for (int i = currentLine; i < p.iLine; i++) {  			tempSB.AppendLine (@"\line");  			if (IncludeLineNumbers)  				tempSB.AppendFormat (@"{{\cf{1} {0}}}\tab"' i + 2' lineNumberColor);  		}  		currentLine = p.iLine;  	}  	switch (c.c) {  	case '\\':  		tempSB.Append (@"\\");  		break;  	case '{':  		tempSB.Append (@"\{");  		break;  	case '}':  		tempSB.Append (@"\}");  		break;  	default:  		var ch = c.c;  		var code = (int)ch;  		if (code < 128)  			tempSB.Append (c.c);  		else  			tempSB.AppendFormat (@"{{\u{0}}}"' code);  		break;  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: foreach (Place p in r) {  	Char c = r.tb [p.iLine] [p.iChar];  	if (c.style != currentStyleId) {  		Flush (sb' tempSB' currentStyleId);  		currentStyleId = c.style;  		styles [currentStyleId] = null;  	}  	if (p.iLine != currentLine) {  		for (int i = currentLine; i < p.iLine; i++) {  			tempSB.AppendLine (@"\line");  			if (IncludeLineNumbers)  				tempSB.AppendFormat (@"{{\cf{1} {0}}}\tab"' i + 2' lineNumberColor);  		}  		currentLine = p.iLine;  	}  	switch (c.c) {  	case '\\':  		tempSB.Append (@"\\");  		break;  	case '{':  		tempSB.Append (@"\{");  		break;  	case '}':  		tempSB.Append (@"\}");  		break;  	default:  		var ch = c.c;  		var code = (int)ch;  		if (code < 128)  			tempSB.Append (c.c);  		else  			tempSB.AppendFormat (@"{{\u{0}}}"' code);  		break;  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: if (p.iLine != currentLine) {  	for (int i = currentLine; i < p.iLine; i++) {  		tempSB.AppendLine (@"\line");  		if (IncludeLineNumbers)  			tempSB.AppendFormat (@"{{\cf{1} {0}}}\tab"' i + 2' lineNumberColor);  	}  	currentLine = p.iLine;  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: for (int i = currentLine; i < p.iLine; i++) {  	tempSB.AppendLine (@"\line");  	if (IncludeLineNumbers)  		tempSB.AppendFormat (@"{{\cf{1} {0}}}\tab"' i + 2' lineNumberColor);  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: if (IncludeLineNumbers)  	tempSB.AppendFormat (@"{{\cf{1} {0}}}\tab"' i + 2' lineNumberColor);  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: tempSB.AppendFormat (@"{{\cf{1} {0}}}\tab"' i + 2' lineNumberColor);  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: switch (c.c) {  case '\\':  	tempSB.Append (@"\\");  	break;  case '{':  	tempSB.Append (@"\{");  	break;  case '}':  	tempSB.Append (@"\}");  	break;  default:  	var ch = c.c;  	var code = (int)ch;  	if (code < 128)  		tempSB.Append (c.c);  	else  		tempSB.AppendFormat (@"{{\u{0}}}"' code);  	break;  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: if (code < 128)  	tempSB.Append (c.c);  else  	tempSB.AppendFormat (@"{{\u{0}}}"' code);  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: if (UseOriginalFont) {  	sb.Insert (0' string.Format (@"{{\fonttbl{{\f0\fmodern {0};}}}}{{\fs{1} "' tb.Font.Name' (int)(2 * tb.Font.SizeInPoints)' tb.CharHeight));  	sb.AppendLine (@"}");  }  
Magic Number,Andi.Libs.FastColoredTextBox,ExportToRTF,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\ExportToRTF.cs,GetRtf,The following statement contains a magic number: sb.Insert (0' string.Format (@"{{\fonttbl{{\f0\fmodern {0};}}}}{{\fs{1} "' tb.Font.Name' (int)(2 * tb.Font.SizeInPoints)' tb.CharHeight));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: TabLength = 4;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: BracketsStyle = new MarkerStyle (new SolidBrush (Color.FromArgb (80' Color.Lime)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: BracketsStyle2 = new MarkerStyle (new SolidBrush (Color.FromArgb (60' Color.Red)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: DelayedEventsInterval = 100;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: DelayedTextChangedInterval = 100;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: DisabledColor = Color.FromArgb (100' 180' 180' 180);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: DisabledColor = Color.FromArgb (100' 180' 180' 180);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: DisabledColor = Color.FromArgb (100' 180' 180' 180);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: DisabledColor = Color.FromArgb (100' 180' 180' 180);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FastColoredTextBox,The following statement contains a magic number: timer3.Interval = 500;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnToolTip,The following statement contains a magic number: if (Math.Abs (p.X - lastMouseCoord.X) > CharWidth * 2 || Math.Abs (p.Y - lastMouseCoord.Y) > CharHeight * 2)  	return;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnToolTip,The following statement contains a magic number: if (Math.Abs (p.X - lastMouseCoord.X) > CharWidth * 2 || Math.Abs (p.Y - lastMouseCoord.Y) > CharHeight * 2)  	return;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnCharSizeChanged,The following statement contains a magic number: VerticalScroll.LargeChange = 10 * charHeight;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,GetStylesOfChar,The following statement contains a magic number: if (place.iLine < LinesCount && place.iChar < this [place.iLine].Count) {  	#if Styles32  	                var s = (uint) this[place].style;                 for (int i = 0; i < 32; i++)                     if ((s & ((uint) 1) << i) != 0)                         result.Add(Styles[i]); #else  	var s = (ushort)this [place].style;  	for (int i = 0; i < 16; i++)  		if ((s & ((ushort)1) << i) != 0)  			result.Add (Styles [i]);  	#endif  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,GetStylesOfChar,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	if ((s & ((ushort)1) << i) != 0)  		result.Add (Styles [i]);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,SetClipboard,The following statement contains a magic number: try {  	/*                     while (GetOpenClipboardWindow() != IntPtr.Zero)                         Thread.Sleep(0);*/CloseClipboard ();  	Clipboard.SetDataObject (data' true' 5' 100);  }  catch (ExternalException) {  	//occurs if some other process holds open clipboard  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,SetClipboard,The following statement contains a magic number: try {  	/*                     while (GetOpenClipboardWindow() != IntPtr.Zero)                         Thread.Sleep(0);*/CloseClipboard ();  	Clipboard.SetDataObject (data' true' 5' 100);  }  catch (ExternalException) {  	//occurs if some other process holds open clipboard  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,SetClipboard,The following statement contains a magic number: Clipboard.SetDataObject (data' true' 5' 100);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,SetClipboard,The following statement contains a magic number: Clipboard.SetDataObject (data' true' 5' 100);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcMinAutosizeWidth,The following statement contains a magic number: minWidth = LeftIndent + (maxLineLength) * CharWidth + 2 + Paddings.Left + Paddings.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcMinAutosizeWidth,The following statement contains a magic number: if (wordWrap)  	switch (WordWrapMode) {  	case WordWrapMode.WordWrapControlWidth:  	case WordWrapMode.CharWrapControlWidth:  		maxLineLength = Math.Min (maxLineLength' (ClientSize.Width - LeftIndent - Paddings.Left - Paddings.Right) / CharWidth);  		minWidth = 0;  		break;  	case WordWrapMode.WordWrapPreferredWidth:  	case WordWrapMode.CharWrapPreferredWidth:  		maxLineLength = Math.Min (maxLineLength' PreferredLineWidth);  		minWidth = LeftIndent + PreferredLineWidth * CharWidth + 2 + Paddings.Left + Paddings.Right;  		break;  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcMinAutosizeWidth,The following statement contains a magic number: switch (WordWrapMode) {  case WordWrapMode.WordWrapControlWidth:  case WordWrapMode.CharWrapControlWidth:  	maxLineLength = Math.Min (maxLineLength' (ClientSize.Width - LeftIndent - Paddings.Left - Paddings.Right) / CharWidth);  	minWidth = 0;  	break;  case WordWrapMode.WordWrapPreferredWidth:  case WordWrapMode.CharWrapPreferredWidth:  	maxLineLength = Math.Min (maxLineLength' PreferredLineWidth);  	minWidth = LeftIndent + PreferredLineWidth * CharWidth + 2 + Paddings.Left + Paddings.Right;  	break;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcMinAutosizeWidth,The following statement contains a magic number: minWidth = LeftIndent + PreferredLineWidth * CharWidth + 2 + Paddings.Left + Paddings.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,GetMaxLineWordWrapedWidth,The following statement contains a magic number: if (wordWrap)  	switch (wordWrapMode) {  	case WordWrapMode.WordWrapControlWidth:  	case WordWrapMode.CharWrapControlWidth:  		return ClientSize.Width;  	case WordWrapMode.WordWrapPreferredWidth:  	case WordWrapMode.CharWrapPreferredWidth:  		return LeftIndent + PreferredLineWidth * CharWidth + 2 + Paddings.Left + Paddings.Right;  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,GetMaxLineWordWrapedWidth,The following statement contains a magic number: switch (wordWrapMode) {  case WordWrapMode.WordWrapControlWidth:  case WordWrapMode.CharWrapControlWidth:  	return ClientSize.Width;  case WordWrapMode.WordWrapPreferredWidth:  case WordWrapMode.CharWrapPreferredWidth:  	return LeftIndent + PreferredLineWidth * CharWidth + 2 + Paddings.Left + Paddings.Right;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,GetMaxLineWordWrapedWidth,The following statement contains a magic number: return LeftIndent + PreferredLineWidth * CharWidth + 2 + Paddings.Left + Paddings.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoCaretVisible,The following statement contains a magic number: DoVisibleRectangle (new Rectangle (car' new Size (2 * CharWidth' 2 * CharHeight)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoCaretVisible,The following statement contains a magic number: DoVisibleRectangle (new Rectangle (car' new Size (2 * CharWidth' 2 * CharHeight)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoSelectionVisible,The following statement contains a magic number: DoVisibleRectangle (new Rectangle (PlaceToPoint (new Place (0' Selection.End.iLine))' new Size (2 * CharWidth' 2 * CharHeight)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoSelectionVisible,The following statement contains a magic number: DoVisibleRectangle (new Rectangle (PlaceToPoint (new Place (0' Selection.End.iLine))' new Size (2 * CharWidth' 2 * CharHeight)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoSelectionVisible,The following statement contains a magic number: car.Offset (-CharWidth' -ClientSize.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoRangeVisible,The following statement contains a magic number: if (tryToCentre) {  	p.Offset (0' -ClientSize.Height / 2);  	h = ClientSize.Height;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoRangeVisible,The following statement contains a magic number: p.Offset (0' -ClientSize.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoRangeVisible,The following statement contains a magic number: DoVisibleRectangle (new Rectangle (p' new Size (2 * CharWidth' h)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAction,The following statement contains a magic number: switch (action) {  case FCTBAction.ZoomIn:  	ChangeFontSize (2);  	break;  case FCTBAction.ZoomOut:  	ChangeFontSize (-2);  	break;  case FCTBAction.ZoomNormal:  	RestoreFontSize ();  	break;  case FCTBAction.ScrollDown:  	DoScrollVertical (1' -1);  	break;  case FCTBAction.ScrollUp:  	DoScrollVertical (1' 1);  	break;  case FCTBAction.GoToDialog:  	ShowGoToDialog ();  	break;  case FCTBAction.FindDialog:  	ShowFindDialog ();  	break;  case FCTBAction.FindChar:  	findCharMode = true;  	break;  case FCTBAction.FindNext:  	if (findForm == null || findForm.tbFind.Text == "")  		ShowFindDialog ();  	else  		findForm.FindNext (findForm.tbFind.Text);  	break;  case FCTBAction.ReplaceDialog:  	ShowReplaceDialog ();  	break;  case FCTBAction.Copy:  	Copy ();  	break;  case FCTBAction.CommentSelected:  	CommentSelected ();  	break;  case FCTBAction.Cut:  	if (!Selection.ReadOnly)  		Cut ();  	break;  case FCTBAction.Paste:  	if (!Selection.ReadOnly)  		Paste ();  	break;  case FCTBAction.SelectAll:  	Selection.SelectAll ();  	break;  case FCTBAction.Undo:  	if (!ReadOnly)  		Undo ();  	break;  case FCTBAction.Redo:  	if (!ReadOnly)  		Redo ();  	break;  case FCTBAction.LowerCase:  	if (!Selection.ReadOnly)  		LowerCase ();  	break;  case FCTBAction.UpperCase:  	if (!Selection.ReadOnly)  		UpperCase ();  	break;  case FCTBAction.IndentDecrease:  	if (!Selection.ReadOnly)  		DecreaseIndent ();  	break;  case FCTBAction.IndentIncrease:  	if (!Selection.ReadOnly) {  		if (Selection.Start == Selection.End && this [Selection.Start.iLine].StartSpacesCount < Selection.Start.iChar) {  			ProcessKey ('\t'' Keys.None);  		}  		else  			IncreaseIndent ();  	}  	break;  case FCTBAction.AutoIndentChars:  	if (!Selection.ReadOnly)  		DoAutoIndentChars (Selection.Start.iLine);  	break;  case FCTBAction.NavigateBackward:  	NavigateBackward ();  	break;  case FCTBAction.NavigateForward:  	NavigateForward ();  	break;  case FCTBAction.UnbookmarkLine:  	UnbookmarkLine (Selection.Start.iLine);  	break;  case FCTBAction.BookmarkLine:  	BookmarkLine (Selection.Start.iLine);  	break;  case FCTBAction.GoNextBookmark:  	GotoNextBookmark (Selection.Start.iLine);  	break;  case FCTBAction.GoPrevBookmark:  	GotoPrevBookmark (Selection.Start.iLine);  	break;  case FCTBAction.ClearWordLeft:  	if (OnKeyPressing ('\b'))  		//KeyPress event processed key  		break;  	if (!Selection.ReadOnly) {  		if (!Selection.IsEmpty)  			ClearSelected ();  		Selection.GoWordLeft (true);  		if (!Selection.ReadOnly)  			ClearSelected ();  	}  	OnKeyPressed ('\b');  	break;  case FCTBAction.ReplaceMode:  	if (!ReadOnly)  		isReplaceMode = !isReplaceMode;  	break;  case FCTBAction.DeleteCharRight:  	if (!Selection.ReadOnly) {  		if (OnKeyPressing ((char)0xff))  			//KeyPress event processed key  			break;  		if (!Selection.IsEmpty)  			ClearSelected ();  		else {  			//if line contains only spaces then delete line  			if (this [Selection.Start.iLine].StartSpacesCount == this [Selection.Start.iLine].Count)  				RemoveSpacesAfterCaret ();  			if (!Selection.IsReadOnlyRightChar ())  				if (Selection.GoRightThroughFolded ()) {  					int iLine = Selection.Start.iLine;  					InsertChar ('\b');  					//if removed \n then trim spaces  					if (iLine != Selection.Start.iLine && AutoIndent)  						if (Selection.Start.iChar > 0)  							RemoveSpacesAfterCaret ();  				}  		}  		if (AutoIndentChars)  			DoAutoIndentChars (Selection.Start.iLine);  		OnKeyPressed ((char)0xff);  	}  	break;  case FCTBAction.ClearWordRight:  	if (OnKeyPressing ((char)0xff))  		//KeyPress event processed key  		break;  	if (!Selection.ReadOnly) {  		if (!Selection.IsEmpty)  			ClearSelected ();  		Selection.GoWordRight (true);  		if (!Selection.ReadOnly)  			ClearSelected ();  	}  	OnKeyPressed ((char)0xff);  	break;  case FCTBAction.GoWordLeft:  	Selection.GoWordLeft (false);  	break;  case FCTBAction.GoWordLeftWithSelection:  	Selection.GoWordLeft (true);  	break;  case FCTBAction.GoLeft:  	Selection.GoLeft (false);  	break;  case FCTBAction.GoLeftWithSelection:  	Selection.GoLeft (true);  	break;  case FCTBAction.GoLeft_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoLeft_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.GoWordRight:  	Selection.GoWordRight (false);  	break;  case FCTBAction.GoWordRightWithSelection:  	Selection.GoWordRight (true);  	break;  case FCTBAction.GoRight:  	Selection.GoRight (false);  	break;  case FCTBAction.GoRightWithSelection:  	Selection.GoRight (true);  	break;  case FCTBAction.GoRight_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoRight_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.GoUp:  	Selection.GoUp (false);  	ScrollLeft ();  	break;  case FCTBAction.GoUpWithSelection:  	Selection.GoUp (true);  	ScrollLeft ();  	break;  case FCTBAction.GoUp_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoUp_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.MoveSelectedLinesUp:  	if (!Selection.ColumnSelectionMode)  		MoveSelectedLinesUp ();  	break;  case FCTBAction.GoDown:  	Selection.GoDown (false);  	ScrollLeft ();  	break;  case FCTBAction.GoDownWithSelection:  	Selection.GoDown (true);  	ScrollLeft ();  	break;  case FCTBAction.GoDown_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoDown_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.MoveSelectedLinesDown:  	if (!Selection.ColumnSelectionMode)  		MoveSelectedLinesDown ();  	break;  case FCTBAction.GoPageUp:  	Selection.GoPageUp (false);  	ScrollLeft ();  	break;  case FCTBAction.GoPageUpWithSelection:  	Selection.GoPageUp (true);  	ScrollLeft ();  	break;  case FCTBAction.GoPageDown:  	Selection.GoPageDown (false);  	ScrollLeft ();  	break;  case FCTBAction.GoPageDownWithSelection:  	Selection.GoPageDown (true);  	ScrollLeft ();  	break;  case FCTBAction.GoFirstLine:  	Selection.GoFirst (false);  	break;  case FCTBAction.GoFirstLineWithSelection:  	Selection.GoFirst (true);  	break;  case FCTBAction.GoHome:  	GoHome (false);  	ScrollLeft ();  	break;  case FCTBAction.GoHomeWithSelection:  	GoHome (true);  	ScrollLeft ();  	break;  case FCTBAction.GoLastLine:  	Selection.GoLast (false);  	break;  case FCTBAction.GoLastLineWithSelection:  	Selection.GoLast (true);  	break;  case FCTBAction.GoEnd:  	Selection.GoEnd (false);  	break;  case FCTBAction.GoEndWithSelection:  	Selection.GoEnd (true);  	break;  case FCTBAction.ClearHints:  	ClearHints ();  	if (MacrosManager != null)  		MacrosManager.IsRecording = false;  	break;  case FCTBAction.MacroRecord:  	if (MacrosManager != null) {  		if (MacrosManager.AllowMacroRecordingByUser)  			MacrosManager.IsRecording = !MacrosManager.IsRecording;  		if (MacrosManager.IsRecording)  			MacrosManager.ClearMacros ();  	}  	break;  case FCTBAction.MacroExecute:  	if (MacrosManager != null) {  		MacrosManager.IsRecording = false;  		MacrosManager.ExecuteMacros ();  	}  	break;  case FCTBAction.CustomAction1:  case FCTBAction.CustomAction2:  case FCTBAction.CustomAction3:  case FCTBAction.CustomAction4:  case FCTBAction.CustomAction5:  case FCTBAction.CustomAction6:  case FCTBAction.CustomAction7:  case FCTBAction.CustomAction8:  case FCTBAction.CustomAction9:  case FCTBAction.CustomAction10:  case FCTBAction.CustomAction11:  case FCTBAction.CustomAction12:  case FCTBAction.CustomAction13:  case FCTBAction.CustomAction14:  case FCTBAction.CustomAction15:  case FCTBAction.CustomAction16:  case FCTBAction.CustomAction17:  case FCTBAction.CustomAction18:  case FCTBAction.CustomAction19:  case FCTBAction.CustomAction20:  	OnCustomAction (new CustomActionEventArgs (action));  	break;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAction,The following statement contains a magic number: switch (action) {  case FCTBAction.ZoomIn:  	ChangeFontSize (2);  	break;  case FCTBAction.ZoomOut:  	ChangeFontSize (-2);  	break;  case FCTBAction.ZoomNormal:  	RestoreFontSize ();  	break;  case FCTBAction.ScrollDown:  	DoScrollVertical (1' -1);  	break;  case FCTBAction.ScrollUp:  	DoScrollVertical (1' 1);  	break;  case FCTBAction.GoToDialog:  	ShowGoToDialog ();  	break;  case FCTBAction.FindDialog:  	ShowFindDialog ();  	break;  case FCTBAction.FindChar:  	findCharMode = true;  	break;  case FCTBAction.FindNext:  	if (findForm == null || findForm.tbFind.Text == "")  		ShowFindDialog ();  	else  		findForm.FindNext (findForm.tbFind.Text);  	break;  case FCTBAction.ReplaceDialog:  	ShowReplaceDialog ();  	break;  case FCTBAction.Copy:  	Copy ();  	break;  case FCTBAction.CommentSelected:  	CommentSelected ();  	break;  case FCTBAction.Cut:  	if (!Selection.ReadOnly)  		Cut ();  	break;  case FCTBAction.Paste:  	if (!Selection.ReadOnly)  		Paste ();  	break;  case FCTBAction.SelectAll:  	Selection.SelectAll ();  	break;  case FCTBAction.Undo:  	if (!ReadOnly)  		Undo ();  	break;  case FCTBAction.Redo:  	if (!ReadOnly)  		Redo ();  	break;  case FCTBAction.LowerCase:  	if (!Selection.ReadOnly)  		LowerCase ();  	break;  case FCTBAction.UpperCase:  	if (!Selection.ReadOnly)  		UpperCase ();  	break;  case FCTBAction.IndentDecrease:  	if (!Selection.ReadOnly)  		DecreaseIndent ();  	break;  case FCTBAction.IndentIncrease:  	if (!Selection.ReadOnly) {  		if (Selection.Start == Selection.End && this [Selection.Start.iLine].StartSpacesCount < Selection.Start.iChar) {  			ProcessKey ('\t'' Keys.None);  		}  		else  			IncreaseIndent ();  	}  	break;  case FCTBAction.AutoIndentChars:  	if (!Selection.ReadOnly)  		DoAutoIndentChars (Selection.Start.iLine);  	break;  case FCTBAction.NavigateBackward:  	NavigateBackward ();  	break;  case FCTBAction.NavigateForward:  	NavigateForward ();  	break;  case FCTBAction.UnbookmarkLine:  	UnbookmarkLine (Selection.Start.iLine);  	break;  case FCTBAction.BookmarkLine:  	BookmarkLine (Selection.Start.iLine);  	break;  case FCTBAction.GoNextBookmark:  	GotoNextBookmark (Selection.Start.iLine);  	break;  case FCTBAction.GoPrevBookmark:  	GotoPrevBookmark (Selection.Start.iLine);  	break;  case FCTBAction.ClearWordLeft:  	if (OnKeyPressing ('\b'))  		//KeyPress event processed key  		break;  	if (!Selection.ReadOnly) {  		if (!Selection.IsEmpty)  			ClearSelected ();  		Selection.GoWordLeft (true);  		if (!Selection.ReadOnly)  			ClearSelected ();  	}  	OnKeyPressed ('\b');  	break;  case FCTBAction.ReplaceMode:  	if (!ReadOnly)  		isReplaceMode = !isReplaceMode;  	break;  case FCTBAction.DeleteCharRight:  	if (!Selection.ReadOnly) {  		if (OnKeyPressing ((char)0xff))  			//KeyPress event processed key  			break;  		if (!Selection.IsEmpty)  			ClearSelected ();  		else {  			//if line contains only spaces then delete line  			if (this [Selection.Start.iLine].StartSpacesCount == this [Selection.Start.iLine].Count)  				RemoveSpacesAfterCaret ();  			if (!Selection.IsReadOnlyRightChar ())  				if (Selection.GoRightThroughFolded ()) {  					int iLine = Selection.Start.iLine;  					InsertChar ('\b');  					//if removed \n then trim spaces  					if (iLine != Selection.Start.iLine && AutoIndent)  						if (Selection.Start.iChar > 0)  							RemoveSpacesAfterCaret ();  				}  		}  		if (AutoIndentChars)  			DoAutoIndentChars (Selection.Start.iLine);  		OnKeyPressed ((char)0xff);  	}  	break;  case FCTBAction.ClearWordRight:  	if (OnKeyPressing ((char)0xff))  		//KeyPress event processed key  		break;  	if (!Selection.ReadOnly) {  		if (!Selection.IsEmpty)  			ClearSelected ();  		Selection.GoWordRight (true);  		if (!Selection.ReadOnly)  			ClearSelected ();  	}  	OnKeyPressed ((char)0xff);  	break;  case FCTBAction.GoWordLeft:  	Selection.GoWordLeft (false);  	break;  case FCTBAction.GoWordLeftWithSelection:  	Selection.GoWordLeft (true);  	break;  case FCTBAction.GoLeft:  	Selection.GoLeft (false);  	break;  case FCTBAction.GoLeftWithSelection:  	Selection.GoLeft (true);  	break;  case FCTBAction.GoLeft_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoLeft_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.GoWordRight:  	Selection.GoWordRight (false);  	break;  case FCTBAction.GoWordRightWithSelection:  	Selection.GoWordRight (true);  	break;  case FCTBAction.GoRight:  	Selection.GoRight (false);  	break;  case FCTBAction.GoRightWithSelection:  	Selection.GoRight (true);  	break;  case FCTBAction.GoRight_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoRight_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.GoUp:  	Selection.GoUp (false);  	ScrollLeft ();  	break;  case FCTBAction.GoUpWithSelection:  	Selection.GoUp (true);  	ScrollLeft ();  	break;  case FCTBAction.GoUp_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoUp_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.MoveSelectedLinesUp:  	if (!Selection.ColumnSelectionMode)  		MoveSelectedLinesUp ();  	break;  case FCTBAction.GoDown:  	Selection.GoDown (false);  	ScrollLeft ();  	break;  case FCTBAction.GoDownWithSelection:  	Selection.GoDown (true);  	ScrollLeft ();  	break;  case FCTBAction.GoDown_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoDown_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.MoveSelectedLinesDown:  	if (!Selection.ColumnSelectionMode)  		MoveSelectedLinesDown ();  	break;  case FCTBAction.GoPageUp:  	Selection.GoPageUp (false);  	ScrollLeft ();  	break;  case FCTBAction.GoPageUpWithSelection:  	Selection.GoPageUp (true);  	ScrollLeft ();  	break;  case FCTBAction.GoPageDown:  	Selection.GoPageDown (false);  	ScrollLeft ();  	break;  case FCTBAction.GoPageDownWithSelection:  	Selection.GoPageDown (true);  	ScrollLeft ();  	break;  case FCTBAction.GoFirstLine:  	Selection.GoFirst (false);  	break;  case FCTBAction.GoFirstLineWithSelection:  	Selection.GoFirst (true);  	break;  case FCTBAction.GoHome:  	GoHome (false);  	ScrollLeft ();  	break;  case FCTBAction.GoHomeWithSelection:  	GoHome (true);  	ScrollLeft ();  	break;  case FCTBAction.GoLastLine:  	Selection.GoLast (false);  	break;  case FCTBAction.GoLastLineWithSelection:  	Selection.GoLast (true);  	break;  case FCTBAction.GoEnd:  	Selection.GoEnd (false);  	break;  case FCTBAction.GoEndWithSelection:  	Selection.GoEnd (true);  	break;  case FCTBAction.ClearHints:  	ClearHints ();  	if (MacrosManager != null)  		MacrosManager.IsRecording = false;  	break;  case FCTBAction.MacroRecord:  	if (MacrosManager != null) {  		if (MacrosManager.AllowMacroRecordingByUser)  			MacrosManager.IsRecording = !MacrosManager.IsRecording;  		if (MacrosManager.IsRecording)  			MacrosManager.ClearMacros ();  	}  	break;  case FCTBAction.MacroExecute:  	if (MacrosManager != null) {  		MacrosManager.IsRecording = false;  		MacrosManager.ExecuteMacros ();  	}  	break;  case FCTBAction.CustomAction1:  case FCTBAction.CustomAction2:  case FCTBAction.CustomAction3:  case FCTBAction.CustomAction4:  case FCTBAction.CustomAction5:  case FCTBAction.CustomAction6:  case FCTBAction.CustomAction7:  case FCTBAction.CustomAction8:  case FCTBAction.CustomAction9:  case FCTBAction.CustomAction10:  case FCTBAction.CustomAction11:  case FCTBAction.CustomAction12:  case FCTBAction.CustomAction13:  case FCTBAction.CustomAction14:  case FCTBAction.CustomAction15:  case FCTBAction.CustomAction16:  case FCTBAction.CustomAction17:  case FCTBAction.CustomAction18:  case FCTBAction.CustomAction19:  case FCTBAction.CustomAction20:  	OnCustomAction (new CustomActionEventArgs (action));  	break;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAction,The following statement contains a magic number: ChangeFontSize (2);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAction,The following statement contains a magic number: ChangeFontSize (-2);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,RestoreFontSize,The following statement contains a magic number: Zoom = 100;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutocompleteBrackets,The following statement contains a magic number: if (AutoCompleteBrackets) {  	if (!Selection.ColumnSelectionMode)  		for (int i = 1; i < autoCompleteBracketsList.Length; i += 2)  			if (c == autoCompleteBracketsList [i] && c == Selection.CharAfterStart) {  				Selection.GoRight ();  				return true;  			}  	for (int i = 0; i < autoCompleteBracketsList.Length; i += 2)  		if (c == autoCompleteBracketsList [i]) {  			InsertBrackets (autoCompleteBracketsList [i]' autoCompleteBracketsList [i + 1]);  			return true;  		}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutocompleteBrackets,The following statement contains a magic number: if (AutoCompleteBrackets) {  	if (!Selection.ColumnSelectionMode)  		for (int i = 1; i < autoCompleteBracketsList.Length; i += 2)  			if (c == autoCompleteBracketsList [i] && c == Selection.CharAfterStart) {  				Selection.GoRight ();  				return true;  			}  	for (int i = 0; i < autoCompleteBracketsList.Length; i += 2)  		if (c == autoCompleteBracketsList [i]) {  			InsertBrackets (autoCompleteBracketsList [i]' autoCompleteBracketsList [i + 1]);  			return true;  		}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutocompleteBrackets,The following statement contains a magic number: if (!Selection.ColumnSelectionMode)  	for (int i = 1; i < autoCompleteBracketsList.Length; i += 2)  		if (c == autoCompleteBracketsList [i] && c == Selection.CharAfterStart) {  			Selection.GoRight ();  			return true;  		}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutocompleteBrackets,The following statement contains a magic number: for (int i = 1; i < autoCompleteBracketsList.Length; i += 2)  	if (c == autoCompleteBracketsList [i] && c == Selection.CharAfterStart) {  		Selection.GoRight ();  		return true;  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutocompleteBrackets,The following statement contains a magic number: i += 2
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutocompleteBrackets,The following statement contains a magic number: for (int i = 0; i < autoCompleteBracketsList.Length; i += 2)  	if (c == autoCompleteBracketsList [i]) {  		InsertBrackets (autoCompleteBracketsList [i]' autoCompleteBracketsList [i + 1]);  		return true;  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAutocompleteBrackets,The following statement contains a magic number: i += 2
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (HorizontalScroll.Value <= Paddings.Left)  	e.Graphics.FillRectangle (paddingBrush' LeftIndent - HorizontalScroll.Value - 2' 0' Math.Max (0' Paddings.Left - 1)' ClientSize.Height);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (paddingBrush' LeftIndent - HorizontalScroll.Value - 2' 0' Math.Max (0' Paddings.Left - 1)' ClientSize.Height);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: for (iLine = startLine; iLine < lines.Count; iLine++) {  	Line line = lines [iLine];  	LineInfo lineInfo = LineInfos [iLine];  	//  	if (lineInfo.startY > VerticalScroll.Value + ClientSize.Height)  		break;  	if (lineInfo.startY + lineInfo.WordWrapStringsCount * CharHeight < VerticalScroll.Value)  		continue;  	if (lineInfo.VisibleState == VisibleState.Hidden)  		continue;  	int y = lineInfo.startY - VerticalScroll.Value;  	//  	e.Graphics.SmoothingMode = SmoothingMode.None;  	//draw line background  	if (lineInfo.VisibleState == VisibleState.Visible)  		if (line.BackgroundBrush != null)  			e.Graphics.FillRectangle (line.BackgroundBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight * lineInfo.WordWrapStringsCount));  	//draw current line background  	if (CurrentLineColor != Color.Transparent && iLine == Selection.Start.iLine)  		if (Selection.IsEmpty)  			e.Graphics.FillRectangle (currentLineBrush' new Rectangle (textAreaRect.Left' y' textAreaRect.Width' CharHeight));  	//draw changed line marker  	if (ChangedLineColor != Color.Transparent && line.IsChanged)  		e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  	//  	e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;  	//  	//draw bookmark  	if (bookmarksByLineIndex.ContainsKey (iLine))  		bookmarksByLineIndex [iLine].Paint (e.Graphics' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount));  	//OnPaintLine event  	if (lineInfo.VisibleState == VisibleState.Visible)  		OnPaintLine (new PaintLineEventArgs (iLine' new Rectangle (LeftIndent' y' Width' CharHeight * lineInfo.WordWrapStringsCount)' e.Graphics' e.ClipRectangle));  	//draw line number  	if (ShowLineNumbers)  		using (var lineNumberBrush = new SolidBrush (LineNumberColor))  			e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  	//create markers  	if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  		visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  		visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  	if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  		e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  	//draw wordwrap strings of line  	for (int iWordWrapLine = 0; iWordWrapLine < lineInfo.WordWrapStringsCount; iWordWrapLine++) {  		y = lineInfo.startY + iWordWrapLine * CharHeight - VerticalScroll.Value;  		//indent  		var indent = iWordWrapLine == 0 ? 0 : lineInfo.wordWrapIndent * CharWidth;  		//draw chars  		DrawLineChars (e.Graphics' firstChar' lastChar' iLine' iWordWrapLine' x + indent' y);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (ChangedLineColor != Color.Transparent && line.IsChanged)  	e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (ChangedLineColor != Color.Transparent && line.IsChanged)  	e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (ChangedLineColor != Color.Transparent && line.IsChanged)  	e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (changedLineBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight + 1));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (ShowLineNumbers)  	using (var lineNumberBrush = new SolidBrush (LineNumberColor))  		e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (ShowLineNumbers)  	using (var lineNumberBrush = new SolidBrush (LineNumberColor))  		e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (ShowLineNumbers)  	using (var lineNumberBrush = new SolidBrush (LineNumberColor))  		e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: using (var lineNumberBrush = new SolidBrush (LineNumberColor))  	e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: using (var lineNumberBrush = new SolidBrush (LineNumberColor))  	e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: using (var lineNumberBrush = new SolidBrush (LineNumberColor))  	e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawString ((iLine + lineNumberStartValue).ToString ()' Font' lineNumberBrush' new RectangleF (-10' y' LeftIndent - minLeftIndent - 2 + 10' CharHeight)' new StringFormat (StringFormatFlags.DirectionRightToLeft));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  	visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  	visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  	visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  	visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (lineInfo.VisibleState == VisibleState.StartOfHiddenBlock)  	visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new ExpandFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  	visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  	visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  	visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  	visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (!string.IsNullOrEmpty (line.FoldingStartMarker) && lineInfo.VisibleState == VisibleState.Visible && string.IsNullOrEmpty (line.FoldingEndMarker))  	visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: visibleMarkers.Add (new CollapseFoldingMarker (iLine' new Rectangle (LeftIndentLine - 4' y + CharHeight / 2 - 3' 8' 8)));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (lineInfo.VisibleState == VisibleState.Visible && !string.IsNullOrEmpty (line.FoldingEndMarker) && string.IsNullOrEmpty (line.FoldingStartMarker))  	e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (servicePen' LeftIndentLine' y + CharHeight * lineInfo.WordWrapStringsCount - 1' LeftIndentLine + 4' y + CharHeight * lineInfo.WordWrapStringsCount - 1);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if ((startFoldingLine >= 0 || endFoldingLine >= 0) && Selection.Start == Selection.End)  	if (endFoldingLine < LineInfos.Count) {  		//folding indicator  		int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  		int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  		using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  			e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if ((startFoldingLine >= 0 || endFoldingLine >= 0) && Selection.Start == Selection.End)  	if (endFoldingLine < LineInfos.Count) {  		//folding indicator  		int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  		int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  		using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  			e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if ((startFoldingLine >= 0 || endFoldingLine >= 0) && Selection.Start == Selection.End)  	if (endFoldingLine < LineInfos.Count) {  		//folding indicator  		int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  		int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  		using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  			e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if ((startFoldingLine >= 0 || endFoldingLine >= 0) && Selection.Start == Selection.End)  	if (endFoldingLine < LineInfos.Count) {  		//folding indicator  		int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  		int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  		using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  			e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if ((startFoldingLine >= 0 || endFoldingLine >= 0) && Selection.Start == Selection.End)  	if (endFoldingLine < LineInfos.Count) {  		//folding indicator  		int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  		int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  		using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  			e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (endFoldingLine < LineInfos.Count) {  	//folding indicator  	int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  	int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  	using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  		e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (endFoldingLine < LineInfos.Count) {  	//folding indicator  	int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  	int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  	using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  		e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (endFoldingLine < LineInfos.Count) {  	//folding indicator  	int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  	int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  	using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  		e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (endFoldingLine < LineInfos.Count) {  	//folding indicator  	int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  	int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  	using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  		e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: if (endFoldingLine < LineInfos.Count) {  	//folding indicator  	int startFoldingY = (startFoldingLine >= 0 ? LineInfos [startFoldingLine].startY : 0) - VerticalScroll.Value + CharHeight / 2;  	int endFoldingY = (endFoldingLine >= 0 ? LineInfos [endFoldingLine].startY + (LineInfos [endFoldingLine].WordWrapStringsCount - 1) * CharHeight : TextHeight + CharHeight) - VerticalScroll.Value + CharHeight;  	using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  		e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  	e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  	e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  	e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: using (var indicatorPen = new Pen (Color.FromArgb (100' FoldingIndicatorColor)' 4))  	e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (indicatorPen' LeftIndent - 5' startFoldingY' LeftIndent - 5' endFoldingY);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: graphics.TranslateTransform (rect.Left + h / 2' rect.Top + h / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: graphics.TranslateTransform (rect.Left + h / 2' rect.Top + h / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: graphics.RotateTransform (180 * (DateTime.Now.Millisecond / 1000f));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: using (var pen = new Pen (Color.Red' 2)) {  	graphics.DrawArc (pen' iconRect' 0' 90);  	graphics.DrawArc (pen' iconRect' 180' 90);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: using (var pen = new Pen (Color.Red' 2)) {  	graphics.DrawArc (pen' iconRect' 0' 90);  	graphics.DrawArc (pen' iconRect' 180' 90);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: using (var pen = new Pen (Color.Red' 2)) {  	graphics.DrawArc (pen' iconRect' 0' 90);  	graphics.DrawArc (pen' iconRect' 180' 90);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: using (var pen = new Pen (Color.Red' 2)) {  	graphics.DrawArc (pen' iconRect' 0' 90);  	graphics.DrawArc (pen' iconRect' 180' 90);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: graphics.DrawArc (pen' iconRect' 0' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: graphics.DrawArc (pen' iconRect' 180' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: graphics.DrawArc (pen' iconRect' 180' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawRecordingHint,The following statement contains a magic number: tm = new System.Threading.Timer (o =>  {  	Invalidate (rect);  	tm.Dispose ();  }' null' 200' System.Threading.Timeout.Infinite);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawTextAreaBorder,The following statement contains a magic number: if (TextAreaBorder == TextAreaBorderType.Shadow) {  	const int shadowSize = 4;  	var rBottom = new Rectangle (rect.Left + shadowSize' rect.Bottom' rect.Width - shadowSize' shadowSize);  	var rCorner = new Rectangle (rect.Right' rect.Bottom' shadowSize' shadowSize);  	var rRight = new Rectangle (rect.Right' rect.Top + shadowSize' shadowSize' rect.Height - shadowSize);  	using (var brush = new SolidBrush (Color.FromArgb (80' TextAreaBorderColor))) {  		graphics.FillRectangle (brush' rBottom);  		graphics.FillRectangle (brush' rRight);  		graphics.FillRectangle (brush' rCorner);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawTextAreaBorder,The following statement contains a magic number: if (TextAreaBorder == TextAreaBorderType.Shadow) {  	const int shadowSize = 4;  	var rBottom = new Rectangle (rect.Left + shadowSize' rect.Bottom' rect.Width - shadowSize' shadowSize);  	var rCorner = new Rectangle (rect.Right' rect.Bottom' shadowSize' shadowSize);  	var rRight = new Rectangle (rect.Right' rect.Top + shadowSize' shadowSize' rect.Height - shadowSize);  	using (var brush = new SolidBrush (Color.FromArgb (80' TextAreaBorderColor))) {  		graphics.FillRectangle (brush' rBottom);  		graphics.FillRectangle (brush' rRight);  		graphics.FillRectangle (brush' rCorner);  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawTextAreaBorder,The following statement contains a magic number: using (var brush = new SolidBrush (Color.FromArgb (80' TextAreaBorderColor))) {  	graphics.FillRectangle (brush' rBottom);  	graphics.FillRectangle (brush' rRight);  	graphics.FillRectangle (brush' rCorner);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: foreach (Hint hint in hints) {  	Range r = hint.Range.Clone ();  	r.Normalize ();  	Point p1 = PlaceToPoint (r.Start);  	Point p2 = PlaceToPoint (r.End);  	if (GetVisibleState (r.Start.iLine) != VisibleState.Visible || GetVisibleState (r.End.iLine) != VisibleState.Visible)  		continue;  	using (var pen = new Pen (hint.BorderColor)) {  		pen.DashStyle = DashStyle.Dash;  		if (r.IsEmpty) {  			p1.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)  			});  		}  		else {  			p1.Offset (-1' -1);  			p2.Offset (1' -1);  			gr.DrawLines (pen' new[] {  				new Point (p1.X + CharWidth / 2' p1.Y)'  				p1'  				new Point (p1.X' p1.Y + charHeight + 2)'  				new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  			});  			gr.DrawLines (pen' new[] {  				new Point (p2.X - CharWidth / 2' p2.Y)'  				p2'  				new Point (p2.X' p2.Y + charHeight + 2)'  				new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  			});  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: using (var pen = new Pen (hint.BorderColor)) {  	pen.DashStyle = DashStyle.Dash;  	if (r.IsEmpty) {  		p1.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)  		});  	}  	else {  		p1.Offset (-1' -1);  		p2.Offset (1' -1);  		gr.DrawLines (pen' new[] {  			new Point (p1.X + CharWidth / 2' p1.Y)'  			p1'  			new Point (p1.X' p1.Y + charHeight + 2)'  			new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  		});  		gr.DrawLines (pen' new[] {  			new Point (p2.X - CharWidth / 2' p2.Y)'  			p2'  			new Point (p2.X' p2.Y + charHeight + 2)'  			new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  		});  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: if (r.IsEmpty) {  	p1.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)  	});  }  else {  	p1.Offset (-1' -1);  	p2.Offset (1' -1);  	gr.DrawLines (pen' new[] {  		new Point (p1.X + CharWidth / 2' p1.Y)'  		p1'  		new Point (p1.X' p1.Y + charHeight + 2)'  		new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  	});  	gr.DrawLines (pen' new[] {  		new Point (p2.X - CharWidth / 2' p2.Y)'  		p2'  		new Point (p2.X' p2.Y + charHeight + 2)'  		new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  	});  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	p1'  	new Point (p1.X' p1.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	new Point (p1.X + CharWidth / 2' p1.Y)'  	p1'  	new Point (p1.X' p1.Y + charHeight + 2)'  	new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	new Point (p1.X + CharWidth / 2' p1.Y)'  	p1'  	new Point (p1.X' p1.Y + charHeight + 2)'  	new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	new Point (p1.X + CharWidth / 2' p1.Y)'  	p1'  	new Point (p1.X' p1.Y + charHeight + 2)'  	new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	new Point (p1.X + CharWidth / 2' p1.Y)'  	p1'  	new Point (p1.X' p1.Y + charHeight + 2)'  	new Point (p1.X + CharWidth / 2' p1.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	new Point (p2.X - CharWidth / 2' p2.Y)'  	p2'  	new Point (p2.X' p2.Y + charHeight + 2)'  	new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	new Point (p2.X - CharWidth / 2' p2.Y)'  	p2'  	new Point (p2.X' p2.Y + charHeight + 2)'  	new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	new Point (p2.X - CharWidth / 2' p2.Y)'  	p2'  	new Point (p2.X' p2.Y + charHeight + 2)'  	new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,PaintHintBrackets,The following statement contains a magic number: gr.DrawLines (pen' new[] {  	new Point (p2.X - CharWidth / 2' p2.Y)'  	p2'  	new Point (p2.X' p2.Y + charHeight + 2)'  	new Point (p2.X - CharWidth / 2' p2.Y + charHeight + 2)  });  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawFoldingLines,The following statement contains a magic number: using (var pen = new Pen (Color.FromArgb (200' ServiceLinesColor)) {  	DashStyle = DashStyle.Dot  })  	foreach (var iLine in foldingPairs)  		if (iLine.Key < endLine && iLine.Value > startLine) {  			Line line = lines [iLine.Key];  			int y = LineInfos [iLine.Key].startY - VerticalScroll.Value + CharHeight;  			y += y % 2;  			int y2;  			if (iLine.Value >= LinesCount)  				y2 = LineInfos [LinesCount - 1].startY + CharHeight - VerticalScroll.Value;  			else if (LineInfos [iLine.Value].VisibleState == VisibleState.Visible) {  				int d = 0;  				int spaceCount = line.StartSpacesCount;  				if (lines [iLine.Value].Count <= spaceCount || lines [iLine.Value] [spaceCount].c == ' ')  					d = CharHeight;  				y2 = LineInfos [iLine.Value].startY - VerticalScroll.Value + d;  			}  			else  				continue;  			int x = LeftIndent + Paddings.Left + line.StartSpacesCount * CharWidth - HorizontalScroll.Value;  			if (x >= LeftIndent + Paddings.Left)  				e.Graphics.DrawLine (pen' x' y >= 0 ? y : 0' x' y2 < ClientSize.Height ? y2 : ClientSize.Height);  		}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawFoldingLines,The following statement contains a magic number: using (var pen = new Pen (Color.FromArgb (200' ServiceLinesColor)) {  	DashStyle = DashStyle.Dot  })  	foreach (var iLine in foldingPairs)  		if (iLine.Key < endLine && iLine.Value > startLine) {  			Line line = lines [iLine.Key];  			int y = LineInfos [iLine.Key].startY - VerticalScroll.Value + CharHeight;  			y += y % 2;  			int y2;  			if (iLine.Value >= LinesCount)  				y2 = LineInfos [LinesCount - 1].startY + CharHeight - VerticalScroll.Value;  			else if (LineInfos [iLine.Value].VisibleState == VisibleState.Visible) {  				int d = 0;  				int spaceCount = line.StartSpacesCount;  				if (lines [iLine.Value].Count <= spaceCount || lines [iLine.Value] [spaceCount].c == ' ')  					d = CharHeight;  				y2 = LineInfos [iLine.Value].startY - VerticalScroll.Value + d;  			}  			else  				continue;  			int x = LeftIndent + Paddings.Left + line.StartSpacesCount * CharWidth - HorizontalScroll.Value;  			if (x >= LeftIndent + Paddings.Left)  				e.Graphics.DrawLine (pen' x' y >= 0 ? y : 0' x' y2 < ClientSize.Height ? y2 : ClientSize.Height);  		}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawFoldingLines,The following statement contains a magic number: foreach (var iLine in foldingPairs)  	if (iLine.Key < endLine && iLine.Value > startLine) {  		Line line = lines [iLine.Key];  		int y = LineInfos [iLine.Key].startY - VerticalScroll.Value + CharHeight;  		y += y % 2;  		int y2;  		if (iLine.Value >= LinesCount)  			y2 = LineInfos [LinesCount - 1].startY + CharHeight - VerticalScroll.Value;  		else if (LineInfos [iLine.Value].VisibleState == VisibleState.Visible) {  			int d = 0;  			int spaceCount = line.StartSpacesCount;  			if (lines [iLine.Value].Count <= spaceCount || lines [iLine.Value] [spaceCount].c == ' ')  				d = CharHeight;  			y2 = LineInfos [iLine.Value].startY - VerticalScroll.Value + d;  		}  		else  			continue;  		int x = LeftIndent + Paddings.Left + line.StartSpacesCount * CharWidth - HorizontalScroll.Value;  		if (x >= LeftIndent + Paddings.Left)  			e.Graphics.DrawLine (pen' x' y >= 0 ? y : 0' x' y2 < ClientSize.Height ? y2 : ClientSize.Height);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawFoldingLines,The following statement contains a magic number: if (iLine.Key < endLine && iLine.Value > startLine) {  	Line line = lines [iLine.Key];  	int y = LineInfos [iLine.Key].startY - VerticalScroll.Value + CharHeight;  	y += y % 2;  	int y2;  	if (iLine.Value >= LinesCount)  		y2 = LineInfos [LinesCount - 1].startY + CharHeight - VerticalScroll.Value;  	else if (LineInfos [iLine.Value].VisibleState == VisibleState.Visible) {  		int d = 0;  		int spaceCount = line.StartSpacesCount;  		if (lines [iLine.Value].Count <= spaceCount || lines [iLine.Value] [spaceCount].c == ' ')  			d = CharHeight;  		y2 = LineInfos [iLine.Value].startY - VerticalScroll.Value + d;  	}  	else  		continue;  	int x = LeftIndent + Paddings.Left + line.StartSpacesCount * CharWidth - HorizontalScroll.Value;  	if (x >= LeftIndent + Paddings.Left)  		e.Graphics.DrawLine (pen' x' y >= 0 ? y : 0' x' y2 < ClientSize.Height ? y2 : ClientSize.Height);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawFoldingLines,The following statement contains a magic number: y += y % 2;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnMouseDown,The following statement contains a magic number: if (e.Button == MouseButtons.Left) {  	VisualMarker marker = FindVisualMarkerForPoint (e.Location);  	//click on marker  	if (marker != null) {  		mouseIsDrag = false;  		mouseIsDragDrop = false;  		draggedRange = null;  		OnMarkerClick (e' marker);  		return;  	}  	mouseIsDrag = true;  	mouseIsDragDrop = false;  	draggedRange = null;  	isLineSelect = (e.Location.X < LeftIndentLine);  	if (!isLineSelect) {  		var p = PointToPlace (e.Location);  		if (e.Clicks == 2) {  			mouseIsDrag = false;  			mouseIsDragDrop = false;  			draggedRange = null;  			SelectWord (p);  			return;  		}  		if (Selection.IsEmpty || !Selection.Contains (p) || this [p.iLine].Count <= p.iChar || ReadOnly)  			OnMouseClickText (e);  		else {  			mouseIsDragDrop = true;  			mouseIsDrag = false;  		}  	}  	else {  		CheckAndChangeSelectionType ();  		Selection.BeginUpdate ();  		//select whole line  		int iLine = PointToPlaceSimple (e.Location).iLine;  		lineSelectFrom = iLine;  		Selection.Start = new Place (0' iLine);  		Selection.End = new Place (GetLineLength (iLine)' iLine);  		Selection.EndUpdate ();  		Invalidate ();  	}  }  else if (e.Button == MouseButtons.Middle) {  	ActivateMiddleClickScrollingMode (e);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnMouseDown,The following statement contains a magic number: if (!isLineSelect) {  	var p = PointToPlace (e.Location);  	if (e.Clicks == 2) {  		mouseIsDrag = false;  		mouseIsDragDrop = false;  		draggedRange = null;  		SelectWord (p);  		return;  	}  	if (Selection.IsEmpty || !Selection.Contains (p) || this [p.iLine].Count <= p.iChar || ReadOnly)  		OnMouseClickText (e);  	else {  		mouseIsDragDrop = true;  		mouseIsDrag = false;  	}  }  else {  	CheckAndChangeSelectionType ();  	Selection.BeginUpdate ();  	//select whole line  	int iLine = PointToPlaceSimple (e.Location).iLine;  	lineSelectFrom = iLine;  	Selection.Start = new Place (0' iLine);  	Selection.End = new Place (GetLineLength (iLine)' iLine);  	Selection.EndUpdate ();  	Invalidate ();  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnMouseDown,The following statement contains a magic number: if (e.Clicks == 2) {  	mouseIsDrag = false;  	mouseIsDragDrop = false;  	draggedRange = null;  	SelectWord (p);  	return;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnMouseWheel,The following statement contains a magic number: if (lastModifiers == Keys.Control) {  	ChangeFontSize (2 * Math.Sign (e.Delta));  	((HandledMouseEventArgs)e).Handled = true;  }  else if (VerticalScroll.Visible || !ShowScrollBars) {  	//base.OnMouseWheel(e);  	// Determine scoll offset  	int mouseWheelScrollLinesSetting = GetControlPanelWheelScrollLinesValue ();  	DoScrollVertical (mouseWheelScrollLinesSetting' e.Delta);  	((HandledMouseEventArgs)e).Handled = true;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnMouseWheel,The following statement contains a magic number: ChangeFontSize (2 * Math.Sign (e.Delta));  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ChangeFontSize,The following statement contains a magic number: using (var gr = Graphics.FromHwnd (Handle)) {  	var dpi = gr.DpiY;  	var newPoints = points + step * 72f / dpi;  	if (newPoints < 1f)  		return;  	var k = newPoints / originalFont.SizeInPoints;  	Zoom = (int)(100 * k);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ChangeFontSize,The following statement contains a magic number: Zoom = (int)(100 * k);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,YtoLineIndex,The following statement contains a magic number: i = i < 0 ? -i - 2 : i;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,Print,The following statement contains a magic number: wb.Location = new Point (-1000' -1000);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,Print,The following statement contains a magic number: wb.Location = new Point (-1000' -1000);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnDragOver,The following statement contains a magic number: if (e.Data.GetDataPresent (DataFormats.Text)) {  	Point p = PointToClient (new Point (e.X' e.Y));  	Selection.Start = PointToPlace (p);  	if (p.Y < 6 && VerticalScroll.Visible && VerticalScroll.Value > 0)  		VerticalScroll.Value = Math.Max (0' VerticalScroll.Value - charHeight);  	DoCaretVisible ();  	Invalidate ();  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,OnDragOver,The following statement contains a magic number: if (p.Y < 6 && VerticalScroll.Visible && VerticalScroll.Value > 0)  	VerticalScroll.Value = Math.Max (0' VerticalScroll.Value - charHeight);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ActivateMiddleClickScrollingMode,The following statement contains a magic number: if (!middleClickScrollingActivated) {  	if ((!HorizontalScroll.Visible) && (!VerticalScroll.Visible))  		if (ShowScrollBars)  			return;  	middleClickScrollingActivated = true;  	middleClickScrollingOriginPoint = e.Location;  	middleClickScrollingOriginScroll = new Point (HorizontalScroll.Value' VerticalScroll.Value);  	middleClickScrollingTimer.Interval = 50;  	middleClickScrollingTimer.Enabled = true;  	Capture = true;  	// Refresh the control   	Refresh ();  	// Disable drawing  	SendMessage (Handle' WM_SETREDRAW' 0' 0);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,ActivateMiddleClickScrollingMode,The following statement contains a magic number: middleClickScrollingTimer.Interval = 50;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (distance > 10) {  	if (angleInDegree >= 325 || angleInDegree <= 35)  		this.middleClickScollDirection = ScrollDirection.Right;  	else if (angleInDegree <= 55)  		this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  	else if (angleInDegree <= 125)  		this.middleClickScollDirection = ScrollDirection.Up;  	else if (angleInDegree <= 145)  		this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  	else if (angleInDegree <= 215)  		this.middleClickScollDirection = ScrollDirection.Left;  	else if (angleInDegree <= 235)  		this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  	else if (angleInDegree <= 305)  		this.middleClickScollDirection = ScrollDirection.Down;  	else  		this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  }  else {  	this.middleClickScollDirection = ScrollDirection.None;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree >= 325 || angleInDegree <= 35)  	this.middleClickScollDirection = ScrollDirection.Right;  else if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree >= 325 || angleInDegree <= 35)  	this.middleClickScollDirection = ScrollDirection.Right;  else if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree >= 325 || angleInDegree <= 35)  	this.middleClickScollDirection = ScrollDirection.Right;  else if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree >= 325 || angleInDegree <= 35)  	this.middleClickScollDirection = ScrollDirection.Right;  else if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree >= 325 || angleInDegree <= 35)  	this.middleClickScollDirection = ScrollDirection.Right;  else if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree >= 325 || angleInDegree <= 35)  	this.middleClickScollDirection = ScrollDirection.Right;  else if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree >= 325 || angleInDegree <= 35)  	this.middleClickScollDirection = ScrollDirection.Right;  else if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree >= 325 || angleInDegree <= 35)  	this.middleClickScollDirection = ScrollDirection.Right;  else if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 55)  	this.middleClickScollDirection = ScrollDirection.Right | ScrollDirection.Up;  else if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 125)  	this.middleClickScollDirection = ScrollDirection.Up;  else if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 145)  	this.middleClickScollDirection = ScrollDirection.Up | ScrollDirection.Left;  else if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 215)  	this.middleClickScollDirection = ScrollDirection.Left;  else if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 235)  	this.middleClickScollDirection = ScrollDirection.Left | ScrollDirection.Down;  else if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,middleClickScrollingTimer_Tick,The following statement contains a magic number: if (angleInDegree <= 305)  	this.middleClickScollDirection = ScrollDirection.Down;  else  	this.middleClickScollDirection = ScrollDirection.Down | ScrollDirection.Right;  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: using (SolidBrush inverseColorBrush = new SolidBrush (inverseColor)) {  	var p = middleClickScrollingOriginPoint;  	var state = gr.Save ();  	gr.SmoothingMode = SmoothingMode.HighQuality;  	gr.TranslateTransform (p.X' p.Y);  	gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.Restore (state);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: using (SolidBrush inverseColorBrush = new SolidBrush (inverseColor)) {  	var p = middleClickScrollingOriginPoint;  	var state = gr.Save ();  	gr.SmoothingMode = SmoothingMode.HighQuality;  	gr.TranslateTransform (p.X' p.Y);  	gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.Restore (state);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: using (SolidBrush inverseColorBrush = new SolidBrush (inverseColor)) {  	var p = middleClickScrollingOriginPoint;  	var state = gr.Save ();  	gr.SmoothingMode = SmoothingMode.HighQuality;  	gr.TranslateTransform (p.X' p.Y);  	gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.Restore (state);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: using (SolidBrush inverseColorBrush = new SolidBrush (inverseColor)) {  	var p = middleClickScrollingOriginPoint;  	var state = gr.Save ();  	gr.SmoothingMode = SmoothingMode.HighQuality;  	gr.TranslateTransform (p.X' p.Y);  	gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.Restore (state);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: using (SolidBrush inverseColorBrush = new SolidBrush (inverseColor)) {  	var p = middleClickScrollingOriginPoint;  	var state = gr.Save ();  	gr.SmoothingMode = SmoothingMode.HighQuality;  	gr.TranslateTransform (p.X' p.Y);  	gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.Restore (state);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: using (SolidBrush inverseColorBrush = new SolidBrush (inverseColor)) {  	var p = middleClickScrollingOriginPoint;  	var state = gr.Save ();  	gr.SmoothingMode = SmoothingMode.HighQuality;  	gr.TranslateTransform (p.X' p.Y);  	gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.Restore (state);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: using (SolidBrush inverseColorBrush = new SolidBrush (inverseColor)) {  	var p = middleClickScrollingOriginPoint;  	var state = gr.Save ();  	gr.SmoothingMode = SmoothingMode.HighQuality;  	gr.TranslateTransform (p.X' p.Y);  	gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollVertically)  		DrawTriangle (gr' inverseColorBrush);  	gr.RotateTransform (90);  	if (ableToScrollHorizontally)  		DrawTriangle (gr' inverseColorBrush);  	gr.Restore (state);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: gr.FillEllipse (inverseColorBrush' -2' -2' 4' 4);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: gr.RotateTransform (90);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: gr.RotateTransform (90);  
Magic Number,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DrawMiddleClickScrolling,The following statement contains a magic number: gr.RotateTransform (90);  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,FileTextSource,The following statement contains a magic number: timer.Interval = 10000;  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,OpenFile,The following statement contains a magic number: while (fs.Position < length) {  	var b = fs.ReadByte ();  	if (b == 10)// \n  	 {  		sourceFileLinePositions.Add ((int)(fs.Position) + shift);  		base.lines.Add (null);  	}  	else if (prev == 13)// \r (Mac format)  	 {  		sourceFileLinePositions.Add ((int)(fs.Position - 1) + shift);  		base.lines.Add (null);  		SaveEOL = "\r";  	}  	prev = b;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,OpenFile,The following statement contains a magic number: while (fs.Position < length) {  	var b = fs.ReadByte ();  	if (b == 10)// \n  	 {  		sourceFileLinePositions.Add ((int)(fs.Position) + shift);  		base.lines.Add (null);  	}  	else if (prev == 13)// \r (Mac format)  	 {  		sourceFileLinePositions.Add ((int)(fs.Position - 1) + shift);  		base.lines.Add (null);  		SaveEOL = "\r";  	}  	prev = b;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,OpenFile,The following statement contains a magic number: if (b == 10)// \n   {  	sourceFileLinePositions.Add ((int)(fs.Position) + shift);  	base.lines.Add (null);  }  else if (prev == 13)// \r (Mac format)   {  	sourceFileLinePositions.Add ((int)(fs.Position - 1) + shift);  	base.lines.Add (null);  	SaveEOL = "\r";  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,OpenFile,The following statement contains a magic number: if (b == 10)// \n   {  	sourceFileLinePositions.Add ((int)(fs.Position) + shift);  	base.lines.Add (null);  }  else if (prev == 13)// \r (Mac format)   {  	sourceFileLinePositions.Add ((int)(fs.Position - 1) + shift);  	base.lines.Add (null);  	SaveEOL = "\r";  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,OpenFile,The following statement contains a magic number: if (prev == 13)// \r (Mac format)   {  	sourceFileLinePositions.Add ((int)(fs.Position - 1) + shift);  	base.lines.Add (null);  	SaveEOL = "\r";  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,OpenFile,The following statement contains a magic number: if (prev == 13) {  	sourceFileLinePositions.Add ((int)(fs.Position) + shift);  	base.lines.Add (null);  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineShift,The following statement contains a magic number: if (enc.HeaderName == "utf-32")  	return 3;  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineShift,The following statement contains a magic number: return 3;  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE && signature [2] == 0x00 && signature [3] == 0x00 && c >= 4) {  	enc = Encoding.UTF32;  	//UTF32 LE  	bytesPerSignature = 4;  }  else if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: bytesPerSignature = 4;  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0x00 && signature [1] == 0x00 && signature [2] == 0xFE && signature [3] == 0xFF) {  	enc = new UTF32Encoding (true' true);  	//UTF32 BE  	bytesPerSignature = 4;  }  else if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: bytesPerSignature = 4;  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xEF && signature [1] == 0xBB && signature [2] == 0xBF) {  	enc = Encoding.UTF8;  	//UTF8  	bytesPerSignature = 3;  }  else if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: bytesPerSignature = 3;  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFE && signature [1] == 0xFF) {  	enc = Encoding.BigEndianUnicode;  	//UTF16 BE  	bytesPerSignature = 2;  }  else if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: bytesPerSignature = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: if (signature [0] == 0xFF && signature [1] == 0xFE) {  	enc = Encoding.Unicode;  	//UTF16 LE  	bytesPerSignature = 2;  }  
Magic Number,Andi.Libs.FastColoredTextBox,FileTextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FileTextSource.cs,DefineEncoding,The following statement contains a magic number: bytesPerSignature = 2;  
Magic Number,Andi.Libs.FastColoredTextBox,Hints,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,LayoutHint,The following statement contains a magic number: if (hint.Dock == DockStyle.Fill) {  	hint.Width = tb.ClientSize.Width - tb.LeftIndent - 2;  	hint.HostPanel.Left = tb.LeftIndent;  }  else {  	var p1 = tb.PlaceToPoint (hint.Range.Start);  	var p2 = tb.PlaceToPoint (hint.Range.End);  	var cx = (p1.X + p2.X) / 2;  	hint.HostPanel.Left = Math.Max (tb.LeftIndent' cx - hint.HostPanel.Width / 2);  }  
Magic Number,Andi.Libs.FastColoredTextBox,Hints,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,LayoutHint,The following statement contains a magic number: if (hint.Dock == DockStyle.Fill) {  	hint.Width = tb.ClientSize.Width - tb.LeftIndent - 2;  	hint.HostPanel.Left = tb.LeftIndent;  }  else {  	var p1 = tb.PlaceToPoint (hint.Range.Start);  	var p2 = tb.PlaceToPoint (hint.Range.End);  	var cx = (p1.X + p2.X) / 2;  	hint.HostPanel.Left = Math.Max (tb.LeftIndent' cx - hint.HostPanel.Width / 2);  }  
Magic Number,Andi.Libs.FastColoredTextBox,Hints,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,LayoutHint,The following statement contains a magic number: if (hint.Dock == DockStyle.Fill) {  	hint.Width = tb.ClientSize.Width - tb.LeftIndent - 2;  	hint.HostPanel.Left = tb.LeftIndent;  }  else {  	var p1 = tb.PlaceToPoint (hint.Range.Start);  	var p2 = tb.PlaceToPoint (hint.Range.End);  	var cx = (p1.X + p2.X) / 2;  	hint.HostPanel.Left = Math.Max (tb.LeftIndent' cx - hint.HostPanel.Width / 2);  }  
Magic Number,Andi.Libs.FastColoredTextBox,Hints,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,LayoutHint,The following statement contains a magic number: hint.Width = tb.ClientSize.Width - tb.LeftIndent - 2;  
Magic Number,Andi.Libs.FastColoredTextBox,Hints,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,LayoutHint,The following statement contains a magic number: hint.HostPanel.Left = Math.Max (tb.LeftIndent' cx - hint.HostPanel.Width / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,Hint,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Init,The following statement contains a magic number: if (InnerControl != null) {  	HostPanel.Controls.Add (InnerControl);  	HostPanel.Width = InnerControl.Width + 2;  	HostPanel.Height = InnerControl.Height + 2;  	InnerControl.Dock = DockStyle.Fill;  	InnerControl.Visible = true;  	BackColor = SystemColors.Control;  }  else {  	HostPanel.Height = Range.tb.CharHeight + 5;  }  
Magic Number,Andi.Libs.FastColoredTextBox,Hint,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Init,The following statement contains a magic number: if (InnerControl != null) {  	HostPanel.Controls.Add (InnerControl);  	HostPanel.Width = InnerControl.Width + 2;  	HostPanel.Height = InnerControl.Height + 2;  	InnerControl.Dock = DockStyle.Fill;  	InnerControl.Visible = true;  	BackColor = SystemColors.Control;  }  else {  	HostPanel.Height = Range.tb.CharHeight + 5;  }  
Magic Number,Andi.Libs.FastColoredTextBox,Hint,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Init,The following statement contains a magic number: if (InnerControl != null) {  	HostPanel.Controls.Add (InnerControl);  	HostPanel.Width = InnerControl.Width + 2;  	HostPanel.Height = InnerControl.Height + 2;  	InnerControl.Dock = DockStyle.Fill;  	InnerControl.Visible = true;  	BackColor = SystemColors.Control;  }  else {  	HostPanel.Height = Range.tb.CharHeight + 5;  }  
Magic Number,Andi.Libs.FastColoredTextBox,Hint,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Init,The following statement contains a magic number: HostPanel.Width = InnerControl.Width + 2;  
Magic Number,Andi.Libs.FastColoredTextBox,Hint,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Init,The following statement contains a magic number: HostPanel.Height = InnerControl.Height + 2;  
Magic Number,Andi.Libs.FastColoredTextBox,Hint,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hints.cs,Init,The following statement contains a magic number: HostPanel.Height = Range.tb.CharHeight + 5;  
Magic Number,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,ToString,The following statement contains a magic number: if (sb.Length > 1)  	sb.Remove (sb.Length - 2' 2);  
Magic Number,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,ToString,The following statement contains a magic number: if (sb.Length > 1)  	sb.Remove (sb.Length - 2' 2);  
Magic Number,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,ToString,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,Andi.Libs.FastColoredTextBox,HotkeysMapping,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Hotkeys.cs,ToString,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,Andi.Libs.FastColoredTextBox,HotkeysEditorForm,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\HotkeysEditorForm.cs,dgv_RowsAdded,The following statement contains a magic number: cell = (dgv [2' e.RowIndex] as DataGridViewComboBoxCell);  
Magic Number,Andi.Libs.FastColoredTextBox,PlatformType,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\PlatformType.cs,GetOperationSystemPlatform,The following statement contains a magic number: if (Environment.OSVersion.Version.Major > 5 || (Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor >= 1)) {  	GetNativeSystemInfo (ref sysInfo);  }  // else use GetSystemInfo  else {  	GetSystemInfo (ref sysInfo);  }  
Magic Number,Andi.Libs.FastColoredTextBox,PlatformType,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\PlatformType.cs,GetOperationSystemPlatform,The following statement contains a magic number: if (Environment.OSVersion.Version.Major > 5 || (Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor >= 1)) {  	GetNativeSystemInfo (ref sysInfo);  }  // else use GetSystemInfo  else {  	GetSystemInfo (ref sysInfo);  }  
Magic Number,Andi.Libs.FastColoredTextBox,Range,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Range.cs,SetStyle,The following statement contains a magic number: if (Math.Abs (Start.iLine - End.iLine) > 1000)  	options |= SyntaxHighlighter.RegexCompiledOption;  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,Ruler,The following statement contains a magic number: MinimumSize = new Size (0' 24);  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,Ruler,The following statement contains a magic number: MaximumSize = new Size (int.MaxValue / 2' 24);  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,Ruler,The following statement contains a magic number: MaximumSize = new Size (int.MaxValue / 2' 24);  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (new LinearGradientBrush (new Rectangle (0' 0' Width' Height)' BackColor' BackColor2' 270)' new Rectangle (0' 0' Width' Height));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (TickColor))  	using (var textBrush = new SolidBrush (ForeColor))  		for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  			if (column % 10 == 0)  				e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  			e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  		}  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (TickColor))  	using (var textBrush = new SolidBrush (ForeColor))  		for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  			if (column % 10 == 0)  				e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  			e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  		}  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (TickColor))  	using (var textBrush = new SolidBrush (ForeColor))  		for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  			if (column % 10 == 0)  				e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  			e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  		}  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (TickColor))  	using (var textBrush = new SolidBrush (ForeColor))  		for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  			if (column % 10 == 0)  				e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  			e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  		}  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var textBrush = new SolidBrush (ForeColor))  	for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  		if (column % 10 == 0)  			e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  		e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var textBrush = new SolidBrush (ForeColor))  	for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  		if (column % 10 == 0)  			e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  		e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var textBrush = new SolidBrush (ForeColor))  	for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  		if (column % 10 == 0)  			e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  		e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var textBrush = new SolidBrush (ForeColor))  	for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  		if (column % 10 == 0)  			e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  		e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  	}  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  	if (column % 10 == 0)  		e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  	e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  	if (column % 10 == 0)  		e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  	e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  	if (column % 10 == 0)  		e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  	e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: for (float x = zeroPoint.X; x < Right; x += columnWidth' ++column) {  	if (column % 10 == 0)  		e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  	e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: if (column % 10 == 0)  	e.Graphics.DrawString (column.ToString ()' Font' textBrush' x' 0f' sf);  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' (int)x' fontSize.Height + (column % 5 == 0 ? 1 : 3)' (int)x' Height - 4);  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (TickColor))  	e.Graphics.DrawLine (pen' new Point (car.X - 3' Height - 3)' new Point (car.X + 3' Height - 3));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (TickColor))  	e.Graphics.DrawLine (pen' new Point (car.X - 3' Height - 3)' new Point (car.X + 3' Height - 3));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (TickColor))  	e.Graphics.DrawLine (pen' new Point (car.X - 3' Height - 3)' new Point (car.X + 3' Height - 3));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (TickColor))  	e.Graphics.DrawLine (pen' new Point (car.X - 3' Height - 3)' new Point (car.X + 3' Height - 3));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X - 3' Height - 3)' new Point (car.X + 3' Height - 3));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X - 3' Height - 3)' new Point (car.X + 3' Height - 3));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X - 3' Height - 3)' new Point (car.X + 3' Height - 3));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X - 3' Height - 3)' new Point (car.X + 3' Height - 3));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: using (var pen = new Pen (CaretTickColor)) {  	e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  	e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  }  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X - 2' fontSize.Height + 3)' new Point (car.X - 2' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X' fontSize.Height + 1)' new Point (car.X' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Ruler,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Ruler.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (pen' new Point (car.X + 2' fontSize.Height + 3)' new Point (car.X + 2' Height - 4));  
Magic Number,Andi.Libs.FastColoredTextBox,Style,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetRoundedRectangle,The following statement contains a magic number: gp.AddArc (rect.X' rect.Y' d' d' 180' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,Style,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetRoundedRectangle,The following statement contains a magic number: gp.AddArc (rect.X' rect.Y' d' d' 180' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,Style,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetRoundedRectangle,The following statement contains a magic number: gp.AddArc (rect.X + rect.Width - d' rect.Y' d' d' 270' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,Style,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetRoundedRectangle,The following statement contains a magic number: gp.AddArc (rect.X + rect.Width - d' rect.Y' d' d' 270' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,Style,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetRoundedRectangle,The following statement contains a magic number: gp.AddArc (rect.X + rect.Width - d' rect.Y + rect.Height - d' d' d' 0' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,Style,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetRoundedRectangle,The following statement contains a magic number: gp.AddArc (rect.X' rect.Y + rect.Height - d' d' d' 90' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,Style,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetRoundedRectangle,The following statement contains a magic number: gp.AddArc (rect.X' rect.Y + rect.Height - d' d' d' 90' 90);  
Magic Number,Andi.Libs.FastColoredTextBox,Style,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,GetRoundedRectangle,The following statement contains a magic number: gp.AddLine (rect.X' rect.Y + rect.Height - d' rect.X' rect.Y + d / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: using (var f = new Font (range.tb.Font' FontStyle)) {  	Line line = range.tb [range.Start.iLine];  	float dx = range.tb.CharWidth;  	float y = position.Y + range.tb.LineInterval / 2;  	float x = position.X - range.tb.CharWidth / 3;  	if (ForeBrush == null)  		ForeBrush = new SolidBrush (range.tb.ForeColor);  	if (range.tb.ImeAllowed) {  		//IME mode  		for (int i = range.Start.iChar; i < range.End.iChar; i++) {  			SizeF size = FastColoredTextBox.GetCharSize (f' line [i].c);  			var gs = gr.Save ();  			float k = size.Width > range.tb.CharWidth + 1 ? range.tb.CharWidth / size.Width : 1;  			gr.TranslateTransform (x' y + (1 - k) * range.tb.CharHeight / 2);  			gr.ScaleTransform (k' (float)Math.Sqrt (k));  			gr.DrawString (line [i].c.ToString ()' f' ForeBrush' 0' 0' stringFormat);  			gr.Restore (gs);  			x += dx;  		}  	}  	else {  		//classic mode   		for (int i = range.Start.iChar; i < range.End.iChar; i++) {  			//draw char  			gr.DrawString (line [i].c.ToString ()' f' ForeBrush' x' y' stringFormat);  			x += dx;  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: using (var f = new Font (range.tb.Font' FontStyle)) {  	Line line = range.tb [range.Start.iLine];  	float dx = range.tb.CharWidth;  	float y = position.Y + range.tb.LineInterval / 2;  	float x = position.X - range.tb.CharWidth / 3;  	if (ForeBrush == null)  		ForeBrush = new SolidBrush (range.tb.ForeColor);  	if (range.tb.ImeAllowed) {  		//IME mode  		for (int i = range.Start.iChar; i < range.End.iChar; i++) {  			SizeF size = FastColoredTextBox.GetCharSize (f' line [i].c);  			var gs = gr.Save ();  			float k = size.Width > range.tb.CharWidth + 1 ? range.tb.CharWidth / size.Width : 1;  			gr.TranslateTransform (x' y + (1 - k) * range.tb.CharHeight / 2);  			gr.ScaleTransform (k' (float)Math.Sqrt (k));  			gr.DrawString (line [i].c.ToString ()' f' ForeBrush' 0' 0' stringFormat);  			gr.Restore (gs);  			x += dx;  		}  	}  	else {  		//classic mode   		for (int i = range.Start.iChar; i < range.End.iChar; i++) {  			//draw char  			gr.DrawString (line [i].c.ToString ()' f' ForeBrush' x' y' stringFormat);  			x += dx;  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: using (var f = new Font (range.tb.Font' FontStyle)) {  	Line line = range.tb [range.Start.iLine];  	float dx = range.tb.CharWidth;  	float y = position.Y + range.tb.LineInterval / 2;  	float x = position.X - range.tb.CharWidth / 3;  	if (ForeBrush == null)  		ForeBrush = new SolidBrush (range.tb.ForeColor);  	if (range.tb.ImeAllowed) {  		//IME mode  		for (int i = range.Start.iChar; i < range.End.iChar; i++) {  			SizeF size = FastColoredTextBox.GetCharSize (f' line [i].c);  			var gs = gr.Save ();  			float k = size.Width > range.tb.CharWidth + 1 ? range.tb.CharWidth / size.Width : 1;  			gr.TranslateTransform (x' y + (1 - k) * range.tb.CharHeight / 2);  			gr.ScaleTransform (k' (float)Math.Sqrt (k));  			gr.DrawString (line [i].c.ToString ()' f' ForeBrush' 0' 0' stringFormat);  			gr.Restore (gs);  			x += dx;  		}  	}  	else {  		//classic mode   		for (int i = range.Start.iChar; i < range.End.iChar; i++) {  			//draw char  			gr.DrawString (line [i].c.ToString ()' f' ForeBrush' x' y' stringFormat);  			x += dx;  		}  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: if (range.tb.ImeAllowed) {  	//IME mode  	for (int i = range.Start.iChar; i < range.End.iChar; i++) {  		SizeF size = FastColoredTextBox.GetCharSize (f' line [i].c);  		var gs = gr.Save ();  		float k = size.Width > range.tb.CharWidth + 1 ? range.tb.CharWidth / size.Width : 1;  		gr.TranslateTransform (x' y + (1 - k) * range.tb.CharHeight / 2);  		gr.ScaleTransform (k' (float)Math.Sqrt (k));  		gr.DrawString (line [i].c.ToString ()' f' ForeBrush' 0' 0' stringFormat);  		gr.Restore (gs);  		x += dx;  	}  }  else {  	//classic mode   	for (int i = range.Start.iChar; i < range.End.iChar; i++) {  		//draw char  		gr.DrawString (line [i].c.ToString ()' f' ForeBrush' x' y' stringFormat);  		x += dx;  	}  }  
Magic Number,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: for (int i = range.Start.iChar; i < range.End.iChar; i++) {  	SizeF size = FastColoredTextBox.GetCharSize (f' line [i].c);  	var gs = gr.Save ();  	float k = size.Width > range.tb.CharWidth + 1 ? range.tb.CharWidth / size.Width : 1;  	gr.TranslateTransform (x' y + (1 - k) * range.tb.CharHeight / 2);  	gr.ScaleTransform (k' (float)Math.Sqrt (k));  	gr.DrawString (line [i].c.ToString ()' f' ForeBrush' 0' 0' stringFormat);  	gr.Restore (gs);  	x += dx;  }  
Magic Number,Andi.Libs.FastColoredTextBox,TextStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: gr.TranslateTransform (x' y + (1 - k) * range.tb.CharHeight / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: if (range.End.iChar > range.Start.iChar) {  	base.Draw (gr' position' range);  	int firstNonSpaceSymbolX = position.X;  	//find first non space symbol  	for (int i = range.Start.iChar; i < range.End.iChar; i++)  		if (range.tb [range.Start.iLine] [i].c != ' ')  			break;  		else  			firstNonSpaceSymbolX += range.tb.CharWidth;  	//create marker  	range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (firstNonSpaceSymbolX' position.Y' position.X + (range.End.iChar - range.Start.iChar) * range.tb.CharWidth - firstNonSpaceSymbolX' range.tb.CharHeight)));  }  else {  	//draw '...'  	using (Font f = new Font (range.tb.Font' FontStyle))  		gr.DrawString ("..."' f' ForeBrush' range.tb.LeftIndent' position.Y - 2);  	//create marker  	range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (range.tb.LeftIndent + 2' position.Y' 2 * range.tb.CharHeight' range.tb.CharHeight)));  }  
Magic Number,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: if (range.End.iChar > range.Start.iChar) {  	base.Draw (gr' position' range);  	int firstNonSpaceSymbolX = position.X;  	//find first non space symbol  	for (int i = range.Start.iChar; i < range.End.iChar; i++)  		if (range.tb [range.Start.iLine] [i].c != ' ')  			break;  		else  			firstNonSpaceSymbolX += range.tb.CharWidth;  	//create marker  	range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (firstNonSpaceSymbolX' position.Y' position.X + (range.End.iChar - range.Start.iChar) * range.tb.CharWidth - firstNonSpaceSymbolX' range.tb.CharHeight)));  }  else {  	//draw '...'  	using (Font f = new Font (range.tb.Font' FontStyle))  		gr.DrawString ("..."' f' ForeBrush' range.tb.LeftIndent' position.Y - 2);  	//create marker  	range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (range.tb.LeftIndent + 2' position.Y' 2 * range.tb.CharHeight' range.tb.CharHeight)));  }  
Magic Number,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: if (range.End.iChar > range.Start.iChar) {  	base.Draw (gr' position' range);  	int firstNonSpaceSymbolX = position.X;  	//find first non space symbol  	for (int i = range.Start.iChar; i < range.End.iChar; i++)  		if (range.tb [range.Start.iLine] [i].c != ' ')  			break;  		else  			firstNonSpaceSymbolX += range.tb.CharWidth;  	//create marker  	range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (firstNonSpaceSymbolX' position.Y' position.X + (range.End.iChar - range.Start.iChar) * range.tb.CharWidth - firstNonSpaceSymbolX' range.tb.CharHeight)));  }  else {  	//draw '...'  	using (Font f = new Font (range.tb.Font' FontStyle))  		gr.DrawString ("..."' f' ForeBrush' range.tb.LeftIndent' position.Y - 2);  	//create marker  	range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (range.tb.LeftIndent + 2' position.Y' 2 * range.tb.CharHeight' range.tb.CharHeight)));  }  
Magic Number,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: using (Font f = new Font (range.tb.Font' FontStyle))  	gr.DrawString ("..."' f' ForeBrush' range.tb.LeftIndent' position.Y - 2);  
Magic Number,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: gr.DrawString ("..."' f' ForeBrush' range.tb.LeftIndent' position.Y - 2);  
Magic Number,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (range.tb.LeftIndent + 2' position.Y' 2 * range.tb.CharHeight' range.tb.CharHeight)));  
Magic Number,Andi.Libs.FastColoredTextBox,FoldedBlockStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,Draw,The following statement contains a magic number: range.tb.AddVisualMarker (new FoldedAreaMarker (range.Start.iLine' new Rectangle (range.tb.LeftIndent + 2' position.Y' 2 * range.tb.CharHeight' range.tb.CharHeight)));  
Magic Number,Andi.Libs.FastColoredTextBox,WavyLineStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,DrawWavyLine,The following statement contains a magic number: if (end.X - start.X < 2) {  	graphics.DrawLine (Pen' start' end);  	return;  }  
Magic Number,Andi.Libs.FastColoredTextBox,WavyLineStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,DrawWavyLine,The following statement contains a magic number: for (int i = start.X; i <= end.X; i += 2) {  	points.Add (new Point (i' start.Y + offset));  	offset = -offset;  }  
Magic Number,Andi.Libs.FastColoredTextBox,WavyLineStyle,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\Style.cs,DrawWavyLine,The following statement contains a magic number: i += 2
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,CSharpAutoIndentNeeded,The following statement contains a magic number: if (Regex.IsMatch (args.LineText' @"^\s*(case|default)\b.*:\s*($|//)")) {  	args.Shift = -args.TabLength / 2;  	return;  }  
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,CSharpAutoIndentNeeded,The following statement contains a magic number: args.Shift = -args.TabLength / 2;  
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseColor,The following statement contains a magic number: if (s.StartsWith ("#")) {  	if (s.Length <= 7)  		return Color.FromArgb (255' Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier)));  	else  		return Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier));  }  else  	return Color.FromName (s);  
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseColor,The following statement contains a magic number: if (s.StartsWith ("#")) {  	if (s.Length <= 7)  		return Color.FromArgb (255' Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier)));  	else  		return Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier));  }  else  	return Color.FromName (s);  
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseColor,The following statement contains a magic number: if (s.Length <= 7)  	return Color.FromArgb (255' Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier)));  else  	return Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier));  
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseColor,The following statement contains a magic number: if (s.Length <= 7)  	return Color.FromArgb (255' Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier)));  else  	return Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier));  
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,ParseColor,The following statement contains a magic number: return Color.FromArgb (255' Color.FromArgb (Int32.Parse (s.Substring (1)' NumberStyles.AllowHexSpecifier)));  
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,RestoreBrackets,The following statement contains a magic number: tb.LeftBracket2 = oldBrackets [2];  
Magic Number,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,RestoreBrackets,The following statement contains a magic number: tb.RightBracket2 = oldBrackets [3];  
Magic Number,Andi.Libs.FastColoredTextBox,TextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\TextSource.cs,TextSource,The following statement contains a magic number: if (Enum.GetUnderlyingType (typeof(StyleIndex)) == typeof(UInt32))  	Styles = new Style[32];  else  	Styles = new Style[16];  
Magic Number,Andi.Libs.FastColoredTextBox,TextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\TextSource.cs,TextSource,The following statement contains a magic number: if (Enum.GetUnderlyingType (typeof(StyleIndex)) == typeof(UInt32))  	Styles = new Style[32];  else  	Styles = new Style[16];  
Magic Number,Andi.Libs.FastColoredTextBox,TextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\TextSource.cs,TextSource,The following statement contains a magic number: Styles = new Style[32];  
Magic Number,Andi.Libs.FastColoredTextBox,TextSource,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\TextSource.cs,TextSource,The following statement contains a magic number: Styles = new Style[16];  
Magic Number,Andi.Libs.FastColoredTextBox,UnfocusablePanel,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\UnfocusablePanel.cs,OnPaint,The following statement contains a magic number: using (var brush = new LinearGradientBrush (ClientRectangle' BackColor2' BackColor' 90))  	e.Graphics.FillRectangle (brush' 0' 0' ClientSize.Width - 1' ClientSize.Height - 1);  
Magic Number,Andi.Libs.FastColoredTextBox,UnfocusablePanel,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\UnfocusablePanel.cs,OnPaint,The following statement contains a magic number: if (!string.IsNullOrEmpty (Text)) {  	StringFormat sf = new StringFormat ();  	sf.Alignment = TextAlignment;  	sf.LineAlignment = StringAlignment.Center;  	using (var brush = new SolidBrush (ForeColor))  		e.Graphics.DrawString (Text' Font' brush' new RectangleF (1' 1' ClientSize.Width - 2' ClientSize.Height - 2)' sf);  }  
Magic Number,Andi.Libs.FastColoredTextBox,UnfocusablePanel,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\UnfocusablePanel.cs,OnPaint,The following statement contains a magic number: if (!string.IsNullOrEmpty (Text)) {  	StringFormat sf = new StringFormat ();  	sf.Alignment = TextAlignment;  	sf.LineAlignment = StringAlignment.Center;  	using (var brush = new SolidBrush (ForeColor))  		e.Graphics.DrawString (Text' Font' brush' new RectangleF (1' 1' ClientSize.Width - 2' ClientSize.Height - 2)' sf);  }  
Magic Number,Andi.Libs.FastColoredTextBox,UnfocusablePanel,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\UnfocusablePanel.cs,OnPaint,The following statement contains a magic number: using (var brush = new SolidBrush (ForeColor))  	e.Graphics.DrawString (Text' Font' brush' new RectangleF (1' 1' ClientSize.Width - 2' ClientSize.Height - 2)' sf);  
Magic Number,Andi.Libs.FastColoredTextBox,UnfocusablePanel,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\UnfocusablePanel.cs,OnPaint,The following statement contains a magic number: using (var brush = new SolidBrush (ForeColor))  	e.Graphics.DrawString (Text' Font' brush' new RectangleF (1' 1' ClientSize.Width - 2' ClientSize.Height - 2)' sf);  
Magic Number,Andi.Libs.FastColoredTextBox,UnfocusablePanel,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\UnfocusablePanel.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawString (Text' Font' brush' new RectangleF (1' 1' ClientSize.Width - 2' ClientSize.Height - 2)' sf);  
Magic Number,Andi.Libs.FastColoredTextBox,UnfocusablePanel,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\UnfocusablePanel.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawString (Text' Font' brush' new RectangleF (1' 1' ClientSize.Width - 2' ClientSize.Height - 2)' sf);  
Magic Number,Andi.Libs.FastColoredTextBox,CollapseFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (pen' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,CollapseFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (pen' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,CollapseFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (pen' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,CollapseFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (pen' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (Pens.Red' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (Pens.Red' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (Pens.Red' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (Pens.Red' rectangle.Left + 2' rectangle.Top + rectangle.Height / 2' rectangle.Right - 2' rectangle.Top + rectangle.Height / 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (Pens.Red' rectangle.Left + rectangle.Width / 2' rectangle.Top + 2' rectangle.Left + rectangle.Width / 2' rectangle.Bottom - 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (Pens.Red' rectangle.Left + rectangle.Width / 2' rectangle.Top + 2' rectangle.Left + rectangle.Width / 2' rectangle.Bottom - 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (Pens.Red' rectangle.Left + rectangle.Width / 2' rectangle.Top + 2' rectangle.Left + rectangle.Width / 2' rectangle.Bottom - 2);  
Magic Number,Andi.Libs.FastColoredTextBox,ExpandFoldingMarker,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\VisualMarker.cs,Draw,The following statement contains a magic number: gr.DrawLine (Pens.Red' rectangle.Left + rectangle.Width / 2' rectangle.Top + 2' rectangle.Left + rectangle.Width / 2' rectangle.Bottom - 2);  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,HexBox,The following statement contains a magic number: _thumbTrackTimer.Interval = 50;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,ToScrollPos,The following statement contains a magic number: if (_scrollVmax < max)  	return (int)value;  else {  	double valperc = (double)value / (double)_scrollVmax * (double)100;  	int res = (int)Math.Floor ((double)max / (double)100 * valperc);  	res = (int)Math.Max (_scrollVmin' res);  	res = (int)Math.Min (_scrollVmax' res);  	return res;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,ToScrollPos,The following statement contains a magic number: if (_scrollVmax < max)  	return (int)value;  else {  	double valperc = (double)value / (double)_scrollVmax * (double)100;  	int res = (int)Math.Floor ((double)max / (double)100 * valperc);  	res = (int)Math.Max (_scrollVmin' res);  	res = (int)Math.Min (_scrollVmax' res);  	return res;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,FromScrollPos,The following statement contains a magic number: if (_scrollVmax < max) {  	return (long)value;  }  else {  	double valperc = (double)value / (double)max * (double)100;  	long res = (int)Math.Floor ((double)_scrollVmax / (double)100 * valperc);  	return res;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,FromScrollPos,The following statement contains a magic number: if (_scrollVmax < max) {  	return (long)value;  }  else {  	double valperc = (double)value / (double)max * (double)100;  	long res = (int)Math.Floor ((double)_scrollVmax / (double)100 * valperc);  	return res;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,GetHexBytePositionInfo,The following statement contains a magic number: byteCharaterPos = (iX % 3);  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,Find,The following statement contains a magic number: for (long pos = startIndex; pos < _byteProvider.Length; pos++) {  	if (_abortFind)  		return -2;  	if (pos % 1000 == 0)  		// for performance reasons: DoEvents only 1 times per 1000 loops  		Application.DoEvents ();  	byte compareByte = _byteProvider.ReadByte (pos);  	bool buffer1Match = compareByte == buffer1 [match];  	bool hasBuffer2 = buffer2 != null;  	bool buffer2Match = hasBuffer2 ? compareByte == buffer2 [match] : false;  	bool isMatch = buffer1Match || buffer2Match;  	if (!isMatch) {  		pos -= match;  		match = 0;  		_findingPos = pos;  		continue;  	}  	match++;  	if (match == buffer1Length) {  		long bytePos = pos - buffer1Length + 1;  		Select (bytePos' buffer1Length);  		ScrollByteIntoView (_bytePos + _selectionLength);  		ScrollByteIntoView (_bytePos);  		return bytePos;  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,Find,The following statement contains a magic number: for (long pos = startIndex; pos < _byteProvider.Length; pos++) {  	if (_abortFind)  		return -2;  	if (pos % 1000 == 0)  		// for performance reasons: DoEvents only 1 times per 1000 loops  		Application.DoEvents ();  	byte compareByte = _byteProvider.ReadByte (pos);  	bool buffer1Match = compareByte == buffer1 [match];  	bool hasBuffer2 = buffer2 != null;  	bool buffer2Match = hasBuffer2 ? compareByte == buffer2 [match] : false;  	bool isMatch = buffer1Match || buffer2Match;  	if (!isMatch) {  		pos -= match;  		match = 0;  		_findingPos = pos;  		continue;  	}  	match++;  	if (match == buffer1Length) {  		long bytePos = pos - buffer1Length + 1;  		Select (bytePos' buffer1Length);  		ScrollByteIntoView (_bytePos + _selectionLength);  		ScrollByteIntoView (_bytePos);  		return bytePos;  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,Find,The following statement contains a magic number: if (_abortFind)  	return -2;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,Find,The following statement contains a magic number: return -2;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,Find,The following statement contains a magic number: if (pos % 1000 == 0)  	// for performance reasons: DoEvents only 1 times per 1000 loops  	Application.DoEvents ();  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++) {  	long firstLineByte = (startByte + (_iHexMaxHBytes) * i) + _lineInfoOffset;  	PointF bytePointF = GetBytePointF (new Point (0' 0 + i));  	string info = firstLineByte.ToString (_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  	int nulls = 8 - info.Length;  	string formattedInfo;  	if (nulls > -1) {  		formattedInfo = new string ('0'' 8 - info.Length) + info;  	}  	else {  		formattedInfo = new string ('~'' 8);  	}  	g.DrawString (formattedInfo' Font' brush' new PointF (_recLineInfo.X' bytePointF.Y)' _stringFormat);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++) {  	long firstLineByte = (startByte + (_iHexMaxHBytes) * i) + _lineInfoOffset;  	PointF bytePointF = GetBytePointF (new Point (0' 0 + i));  	string info = firstLineByte.ToString (_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  	int nulls = 8 - info.Length;  	string formattedInfo;  	if (nulls > -1) {  		formattedInfo = new string ('0'' 8 - info.Length) + info;  	}  	else {  		formattedInfo = new string ('~'' 8);  	}  	g.DrawString (formattedInfo' Font' brush' new PointF (_recLineInfo.X' bytePointF.Y)' _stringFormat);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++) {  	long firstLineByte = (startByte + (_iHexMaxHBytes) * i) + _lineInfoOffset;  	PointF bytePointF = GetBytePointF (new Point (0' 0 + i));  	string info = firstLineByte.ToString (_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  	int nulls = 8 - info.Length;  	string formattedInfo;  	if (nulls > -1) {  		formattedInfo = new string ('0'' 8 - info.Length) + info;  	}  	else {  		formattedInfo = new string ('~'' 8);  	}  	g.DrawString (formattedInfo' Font' brush' new PointF (_recLineInfo.X' bytePointF.Y)' _stringFormat);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: if (nulls > -1) {  	formattedInfo = new string ('0'' 8 - info.Length) + info;  }  else {  	formattedInfo = new string ('~'' 8);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: if (nulls > -1) {  	formattedInfo = new string ('0'' 8 - info.Length) + info;  }  else {  	formattedInfo = new string ('~'' 8);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: formattedInfo = new string ('0'' 8 - info.Length) + info;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: formattedInfo = new string ('~'' 8);  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintColumnSeparator,The following statement contains a magic number: for (int col = GroupSize; col < _iHexMaxHBytes; col += GroupSize) {  	var pen = new Pen (new SolidBrush (this.InfoForeColor)' 1);  	PointF headerPointF = GetColumnInfoPointF (col);  	headerPointF.X -= _charSize.Width / 2;  	g.DrawLine (pen' headerPointF' new PointF (headerPointF.X' headerPointF.Y + _recColumnInfo.Height + _recHex.Height));  	if (StringViewVisible) {  		PointF byteStringPointF = GetByteStringPointF (new Point (col' 0));  		headerPointF.X -= 2;  		g.DrawLine (pen' new PointF (byteStringPointF.X' byteStringPointF.Y)' new PointF (byteStringPointF.X' byteStringPointF.Y + _recHex.Height));  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintColumnSeparator,The following statement contains a magic number: for (int col = GroupSize; col < _iHexMaxHBytes; col += GroupSize) {  	var pen = new Pen (new SolidBrush (this.InfoForeColor)' 1);  	PointF headerPointF = GetColumnInfoPointF (col);  	headerPointF.X -= _charSize.Width / 2;  	g.DrawLine (pen' headerPointF' new PointF (headerPointF.X' headerPointF.Y + _recColumnInfo.Height + _recHex.Height));  	if (StringViewVisible) {  		PointF byteStringPointF = GetByteStringPointF (new Point (col' 0));  		headerPointF.X -= 2;  		g.DrawLine (pen' new PointF (byteStringPointF.X' byteStringPointF.Y)' new PointF (byteStringPointF.X' byteStringPointF.Y + _recHex.Height));  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintColumnSeparator,The following statement contains a magic number: headerPointF.X -= _charSize.Width / 2;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintColumnSeparator,The following statement contains a magic number: if (StringViewVisible) {  	PointF byteStringPointF = GetByteStringPointF (new Point (col' 0));  	headerPointF.X -= 2;  	g.DrawLine (pen' new PointF (byteStringPointF.X' byteStringPointF.Y)' new PointF (byteStringPointF.X' byteStringPointF.Y + _recHex.Height));  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintColumnSeparator,The following statement contains a magic number: headerPointF.X -= 2;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine == 0) {  	Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (singleLine.IntersectsWith (_recHex)) {  		singleLine.Intersect (_recHex);  		PaintCurrentByteSign (g' singleLine);  	}  }  else {  	Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (firstLine.IntersectsWith (_recHex)) {  		firstLine.Intersect (_recHex);  		PaintCurrentByteSign (g' firstLine);  	}  	if (multiLine > 1) {  		Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  		if (betweenLines.IntersectsWith (_recHex)) {  			betweenLines.Intersect (_recHex);  			PaintCurrentByteSign (g' betweenLines);  		}  	}  	Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (lastLine.IntersectsWith (_recHex)) {  		lastLine.Intersect (_recHex);  		PaintCurrentByteSign (g' lastLine);  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine == 0) {  	Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (singleLine.IntersectsWith (_recHex)) {  		singleLine.Intersect (_recHex);  		PaintCurrentByteSign (g' singleLine);  	}  }  else {  	Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (firstLine.IntersectsWith (_recHex)) {  		firstLine.Intersect (_recHex);  		PaintCurrentByteSign (g' firstLine);  	}  	if (multiLine > 1) {  		Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  		if (betweenLines.IntersectsWith (_recHex)) {  			betweenLines.Intersect (_recHex);  			PaintCurrentByteSign (g' betweenLines);  		}  	}  	Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (lastLine.IntersectsWith (_recHex)) {  		lastLine.Intersect (_recHex);  		PaintCurrentByteSign (g' lastLine);  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine == 0) {  	Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (singleLine.IntersectsWith (_recHex)) {  		singleLine.Intersect (_recHex);  		PaintCurrentByteSign (g' singleLine);  	}  }  else {  	Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (firstLine.IntersectsWith (_recHex)) {  		firstLine.Intersect (_recHex);  		PaintCurrentByteSign (g' firstLine);  	}  	if (multiLine > 1) {  		Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  		if (betweenLines.IntersectsWith (_recHex)) {  			betweenLines.Intersect (_recHex);  			PaintCurrentByteSign (g' betweenLines);  		}  	}  	Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (lastLine.IntersectsWith (_recHex)) {  		lastLine.Intersect (_recHex);  		PaintCurrentByteSign (g' lastLine);  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine == 0) {  	Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (singleLine.IntersectsWith (_recHex)) {  		singleLine.Intersect (_recHex);  		PaintCurrentByteSign (g' singleLine);  	}  }  else {  	Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (firstLine.IntersectsWith (_recHex)) {  		firstLine.Intersect (_recHex);  		PaintCurrentByteSign (g' firstLine);  	}  	if (multiLine > 1) {  		Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  		if (betweenLines.IntersectsWith (_recHex)) {  			betweenLines.Intersect (_recHex);  			PaintCurrentByteSign (g' betweenLines);  		}  	}  	Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (lastLine.IntersectsWith (_recHex)) {  		lastLine.Intersect (_recHex);  		PaintCurrentByteSign (g' lastLine);  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine > 1) {  	Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  	if (betweenLines.IntersectsWith (_recHex)) {  		betweenLines.Intersect (_recHex);  		PaintCurrentByteSign (g' betweenLines);  	}  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: using (var graphics = this.CreateGraphics ()) {  	charSize = this.CreateGraphics ().MeasureString ("A"' Font' 100' _stringFormat);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: charSize = this.CreateGraphics ().MeasureString ("A"' Font' 100' _stringFormat);  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_lineInfoVisible) {  	_recLineInfo = new Rectangle (_recContent.X + marginLeft' _recContent.Y' (int)(_charSize.Width * 10)' _recContent.Height);  	requiredWidth += _recLineInfo.Width;  }  else {  	_recLineInfo = Rectangle.Empty;  	_recLineInfo.X = marginLeft;  	requiredWidth += marginLeft;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recLineInfo = new Rectangle (_recContent.X + marginLeft' _recContent.Y' (int)(_charSize.Width * 10)' _recContent.Height);  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recColumnInfo = new Rectangle (_recLineInfo.X + _recLineInfo.Width' _recContent.Y' _recContent.Width - _recLineInfo.Width' (int)charSize.Height + 4);  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_columnInfoVisible) {  	_recLineInfo.Y += (int)charSize.Height + 4;  	_recLineInfo.Height -= (int)charSize.Height + 4;  }  else {  	_recColumnInfo.Height = 0;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_columnInfoVisible) {  	_recLineInfo.Y += (int)charSize.Height + 4;  	_recLineInfo.Height -= (int)charSize.Height + 4;  }  else {  	_recColumnInfo.Height = 0;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recLineInfo.Y += (int)charSize.Height + 4;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recLineInfo.Height -= (int)charSize.Height + 4;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (_stringViewVisible) {  		hmax -= 2;  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  		else  			SetHorizontalByteCount (1);  	}  	else {  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  		else  			SetHorizontalByteCount (1);  	}  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (_stringViewVisible) {  		hmax -= 2;  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  		else  			SetHorizontalByteCount (1);  	}  	else {  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  		else  			SetHorizontalByteCount (1);  	}  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (_stringViewVisible) {  		hmax -= 2;  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  		else  			SetHorizontalByteCount (1);  	}  	else {  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  		else  			SetHorizontalByteCount (1);  	}  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (_stringViewVisible) {  		hmax -= 2;  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  		else  			SetHorizontalByteCount (1);  	}  	else {  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  		else  			SetHorizontalByteCount (1);  	}  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (_stringViewVisible) {  		hmax -= 2;  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  		else  			SetHorizontalByteCount (1);  	}  	else {  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  		else  			SetHorizontalByteCount (1);  	}  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (_stringViewVisible) {  		hmax -= 2;  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  		else  			SetHorizontalByteCount (1);  	}  	else {  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  		else  			SetHorizontalByteCount (1);  	}  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (_stringViewVisible) {  		hmax -= 2;  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  		else  			SetHorizontalByteCount (1);  	}  	else {  		if (hmax > 1)  			SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  		else  			SetHorizontalByteCount (1);  	}  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  	requiredWidth += _recHex.Width;  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_stringViewVisible) {  	hmax -= 2;  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  	else  		SetHorizontalByteCount (1);  }  else {  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  	else  		SetHorizontalByteCount (1);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_stringViewVisible) {  	hmax -= 2;  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  	else  		SetHorizontalByteCount (1);  }  else {  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  	else  		SetHorizontalByteCount (1);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_stringViewVisible) {  	hmax -= 2;  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  	else  		SetHorizontalByteCount (1);  }  else {  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  	else  		SetHorizontalByteCount (1);  }  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: hmax -= 2;  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (hmax > 1)  	SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  else  	SetHorizontalByteCount (1);  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 4));  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (hmax > 1)  	SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  else  	SetHorizontalByteCount (1);  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  
Magic Number,Andi.Libs.HexBox,HexBox,C:\repos\andibadra_ANDT\Andi.Libs\HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  	// We can defer the modulo operation:  	// s1 maximally grows from 65521 to 65521 + 255 * 3800  	// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  	int n = 3800;  	if (n > count) {  		n = count;  	}  	count -= n;  	while (--n >= 0) {  		s1 = s1 + (uint)(buffer [offset++] & 0xff);  		s2 = s2 + s1;  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\CRC32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.CrcTable [(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ value) & 0xFF] ^ (crc >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\CRC32.cs,Update,The following statement contains a magic number: while (--count >= 0) {  	crc = CrcTable [(crc ^ buffer [offset++]) & 0xFF] ^ (crc >> 8);  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ buffer [offset++]) & 0xFF] ^ (crc >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: if (temp < 0) {  	temp = 256 + temp;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: temp = 256 + temp;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table [temp]));  
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  	throw new ArgumentException ("Buffer is too small"' "buffer");  }  
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  	throw new ArgumentException ("Buffer is too small"' "buffer");  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  	int index = 2;  	int elements = 2;  	// Scan for two separate elements \\machine\share\restofpath  	while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  		index++;  	}  	index++;  	if (index < path.Length) {  		result = path.Substring (index);  	}  	else {  		result = "";  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  	int index = 2;  	int elements = 2;  	// Scan for two separate elements \\machine\share\restofpath  	while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  		index++;  	}  	index++;  	if (index < path.Length) {  		result = path.Substring (index);  	}  	else {  		result = "";  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: dropCount = 3;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [1] = newKeys [1] * 134775813 + 1;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [1] = (byte)((newKeys [0] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [2] = (byte)((newKeys [0] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [2] = (byte)((newKeys [0] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [3] = (byte)((newKeys [0] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [3] = (byte)((newKeys [0] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [4] = (byte)(newKeys [1] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [5] = (byte)((newKeys [1] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [5] = (byte)((newKeys [1] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [6] = (byte)((newKeys [1] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [6] = (byte)((newKeys [1] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [7] = (byte)((newKeys [1] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [7] = (byte)((newKeys [1] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [8] = (byte)(newKeys [2] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [8] = (byte)(newKeys [2] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: return (byte)((temp * (temp ^ 1)) >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: if (keyData.Length != 12) {  	throw new InvalidOperationException ("Key length is not valid");  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys = new uint[3];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [1] = keys [1] * 134775813 + 1;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,Reset,The following statement contains a magic number: keys [2] = 0;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicManaged,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKey,The following statement contains a magic number: key_ = new byte[12];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESStream.cs,ZipAESStream,The following statement contains a magic number: _slideBuffer = new byte[1024];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32)  	// 24 valid for AES but not supported by Winzip  	throw new Exception ("Invalid blocksize " + blockSize + ". Must be 16 or 32.");  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32)  	// 24 valid for AES but not supported by Winzip  	throw new Exception ("Invalid blocksize " + blockSize + ". Must be 16 or 32.");  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize / 2)  	throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize / 2)  	throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: level = 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: level = 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header |= level_flags << 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if ((state & IS_SETDICT) != 0) {  	int chksum = engine.Adler;  	engine.ResetAdler ();  	pending.WriteShortMSB (chksum >> 16);  	pending.WriteShortMSB (chksum & 0xffff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (chksum >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: neededbits -= 10;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!noZlibHeaderOrFooter) {  	int adler = engine.Adler;  	pending.WriteShortMSB (adler >> 16);  	pending.WriteShortMSB (adler & 0xffff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (adler >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following statement contains a magic number: if ((level < 0) || (level > 9)) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd) {  	int more = 2 * WSIZE - lookahead - strstart;  	if (more > inputEnd - inputOff) {  		more = inputEnd - inputOff;  	}  	System.Array.Copy (inputBuf' inputOff' window' strstart + lookahead' more);  	adler.Update (inputBuf' inputOff' more);  	inputOff += more;  	totalIn += more;  	lookahead += more;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= this.goodLength) {  	chainLength >>= 2;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: chainLength >>= 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	#if DebugDeflation  	 				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) ) 				{ 					throw new InvalidOperationException("no future"); 				} #endif  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) {  		// Do nothing  	}  	if (scan > best_end) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && (ins_h == 0) ) 						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart)); #endif  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	#if DebugDeflation  	 				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) ) 				{ 					throw new InvalidOperationException("no future"); 				} #endif  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) {  		// Do nothing  	}  	if (scan > best_end) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && (ins_h == 0) ) 						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart)); #endif  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: match = curMatch + 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: scan += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		// We are flushing everything  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int hashHead;  	if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		// longestMatch sets matchStart and matchLen  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 						for (int i = 0 ; i < matchLen; i++) { 							if (window[strstart + i] != window[matchStart + i]) { 								throw new SharpZipBaseException("Match failure"); 							} 						} 					} #endif  		bool full = huffman.TallyDist (strstart - matchStart' matchLen);  		lookahead -= matchLen;  		if (matchLen <= max_lazy && lookahead >= MIN_MATCH) {  			while (--matchLen > 0) {  				++strstart;  				InsertString ();  			}  			++strstart;  		}  		else {  			strstart += matchLen;  			if (lookahead >= MIN_MATCH - 1) {  				UpdateHash ();  			}  		}  		matchLen = MIN_MATCH - 1;  		if (!full) {  			continue;  		}  	}  	else {  		// No match found  		huffman.TallyLit (window [strstart] & 0xff);  		++strstart;  		--lookahead;  	}  	if (huffman.IsFull ()) {  		bool lastBlock = finish && (lookahead == 0);  		huffman.FlushBlock (window' blockStart' strstart - blockStart' lastBlock);  		blockStart = strstart;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (lookahead >= MIN_MATCH) {  	int hashHead = InsertString ();  	if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		// longestMatch sets matchStart and matchLen  		// Discard match if too small and too far away  		if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  			matchLen = MIN_MATCH - 1;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  	// longestMatch sets matchStart and matchLen  	// Discard match if too small and too far away  	if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  		matchLen = MIN_MATCH - 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  	matchLen = MIN_MATCH - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  	#if DebugDeflation  						if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  	huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  	prevLen -= 2;  	do {  		strstart++;  		lookahead--;  		if (lookahead >= MIN_MATCH) {  			InsertString ();  		}  	}  	while (--prevLen > 0);  	strstart++;  	lookahead--;  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  }  else {  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	prevAvailable = true;  	strstart++;  	lookahead--;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: prevLen -= 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x030 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDCodes [i] = BitReverse (i << 11);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDLength [i] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree (this' DIST_NUM' 1' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (distTree.numCodes - 1' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++) {  	pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (bits > 0 && bits <= 5) {  	pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: bits = dc / 2 - 1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--) {  	if (blTree.length [BL_ORDER [i]] > 0) {  		blTreeCodes = i + 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf [last_lit++] = (byte)(length - 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += dc / 2 - 1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  	return 285;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  	return 285;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: return 285;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  	code += 4;  	length >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  	code += 4;  	length >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: code += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: code += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  	throw new SharpZipBaseException ("Header checksum illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8)) {  	throw new SharpZipBaseException ("Compression Method unknown");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) {  	// Dictionary flag?  	mode = DECODE_BLOCKS;  }  else {  	mode = DECODE_DICT;  	neededBits = 32;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: readAdler = (readAdler << 8) | dictByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  	outputWindow.Write (symbol);  	if (--free < 258) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (--free < 258) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (symbol < 257) {  	if (symbol < 0) {  		return false;  	}  	else {  		// symbol == 256: end of block  		distTree = null;  		litlenTree = null;  		mode = DECODE_BLOCKS;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: repLength = CPLENS [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: neededBits = CPLEXT [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: readAdler = (readAdler << 8) | chkByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (isLastBlock) {  	if (noHeader) {  		mode = FINISHED;  		return false;  	}  	else {  		input.SkipToByteBoundary ();  		neededBits = 32;  		mode = DECODE_CHKSUM;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (noHeader) {  	mode = FINISHED;  	return false;  }  else {  	input.SkipToByteBoundary ();  	neededBits = 32;  	mode = DECODE_CHKSUM;  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if ((uncomprLen = input.PeekBits (16)) < 0) {  	return false;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum += 257;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: dnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum = input.PeekBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blLens = new byte[19];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  	/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  	litdistLens [ptr++] = lastLen = (byte)symbol;  	if (ptr == num) {  		/* Finished */return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: if (symbol >= 17) {  	/* repeat zero *///  		  System.err.println("repeating zero");  	lastLen = 0;  }  else {  	if (ptr == 0) {  		throw new SharpZipBaseException ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: repSymbol = symbol - 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths = new byte[32];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code += blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treeSize += (end - start) >> (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code -= blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: i += 1 << 7
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treePtr += 1 << (bits - 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [revcode] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: subTree = -(subTree >> 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: nextCode [bits] = code + (1 << (16 - bits));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buffer_ [end++] = unchecked((byte)bits);  	if (bitCount > 8) {  		buffer_ [end++] = unchecked((byte)(bits >> 8));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buffer_ [end++] = unchecked((byte)bits);  	if (bitCount > 8) {  		buffer_ [end++] = unchecked((byte)(bits >> 8));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buffer_ [end++] = unchecked((byte)(bits >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buffer_ [end++] = unchecked((byte)(bits >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(bits >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(bits >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bits >>= 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bitCount -= 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(s >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bits >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bitCount -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,DeflaterOutputStream,The following statement contains a magic number: if (bufferSize < 512) {  	throw new ArgumentOutOfRangeException ("bufferSize");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  	bufferSize = 1024;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  	bufferSize = 1024;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: bufferSize = 1024;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte () | (ReadLeByte () << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort () | (ReadLeShort () << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeLong,The following statement contains a magic number: return (uint)ReadLeInt () | ((long)ReadLeInt () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,Skip,The following statement contains a magic number: if (baseInputStream.CanSeek) {  	baseInputStream.Seek (count' SeekOrigin.Current);  	return count;  }  else {  	int length = 2048;  	if (count < length) {  		length = (int)count;  	}  	byte[] tmp = new byte[length];  	int readCount = 1;  	long toSkip = count;  	while ((toSkip > 0) && (readCount > 0)) {  		if (toSkip < length) {  			length = (int)toSkip;  		}  		readCount = baseInputStream.Read (tmp' 0' length);  		toSkip -= readCount;  	}  	return count - toSkip;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: bitsInBuffer_ += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  	// bits_in_buffer may only be 0 or a multiple of 8  	throw new InvalidOperationException ("Bit buffer is not byte aligned!");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: buffer_ >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  	// We always want an even number of bytes in input' see peekBits  	buffer_ = (uint)(window_ [windowStart_++] & 0xff);  	bitsInBuffer_ = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  	// We always want an even number of bytes in input' see PeekBits  	buffer_ |= (uint)((buffer [offset++] & 0xff) << bitsInBuffer_);  	bitsInBuffer_ += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: bitsInBuffer_ += 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: if (buffer_ == null) {  	buffer_ = new byte[4096];  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: buffer_ = new byte[4096];  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (proceed) {  	if (events_ != null) {  		continueRunning_ = events_.OnProcessFile (entry.Name);  	}  	if (continueRunning_) {  		try {  			using (FileStream outputStream = File.Create (targetName)) {  				if (buffer_ == null) {  					buffer_ = new byte[4096];  				}  				if ((events_ != null) && (events_.Progress != null)) {  					StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  				}  				else {  					StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  				}  				if (events_ != null) {  					continueRunning_ = events_.OnCompletedFile (entry.Name);  				}  			}  			#if !NETCF_1_0 && !NETCF_2_0  			if (restoreDateTimeOnExtract_) {  				File.SetLastWriteTime (targetName' entry.DateTime);  			}  			if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1)) {  				FileAttributes fileAttributes = (FileAttributes)entry.ExternalFileAttributes;  				// TODO: FastZip - Setting of other file attributes on extraction is a little trickier.  				fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);  				File.SetAttributes (targetName' fileAttributes);  			}  			#endif  		}  		catch (Exception ex) {  			if (events_ != null) {  				continueRunning_ = events_.OnFileFailure (targetName' ex);  			}  			else {  				continueRunning_ = false;  				throw;  			}  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (continueRunning_) {  	try {  		using (FileStream outputStream = File.Create (targetName)) {  			if (buffer_ == null) {  				buffer_ = new byte[4096];  			}  			if ((events_ != null) && (events_.Progress != null)) {  				StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  			}  			else {  				StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  			}  			if (events_ != null) {  				continueRunning_ = events_.OnCompletedFile (entry.Name);  			}  		}  		#if !NETCF_1_0 && !NETCF_2_0  		if (restoreDateTimeOnExtract_) {  			File.SetLastWriteTime (targetName' entry.DateTime);  		}  		if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1)) {  			FileAttributes fileAttributes = (FileAttributes)entry.ExternalFileAttributes;  			// TODO: FastZip - Setting of other file attributes on extraction is a little trickier.  			fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);  			File.SetAttributes (targetName' fileAttributes);  		}  		#endif  	}  	catch (Exception ex) {  		if (events_ != null) {  			continueRunning_ = events_.OnFileFailure (targetName' ex);  		}  		else {  			continueRunning_ = false;  			throw;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: try {  	using (FileStream outputStream = File.Create (targetName)) {  		if (buffer_ == null) {  			buffer_ = new byte[4096];  		}  		if ((events_ != null) && (events_.Progress != null)) {  			StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  		}  		else {  			StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  		}  		if (events_ != null) {  			continueRunning_ = events_.OnCompletedFile (entry.Name);  		}  	}  	#if !NETCF_1_0 && !NETCF_2_0  	if (restoreDateTimeOnExtract_) {  		File.SetLastWriteTime (targetName' entry.DateTime);  	}  	if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1)) {  		FileAttributes fileAttributes = (FileAttributes)entry.ExternalFileAttributes;  		// TODO: FastZip - Setting of other file attributes on extraction is a little trickier.  		fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);  		File.SetAttributes (targetName' fileAttributes);  	}  	#endif  }  catch (Exception ex) {  	if (events_ != null) {  		continueRunning_ = events_.OnFileFailure (targetName' ex);  	}  	else {  		continueRunning_ = false;  		throw;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: using (FileStream outputStream = File.Create (targetName)) {  	if (buffer_ == null) {  		buffer_ = new byte[4096];  	}  	if ((events_ != null) && (events_.Progress != null)) {  		StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  	}  	else {  		StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  	}  	if (events_ != null) {  		continueRunning_ = events_.OnCompletedFile (entry.Name);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (buffer_ == null) {  	buffer_ = new byte[4096];  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: buffer_ = new byte[4096];  
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 2] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 3] = ':';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ZipEntry,The following statement contains a magic number: if ((versionRequiredToExtract != 0) && (versionRequiredToExtract < 10)) {  	throw new ArgumentOutOfRangeException ("versionRequiredToExtract");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x0001)) {  	// Version required to extract is ignored here as some archivers dont set it correctly  	// in theory it should be version 45 or higher  	// The recorded size will change but remember that this is zip64.  	forceZip64_ = true;  	if (extraData.ValueLength < 4) {  		throw new ZipException ("Extra data extended Zip64 information length is invalid");  	}  	if (localHeader || (size == uint.MaxValue)) {  		size = (ulong)extraData.ReadLong ();  	}  	if (localHeader || (compressedSize == uint.MaxValue)) {  		compressedSize = (ulong)extraData.ReadLong ();  	}  	if (!localHeader && (offset == uint.MaxValue)) {  		offset = extraData.ReadLong ();  	}  	// Disk number on which file starts is ignored  }  else {  	if (((versionToExtract & 0xff) >= ZipConstants.VersionZip64) && ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))) {  		throw new ZipException ("Zip64 Extended information required but is missing.");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.ValueLength < 4) {  	throw new ZipException ("Extra data extended Zip64 information length is invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.ValueLength < 4) {  	throw new ZipException ("NTFS Extra data invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: while (extraData.UnreadCount >= 4) {  	int ntfsTag = extraData.ReadShort ();  	int ntfsLength = extraData.ReadShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModification = extraData.ReadLong ();  			long lastAccess = extraData.ReadLong ();  			long createTime = extraData.ReadLong ();  			DateTime = System.DateTime.FromFileTime (lastModification);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		extraData.Skip (ntfsLength);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: while (extraData.UnreadCount >= 4) {  	int ntfsTag = extraData.ReadShort ();  	int ntfsLength = extraData.ReadShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModification = extraData.ReadLong ();  			long lastAccess = extraData.ReadLong ();  			long createTime = extraData.ReadLong ();  			DateTime = System.DateTime.FromFileTime (lastModification);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		extraData.Skip (ntfsLength);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (ntfsTag == 1) {  	if (ntfsLength >= 24) {  		long lastModification = extraData.ReadLong ();  		long lastAccess = extraData.ReadLong ();  		long createTime = extraData.ReadLong ();  		DateTime = System.DateTime.FromFileTime (lastModification);  	}  	break;  }  else {  	// An unknown NTFS tag so simply skip it.  	extraData.Skip (ntfsLength);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (ntfsLength >= 24) {  	long lastModification = extraData.ReadLong ();  	long lastAccess = extraData.ReadLong ();  	long createTime = extraData.ReadLong ();  	DateTime = System.DateTime.FromFileTime (lastModification);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (((flags & 1) != 0) && (length >= 5)) {  	int iTime = extraData.ReadInt ();  	DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (((flags & 1) != 0) && (length >= 5)) {  	int iTime = extraData.ReadInt ();  	DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (extraData.Find (0x9901)) {  	// Set version and flag for Zipfile.CreateAndInitDecryptionStream  	versionToExtract = ZipConstants.VERSION_AES;  	// Ver 5.1 = AES see "Version" getter  	// Set StrongEncryption flag for ZipFile.CreateAndInitDecryptionStream  	Flags = Flags | (int)GeneralBitFlags.StrongEncryption;  	//  	// Unpack AES extra data field see http://www.winzip.com/aes_info.htm  	int length = extraData.ValueLength;  	// Data size currently 7  	if (length < 7)  		throw new ZipException ("AES Extra Data Length " + length + " invalid.");  	int ver = extraData.ReadShort ();  	// Version number (1=AE-1 2=AE-2)  	int vendorId = extraData.ReadShort ();  	// 2-character vendor ID 0x4541 = "AE"  	int encrStrength = extraData.ReadByte ();  	// encryption strength 1 = 128 2 = 192 3 = 256  	int actualCompress = extraData.ReadShort ();  	// The actual compression method used to compress the file  	_aesVer = ver;  	_aesEncryptionStrength = encrStrength;  	method = (CompressionMethod)actualCompress;  }  else  	throw new ZipException ("AES Extra Data missing");  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (length < 7)  	throw new ZipException ("AES Extra Data Length " + length + " invalid.");  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,The following statement contains a magic number: externalAttributes |= (setAttributes_ | 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  	int iTime = helperStream.ReadLEInt ();  	_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  	int iTime = helperStream.ReadLEInt ();  	_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if ((_flags & Flags.AccessTime) != 0) {  	int iTime = helperStream.ReadLEInt ();  	_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if ((_flags & Flags.CreateTime) != 0) {  	int iTime = helperStream.ReadLEInt ();  	_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.ModificationTime) != 0) {  	TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.AccessTime) != 0) {  	TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.CreateTime) != 0) {  	TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.ReadLEInt ();  		// Reserved  		while (helperStream.Position < helperStream.Length) {  			int ntfsTag = helperStream.ReadLEShort ();  			int ntfsLength = helperStream.ReadLEShort ();  			if (ntfsTag == 1) {  				if (ntfsLength >= 24) {  					long lastModificationTicks = helperStream.ReadLELong ();  					_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  					long lastAccessTicks = helperStream.ReadLELong ();  					_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  					long createTimeTicks = helperStream.ReadLELong ();  					_createTime = DateTime.FromFileTime (createTimeTicks);  				}  				break;  			}  			else {  				// An unknown NTFS tag so simply skip it.  				helperStream.Seek (ntfsLength' SeekOrigin.Current);  			}  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.ReadLEInt ();  	// Reserved  	while (helperStream.Position < helperStream.Length) {  		int ntfsTag = helperStream.ReadLEShort ();  		int ntfsLength = helperStream.ReadLEShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModificationTicks = helperStream.ReadLELong ();  				_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  				long lastAccessTicks = helperStream.ReadLELong ();  				_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  				long createTimeTicks = helperStream.ReadLELong ();  				_createTime = DateTime.FromFileTime (createTimeTicks);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			helperStream.Seek (ntfsLength' SeekOrigin.Current);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: while (helperStream.Position < helperStream.Length) {  	int ntfsTag = helperStream.ReadLEShort ();  	int ntfsLength = helperStream.ReadLEShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModificationTicks = helperStream.ReadLELong ();  			_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  			long lastAccessTicks = helperStream.ReadLELong ();  			_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  			long createTimeTicks = helperStream.ReadLELong ();  			_createTime = DateTime.FromFileTime (createTimeTicks);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		helperStream.Seek (ntfsLength' SeekOrigin.Current);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (ntfsTag == 1) {  	if (ntfsLength >= 24) {  		long lastModificationTicks = helperStream.ReadLELong ();  		_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  		long lastAccessTicks = helperStream.ReadLELong ();  		_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  		long createTimeTicks = helperStream.ReadLELong ();  		_createTime = DateTime.FromFileTime (createTimeTicks);  	}  	break;  }  else {  	// An unknown NTFS tag so simply skip it.  	helperStream.Seek (ntfsLength' SeekOrigin.Current);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (ntfsLength >= 24) {  	long lastModificationTicks = helperStream.ReadLELong ();  	_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  	long lastAccessTicks = helperStream.ReadLELong ();  	_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  	long createTimeTicks = helperStream.ReadLELong ();  	_createTime = DateTime.FromFileTime (createTimeTicks);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteLEInt (0);  		// Reserved  		helperStream.WriteLEShort (1);  		// Tag  		helperStream.WriteLEShort (24);  		// Length = 3 x 8.  		helperStream.WriteLELong (_lastModificationTime.ToFileTime ());  		helperStream.WriteLELong (_lastAccessTime.ToFileTime ());  		helperStream.WriteLELong (_createTime.ToFileTime ());  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteLEInt (0);  	// Reserved  	helperStream.WriteLEShort (1);  	// Tag  	helperStream.WriteLEShort (24);  	// Length = 3 x 8.  	helperStream.WriteLELong (_lastModificationTime.ToFileTime ());  	helperStream.WriteLELong (_lastAccessTime.ToFileTime ());  	helperStream.WriteLELong (_createTime.ToFileTime ());  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: helperStream.WriteLEShort (24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Find,The following statement contains a magic number: while ((localTag != headerID) && (_index < _data.Length - 3)) {  	localTag = ReadShortInternal ();  	localLength = ReadShortInternal ();  	if (localTag != headerID) {  		_index += localLength;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: if (Find (headerID)) {  	newLength -= (ValueLength + 4);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: newLength -= (ValueLength + 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: unchecked {  	_newEntry.WriteByte ((byte)toAdd);  	_newEntry.WriteByte ((byte)(toAdd >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: _newEntry.WriteByte ((byte)(toAdd >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: unchecked {  	AddLeShort ((short)toAdd);  	AddLeShort ((short)(toAdd >> 16));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: AddLeShort ((short)(toAdd >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: unchecked {  	AddLeInt ((int)(toAdd & 0xffffffff));  	AddLeInt ((int)(toAdd >> 32));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: AddLeInt ((int)(toAdd >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: ReadCheck (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: return (ReadInt () & 0xffffffff) | (((long)ReadInt ()) << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: ReadCheck (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: _index += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: ReadCheck (2);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: _index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if ((_readValueStart > _data.Length) || (_readValueStart < 4)) {  	throw new ZipException ("Find must be called before calling a Read method");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if (_index + length < 4) {  	throw new ZipException ("Cannot read before start of tag");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: if (_index > _data.Length - 2) {  	throw new ZipException ("End of extra data");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: _index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: _data [index + 1] = (byte)(source >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: try {  	int entryIndex = 0;  	while (testing && (entryIndex < Count)) {  		if (resultHandler != null) {  			status.SetEntry (this [entryIndex]);  			status.SetOperation (TestOperation.EntryHeader);  			resultHandler (status' null);  		}  		try {  			TestLocalHeader (this [entryIndex]' test);  		}  		catch (ZipException ex) {  			status.AddError ();  			if (resultHandler != null) {  				resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  			}  			if (strategy == TestStrategy.FindFirstError) {  				testing = false;  			}  		}  		if (testing && testData && this [entryIndex].IsFile) {  			if (resultHandler != null) {  				status.SetOperation (TestOperation.EntryData);  				resultHandler (status' null);  			}  			Crc32 crc = new Crc32 ();  			using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  				byte[] buffer = new byte[4096];  				long totalBytes = 0;  				int bytesRead;  				while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  					crc.Update (buffer' 0' bytesRead);  					if (resultHandler != null) {  						totalBytes += bytesRead;  						status.SetBytesTested (totalBytes);  						resultHandler (status' null);  					}  				}  			}  			if (this [entryIndex].Crc != crc.Value) {  				status.AddError ();  				if (resultHandler != null) {  					resultHandler (status' "CRC mismatch");  				}  				if (strategy == TestStrategy.FindFirstError) {  					testing = false;  				}  			}  			if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				ZipHelperStream helper = new ZipHelperStream (baseStream_);  				DescriptorData data = new DescriptorData ();  				helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  				if (this [entryIndex].Crc != data.Crc) {  					status.AddError ();  				}  				if (this [entryIndex].CompressedSize != data.CompressedSize) {  					status.AddError ();  				}  				if (this [entryIndex].Size != data.Size) {  					status.AddError ();  				}  			}  		}  		if (resultHandler != null) {  			status.SetOperation (TestOperation.EntryComplete);  			resultHandler (status' null);  		}  		entryIndex += 1;  	}  	if (resultHandler != null) {  		status.SetOperation (TestOperation.MiscellaneousTests);  		resultHandler (status' null);  	}  	// TODO: the 'Corrina Johns' test where local headers are missing from  	// the central directory.  They are therefore invisible to many archivers.  }  catch (Exception ex) {  	status.AddError ();  	if (resultHandler != null) {  		resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: while (testing && (entryIndex < Count)) {  	if (resultHandler != null) {  		status.SetEntry (this [entryIndex]);  		status.SetOperation (TestOperation.EntryHeader);  		resultHandler (status' null);  	}  	try {  		TestLocalHeader (this [entryIndex]' test);  	}  	catch (ZipException ex) {  		status.AddError ();  		if (resultHandler != null) {  			resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  		}  		if (strategy == TestStrategy.FindFirstError) {  			testing = false;  		}  	}  	if (testing && testData && this [entryIndex].IsFile) {  		if (resultHandler != null) {  			status.SetOperation (TestOperation.EntryData);  			resultHandler (status' null);  		}  		Crc32 crc = new Crc32 ();  		using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  			byte[] buffer = new byte[4096];  			long totalBytes = 0;  			int bytesRead;  			while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  				crc.Update (buffer' 0' bytesRead);  				if (resultHandler != null) {  					totalBytes += bytesRead;  					status.SetBytesTested (totalBytes);  					resultHandler (status' null);  				}  			}  		}  		if (this [entryIndex].Crc != crc.Value) {  			status.AddError ();  			if (resultHandler != null) {  				resultHandler (status' "CRC mismatch");  			}  			if (strategy == TestStrategy.FindFirstError) {  				testing = false;  			}  		}  		if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  			ZipHelperStream helper = new ZipHelperStream (baseStream_);  			DescriptorData data = new DescriptorData ();  			helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  			if (this [entryIndex].Crc != data.Crc) {  				status.AddError ();  			}  			if (this [entryIndex].CompressedSize != data.CompressedSize) {  				status.AddError ();  			}  			if (this [entryIndex].Size != data.Size) {  				status.AddError ();  			}  		}  	}  	if (resultHandler != null) {  		status.SetOperation (TestOperation.EntryComplete);  		resultHandler (status' null);  	}  	entryIndex += 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: if (testing && testData && this [entryIndex].IsFile) {  	if (resultHandler != null) {  		status.SetOperation (TestOperation.EntryData);  		resultHandler (status' null);  	}  	Crc32 crc = new Crc32 ();  	using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  		byte[] buffer = new byte[4096];  		long totalBytes = 0;  		int bytesRead;  		while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  			crc.Update (buffer' 0' bytesRead);  			if (resultHandler != null) {  				totalBytes += bytesRead;  				status.SetBytesTested (totalBytes);  				resultHandler (status' null);  			}  		}  	}  	if (this [entryIndex].Crc != crc.Value) {  		status.AddError ();  		if (resultHandler != null) {  			resultHandler (status' "CRC mismatch");  		}  		if (strategy == TestStrategy.FindFirstError) {  			testing = false;  		}  	}  	if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  		ZipHelperStream helper = new ZipHelperStream (baseStream_);  		DescriptorData data = new DescriptorData ();  		helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  		if (this [entryIndex].Crc != data.Crc) {  			status.AddError ();  		}  		if (this [entryIndex].CompressedSize != data.CompressedSize) {  			status.AddError ();  		}  		if (this [entryIndex].Size != data.Size) {  			status.AddError ();  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  	byte[] buffer = new byte[4096];  	long totalBytes = 0;  	int bytesRead;  	while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  		crc.Update (buffer' 0' bytesRead);  		if (resultHandler != null) {  			totalBytes += bytesRead;  			status.SetBytesTested (totalBytes);  			resultHandler (status' null);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)ReadLEUshort ();  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testData) {  	if (entry.IsFile) {  		if (!entry.IsCompressionMethodSupported ()) {  			throw new ZipException ("Compression method not supported");  		}  		if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  			throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  		}  		if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  			throw new ZipException ("The library does not support the zip version required to extract this entry");  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsFile) {  	if (!entry.IsCompressionMethodSupported ()) {  		throw new ZipException ("Compression method not supported");  	}  	if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  		throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  	}  	if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  		throw new ZipException ("The library does not support the zip version required to extract this entry");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  	throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  	throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  	if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  		throw new ZipException ("Strong encryption flag set but encryption flag is not set");  	}  	if (extractVersion < 50) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (extractVersion < 50) {  	throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  	throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  	if (extractVersion < 62) {  		throw new ZipException ("Strong encryption flag set but version not high enough");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (extractVersion < 62) {  	throw new ZipException ("Strong encryption flag set but version not high enough");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	if (size > 0) {  		throw new ZipException ("Directory cannot have size");  	}  	// There may be other cases where the compressed size can be greater than this?  	// If so until details are known we will be strict.  	if (entry.IsCrypted) {  		if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	else if (compressedSize > 2) {  		// When not compressed the directory size can validly be 2 bytes  		// if the true size wasnt known when data was originally being written.  		// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  		throw new ZipException ("Directory compressed size invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	if (size > 0) {  		throw new ZipException ("Directory cannot have size");  	}  	// There may be other cases where the compressed size can be greater than this?  	// If so until details are known we will be strict.  	if (entry.IsCrypted) {  		if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	else if (compressedSize > 2) {  		// When not compressed the directory size can validly be 2 bytes  		// if the true size wasnt known when data was originally being written.  		// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  		throw new ZipException ("Directory compressed size invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsCrypted) {  	if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  		throw new ZipException ("Directory compressed size invalid");  	}  }  else if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsCrypted) {  	if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  		throw new ZipException ("Directory compressed size invalid");  	}  }  else if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEShort,The following statement contains a magic number: baseStream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEUshort,The following statement contains a magic number: baseStream_.WriteByte ((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort ((ushort)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLeLong,The following statement contains a magic number: WriteLEInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint ((uint)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if (entry.ExternalFileAttributes != -1) {  	WriteLEInt (entry.ExternalFileAttributes);  }  else {  	if (entry.IsDirectory) {  		WriteLEUint (16);  	}  	else {  		WriteLEUint (0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	WriteLEUint (16);  }  else {  	WriteLEUint (0);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: WriteLEUint (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	result = ZipConstants.DataDescriptorSize - 4;  	if (update.Entry.LocalHeaderRequiresZip64) {  		result = ZipConstants.Zip64DataDescriptorSize - 4;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	result = ZipConstants.DataDescriptorSize - 4;  	if (update.Entry.LocalHeaderRequiresZip64) {  		result = ZipConstants.Zip64DataDescriptorSize - 4;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: result = ZipConstants.DataDescriptorSize - 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if (update.Entry.LocalHeaderRequiresZip64) {  	result = ZipConstants.Zip64DataDescriptorSize - 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: result = ZipConstants.Zip64DataDescriptorSize - 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetOutputStream,The following statement contains a magic number: switch (entry.CompressionMethod) {  case CompressionMethod.Stored:  	result = new UncompressedStream (result);  	break;  case CompressionMethod.Deflated:  	DeflaterOutputStream dos = new DeflaterOutputStream (result' new Deflater (9' true));  	dos.IsStreamOwner = false;  	result = dos;  	break;  default:  	throw new ZipException ("Unknown compression method " + entry.CompressionMethod);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CopyEntry,The following statement contains a magic number: if (update.Entry.CompressedSize > 0) {  	const int NameLengthOffset = 26;  	long entryDataOffset = update.Entry.Offset + NameLengthOffset;  	// TODO: This wont work for SFX files!  	baseStream_.Seek (entryDataOffset' SeekOrigin.Begin);  	uint nameLength = ReadLEUshort ();  	uint extraLength = ReadLEUshort ();  	baseStream_.Seek (nameLength + extraLength' SeekOrigin.Current);  	CopyBytes (update' workFile.baseStream_' baseStream_' update.Entry.CompressedSize' false);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,UpdateCommentOnly,The following statement contains a magic number: using (updateFile) {  	long locatedCentralDirOffset = updateFile.LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff);  	if (locatedCentralDirOffset < 0) {  		throw new ZipException ("Cannot find central directory");  	}  	const int CentralHeaderCommentSizeOffset = 16;  	updateFile.Position += CentralHeaderCommentSizeOffset;  	byte[] rawComment = newComment_.RawComment;  	updateFile.WriteLEShort (rawComment.Length);  	updateFile.Write (rawComment' 0' rawComment.Length);  	updateFile.SetLength (updateFile.Position);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadLEUshort,The following statement contains a magic number: return unchecked((ushort)((ushort)data1 | (ushort)(data2 << 8)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadLEUint,The following statement contains a magic number: return (uint)(ReadLEUshort () | (ReadLEUshort () << 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadLEUlong,The following statement contains a magic number: return ReadLEUint () | ((ulong)ReadLEUint () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize))) {  	offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  	if (offsetOfFirstEntry <= 0) {  		throw new ZipException ("Invalid embedded zip archive");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize))) {  	offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  	if (offsetOfFirstEntry <= 0) {  		throw new ZipException ("Invalid embedded zip archive");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: entry.CryptoCheckValue = (byte)(crc >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	result = new CryptoStream (baseStream' classicManaged.CreateDecryptor (key' null)' CryptoStreamMode.Read);  	CheckClassicPassword (result' entry);  }  else {  	#if !NET_1_1 && !NETCF_2_0  	if (entry.Version == ZipConstants.VERSION_AES) {  		//  		OnKeysRequired (entry.Name);  		if (HaveKeys == false) {  			throw new ZipException ("No password available for AES encrypted stream");  		}  		int saltLen = entry.AESSaltLen;  		byte[] saltBytes = new byte[saltLen];  		int saltIn = baseStream.Read (saltBytes' 0' saltLen);  		if (saltIn != saltLen)  			throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  		//  		byte[] pwdVerifyRead = new byte[2];  		baseStream.Read (pwdVerifyRead' 0' 2);  		int blockSize = entry.AESKeySize / 8;  		// bits to bytes  		ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  		byte[] pwdVerifyCalc = decryptor.PwdVerifier;  		if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  			throw new Exception ("Invalid password for AES");  		result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  	}  	else  	#endif  	 {  		throw new ZipException ("Decryption method not supported");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	result = new CryptoStream (baseStream' classicManaged.CreateDecryptor (key' null)' CryptoStreamMode.Read);  	CheckClassicPassword (result' entry);  }  else {  	#if !NET_1_1 && !NETCF_2_0  	if (entry.Version == ZipConstants.VERSION_AES) {  		//  		OnKeysRequired (entry.Name);  		if (HaveKeys == false) {  			throw new ZipException ("No password available for AES encrypted stream");  		}  		int saltLen = entry.AESSaltLen;  		byte[] saltBytes = new byte[saltLen];  		int saltIn = baseStream.Read (saltBytes' 0' saltLen);  		if (saltIn != saltLen)  			throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  		//  		byte[] pwdVerifyRead = new byte[2];  		baseStream.Read (pwdVerifyRead' 0' 2);  		int blockSize = entry.AESKeySize / 8;  		// bits to bytes  		ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  		byte[] pwdVerifyCalc = decryptor.PwdVerifier;  		if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  			throw new Exception ("Invalid password for AES");  		result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  	}  	else  	#endif  	 {  		throw new ZipException ("Decryption method not supported");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	result = new CryptoStream (baseStream' classicManaged.CreateDecryptor (key' null)' CryptoStreamMode.Read);  	CheckClassicPassword (result' entry);  }  else {  	#if !NET_1_1 && !NETCF_2_0  	if (entry.Version == ZipConstants.VERSION_AES) {  		//  		OnKeysRequired (entry.Name);  		if (HaveKeys == false) {  			throw new ZipException ("No password available for AES encrypted stream");  		}  		int saltLen = entry.AESSaltLen;  		byte[] saltBytes = new byte[saltLen];  		int saltIn = baseStream.Read (saltBytes' 0' saltLen);  		if (saltIn != saltLen)  			throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  		//  		byte[] pwdVerifyRead = new byte[2];  		baseStream.Read (pwdVerifyRead' 0' 2);  		int blockSize = entry.AESKeySize / 8;  		// bits to bytes  		ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  		byte[] pwdVerifyCalc = decryptor.PwdVerifier;  		if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  			throw new Exception ("Invalid password for AES");  		result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  	}  	else  	#endif  	 {  		throw new ZipException ("Decryption method not supported");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if (entry.Version == ZipConstants.VERSION_AES) {  	//  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for AES encrypted stream");  	}  	int saltLen = entry.AESSaltLen;  	byte[] saltBytes = new byte[saltLen];  	int saltIn = baseStream.Read (saltBytes' 0' saltLen);  	if (saltIn != saltLen)  		throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  	//  	byte[] pwdVerifyRead = new byte[2];  	baseStream.Read (pwdVerifyRead' 0' 2);  	int blockSize = entry.AESKeySize / 8;  	// bits to bytes  	ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  	byte[] pwdVerifyCalc = decryptor.PwdVerifier;  	if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  		throw new Exception ("Invalid password for AES");  	result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  }  else  #endif   {  	throw new ZipException ("Decryption method not supported");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if (entry.Version == ZipConstants.VERSION_AES) {  	//  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for AES encrypted stream");  	}  	int saltLen = entry.AESSaltLen;  	byte[] saltBytes = new byte[saltLen];  	int saltIn = baseStream.Read (saltBytes' 0' saltLen);  	if (saltIn != saltLen)  		throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  	//  	byte[] pwdVerifyRead = new byte[2];  	baseStream.Read (pwdVerifyRead' 0' 2);  	int blockSize = entry.AESKeySize / 8;  	// bits to bytes  	ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  	byte[] pwdVerifyCalc = decryptor.PwdVerifier;  	if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  		throw new Exception ("Invalid password for AES");  	result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  }  else  #endif   {  	throw new ZipException ("Decryption method not supported");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if (entry.Version == ZipConstants.VERSION_AES) {  	//  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for AES encrypted stream");  	}  	int saltLen = entry.AESSaltLen;  	byte[] saltBytes = new byte[saltLen];  	int saltIn = baseStream.Read (saltBytes' 0' saltLen);  	if (saltIn != saltLen)  		throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  	//  	byte[] pwdVerifyRead = new byte[2];  	baseStream.Read (pwdVerifyRead' 0' 2);  	int blockSize = entry.AESKeySize / 8;  	// bits to bytes  	ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  	byte[] pwdVerifyCalc = decryptor.PwdVerifier;  	if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  		throw new Exception ("Invalid password for AES");  	result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  }  else  #endif   {  	throw new ZipException ("Decryption method not supported");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: baseStream.Read (pwdVerifyRead' 0' 2);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  	// which doesnt do this.  	result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write);  	if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  		WriteEncryptionHeader (result' entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (result' entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  	// which doesnt do this.  	result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write);  	if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  		WriteEncryptionHeader (result' entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (result' entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  	WriteEncryptionHeader (result' entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (result' entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  	WriteEncryptionHeader (result' entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (result' entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: WriteEncryptionHeader (result' entry.DosTime << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,MakeTemporaryCopy,The following statement contains a magic number: StreamUtils.Copy (stream' temporaryStream_' new byte[4096]);  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if ((stream == null) || !stream.CanWrite) {  	result = new MemoryStream ();  	if (stream != null) {  		stream.Position = 0;  		StreamUtils.Copy (stream' result' new byte[4096]);  		stream.Close ();  	}  }  else {  	result = stream;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if (stream != null) {  	stream.Position = 0;  	StreamUtils.Copy (stream' result' new byte[4096]);  	stream.Close ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: StreamUtils.Copy (stream' result' new byte[4096]);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteZip64EndOfCentralDirectory,The following statement contains a magic number: WriteLELong (44);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,ReadLEShort,The following statement contains a magic number: return byteValue1 | (byteValue2 << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,ReadLEInt,The following statement contains a magic number: return ReadLEShort () | (ReadLEShort () << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,ReadLELong,The following statement contains a magic number: return (uint)ReadLEInt () | ((long)ReadLEInt () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEShort,The following statement contains a magic number: stream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUshort,The following statement contains a magic number: stream_.WriteByte ((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort ((ushort)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLELong,The following statement contains a magic number: WriteLEInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint ((uint)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if (entry.LocalHeaderRequiresZip64) {  	WriteLELong (entry.CompressedSize);  	WriteLELong (entry.Size);  	result += 16;  }  else {  	WriteLEInt ((int)entry.CompressedSize);  	WriteLEInt ((int)entry.Size);  	result += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if (entry.LocalHeaderRequiresZip64) {  	WriteLELong (entry.CompressedSize);  	WriteLELong (entry.Size);  	result += 16;  }  else {  	WriteLEInt ((int)entry.CompressedSize);  	WriteLEInt ((int)entry.Size);  	result += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CompleteCloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	ReadDataDescriptor ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  	if ((flags & 8) != 0) {  		// We don't know how much we must skip' read until end.  		byte[] tmp = new byte[4096];  		// Read will close this entry  		while (Read (tmp' 0' tmp.Length) > 0) {  		}  		return;  	}  	csize -= inf.TotalIn;  	inputBuffer.Available += inf.RemainingInput;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  	if ((flags & 8) != 0) {  		// We don't know how much we must skip' read until end.  		byte[] tmp = new byte[4096];  		// Read will close this entry  		while (Read (tmp' 0' tmp.Length) > 0) {  		}  		return;  	}  	csize -= inf.TotalIn;  	inputBuffer.Available += inf.RemainingInput;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	// We don't know how much we must skip' read until end.  	byte[] tmp = new byte[4096];  	// Read will close this entry  	while (Read (tmp' 0' tmp.Length) > 0) {  	}  	return;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	// We don't know how much we must skip' read until end.  	byte[] tmp = new byte[4096];  	// Read will close this entry  	while (Read (tmp' 0' tmp.Length) > 0) {  	}  	return;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: switch (method) {  case (int)CompressionMethod.Deflated:  	count = base.Read (buffer' offset' count);  	if (count <= 0) {  		if (!inf.IsFinished) {  			throw new ZipException ("Inflater not finished!");  		}  		inputBuffer.Available = inf.RemainingInput;  		// A csize of -1 is from an unpatched local header  		if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  			throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  		}  		inf.Reset ();  		finished = true;  	}  	break;  case (int)CompressionMethod.Stored:  	if ((count > csize) && (csize >= 0)) {  		count = (int)csize;  	}  	if (count > 0) {  		count = inputBuffer.ReadClearTextBuffer (buffer' offset' count);  		if (count > 0) {  			csize -= count;  			size -= count;  		}  	}  	if (csize == 0) {  		finished = true;  	}  	else {  		if (count < 0) {  			throw new ZipException ("EOF in stored block");  		}  	}  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: if (count <= 0) {  	if (!inf.IsFinished) {  		throw new ZipException ("Inflater not finished!");  	}  	inputBuffer.Available = inf.RemainingInput;  	// A csize of -1 is from an unpatched local header  	if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  		throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  	}  	inf.Reset ();  	finished = true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  	throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryCharsRelaxed [howMany - 2] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: howMany = invalidPathChars.Length + 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 2] = '\\';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 3] = '*';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 4] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: unchecked {  	baseOutputStream_.WriteByte ((byte)(value & 0xff));  	baseOutputStream_.WriteByte ((byte)((value >> 8) & 0xff));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: baseOutputStream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: unchecked {  	WriteLeShort (value);  	WriteLeShort (value >> 16);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: WriteLeShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: unchecked {  	WriteLeInt ((int)value);  	WriteLeInt ((int)(value >> 32));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: WriteLeInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (headerInfoAvailable == false) {  	if (CanPatchEntries == false) {  		// Only way to record size and compressed size is to append a data descriptor  		// after compressed data.  		// Stored entries of this form have already been converted to deflating.  		entry.Flags |= 8;  	}  	else {  		patchEntryHeader = true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (CanPatchEntries == false) {  	// Only way to record size and compressed size is to append a data descriptor  	// after compressed data.  	// Stored entries of this form have already been converted to deflating.  	entry.Flags |= 8;  }  else {  	patchEntryHeader = true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: entry.Flags |= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (Password != null) {  	entry.IsCrypted = true;  	if (entry.Crc < 0) {  		// Need to append a data descriptor as the crc isnt available for use  		// with encryption' the date is used instead.  Setting the flag  		// indicates this to the decompressor.  		entry.Flags |= 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.Crc < 0) {  	// Need to append a data descriptor as the crc isnt available for use  	// with encryption' the date is used instead.  Setting the flag  	// indicates this to the decompressor.  	entry.Flags |= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: entry.Flags |= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.IsCrypted) {  	#if !NET_1_1 && !NETCF_2_0  	if (entry.AESKeySize > 0) {  		WriteAESHeader (entry);  	}  	else  	#endif  	 {  		if (entry.Crc < 0) {  			// so testing Zip will says its ok  			WriteEncryptionHeader (entry.DosTime << 16);  		}  		else {  			WriteEncryptionHeader (entry.Crc);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.AESKeySize > 0) {  	WriteAESHeader (entry);  }  else  #endif   {  	if (entry.Crc < 0) {  		// so testing Zip will says its ok  		WriteEncryptionHeader (entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.Crc < 0) {  	// so testing Zip will says its ok  	WriteEncryptionHeader (entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: WriteEncryptionHeader (entry.DosTime << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if (curEntry.AESKeySize > 0) {  	baseOutputStream_.Write (AESAuthCode' 0' 10);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: baseOutputStream_.Write (AESAuthCode' 0' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if ((curEntry.Flags & 8) != 0) {  	WriteLeInt (ZipConstants.DataDescriptorSignature);  	WriteLeInt (unchecked((int)curEntry.Crc));  	if (curEntry.LocalHeaderRequiresZip64) {  		WriteLeLong (curEntry.CompressedSize);  		WriteLeLong (curEntry.Size);  		offset += ZipConstants.Zip64DataDescriptorSize;  	}  	else {  		WriteLeInt ((int)curEntry.CompressedSize);  		WriteLeInt ((int)curEntry.Size);  		offset += ZipConstants.DataDescriptorSize;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: foreach (ZipEntry entry in entries) {  	WriteLeInt (ZipConstants.CentralHeaderSignature);  	WriteLeShort (ZipConstants.VersionMadeBy);  	WriteLeShort (entry.Version);  	WriteLeShort (entry.Flags);  	WriteLeShort ((short)entry.CompressionMethodForHeader);  	WriteLeInt ((int)entry.DosTime);  	WriteLeInt ((int)entry.Crc);  	if (entry.IsZip64Forced () || (entry.CompressedSize >= uint.MaxValue)) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.CompressedSize);  	}  	if (entry.IsZip64Forced () || (entry.Size >= uint.MaxValue)) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.Size);  	}  	byte[] name = ZipConstants.ConvertToArray (entry.Flags' entry.Name);  	if (name.Length > 0xffff) {  		throw new ZipException ("Name too long.");  	}  	ZipExtraData ed = new ZipExtraData (entry.ExtraData);  	if (entry.CentralHeaderRequiresZip64) {  		ed.StartNewEntry ();  		if (entry.IsZip64Forced () || (entry.Size >= 0xffffffff)) {  			ed.AddLeLong (entry.Size);  		}  		if (entry.IsZip64Forced () || (entry.CompressedSize >= 0xffffffff)) {  			ed.AddLeLong (entry.CompressedSize);  		}  		if (entry.Offset >= 0xffffffff) {  			ed.AddLeLong (entry.Offset);  		}  		ed.AddNewEntry (1);  	}  	else {  		ed.Delete (1);  	}  	#if !NET_1_1 && !NETCF_2_0  	if (entry.AESKeySize > 0) {  		AddExtraDataAES (entry' ed);  	}  	#endif  	byte[] extra = ed.GetEntryData ();  	byte[] entryComment = (entry.Comment != null) ? ZipConstants.ConvertToArray (entry.Flags' entry.Comment) : new byte[0];  	if (entryComment.Length > 0xffff) {  		throw new ZipException ("Comment too long.");  	}  	WriteLeShort (name.Length);  	WriteLeShort (extra.Length);  	WriteLeShort (entryComment.Length);  	WriteLeShort (0);  	// disk number  	WriteLeShort (0);  	// internal file attributes  	// external file attributes  	if (entry.ExternalFileAttributes != -1) {  		WriteLeInt (entry.ExternalFileAttributes);  	}  	else {  		if (entry.IsDirectory) {  			// mark entry as directory (from nikolam.AT.perfectinfo.com)  			WriteLeInt (16);  		}  		else {  			WriteLeInt (0);  		}  	}  	if (entry.Offset >= uint.MaxValue) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.Offset);  	}  	if (name.Length > 0) {  		baseOutputStream_.Write (name' 0' name.Length);  	}  	if (extra.Length > 0) {  		baseOutputStream_.Write (extra' 0' extra.Length);  	}  	if (entryComment.Length > 0) {  		baseOutputStream_.Write (entryComment' 0' entryComment.Length);  	}  	sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: if (entry.ExternalFileAttributes != -1) {  	WriteLeInt (entry.ExternalFileAttributes);  }  else {  	if (entry.IsDirectory) {  		// mark entry as directory (from nikolam.AT.perfectinfo.com)  		WriteLeInt (16);  	}  	else {  		WriteLeInt (0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: if (entry.IsDirectory) {  	// mark entry as directory (from nikolam.AT.perfectinfo.com)  	WriteLeInt (16);  }  else {  	WriteLeInt (0);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: WriteLeInt (16);  
Magic Number,Andi.Libs.IniParser.Model.Configuration,BaseIniParserConfiguration,C:\repos\andibadra_ANDT\Andi.Libs\IniParser\Model\Configuration\BaseIniParserConfiguration.cs,GetHashCode,The following statement contains a magic number: foreach (var property in GetType ().GetProperties ()) {  	hash = (hash * 7) + property.GetValue (this' null).GetHashCode ();  }  
Magic Number,Andi.Libs.IniParser.Model.Configuration,BaseIniParserConfiguration,C:\repos\andibadra_ANDT\Andi.Libs\IniParser\Model\Configuration\BaseIniParserConfiguration.cs,GetHashCode,The following statement contains a magic number: hash = (hash * 7) + property.GetValue (this' null).GetHashCode ();  
Magic Number,Andi.Libs.IniParser.Parser,IniDataParser,C:\repos\andibadra_ANDT\Andi.Libs\IniParser\Parser\IniDataParser.cs,ProcessSection,The following statement contains a magic number: sectionName = sectionName.Substring (1' sectionName.Length - 2).Trim ();  
Missing Default,Andi.Libs.FastColoredTextBox,AutocompleteListView,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\AutocompleteMenu.cs,ProcessKey,The following switch statement is missing a default case: switch (keyData) {  case Keys.Down:  	SelectNext (+1);  	return true;  case Keys.PageDown:  	SelectNext (+10);  	return true;  case Keys.Up:  	SelectNext (-1);  	return true;  case Keys.PageUp:  	SelectNext (-10);  	return true;  case Keys.Enter:  	OnSelecting ();  	return true;  case Keys.Tab:  	if (!AllowTabKey)  		break;  	OnSelecting ();  	return true;  case Keys.Escape:  	Menu.Close ();  	return true;  }  
Missing Default,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,CalcMinAutosizeWidth,The following switch statement is missing a default case: switch (WordWrapMode) {  case WordWrapMode.WordWrapControlWidth:  case WordWrapMode.CharWrapControlWidth:  	maxLineLength = Math.Min (maxLineLength' (ClientSize.Width - LeftIndent - Paddings.Left - Paddings.Right) / CharWidth);  	minWidth = 0;  	break;  case WordWrapMode.WordWrapPreferredWidth:  case WordWrapMode.CharWrapPreferredWidth:  	maxLineLength = Math.Min (maxLineLength' PreferredLineWidth);  	minWidth = LeftIndent + PreferredLineWidth * CharWidth + 2 + Paddings.Left + Paddings.Right;  	break;  }  
Missing Default,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,GetMaxLineWordWrapedWidth,The following switch statement is missing a default case: switch (wordWrapMode) {  case WordWrapMode.WordWrapControlWidth:  case WordWrapMode.CharWrapControlWidth:  	return ClientSize.Width;  case WordWrapMode.WordWrapPreferredWidth:  case WordWrapMode.CharWrapPreferredWidth:  	return LeftIndent + PreferredLineWidth * CharWidth + 2 + Paddings.Left + Paddings.Right;  }  
Missing Default,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,RecalcWordWrap,The following switch statement is missing a default case: switch (WordWrapMode) {  case WordWrapMode.WordWrapControlWidth:  	maxCharsPerLine = (ClientSize.Width - LeftIndent - Paddings.Left - Paddings.Right) / CharWidth;  	break;  case WordWrapMode.CharWrapControlWidth:  	maxCharsPerLine = (ClientSize.Width - LeftIndent - Paddings.Left - Paddings.Right) / CharWidth;  	charWrap = true;  	break;  case WordWrapMode.WordWrapPreferredWidth:  	maxCharsPerLine = PreferredLineWidth;  	break;  case WordWrapMode.CharWrapPreferredWidth:  	maxCharsPerLine = PreferredLineWidth;  	charWrap = true;  	break;  }  
Missing Default,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,DoAction,The following switch statement is missing a default case: switch (action) {  case FCTBAction.ZoomIn:  	ChangeFontSize (2);  	break;  case FCTBAction.ZoomOut:  	ChangeFontSize (-2);  	break;  case FCTBAction.ZoomNormal:  	RestoreFontSize ();  	break;  case FCTBAction.ScrollDown:  	DoScrollVertical (1' -1);  	break;  case FCTBAction.ScrollUp:  	DoScrollVertical (1' 1);  	break;  case FCTBAction.GoToDialog:  	ShowGoToDialog ();  	break;  case FCTBAction.FindDialog:  	ShowFindDialog ();  	break;  case FCTBAction.FindChar:  	findCharMode = true;  	break;  case FCTBAction.FindNext:  	if (findForm == null || findForm.tbFind.Text == "")  		ShowFindDialog ();  	else  		findForm.FindNext (findForm.tbFind.Text);  	break;  case FCTBAction.ReplaceDialog:  	ShowReplaceDialog ();  	break;  case FCTBAction.Copy:  	Copy ();  	break;  case FCTBAction.CommentSelected:  	CommentSelected ();  	break;  case FCTBAction.Cut:  	if (!Selection.ReadOnly)  		Cut ();  	break;  case FCTBAction.Paste:  	if (!Selection.ReadOnly)  		Paste ();  	break;  case FCTBAction.SelectAll:  	Selection.SelectAll ();  	break;  case FCTBAction.Undo:  	if (!ReadOnly)  		Undo ();  	break;  case FCTBAction.Redo:  	if (!ReadOnly)  		Redo ();  	break;  case FCTBAction.LowerCase:  	if (!Selection.ReadOnly)  		LowerCase ();  	break;  case FCTBAction.UpperCase:  	if (!Selection.ReadOnly)  		UpperCase ();  	break;  case FCTBAction.IndentDecrease:  	if (!Selection.ReadOnly)  		DecreaseIndent ();  	break;  case FCTBAction.IndentIncrease:  	if (!Selection.ReadOnly) {  		if (Selection.Start == Selection.End && this [Selection.Start.iLine].StartSpacesCount < Selection.Start.iChar) {  			ProcessKey ('\t'' Keys.None);  		}  		else  			IncreaseIndent ();  	}  	break;  case FCTBAction.AutoIndentChars:  	if (!Selection.ReadOnly)  		DoAutoIndentChars (Selection.Start.iLine);  	break;  case FCTBAction.NavigateBackward:  	NavigateBackward ();  	break;  case FCTBAction.NavigateForward:  	NavigateForward ();  	break;  case FCTBAction.UnbookmarkLine:  	UnbookmarkLine (Selection.Start.iLine);  	break;  case FCTBAction.BookmarkLine:  	BookmarkLine (Selection.Start.iLine);  	break;  case FCTBAction.GoNextBookmark:  	GotoNextBookmark (Selection.Start.iLine);  	break;  case FCTBAction.GoPrevBookmark:  	GotoPrevBookmark (Selection.Start.iLine);  	break;  case FCTBAction.ClearWordLeft:  	if (OnKeyPressing ('\b'))  		//KeyPress event processed key  		break;  	if (!Selection.ReadOnly) {  		if (!Selection.IsEmpty)  			ClearSelected ();  		Selection.GoWordLeft (true);  		if (!Selection.ReadOnly)  			ClearSelected ();  	}  	OnKeyPressed ('\b');  	break;  case FCTBAction.ReplaceMode:  	if (!ReadOnly)  		isReplaceMode = !isReplaceMode;  	break;  case FCTBAction.DeleteCharRight:  	if (!Selection.ReadOnly) {  		if (OnKeyPressing ((char)0xff))  			//KeyPress event processed key  			break;  		if (!Selection.IsEmpty)  			ClearSelected ();  		else {  			//if line contains only spaces then delete line  			if (this [Selection.Start.iLine].StartSpacesCount == this [Selection.Start.iLine].Count)  				RemoveSpacesAfterCaret ();  			if (!Selection.IsReadOnlyRightChar ())  				if (Selection.GoRightThroughFolded ()) {  					int iLine = Selection.Start.iLine;  					InsertChar ('\b');  					//if removed \n then trim spaces  					if (iLine != Selection.Start.iLine && AutoIndent)  						if (Selection.Start.iChar > 0)  							RemoveSpacesAfterCaret ();  				}  		}  		if (AutoIndentChars)  			DoAutoIndentChars (Selection.Start.iLine);  		OnKeyPressed ((char)0xff);  	}  	break;  case FCTBAction.ClearWordRight:  	if (OnKeyPressing ((char)0xff))  		//KeyPress event processed key  		break;  	if (!Selection.ReadOnly) {  		if (!Selection.IsEmpty)  			ClearSelected ();  		Selection.GoWordRight (true);  		if (!Selection.ReadOnly)  			ClearSelected ();  	}  	OnKeyPressed ((char)0xff);  	break;  case FCTBAction.GoWordLeft:  	Selection.GoWordLeft (false);  	break;  case FCTBAction.GoWordLeftWithSelection:  	Selection.GoWordLeft (true);  	break;  case FCTBAction.GoLeft:  	Selection.GoLeft (false);  	break;  case FCTBAction.GoLeftWithSelection:  	Selection.GoLeft (true);  	break;  case FCTBAction.GoLeft_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoLeft_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.GoWordRight:  	Selection.GoWordRight (false);  	break;  case FCTBAction.GoWordRightWithSelection:  	Selection.GoWordRight (true);  	break;  case FCTBAction.GoRight:  	Selection.GoRight (false);  	break;  case FCTBAction.GoRightWithSelection:  	Selection.GoRight (true);  	break;  case FCTBAction.GoRight_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoRight_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.GoUp:  	Selection.GoUp (false);  	ScrollLeft ();  	break;  case FCTBAction.GoUpWithSelection:  	Selection.GoUp (true);  	ScrollLeft ();  	break;  case FCTBAction.GoUp_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoUp_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.MoveSelectedLinesUp:  	if (!Selection.ColumnSelectionMode)  		MoveSelectedLinesUp ();  	break;  case FCTBAction.GoDown:  	Selection.GoDown (false);  	ScrollLeft ();  	break;  case FCTBAction.GoDownWithSelection:  	Selection.GoDown (true);  	ScrollLeft ();  	break;  case FCTBAction.GoDown_ColumnSelectionMode:  	CheckAndChangeSelectionType ();  	if (Selection.ColumnSelectionMode)  		Selection.GoDown_ColumnSelectionMode ();  	Invalidate ();  	break;  case FCTBAction.MoveSelectedLinesDown:  	if (!Selection.ColumnSelectionMode)  		MoveSelectedLinesDown ();  	break;  case FCTBAction.GoPageUp:  	Selection.GoPageUp (false);  	ScrollLeft ();  	break;  case FCTBAction.GoPageUpWithSelection:  	Selection.GoPageUp (true);  	ScrollLeft ();  	break;  case FCTBAction.GoPageDown:  	Selection.GoPageDown (false);  	ScrollLeft ();  	break;  case FCTBAction.GoPageDownWithSelection:  	Selection.GoPageDown (true);  	ScrollLeft ();  	break;  case FCTBAction.GoFirstLine:  	Selection.GoFirst (false);  	break;  case FCTBAction.GoFirstLineWithSelection:  	Selection.GoFirst (true);  	break;  case FCTBAction.GoHome:  	GoHome (false);  	ScrollLeft ();  	break;  case FCTBAction.GoHomeWithSelection:  	GoHome (true);  	ScrollLeft ();  	break;  case FCTBAction.GoLastLine:  	Selection.GoLast (false);  	break;  case FCTBAction.GoLastLineWithSelection:  	Selection.GoLast (true);  	break;  case FCTBAction.GoEnd:  	Selection.GoEnd (false);  	break;  case FCTBAction.GoEndWithSelection:  	Selection.GoEnd (true);  	break;  case FCTBAction.ClearHints:  	ClearHints ();  	if (MacrosManager != null)  		MacrosManager.IsRecording = false;  	break;  case FCTBAction.MacroRecord:  	if (MacrosManager != null) {  		if (MacrosManager.AllowMacroRecordingByUser)  			MacrosManager.IsRecording = !MacrosManager.IsRecording;  		if (MacrosManager.IsRecording)  			MacrosManager.ClearMacros ();  	}  	break;  case FCTBAction.MacroExecute:  	if (MacrosManager != null) {  		MacrosManager.IsRecording = false;  		MacrosManager.ExecuteMacros ();  	}  	break;  case FCTBAction.CustomAction1:  case FCTBAction.CustomAction2:  case FCTBAction.CustomAction3:  case FCTBAction.CustomAction4:  case FCTBAction.CustomAction5:  case FCTBAction.CustomAction6:  case FCTBAction.CustomAction7:  case FCTBAction.CustomAction8:  case FCTBAction.CustomAction9:  case FCTBAction.CustomAction10:  case FCTBAction.CustomAction11:  case FCTBAction.CustomAction12:  case FCTBAction.CustomAction13:  case FCTBAction.CustomAction14:  case FCTBAction.CustomAction15:  case FCTBAction.CustomAction16:  case FCTBAction.CustomAction17:  case FCTBAction.CustomAction18:  case FCTBAction.CustomAction19:  case FCTBAction.CustomAction20:  	OnCustomAction (new CustomActionEventArgs (action));  	break;  }  
Missing Default,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,IsInputKey,The following switch statement is missing a default case: switch ((keyData & Keys.KeyCode)) {  case Keys.Prior:  case Keys.Next:  case Keys.End:  case Keys.Home:  case Keys.Left:  case Keys.Right:  case Keys.Up:  case Keys.Down:  	return true;  case Keys.Escape:  	return false;  case Keys.Tab:  	return (keyData & Keys.Control) == Keys.None;  }  
Missing Default,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,FindEndOfFoldingBlock,The following switch statement is missing a default case: switch (FindEndOfFoldingBlockStrategy) {  case FindEndOfFoldingBlockStrategy.Strategy1:  	for (i = iStartLine/*+1*/; i < LinesCount; i++) {  		if (lines.LineHasFoldingStartMarker (i))  			stack.Push (lines [i].FoldingStartMarker);  		if (lines.LineHasFoldingEndMarker (i)) {  			string m = lines [i].FoldingEndMarker;  			while (stack.Count > 0 && stack.Pop () != m)  				;  			if (stack.Count == 0)  				return i;  		}  		maxLines--;  		if (maxLines < 0)  			return i;  	}  	break;  case FindEndOfFoldingBlockStrategy.Strategy2:  	for (i = iStartLine/*+1*/; i < LinesCount; i++) {  		if (lines.LineHasFoldingEndMarker (i)) {  			string m = lines [i].FoldingEndMarker;  			while (stack.Count > 0 && stack.Pop () != m)  				;  			if (stack.Count == 0)  				return i;  		}  		if (lines.LineHasFoldingStartMarker (i))  			stack.Push (lines [i].FoldingStartMarker);  		maxLines--;  		if (maxLines < 0)  			return i;  	}  	break;  }  
Missing Default,Andi.Libs.FastColoredTextBox,FastColoredTextBox,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\FastColoredTextBox.cs,HighlightBrackets,The following switch statement is missing a default case: switch (BracketsHighlightStrategy) {  case BracketsHighlightStrategy.Strategy1:  	HighlightBrackets1 (LeftBracket' RightBracket' ref leftBracketPosition' ref rightBracketPosition);  	break;  case BracketsHighlightStrategy.Strategy2:  	HighlightBrackets2 (LeftBracket' RightBracket' ref leftBracketPosition' ref rightBracketPosition);  	break;  }  
Missing Default,Andi.Libs.FastColoredTextBox,SyntaxHighlighter,C:\repos\andibadra_ANDT\Andi.Libs\FastColoredTextBox\SyntaxHighlighter.cs,InitStyleSchema,The following switch statement is missing a default case: switch (lang) {  case Language.CSharp:  	StringStyle = BrownStyle;  	CommentStyle = GreenStyle;  	NumberStyle = MagentaStyle;  	AttributeStyle = GreenStyle;  	ClassNameStyle = BoldStyle;  	KeywordStyle = BlueStyle;  	CommentTagStyle = GrayStyle;  	break;  case Language.VB:  	StringStyle = BrownStyle;  	CommentStyle = GreenStyle;  	NumberStyle = MagentaStyle;  	ClassNameStyle = BoldStyle;  	KeywordStyle = BlueStyle;  	break;  case Language.HTML:  	CommentStyle = GreenStyle;  	TagBracketStyle = BlueStyle;  	TagNameStyle = MaroonStyle;  	AttributeStyle = RedStyle;  	AttributeValueStyle = BlueStyle;  	HtmlEntityStyle = RedStyle;  	break;  case Language.XML:  	CommentStyle = GreenStyle;  	XmlTagBracketStyle = BlueStyle;  	XmlTagNameStyle = MaroonStyle;  	XmlAttributeStyle = RedStyle;  	XmlAttributeValueStyle = BlueStyle;  	XmlEntityStyle = RedStyle;  	XmlCDataStyle = BlackStyle;  	break;  case Language.JS:  	StringStyle = BrownStyle;  	CommentStyle = GreenStyle;  	NumberStyle = MagentaStyle;  	KeywordStyle = BlueStyle;  	break;  case Language.Lua:  	StringStyle = BrownStyle;  	CommentStyle = GreenStyle;  	NumberStyle = MagentaStyle;  	KeywordStyle = BlueBoldStyle;  	FunctionsStyle = MaroonStyle;  	break;  case Language.PHP:  	StringStyle = RedStyle;  	CommentStyle = GreenStyle;  	NumberStyle = RedStyle;  	VariableStyle = MaroonStyle;  	KeywordStyle = MagentaStyle;  	KeywordStyle2 = BlueStyle;  	KeywordStyle3 = GrayStyle;  	break;  case Language.SQL:  	StringStyle = RedStyle;  	CommentStyle = GreenStyle;  	NumberStyle = MagentaStyle;  	KeywordStyle = BlueBoldStyle;  	StatementsStyle = BlueBoldStyle;  	FunctionsStyle = MaroonStyle;  	VariableStyle = MaroonStyle;  	TypesStyle = BrownStyle;  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction) {  case DEFLATE_STORED:  	if (strstart > blockStart) {  		huffman.FlushStoredBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	UpdateHash ();  	break;  case DEFLATE_FAST:  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	break;  case DEFLATE_SLOW:  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLocalEntryHeader,The following switch statement is missing a default case: switch (useZip64_) {  case UseZip64.Dynamic:  	if (entry.Size < 0) {  		entry.ForceZip64 ();  	}  	break;  case UseZip64.On:  	entry.ForceZip64 ();  	break;  case UseZip64.Off:  	// Do nothing.  The entry itself may be using Zip64 independantly.  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,RunUpdates,The following switch statement is missing a default case: switch (update.Command) {  case UpdateCommand.Copy:  	if (directUpdate) {  		CopyEntryDirect (workFile' update' ref destinationPosition);  	}  	else {  		CopyEntry (workFile' update);  	}  	break;  case UpdateCommand.Modify:  	// TODO: Direct modifying of an entry will take some legwork.  	ModifyEntry (workFile' update);  	break;  case UpdateCommand.Add:  	if (!IsNewArchive && directUpdate) {  		workFile.baseStream_.Position = destinationPosition;  	}  	AddEntry (workFile' update);  	if (directUpdate) {  		destinationPosition = workFile.baseStream_.Position;  	}  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The following switch statement is missing a default case: switch (method) {  case (int)CompressionMethod.Deflated:  	count = base.Read (buffer' offset' count);  	if (count <= 0) {  		if (!inf.IsFinished) {  			throw new ZipException ("Inflater not finished!");  		}  		inputBuffer.Available = inf.RemainingInput;  		// A csize of -1 is from an unpatched local header  		if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  			throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  		}  		inf.Reset ();  		finished = true;  	}  	break;  case (int)CompressionMethod.Stored:  	if ((count > csize) && (csize >= 0)) {  		count = (int)csize;  	}  	if (count > 0) {  		count = inputBuffer.ReadClearTextBuffer (buffer' offset' count);  		if (count > 0) {  			csize -= count;  			size -= count;  		}  	}  	if (csize == 0) {  		finished = true;  	}  	else {  		if (count < 0) {  			throw new ZipException ("EOF in stored block");  		}  	}  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\andibadra_ANDT\Andi.Libs\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Write,The following switch statement is missing a default case: switch (curMethod) {  case CompressionMethod.Deflated:  	base.Write (buffer' offset' count);  	break;  case CompressionMethod.Stored:  	if (Password != null) {  		CopyAndEncrypt (buffer' offset' count);  	}  	else {  		baseOutputStream_.Write (buffer' offset' count);  	}  	break;  }  
