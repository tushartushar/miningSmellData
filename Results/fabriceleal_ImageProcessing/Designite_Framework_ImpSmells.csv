Implementation smell,Namespace,Class,File,Method,Description
Long Method,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,Save,The method has 125 lines of code.
Long Method,Framework.Filters.EdgeDetection.Template,Kirsch,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Kirsch.cs,ApplyFilter,The method has 171 lines of code.
Long Method,Framework.Filters.Simple,ThinningBinary,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\ThinningBinary.cs,ThinningBinary,The method has 274 lines of code.
Long Method,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The method has 116 lines of code.
Complex Method,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,Load,Cyclomatic complexity of the method is 17
Complex Method,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,Save,Cyclomatic complexity of the method is 20
Complex Method,Framework.Batch,RowResults,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Structures.cs,ExportToXml,Cyclomatic complexity of the method is 10
Complex Method,Framework.Batch,RowResults,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Structures.cs,ExportToCsv,Cyclomatic complexity of the method is 14
Complex Method,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,Cyclomatic complexity of the method is 14
Complex Method,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ApplyFilter,Cyclomatic complexity of the method is 10
Complex Method,Framework.Filters.EdgeDetection.SndDerivate,LaplacianOfGauss,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\LaplacianOfGauss.cs,ApplyFilter,Cyclomatic complexity of the method is 12
Complex Method,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,Cyclomatic complexity of the method is 8
Complex Method,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,Cyclomatic complexity of the method is 22
Complex Method,Framework.Filters.Simple,ThinningBinary,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\ThinningBinary.cs,ApplyFilter,Cyclomatic complexity of the method is 9
Complex Method,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,Cyclomatic complexity of the method is 14
Complex Method,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,Cyclomatic complexity of the method is 22
Complex Method,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,ApplyIsefHorizontal,Cyclomatic complexity of the method is 10
Complex Method,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,ApplyIsefVertical,Cyclomatic complexity of the method is 10
Complex Method,Framework.Filters.Smoothing,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Gaussian.cs,GenerateFilter,Cyclomatic complexity of the method is 10
Complex Method,Framework.Filters.Smoothing,Wiener,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Wiener.cs,ApplyFilter,Cyclomatic complexity of the method is 9
Complex Method,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT1D,Cyclomatic complexity of the method is 12
Long Parameter List,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,Load,The method has 5 parameters.
Long Parameter List,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,Save,The method has 5 parameters.
Long Parameter List,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,_graph_FilterExecuted,The method has 5 parameters.
Long Parameter List,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,_graph_FilterMeasured,The method has 6 parameters.
Long Parameter List,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,OnFilterExecuted,The method has 6 parameters.
Long Parameter List,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,OnFilterMeasured,The method has 7 parameters.
Long Parameter List,Framework.Batch,Graph,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Graph.cs,filter_f_FilterExecuted,The method has 5 parameters.
Long Parameter List,Framework.Batch,Graph,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Graph.cs,OnFilterExecuted,The method has 5 parameters.
Long Parameter List,Framework.Batch,Graph,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Graph.cs,filter_f_FilterMeasured,The method has 6 parameters.
Long Parameter List,Framework.Batch,Graph,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Graph.cs,OnFilterMeasured,The method has 6 parameters.
Long Parameter List,Framework.Batch,Node,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Node.cs,OnFilterExecuted,The method has 5 parameters.
Long Parameter List,Framework.Batch,Node,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Node.cs,OnFilterMeasured,The method has 6 parameters.
Long Parameter List,Framework.Batch,NodeFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\NodeFilter.cs,NodeFilter,The method has 5 parameters.
Long Parameter List,Framework.Batch,RowBatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Structures.cs,RowBatchFilter,The method has 5 parameters.
Long Parameter List,Framework.Batch,RowResults,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Structures.cs,RowResults,The method has 7 parameters.
Long Parameter List,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The method has 7 parameters.
Long Parameter List,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,ToColor,The method has 7 parameters.
Long Parameter List,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,ToBitmap,The method has 7 parameters.
Long Parameter List,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,ToBitmap,The method has 7 parameters.
Long Parameter List,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,ToBitmap,The method has 7 parameters.
Long Parameter List,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,ToRGBGreyScale,The method has 7 parameters.
Long Parameter List,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,To8bppGreyScale,The method has 7 parameters.
Long Parameter List,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,CountErrorTolerant,The method has 7 parameters.
Long Parameter List,Framework.Core.Filters.Base,FilterAttribute,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Base\FilterAttribute.cs,FilterAttribute,The method has 5 parameters.
Long Parameter List,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The method has 5 parameters.
Long Parameter List,Framework.Filters.EdgeDetection.Template,FreiChen,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\FreiChen.cs,ApplyFilter,The method has 7 parameters.
Long Parameter List,Framework.Filters.EdgeDetection.Template,Kirsch,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Kirsch.cs,ApplyFilter,The method has 7 parameters.
Long Parameter List,Framework.Filters.EdgeDetection.Template,Prewitt,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Prewitt.cs,ApplyFilter,The method has 7 parameters.
Long Parameter List,Framework.Filters.EdgeDetection.Template,Roberts,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Roberts.cs,ApplyFilter,The method has 7 parameters.
Long Parameter List,Framework.Filters.EdgeDetection.Template,Sobel,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Sobel.cs,ApplyFilter,The method has 7 parameters.
Long Parameter List,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The method has 5 parameters.
Long Parameter List,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The method has 5 parameters.
Long Statement,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,Load,The length of the statement  "					mm = (Metric.MetricDelegate)Delegate.CreateDelegate (typeof(Metric.MetricDelegate)' tm.GetMethod (m.Field<string> ("Method"))); " is 127.
Long Statement,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,Load,The length of the statement  "						measures.Add (new MetricExecReference (m.Field<string> ("Key")' mm' new WeakImage (Facilities.ToImage (m.Field<string> ("Input"))))); " is 133.
Long Statement,Framework.Batch,RowResults,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\Structures.cs,GetXmlSchema,The length of the statement  "		throw new Exception ("Error when trying to obtain xml schema for validating the xml exportation of List<RowResults>."' e); " is 122.
Long Statement,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,UnsafeIterateBitmap,The length of the statement  "		BitmapData bmData = b.LockBits (new Rectangle (0' 0' b.Width' b.Height)' ImageLockMode.ReadWrite' PixelFormat.Format24bppRgb); " is 126.
Long Statement,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,SignalToNoiseRatio,The length of the statement  "		throw new Exception (string.Format ("Image's sizes does not match! img0=({0}'{1}) img1=({2}'{3}) "' clean.GetLength (0)' clean.GetLength (1)' noisy.GetLength (0)' noisy.GetLength (1))); " is 185.
Long Statement,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,CountMatchWhitebytes,The length of the statement  "		throw new Exception (string.Format ("Image's sizes does not match! img0=({0}'{1}) img1=({2}'{3}) "' reference.GetLength (0)' reference.GetLength (1)' newImage.GetLength (0)' newImage.GetLength (1))); " is 199.
Long Statement,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,CountMatchWhitebytesRatio,The length of the statement  "		throw new Exception (string.Format ("Image's sizes does not match! img0=({0}'{1}) img1=({2}'{3}) "' reference.GetLength (0)' reference.GetLength (1)' newImage.GetLength (0)' newImage.GetLength (1))); " is 199.
Long Statement,Framework.Core.Filters.Spatial,Kernel2D,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Spatial\Kernel2D.cs,ApplyConvolution,The length of the statement  "				tot += (kernel._2d_matrix [mappings [i].Item1.X' mappings [i].Item1.Y] * op [mappings [i].Item2.X' mappings [i].Item2.Y]); " is 122.
Long Statement,Framework.Core.Filters.Spatial,Kernel2D,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Spatial\Kernel2D.cs,ApplyConvolution,The length of the statement  "				tot += (kernel._2d_matrix [mappings [i].Item1.X' mappings [i].Item1.Y] * op [mappings [i].Item2.X' mappings [i].Item2.Y]); " is 122.
Long Statement,Framework.Core.Filters.Spatial,SpatialDomainFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Spatial\SpatialDomainFilter.cs,ApplyFilter,The length of the statement  "	throw new NotImplementedException ("Spatial Domain Filters do not operate on ComplexImage. Apply the inverse transform first!"); " is 128.
Long Statement,Framework.Filters.Smoothing,Wiener,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Wiener.cs,ApplyFilter,The length of the statement  "	double['] varianced = Kernel2D.ApplyConvolution (new Kernel2D (0' 1 / (1.0 * window_size * window_size)' window)' img_sqrd); " is 124.
Long Statement,Framework.Filters.Smoothing,Wiener,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Wiener.cs,ApplyFilter,The length of the statement  "			val = (((img [x' y] - meaned [x' y]) / Math.Max (varianced [x' y]' noise)) * Math.Max (varianced [x' y] - noise' 0)) + meaned [x' y]; " is 133.
Long Statement,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The length of the statement  "	double var = double.Parse (configs ["Var"].ToString ())' mean = double.Parse (configs ["Mean"].ToString ())' noise' theta; " is 122.
Long Statement,Framework.Filters.Smoothing.Mean,ContraharmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ContraharmonicMean.cs,ApplyFilter,The length of the statement  "	byte['] tmp_ret = Kernel2D.ApplyFunction (kernel' imageSrc' delegate (Tuple<Point' Point>[] mappings' byte['] operand) { " is 120.
Long Statement,Framework.Filters.Smoothing.Mean,GeometricMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\GeometricMean.cs,ApplyFilter,The length of the statement  "	byte['] tmp_ret = Kernel2D.ApplyFunction (kernel' imageSrc' delegate (Tuple<Point' Point>[] mappings' byte['] operand) { " is 120.
Long Statement,Framework.Filters.Smoothing.Mean,HarmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\HarmonicMean.cs,ApplyFilter,The length of the statement  "	byte['] tmp_ret = Kernel2D.ApplyFunction (kernel' imageSrc' delegate (Tuple<Point' Point>[] mappings' byte['] operand) { " is 120.
Complex Conditional,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ApplyFilter,The conditional expression  "x > BAND && y > BAND && y < height - BAND && x < width - BAND"  is complex.
Complex Conditional,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ApplyFilter,The conditional expression  "x > BAND && y > BAND && y < height - BAND && x < width - BAND"  is complex.
Empty Catch Block,Framework.Core,WeakImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\WeakImage.cs,Dispose,The method has an empty catch block.
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: try {  	#if UNSAFE  	unsafe {  		UnsafeIterateBitmap (ref b' delegate (ref Bitmap bitmap' byte* start' int noffset' int height' int width) {  			for (int y = 0; y < height; ++y) {  				for (int x = 0; x < width; ++x) {  					callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  					start += 3;  				}  				start += noffset;  			}  		});  	}  	#else  	                Color pixel;                 // SAFE MODE                 for (int y = 0; y < b.Height; ++y)                 {                     for (int x = 0; x < b.Width; ++x)                     {                         pixel = b.GetPixel(x' y);                         byte red = pixel.R;                         byte green = pixel.G;                         byte blue = pixel.B;                          callback(ref b' ref red' ref blue' ref green' x' y);                          pixel = Color.FromArgb(red' green' blue);                                                 b.SetPixel(x' y' pixel);                     }                 }                          #endif  }  catch (Exception e) {  	//Debug.Print("Facilities::IterateBitmap" + Environment.NewLine +  	//            "   Exception {0}: {1}"' new object[] { e.GetType().FullName' e.Message });  	throw new Exception (string.Format ("Error while reading Bitmap: {0}"' e.Message)' e);  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: try {  	#if UNSAFE  	unsafe {  		UnsafeIterateBitmap (ref b' delegate (ref Bitmap bitmap' byte* start' int noffset' int height' int width) {  			for (int y = 0; y < height; ++y) {  				for (int x = 0; x < width; ++x) {  					callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  					start += 3;  				}  				start += noffset;  			}  		});  	}  	#else  	                Color pixel;                 // SAFE MODE                 for (int y = 0; y < b.Height; ++y)                 {                     for (int x = 0; x < b.Width; ++x)                     {                         pixel = b.GetPixel(x' y);                         byte red = pixel.R;                         byte green = pixel.G;                         byte blue = pixel.B;                          callback(ref b' ref red' ref blue' ref green' x' y);                          pixel = Color.FromArgb(red' green' blue);                                                 b.SetPixel(x' y' pixel);                     }                 }                          #endif  }  catch (Exception e) {  	//Debug.Print("Facilities::IterateBitmap" + Environment.NewLine +  	//            "   Exception {0}: {1}"' new object[] { e.GetType().FullName' e.Message });  	throw new Exception (string.Format ("Error while reading Bitmap: {0}"' e.Message)' e);  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: unsafe {  	UnsafeIterateBitmap (ref b' delegate (ref Bitmap bitmap' byte* start' int noffset' int height' int width) {  		for (int y = 0; y < height; ++y) {  			for (int x = 0; x < width; ++x) {  				callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  				start += 3;  			}  			start += noffset;  		}  	});  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: unsafe {  	UnsafeIterateBitmap (ref b' delegate (ref Bitmap bitmap' byte* start' int noffset' int height' int width) {  		for (int y = 0; y < height; ++y) {  			for (int x = 0; x < width; ++x) {  				callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  				start += 3;  			}  			start += noffset;  		}  	});  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: UnsafeIterateBitmap (ref b' delegate (ref Bitmap bitmap' byte* start' int noffset' int height' int width) {  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  			start += 3;  		}  		start += noffset;  	}  });  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: UnsafeIterateBitmap (ref b' delegate (ref Bitmap bitmap' byte* start' int noffset' int height' int width) {  	for (int y = 0; y < height; ++y) {  		for (int x = 0; x < width; ++x) {  			callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  			start += 3;  		}  		start += noffset;  	}  });  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	for (int x = 0; x < width; ++x) {  		callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  		start += 3;  	}  	start += noffset;  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	for (int x = 0; x < width; ++x) {  		callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  		start += 3;  	}  	start += noffset;  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  	start += 3;  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  	start += 3;  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: callback (ref bitmap' ref start [2]' ref start [1]' ref start [0]' x' y);  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,IterateBitmapRGB,The following statement contains a magic number: start += 3;  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,UnsafeIterateBitmap,The following statement contains a magic number: try {  	// UNSAFE MODE  	BitmapData bmData = b.LockBits (new Rectangle (0' 0' b.Width' b.Height)' ImageLockMode.ReadWrite' PixelFormat.Format24bppRgb);  	// Bitmap.Stride ------------------------------  	//  - aka stride width' scan width  	//  	// The memory allocated for Microsoft Bitmaps must be   	// aligned on a 32bit boundary.  	//  	// The stride refers to the number of bytes allocated   	// for one scanline of the bitmap  	//  	// Equals to ((width * bpp) + 7) / 8  	//  	int stride = bmData.Stride;  	System.IntPtr Scan0 = bmData.Scan0;  	unsafe {  		byte* p = (byte*)(void*)Scan0;  		int nOffset = stride - b.Width * 3;  		parseArray (ref b' p' nOffset' b.Height' b.Width);  	}  	b.UnlockBits (bmData);  }  catch (Exception e) {  	//Debug.Print("Facilities::IterateBitmap" + Environment.NewLine +  	//            "   Exception {0}: {1}"' new object[] { e.GetType().FullName' e.Message });  	throw new Exception (string.Format ("Error while reading Bitmap using unsafe code: {0}"' e.Message)' e);  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,UnsafeIterateBitmap,The following statement contains a magic number: unsafe {  	byte* p = (byte*)(void*)Scan0;  	int nOffset = stride - b.Width * 3;  	parseArray (ref b' p' nOffset' b.Height' b.Width);  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,ToRGBGreyScale,The following statement contains a magic number: IterateBitmapRGB (ref bitmap' delegate (ref Bitmap bm' ref byte r' ref byte g' ref byte b' int x' int y) {  	int lum = (int)(r * 0.3 + g * 0.59 + b * 0.11);  	ret [x' y] = Color.FromArgb (lum' lum' lum);  	return true;  });  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,ToRGBGreyScale,The following statement contains a magic number: IterateBitmapRGB (ref bitmap' delegate (ref Bitmap bm' ref byte r' ref byte g' ref byte b' int x' int y) {  	int lum = (int)(r * 0.3 + g * 0.59 + b * 0.11);  	ret [x' y] = Color.FromArgb (lum' lum' lum);  	return true;  });  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,ToRGBGreyScale,The following statement contains a magic number: IterateBitmapRGB (ref bitmap' delegate (ref Bitmap bm' ref byte r' ref byte g' ref byte b' int x' int y) {  	int lum = (int)(r * 0.3 + g * 0.59 + b * 0.11);  	ret [x' y] = Color.FromArgb (lum' lum' lum);  	return true;  });  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,To8bppGreyScale,The following statement contains a magic number: IterateBitmapRGB (ref bitmap' delegate (ref Bitmap bm' ref byte r' ref byte g' ref byte b' int x' int y) {  	res = (int)((r + g + b) / 3);  	res = Math.Min (res' byte.MaxValue);  	res = Math.Max (res' byte.MinValue);  	ret [x' y] = (byte)res;  	return true;  });  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,To8bppGreyScale,The following statement contains a magic number: res = (int)((r + g + b) / 3);  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,To8bppGreyScale,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		res = (int)((colors [x' y].R + colors [x' y].G + colors [x' y].B) / 3);  		res = Math.Min (res' byte.MaxValue);  		res = Math.Max (res' byte.MinValue);  		ret [x' y] = (byte)res;  	}  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,To8bppGreyScale,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	res = (int)((colors [x' y].R + colors [x' y].G + colors [x' y].B) / 3);  	res = Math.Min (res' byte.MaxValue);  	res = Math.Max (res' byte.MinValue);  	ret [x' y] = (byte)res;  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,To8bppGreyScale,The following statement contains a magic number: res = (int)((colors [x' y].R + colors [x' y].G + colors [x' y].B) / 3);  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,SignalToNoiseRatio,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		tot += Math.Pow (clean [x' y] - noisy [x' y]' 2);  	}  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,SignalToNoiseRatio,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	tot += Math.Pow (clean [x' y] - noisy [x' y]' 2);  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,SignalToNoiseRatio,The following statement contains a magic number: tot += Math.Pow (clean [x' y] - noisy [x' y]' 2);  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,SignalToNoiseRatio,The following statement contains a magic number: ret = 20 * Math.Log10 (byte.MaxValue / tot);  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,SignalToNoiseRatioSimple,The following statement contains a magic number: for (x = 0; x < width; ++x) {  	for (y = 0; y < height; ++y) {  		stdDev += Math.Pow ((double)clean [x' y] - tot' 2);  	}  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,SignalToNoiseRatioSimple,The following statement contains a magic number: for (y = 0; y < height; ++y) {  	stdDev += Math.Pow ((double)clean [x' y] - tot' 2);  }  
Magic Number,Framework.Core,Facilities,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Facilities.cs,SignalToNoiseRatioSimple,The following statement contains a magic number: stdDev += Math.Pow ((double)clean [x' y] - tot' 2);  
Magic Number,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following statement contains a magic number: for (x = 0; x < width; ++x) {  	for (y = 0; y < height; ++y) {  		switch (bitmapType) {  		case ComplexImageBitmapType.Magnitude:  			data [x' y] = transform [x' y].Magnitude ();  			logs [x' y] = (float)(Math.Log (0.1 + data [x' y]));  			break;  		case ComplexImageBitmapType.Phase:  			data [x' y] = transform [x' y].Phase ();  			logs [x' y] = (float)Math.Log (0.1 + Math.Abs (data [x' y]));  			break;  		}  	}  }  
Magic Number,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following statement contains a magic number: for (x = 0; x < width; ++x) {  	for (y = 0; y < height; ++y) {  		switch (bitmapType) {  		case ComplexImageBitmapType.Magnitude:  			data [x' y] = transform [x' y].Magnitude ();  			logs [x' y] = (float)(Math.Log (0.1 + data [x' y]));  			break;  		case ComplexImageBitmapType.Phase:  			data [x' y] = transform [x' y].Phase ();  			logs [x' y] = (float)Math.Log (0.1 + Math.Abs (data [x' y]));  			break;  		}  	}  }  
Magic Number,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following statement contains a magic number: for (y = 0; y < height; ++y) {  	switch (bitmapType) {  	case ComplexImageBitmapType.Magnitude:  		data [x' y] = transform [x' y].Magnitude ();  		logs [x' y] = (float)(Math.Log (0.1 + data [x' y]));  		break;  	case ComplexImageBitmapType.Phase:  		data [x' y] = transform [x' y].Phase ();  		logs [x' y] = (float)Math.Log (0.1 + Math.Abs (data [x' y]));  		break;  	}  }  
Magic Number,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following statement contains a magic number: for (y = 0; y < height; ++y) {  	switch (bitmapType) {  	case ComplexImageBitmapType.Magnitude:  		data [x' y] = transform [x' y].Magnitude ();  		logs [x' y] = (float)(Math.Log (0.1 + data [x' y]));  		break;  	case ComplexImageBitmapType.Phase:  		data [x' y] = transform [x' y].Phase ();  		logs [x' y] = (float)Math.Log (0.1 + Math.Abs (data [x' y]));  		break;  	}  }  
Magic Number,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following statement contains a magic number: switch (bitmapType) {  case ComplexImageBitmapType.Magnitude:  	data [x' y] = transform [x' y].Magnitude ();  	logs [x' y] = (float)(Math.Log (0.1 + data [x' y]));  	break;  case ComplexImageBitmapType.Phase:  	data [x' y] = transform [x' y].Phase ();  	logs [x' y] = (float)Math.Log (0.1 + Math.Abs (data [x' y]));  	break;  }  
Magic Number,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following statement contains a magic number: switch (bitmapType) {  case ComplexImageBitmapType.Magnitude:  	data [x' y] = transform [x' y].Magnitude ();  	logs [x' y] = (float)(Math.Log (0.1 + data [x' y]));  	break;  case ComplexImageBitmapType.Phase:  	data [x' y] = transform [x' y].Phase ();  	logs [x' y] = (float)Math.Log (0.1 + Math.Abs (data [x' y]));  	break;  }  
Magic Number,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following statement contains a magic number: logs [x' y] = (float)(Math.Log (0.1 + data [x' y]));  
Magic Number,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following statement contains a magic number: logs [x' y] = (float)Math.Log (0.1 + Math.Abs (data [x' y]));  
Magic Number,Framework.Core.Filters.Frequency,FrequencyFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\FrequencyFilter.cs,D,The following statement contains a magic number: return Math.Sqrt (Math.Pow (u - M / 2.0' 2) + Math.Pow (v - N / 2.0' 2));  
Magic Number,Framework.Core.Filters.Frequency,FrequencyFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\FrequencyFilter.cs,D,The following statement contains a magic number: return Math.Sqrt (Math.Pow (u - M / 2.0' 2) + Math.Pow (v - N / 2.0' 2));  
Magic Number,Framework.Core.Filters.Frequency,FrequencyFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\FrequencyFilter.cs,D,The following statement contains a magic number: return Math.Sqrt (Math.Pow (u - M / 2.0' 2) + Math.Pow (v - N / 2.0' 2));  
Magic Number,Framework.Core.Filters.Frequency,FrequencyFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\FrequencyFilter.cs,D,The following statement contains a magic number: return Math.Sqrt (Math.Pow (u - M / 2.0' 2) + Math.Pow (v - N / 2.0' 2));  
Magic Number,Framework.Core.Filters.Spatial,Kernel2D,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Spatial\Kernel2D.cs,Kernel2D,The following statement contains a magic number: if (matrix.GetLength (0) % 2 == 0)  	throw new Exception ("The matrix should have odd dimensions (Ex: 5x5).");  
Magic Number,Framework.Core.Filters.Spatial,Kernel2D,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Spatial\Kernel2D.cs,ResolvePositions,The following statement contains a magic number: if (xUpperB % 2 != 0) {  	// Even-Dim mask  	throw new Exception ("The Kernel2D class does not support even dimension matrixes.");  }  else {  	// Odd-Dim mask  	// The central point corresponds to the pixel being calculated ...  	int center = (xUpperB / 2);  	Point kernelIdxs;  	Point imageIdxs;  	for (int x = 0; x <= xUpperB; ++x) {  		for (int y = 0; y <= yUpperB; ++y) {  			if (_2d_matrix [x' y] != 0) {  				kernelIdxs = new Point (x' y);  				imageIdxs = new Point (xImage - center + x' yImage - center + y);  				// Reset all invalid indexes to -1  				if (imageIdxs.X < 0 || imageIdxs.X >= imageWidth)  					imageIdxs.X = -1;  				if (imageIdxs.Y < 0 || imageIdxs.Y >= imageHeight)  					imageIdxs.Y = -1;  				ret.Add (new Tuple<Point' Point> (kernelIdxs' imageIdxs));  			}  		}  	}  }  
Magic Number,Framework.Core.Filters.Spatial,Kernel2D,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Spatial\Kernel2D.cs,ResolvePositions,The following statement contains a magic number: if (xUpperB % 2 != 0) {  	// Even-Dim mask  	throw new Exception ("The Kernel2D class does not support even dimension matrixes.");  }  else {  	// Odd-Dim mask  	// The central point corresponds to the pixel being calculated ...  	int center = (xUpperB / 2);  	Point kernelIdxs;  	Point imageIdxs;  	for (int x = 0; x <= xUpperB; ++x) {  		for (int y = 0; y <= yUpperB; ++y) {  			if (_2d_matrix [x' y] != 0) {  				kernelIdxs = new Point (x' y);  				imageIdxs = new Point (xImage - center + x' yImage - center + y);  				// Reset all invalid indexes to -1  				if (imageIdxs.X < 0 || imageIdxs.X >= imageWidth)  					imageIdxs.X = -1;  				if (imageIdxs.Y < 0 || imageIdxs.Y >= imageHeight)  					imageIdxs.Y = -1;  				ret.Add (new Tuple<Point' Point> (kernelIdxs' imageIdxs));  			}  		}  	}  }  
Magic Number,Framework.Filters.BandPass,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("n"' new Rangeable (2.0' 1.0' 10.0' 1));  
Magic Number,Framework.Filters.BandPass,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("n"' new Rangeable (2.0' 1.0' 10.0' 1));  
Magic Number,Framework.Filters.BandPass,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Butterworth.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	d = FrequencyFilter.D (u' v' width' height);  	return 1.0 - 1 / (1.0 + Math.Pow (d * w / (d * d - d0_squared)' 2 * n));  });  
Magic Number,Framework.Filters.BandPass,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Butterworth.cs,ApplyFilter,The following statement contains a magic number: return 1.0 - 1 / (1.0 + Math.Pow (d * w / (d * d - d0_squared)' 2 * n));  
Magic Number,Framework.Filters.BandPass,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	d = FrequencyFilter.D (u' v' width' height);  	return Math.Exp (minus_one_half * Math.Pow ((d * d - d0_squared) / (d * w)' 2.0));  });  
Magic Number,Framework.Filters.BandPass,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return Math.Exp (minus_one_half * Math.Pow ((d * d - d0_squared) / (d * w)' 2.0));  
Magic Number,Framework.Filters.BandPass,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandPass,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandPass\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("n"' new Rangeable (2.0' 1.0' 10.0' 1));  
Magic Number,Framework.Filters.BandReject,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("n"' new Rangeable (2.0' 1.0' 10.0' 1));  
Magic Number,Framework.Filters.BandReject,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Butterworth.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	d = FrequencyFilter.D (u' v' width' height);  	return 1 / (1.0 + Math.Pow (d * w / (d * d - d0_squared)' 2 * n));  });  
Magic Number,Framework.Filters.BandReject,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Butterworth.cs,ApplyFilter,The following statement contains a magic number: return 1 / (1.0 + Math.Pow (d * w / (d * d - d0_squared)' 2 * n));  
Magic Number,Framework.Filters.BandReject,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	d = FrequencyFilter.D (u' v' width' height);  	return 1.0 - Math.Exp (minus_one_half * Math.Pow ((d * d - d0_squared) / (d * w)' 2.0));  });  
Magic Number,Framework.Filters.BandReject,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return 1.0 - Math.Exp (minus_one_half * Math.Pow ((d * d - d0_squared) / (d * w)' 2.0));  
Magic Number,Framework.Filters.BandReject,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.BandReject,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\BandReject\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("W"' new Rangeable (10' 1' 3000' 1));  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("AdaptiveGradWinSize"' new Rangeable (7' 1' 333' 2));  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("AdaptiveGradWinSize"' new Rangeable (7' 1' 333' 2));  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("AdaptiveGradWinSize"' new Rangeable (7' 1' 333' 2));  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The following statement contains a magic number: for (i = (-windowSize / 2); i <= (windowSize / 2); ++i) {  	for (j = (-windowSize / 2); j <= (windowSize / 2); ++j) {  		if (bli [x + i' y + j]) {  			sumOn += smoothed [x + i' y + j];  			++totOn;  		}  		else {  			sumOff += smoothed [x + i' y + j];  			++totOff;  		}  	}  }  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The following statement contains a magic number: for (i = (-windowSize / 2); i <= (windowSize / 2); ++i) {  	for (j = (-windowSize / 2); j <= (windowSize / 2); ++j) {  		if (bli [x + i' y + j]) {  			sumOn += smoothed [x + i' y + j];  			++totOn;  		}  		else {  			sumOff += smoothed [x + i' y + j];  			++totOff;  		}  	}  }  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The following statement contains a magic number: for (i = (-windowSize / 2); i <= (windowSize / 2); ++i) {  	for (j = (-windowSize / 2); j <= (windowSize / 2); ++j) {  		if (bli [x + i' y + j]) {  			sumOn += smoothed [x + i' y + j];  			++totOn;  		}  		else {  			sumOff += smoothed [x + i' y + j];  			++totOff;  		}  	}  }  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The following statement contains a magic number: for (i = (-windowSize / 2); i <= (windowSize / 2); ++i) {  	for (j = (-windowSize / 2); j <= (windowSize / 2); ++j) {  		if (bli [x + i' y + j]) {  			sumOn += smoothed [x + i' y + j];  			++totOn;  		}  		else {  			sumOff += smoothed [x + i' y + j];  			++totOff;  		}  	}  }  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The following statement contains a magic number: i = (-windowSize / 2)
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The following statement contains a magic number: for (j = (-windowSize / 2); j <= (windowSize / 2); ++j) {  	if (bli [x + i' y + j]) {  		sumOn += smoothed [x + i' y + j];  		++totOn;  	}  	else {  		sumOff += smoothed [x + i' y + j];  		++totOff;  	}  }  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The following statement contains a magic number: for (j = (-windowSize / 2); j <= (windowSize / 2); ++j) {  	if (bli [x + i' y + j]) {  		sumOn += smoothed [x + i' y + j];  		++totOn;  	}  	else {  		sumOff += smoothed [x + i' y + j];  		++totOff;  	}  }  
Magic Number,Framework.Filters.EdgeDetection.Probabilistic,ShenCastan,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Probabilistic\ShenCastan.cs,ComputeAdaptiveGradient,The following statement contains a magic number: j = (-windowSize / 2)
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,Laplacian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\Laplacian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threshold"' Rangeable.ForByte (5));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,Laplacian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\Laplacian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (0.2' 0.0001' 0.9999' 0.0001));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,Laplacian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\Laplacian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (0.2' 0.0001' 0.9999' 0.0001));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,Laplacian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\Laplacian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (0.2' 0.0001' 0.9999' 0.0001));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,Laplacian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\Laplacian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (0.2' 0.0001' 0.9999' 0.0001));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,LaplacianOfGauss,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\LaplacianOfGauss.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threshold"' Rangeable.ForByte (10));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,LaplacianOfGauss,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\LaplacianOfGauss.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Sigma"' new Rangeable (0.5' 0.5' 20' 0.5));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,LaplacianOfGauss,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\LaplacianOfGauss.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Sigma"' new Rangeable (0.5' 0.5' 20' 0.5));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,LaplacianOfGauss,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\LaplacianOfGauss.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Sigma"' new Rangeable (0.5' 0.5' 20' 0.5));  
Magic Number,Framework.Filters.EdgeDetection.SndDerivate,LaplacianOfGauss,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\SndDerivate\LaplacianOfGauss.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Sigma"' new Rangeable (0.5' 0.5' 20' 0.5));  
Magic Number,Framework.Filters.EdgeDetection.Template,FreiChen,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\FreiChen.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threshold"' Rangeable.ForByte (5));  
Magic Number,Framework.Filters.EdgeDetection.Template,Kirsch,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Kirsch.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threshold"' Rangeable.ForByte (5));  
Magic Number,Framework.Filters.EdgeDetection.Template,Prewitt,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Prewitt.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threshold"' Rangeable.ForByte (5));  
Magic Number,Framework.Filters.EdgeDetection.Template,Roberts,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Roberts.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threshold"' Rangeable.ForByte (5));  
Magic Number,Framework.Filters.EdgeDetection.Template,Sobel,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\EdgeDetection\Template\Sobel.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threshold"' Rangeable.ForByte (5));  
Magic Number,Framework.Filters.Simple,BipolarThreshold,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\BipolarThreshold.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threshold"' Rangeable.ForByte (124));  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threeshoold-Low"' Rangeable.ForByte (5));  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Threeshoold-High"' Rangeable.ForByte (15));  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		if (img [x' y] >= t_high) {  			img [x' y] = 255;  			strong [x' y] = 255;  			strong_points.Push (new Point (x' y));  		}  		else if (img [x' y] >= t_low) {  			img [x' y] = 124;  		}  		else {  			img [x' y] = 0;  		}  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		if (img [x' y] >= t_high) {  			img [x' y] = 255;  			strong [x' y] = 255;  			strong_points.Push (new Point (x' y));  		}  		else if (img [x' y] >= t_low) {  			img [x' y] = 124;  		}  		else {  			img [x' y] = 0;  		}  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		if (img [x' y] >= t_high) {  			img [x' y] = 255;  			strong [x' y] = 255;  			strong_points.Push (new Point (x' y));  		}  		else if (img [x' y] >= t_low) {  			img [x' y] = 124;  		}  		else {  			img [x' y] = 0;  		}  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	if (img [x' y] >= t_high) {  		img [x' y] = 255;  		strong [x' y] = 255;  		strong_points.Push (new Point (x' y));  	}  	else if (img [x' y] >= t_low) {  		img [x' y] = 124;  	}  	else {  		img [x' y] = 0;  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	if (img [x' y] >= t_high) {  		img [x' y] = 255;  		strong [x' y] = 255;  		strong_points.Push (new Point (x' y));  	}  	else if (img [x' y] >= t_low) {  		img [x' y] = 124;  	}  	else {  		img [x' y] = 0;  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	if (img [x' y] >= t_high) {  		img [x' y] = 255;  		strong [x' y] = 255;  		strong_points.Push (new Point (x' y));  	}  	else if (img [x' y] >= t_low) {  		img [x' y] = 124;  	}  	else {  		img [x' y] = 0;  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: if (img [x' y] >= t_high) {  	img [x' y] = 255;  	strong [x' y] = 255;  	strong_points.Push (new Point (x' y));  }  else if (img [x' y] >= t_low) {  	img [x' y] = 124;  }  else {  	img [x' y] = 0;  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: if (img [x' y] >= t_high) {  	img [x' y] = 255;  	strong [x' y] = 255;  	strong_points.Push (new Point (x' y));  }  else if (img [x' y] >= t_low) {  	img [x' y] = 124;  }  else {  	img [x' y] = 0;  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: if (img [x' y] >= t_high) {  	img [x' y] = 255;  	strong [x' y] = 255;  	strong_points.Push (new Point (x' y));  }  else if (img [x' y] >= t_low) {  	img [x' y] = 124;  }  else {  	img [x' y] = 0;  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: img [x' y] = 255;  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: strong [x' y] = 255;  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: if (img [x' y] >= t_low) {  	img [x' y] = 124;  }  else {  	img [x' y] = 0;  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: img [x' y] = 124;  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: while (strong_points.Count > 0) {  	wrk = strong_points.Pop ();  	ngb = GetNeighborhood (wrk.X' wrk.Y' width' height' 360);  	for (i = 0; i < ngb.Length; ++i) {  		// if neighbor already is 255' is already on strong_points'  		// if neighbor has 124' set to 255 and had to strong_points  		if (img [wrk.X' wrk.Y] == 124) {  			img [wrk.X' wrk.Y] = 255;  			// so is not processed again ...  			strong [wrk.X' wrk.Y] = 255;  			strong_points.Push (new Point (wrk.X' wrk.Y));  		}  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: while (strong_points.Count > 0) {  	wrk = strong_points.Pop ();  	ngb = GetNeighborhood (wrk.X' wrk.Y' width' height' 360);  	for (i = 0; i < ngb.Length; ++i) {  		// if neighbor already is 255' is already on strong_points'  		// if neighbor has 124' set to 255 and had to strong_points  		if (img [wrk.X' wrk.Y] == 124) {  			img [wrk.X' wrk.Y] = 255;  			// so is not processed again ...  			strong [wrk.X' wrk.Y] = 255;  			strong_points.Push (new Point (wrk.X' wrk.Y));  		}  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: while (strong_points.Count > 0) {  	wrk = strong_points.Pop ();  	ngb = GetNeighborhood (wrk.X' wrk.Y' width' height' 360);  	for (i = 0; i < ngb.Length; ++i) {  		// if neighbor already is 255' is already on strong_points'  		// if neighbor has 124' set to 255 and had to strong_points  		if (img [wrk.X' wrk.Y] == 124) {  			img [wrk.X' wrk.Y] = 255;  			// so is not processed again ...  			strong [wrk.X' wrk.Y] = 255;  			strong_points.Push (new Point (wrk.X' wrk.Y));  		}  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: while (strong_points.Count > 0) {  	wrk = strong_points.Pop ();  	ngb = GetNeighborhood (wrk.X' wrk.Y' width' height' 360);  	for (i = 0; i < ngb.Length; ++i) {  		// if neighbor already is 255' is already on strong_points'  		// if neighbor has 124' set to 255 and had to strong_points  		if (img [wrk.X' wrk.Y] == 124) {  			img [wrk.X' wrk.Y] = 255;  			// so is not processed again ...  			strong [wrk.X' wrk.Y] = 255;  			strong_points.Push (new Point (wrk.X' wrk.Y));  		}  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: ngb = GetNeighborhood (wrk.X' wrk.Y' width' height' 360);  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (i = 0; i < ngb.Length; ++i) {  	// if neighbor already is 255' is already on strong_points'  	// if neighbor has 124' set to 255 and had to strong_points  	if (img [wrk.X' wrk.Y] == 124) {  		img [wrk.X' wrk.Y] = 255;  		// so is not processed again ...  		strong [wrk.X' wrk.Y] = 255;  		strong_points.Push (new Point (wrk.X' wrk.Y));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (i = 0; i < ngb.Length; ++i) {  	// if neighbor already is 255' is already on strong_points'  	// if neighbor has 124' set to 255 and had to strong_points  	if (img [wrk.X' wrk.Y] == 124) {  		img [wrk.X' wrk.Y] = 255;  		// so is not processed again ...  		strong [wrk.X' wrk.Y] = 255;  		strong_points.Push (new Point (wrk.X' wrk.Y));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: for (i = 0; i < ngb.Length; ++i) {  	// if neighbor already is 255' is already on strong_points'  	// if neighbor has 124' set to 255 and had to strong_points  	if (img [wrk.X' wrk.Y] == 124) {  		img [wrk.X' wrk.Y] = 255;  		// so is not processed again ...  		strong [wrk.X' wrk.Y] = 255;  		strong_points.Push (new Point (wrk.X' wrk.Y));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: if (img [wrk.X' wrk.Y] == 124) {  	img [wrk.X' wrk.Y] = 255;  	// so is not processed again ...  	strong [wrk.X' wrk.Y] = 255;  	strong_points.Push (new Point (wrk.X' wrk.Y));  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: if (img [wrk.X' wrk.Y] == 124) {  	img [wrk.X' wrk.Y] = 255;  	// so is not processed again ...  	strong [wrk.X' wrk.Y] = 255;  	strong_points.Push (new Point (wrk.X' wrk.Y));  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: if (img [wrk.X' wrk.Y] == 124) {  	img [wrk.X' wrk.Y] = 255;  	// so is not processed again ...  	strong [wrk.X' wrk.Y] = 255;  	strong_points.Push (new Point (wrk.X' wrk.Y));  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: img [wrk.X' wrk.Y] = 255;  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,ApplyFilter,The following statement contains a magic number: strong [wrk.X' wrk.Y] = 255;  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (0 == dir) {  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y + 1 < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  else if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (0 == dir) {  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y + 1 < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  else if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (0 == dir) {  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y + 1 < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  else if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (0 == dir) {  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y + 1 < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  else if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Hystersis,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Hystersis.cs,GetNeighborhood,The following statement contains a magic number: if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,ThinningBinary,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\ThinningBinary.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Iterations"' new Rangeable (1' 1' 500' 1));  
Magic Number,Framework.Filters.Simple,HighThreshold,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\HighThreshold.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("High-Threshold"' Rangeable.ForByte (124));  
Magic Number,Framework.Filters.Simple,LowThreshold,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\LowThreshold.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Low-Threshold"' Rangeable.ForByte (124));  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Get neighbors to parse  		mappings = kernel_x.ResolvePositions (x' y' width' height);  		g_x = 0;  		g_y = 0;  		// Calculate convolution  		for (i = 0; i < mappings.Length; ++i) {  			if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  				g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  				g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			}  		}  		g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  		g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  		step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  		// (2) Calculate edge direction' using Gx and Gy  		if (0 == g_x) {  			edges_dir [x' y] = (0 == g_y ? 0 : 90);  		}  		else {  			// need to convert in degree  			edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  		}  		// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  		dummy = edges_dir [x' y];  		// [0;22.5] e [157.5;180]  = 0  		// [22.5;67.5] = 45  		// [67.5;112.5] = 90  		// [112.5;157.5] = 135  		//if (dummy > 180)  		//    throw new Exception(string.Format("Theta = {0}"' dummy));  		if (dummy >= 157.5 || dummy < 22.5) {  			edges_dir [x' y] = 0;  		}  		else if (dummy >= 112.5) {  			edges_dir [x' y] = 135;  		}  		else if (dummy >= 67.5) {  			edges_dir [x' y] = 90;  		}  		else if (dummy >= 22.5) {  			edges_dir [x' y] = 45;  		}  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Get neighbors to parse  	mappings = kernel_x.ResolvePositions (x' y' width' height);  	g_x = 0;  	g_y = 0;  	// Calculate convolution  	for (i = 0; i < mappings.Length; ++i) {  		if (mappings [i].Item2.X != -1 && mappings [i].Item2.Y != -1) {  			g_x += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_x.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  			g_y += img [mappings [i].Item2.X' mappings [i].Item2.Y] * kernel_y.Matrix [mappings [i].Item1.X' mappings [i].Item1.Y];  		}  	}  	g_x = g_x * kernel_x.Multiplier + kernel_x.Threeshold;  	g_y = g_y * kernel_y.Multiplier + kernel_y.Threeshold;  	step2 [x' y] = (byte)Math.Sqrt (g_x * g_x + g_y * g_y);  	// (2) Calculate edge direction' using Gx and Gy  	if (0 == g_x) {  		edges_dir [x' y] = (0 == g_y ? 0 : 90);  	}  	else {  		// need to convert in degree  		edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  	}  	// (3) Relate edge direction to a direction that can be traced in the image (0º' 45º' 90º' 135º)  	dummy = edges_dir [x' y];  	// [0;22.5] e [157.5;180]  = 0  	// [22.5;67.5] = 45  	// [67.5;112.5] = 90  	// [112.5;157.5] = 135  	//if (dummy > 180)  	//    throw new Exception(string.Format("Theta = {0}"' dummy));  	if (dummy >= 157.5 || dummy < 22.5) {  		edges_dir [x' y] = 0;  	}  	else if (dummy >= 112.5) {  		edges_dir [x' y] = 135;  	}  	else if (dummy >= 67.5) {  		edges_dir [x' y] = 90;  	}  	else if (dummy >= 22.5) {  		edges_dir [x' y] = 45;  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (0 == g_x) {  	edges_dir [x' y] = (0 == g_y ? 0 : 90);  }  else {  	// need to convert in degree  	edges_dir [x' y] = Math.Atan (g_y / g_x) * degree_factor;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: edges_dir [x' y] = (0 == g_y ? 0 : 90);  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 157.5 || dummy < 22.5) {  	edges_dir [x' y] = 0;  }  else if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 157.5 || dummy < 22.5) {  	edges_dir [x' y] = 0;  }  else if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 157.5 || dummy < 22.5) {  	edges_dir [x' y] = 0;  }  else if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 157.5 || dummy < 22.5) {  	edges_dir [x' y] = 0;  }  else if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 157.5 || dummy < 22.5) {  	edges_dir [x' y] = 0;  }  else if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 157.5 || dummy < 22.5) {  	edges_dir [x' y] = 0;  }  else if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 157.5 || dummy < 22.5) {  	edges_dir [x' y] = 0;  }  else if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 157.5 || dummy < 22.5) {  	edges_dir [x' y] = 0;  }  else if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 112.5) {  	edges_dir [x' y] = 135;  }  else if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: edges_dir [x' y] = 135;  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 67.5) {  	edges_dir [x' y] = 90;  }  else if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: edges_dir [x' y] = 90;  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: if (dummy >= 22.5) {  	edges_dir [x' y] = 45;  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,ApplyFilter,The following statement contains a magic number: edges_dir [x' y] = 45;  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (0 == dir) {  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y + 1 < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  else if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (0 == dir) {  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y + 1 < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  else if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (0 == dir) {  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y + 1 < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  else if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (0 == dir) {  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y + 1 < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  else if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (45 == dir) {  	if (y - 1 >= 0 && x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y - 1));  	}  	if (y + 1 < h && x + 1 < w) {  		neigh.Add (new Point (x + 1' y + 1));  	}  }  else if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (90 == dir) {  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  	}  	if (x + 1 < w) {  		neigh.Add (new Point (x + 1' y));  	}  }  else if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (135 == dir) {  	if (x - 1 >= 0 && y + 1 < w) {  		neigh.Add (new Point (x - 1' y + 1));  	}  	if (x + 1 < h && y - 1 >= 0) {  		neigh.Add (new Point (x + 1' y - 1));  	}  }  else if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,NonMaximumSupression,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\NonMaximumSupression.cs,GetNeighborhood,The following statement contains a magic number: if (360 == dir) {  	// ALL DIRECTIONS ...  	if (x - 1 >= 0) {  		neigh.Add (new Point (x - 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x - 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x - 1' y + 1));  		}  	}  	if (x + 1 < h) {  		neigh.Add (new Point (x + 1' y));  		if (y - 1 >= 0) {  			neigh.Add (new Point (x + 1' y - 1));  		}  		if (y < h) {  			neigh.Add (new Point (x + 1' y + 1));  		}  	}  	if (y - 1 >= 0) {  		neigh.Add (new Point (x' y - 1));  	}  	if (y < h) {  		neigh.Add (new Point (x' y + 1));  	}  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  	}  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  	}  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  	}  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: ret [x' y] = Color.FromArgb (255 - colors [x' y].R' 255 - colors [x' y].G' 255 - colors [x' y].B);  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		ret [x' y] = (byte)(255 - img [x' y]);  	}  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	ret [x' y] = (byte)(255 - img [x' y]);  }  
Magic Number,Framework.Filters.Simple,Invert,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Simple\Invert.cs,ApplyFilter,The following statement contains a magic number: ret [x' y] = (byte)(255 - img [x' y]);  
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("b"' new Rangeable (0.9' 0.0001' 0.9999' 0.0001));  
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("b"' new Rangeable (0.9' 0.0001' 0.9999' 0.0001));  
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("b"' new Rangeable (0.9' 0.0001' 0.9999' 0.0001));  
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("b"' new Rangeable (0.9' 0.0001' 0.9999' 0.0001));  
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,ApplyIsefHorizontal,The following statement contains a magic number: for (x = 0; x < width; ++x) {  	for (y = height - 2; y >= 0; --y) {  		anticausal [x' y] = b2 * data [x' y] + b * anticausal [x' y + 1];  	}  }  
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,ApplyIsefHorizontal,The following statement contains a magic number: for (y = height - 2; y >= 0; --y) {  	anticausal [x' y] = b2 * data [x' y] + b * anticausal [x' y + 1];  }  
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,ApplyIsefHorizontal,The following statement contains a magic number: y = height - 2
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,ApplyIsefVertical,The following statement contains a magic number: for (x = width - 2; x >= 0; --x) {  	for (y = 0; y < height; ++y) {  		anticausal [x' y] = b2 * data [x' y] + b * anticausal [x + 1' y];  	}  }  
Magic Number,Framework.Filters.Smoothing,Isef,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Isef.cs,ApplyIsefVertical,The following statement contains a magic number: x = width - 2
Magic Number,Framework.Filters.Smoothing,Homomorphic,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Homomorphic.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (1.0' 1.0' 2.0' 0.0001));  
Magic Number,Framework.Filters.Smoothing,Homomorphic,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Homomorphic.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (1.0' 1.0' 2.0' 0.0001));  
Magic Number,Framework.Filters.Smoothing,Homomorphic,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Homomorphic.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Beta"' new Rangeable (0.0001' 0.0' 1.0' 0.0001));  
Magic Number,Framework.Filters.Smoothing,Homomorphic,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Homomorphic.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Beta"' new Rangeable (0.0001' 0.0' 1.0' 0.0001));  
Magic Number,Framework.Filters.Smoothing,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Gaussian.cs,GenerateFilter,The following statement contains a magic number: if (size % 2 == 0)  	throw new Exception (string.Format ("Size must be odd! (size = {0} for sigma = {1})"' size' sigma));  
Magic Number,Framework.Filters.Smoothing,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Sigma"' new Rangeable (0.5' 0.5' 20' 0.5));  
Magic Number,Framework.Filters.Smoothing,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Sigma"' new Rangeable (0.5' 0.5' 20' 0.5));  
Magic Number,Framework.Filters.Smoothing,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Sigma"' new Rangeable (0.5' 0.5' 20' 0.5));  
Magic Number,Framework.Filters.Smoothing,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Sigma"' new Rangeable (0.5' 0.5' 20' 0.5));  
Magic Number,Framework.Filters.Smoothing,Wiener,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Wiener.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing,Wiener,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Wiener.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing,Wiener,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Wiener.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing,Wiener,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Wiener.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (255' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (255' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Alpha"' new Rangeable (255' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: a = Math.Sqrt (var / (double)alpha) / 2.0;  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (x = 0; x < width; ++x) {  	for (y = 0; y < height; ++y) {  		image1 = 0.0;  		for (i = 1; i <= alpha; ++i) {  			rnd.NextBytes (rnd_buffer);  			// Force to ushort' in range [0; 32767]  			rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  			noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  			rnd.NextBytes (rnd_buffer);  			// Force to ushort' in range [0; 32767]  			rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  			theta = rnd_value * MAGIC - Math.PI;  			rx = noise * Math.Cos (theta);  			ry = noise * Math.Sin (theta);  			noise = rx * rx + ry * ry;  			image1 += noise;  		}  		noise_int = (int)Math.Ceiling (image1);  		// (image1 + .5);  		noise_int += img [x' y];  		// add noise to image   		noise_int = (int)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' noise_int));  		ret [x' y] = (Byte)noise_int;  	}  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (x = 0; x < width; ++x) {  	for (y = 0; y < height; ++y) {  		image1 = 0.0;  		for (i = 1; i <= alpha; ++i) {  			rnd.NextBytes (rnd_buffer);  			// Force to ushort' in range [0; 32767]  			rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  			noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  			rnd.NextBytes (rnd_buffer);  			// Force to ushort' in range [0; 32767]  			rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  			theta = rnd_value * MAGIC - Math.PI;  			rx = noise * Math.Cos (theta);  			ry = noise * Math.Sin (theta);  			noise = rx * rx + ry * ry;  			image1 += noise;  		}  		noise_int = (int)Math.Ceiling (image1);  		// (image1 + .5);  		noise_int += img [x' y];  		// add noise to image   		noise_int = (int)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' noise_int));  		ret [x' y] = (Byte)noise_int;  	}  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (x = 0; x < width; ++x) {  	for (y = 0; y < height; ++y) {  		image1 = 0.0;  		for (i = 1; i <= alpha; ++i) {  			rnd.NextBytes (rnd_buffer);  			// Force to ushort' in range [0; 32767]  			rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  			noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  			rnd.NextBytes (rnd_buffer);  			// Force to ushort' in range [0; 32767]  			rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  			theta = rnd_value * MAGIC - Math.PI;  			rx = noise * Math.Cos (theta);  			ry = noise * Math.Sin (theta);  			noise = rx * rx + ry * ry;  			image1 += noise;  		}  		noise_int = (int)Math.Ceiling (image1);  		// (image1 + .5);  		noise_int += img [x' y];  		// add noise to image   		noise_int = (int)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' noise_int));  		ret [x' y] = (Byte)noise_int;  	}  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (x = 0; x < width; ++x) {  	for (y = 0; y < height; ++y) {  		image1 = 0.0;  		for (i = 1; i <= alpha; ++i) {  			rnd.NextBytes (rnd_buffer);  			// Force to ushort' in range [0; 32767]  			rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  			noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  			rnd.NextBytes (rnd_buffer);  			// Force to ushort' in range [0; 32767]  			rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  			theta = rnd_value * MAGIC - Math.PI;  			rx = noise * Math.Cos (theta);  			ry = noise * Math.Sin (theta);  			noise = rx * rx + ry * ry;  			image1 += noise;  		}  		noise_int = (int)Math.Ceiling (image1);  		// (image1 + .5);  		noise_int += img [x' y];  		// add noise to image   		noise_int = (int)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' noise_int));  		ret [x' y] = (Byte)noise_int;  	}  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (y = 0; y < height; ++y) {  	image1 = 0.0;  	for (i = 1; i <= alpha; ++i) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC - Math.PI;  		rx = noise * Math.Cos (theta);  		ry = noise * Math.Sin (theta);  		noise = rx * rx + ry * ry;  		image1 += noise;  	}  	noise_int = (int)Math.Ceiling (image1);  	// (image1 + .5);  	noise_int += img [x' y];  	// add noise to image   	noise_int = (int)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' noise_int));  	ret [x' y] = (Byte)noise_int;  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (y = 0; y < height; ++y) {  	image1 = 0.0;  	for (i = 1; i <= alpha; ++i) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC - Math.PI;  		rx = noise * Math.Cos (theta);  		ry = noise * Math.Sin (theta);  		noise = rx * rx + ry * ry;  		image1 += noise;  	}  	noise_int = (int)Math.Ceiling (image1);  	// (image1 + .5);  	noise_int += img [x' y];  	// add noise to image   	noise_int = (int)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' noise_int));  	ret [x' y] = (Byte)noise_int;  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (y = 0; y < height; ++y) {  	image1 = 0.0;  	for (i = 1; i <= alpha; ++i) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC - Math.PI;  		rx = noise * Math.Cos (theta);  		ry = noise * Math.Sin (theta);  		noise = rx * rx + ry * ry;  		image1 += noise;  	}  	noise_int = (int)Math.Ceiling (image1);  	// (image1 + .5);  	noise_int += img [x' y];  	// add noise to image   	noise_int = (int)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' noise_int));  	ret [x' y] = (Byte)noise_int;  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (y = 0; y < height; ++y) {  	image1 = 0.0;  	for (i = 1; i <= alpha; ++i) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC - Math.PI;  		rx = noise * Math.Cos (theta);  		ry = noise * Math.Sin (theta);  		noise = rx * rx + ry * ry;  		image1 += noise;  	}  	noise_int = (int)Math.Ceiling (image1);  	// (image1 + .5);  	noise_int += img [x' y];  	// add noise to image   	noise_int = (int)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' noise_int));  	ret [x' y] = (Byte)noise_int;  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (i = 1; i <= alpha; ++i) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC - Math.PI;  	rx = noise * Math.Cos (theta);  	ry = noise * Math.Sin (theta);  	noise = rx * rx + ry * ry;  	image1 += noise;  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (i = 1; i <= alpha; ++i) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC - Math.PI;  	rx = noise * Math.Cos (theta);  	ry = noise * Math.Sin (theta);  	noise = rx * rx + ry * ry;  	image1 += noise;  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (i = 1; i <= alpha; ++i) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC - Math.PI;  	rx = noise * Math.Cos (theta);  	ry = noise * Math.Sin (theta);  	noise = rx * rx + ry * ry;  	image1 += noise;  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: for (i = 1; i <= alpha; ++i) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC - Math.PI;  	rx = noise * Math.Cos (theta);  	ry = noise * Math.Sin (theta);  	noise = rx * rx + ry * ry;  	image1 += noise;  }  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: noise = Math.Sqrt (-2 * a * Math.Log (1.0 - rnd_value / 32767.1));  
Magic Number,Framework.Filters.Noise,GammaNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GammaNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Mean"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Mean"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Mean"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC * Math.PI;  		noise *= Math.Cos (theta);  		noise += mean;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC * Math.PI;  		noise *= Math.Cos (theta);  		noise += mean;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC * Math.PI;  		noise *= Math.Cos (theta);  		noise += mean;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC * Math.PI;  		noise *= Math.Cos (theta);  		noise += mean;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC * Math.PI;  	noise *= Math.Cos (theta);  	noise += mean;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC * Math.PI;  	noise *= Math.Cos (theta);  	noise += mean;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC * Math.PI;  	noise *= Math.Cos (theta);  	noise += mean;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC * Math.PI;  	noise *= Math.Cos (theta);  	noise += mean;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: noise = Math.Sqrt (-2 * var * Math.Log (1.0 - rnd_value / 32767.1));  
Magic Number,Framework.Filters.Noise,GaussianNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\GaussianNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC - Math.PI;  		rx = noise * Math.Cos (theta);  		ry = noise * Math.Sin (theta);  		noise = rx * rx + ry * ry;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		// trim  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC - Math.PI;  		rx = noise * Math.Cos (theta);  		ry = noise * Math.Sin (theta);  		noise = rx * rx + ry * ry;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		// trim  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC - Math.PI;  		rx = noise * Math.Cos (theta);  		ry = noise * Math.Sin (theta);  		noise = rx * rx + ry * ry;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		// trim  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		theta = rnd_value * MAGIC - Math.PI;  		rx = noise * Math.Cos (theta);  		ry = noise * Math.Sin (theta);  		noise = rx * rx + ry * ry;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		// trim  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC - Math.PI;  	rx = noise * Math.Cos (theta);  	ry = noise * Math.Sin (theta);  	noise = rx * rx + ry * ry;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	// trim  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC - Math.PI;  	rx = noise * Math.Cos (theta);  	ry = noise * Math.Sin (theta);  	noise = rx * rx + ry * ry;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	// trim  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC - Math.PI;  	rx = noise * Math.Cos (theta);  	ry = noise * Math.Sin (theta);  	noise = rx * rx + ry * ry;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	// trim  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	theta = rnd_value * MAGIC - Math.PI;  	rx = noise * Math.Cos (theta);  	ry = noise * Math.Sin (theta);  	noise = rx * rx + ry * ry;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	// trim  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: noise = Math.Sqrt (-2 * sqrt_var_half * Math.Log (1.0 - rnd_value / 32767.1));  
Magic Number,Framework.Filters.Noise,NegativeExponentialNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\NegativeExponentialNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * par * Math.Log (1.0 - rnd_value / 32767.1));  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		ret [x' y] = (Byte)Math.Ceiling (noise);  		//(Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * par * Math.Log (1.0 - rnd_value / 32767.1));  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		ret [x' y] = (Byte)Math.Ceiling (noise);  		//(Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = Math.Sqrt (-2 * par * Math.Log (1.0 - rnd_value / 32767.1));  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		ret [x' y] = (Byte)Math.Ceiling (noise);  		//(Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * par * Math.Log (1.0 - rnd_value / 32767.1));  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	ret [x' y] = (Byte)Math.Ceiling (noise);  	//(Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * par * Math.Log (1.0 - rnd_value / 32767.1));  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	ret [x' y] = (Byte)Math.Ceiling (noise);  	//(Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = Math.Sqrt (-2 * par * Math.Log (1.0 - rnd_value / 32767.1));  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	ret [x' y] = (Byte)Math.Ceiling (noise);  	//(Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: noise = Math.Sqrt (-2 * par * Math.Log (1.0 - rnd_value / 32767.1));  
Magic Number,Framework.Filters.Noise,RayleighNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\RayleighNoise.cs,ApplyFilter,The following statement contains a magic number: noise = Math.Sqrt (-2 * par * Math.Log (1.0 - rnd_value / 32767.1));  
Magic Number,Framework.Filters.Noise,SaltPepperNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\SaltPepperNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Probability"' new Rangeable (0.15' 0' 1' 0.0001));  
Magic Number,Framework.Filters.Noise,SaltPepperNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\SaltPepperNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Probability"' new Rangeable (0.15' 0' 1' 0.0001));  
Magic Number,Framework.Filters.Noise,SaltPepperNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\SaltPepperNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		if (rnd_value >= MAGIC && rnd_value < prob_norm1)  			ret [x' y] = byte.MinValue;  		// pepper forces to 0 (BLACK)  		else if (rnd_value < MAGIC && rnd_value >= prob_norm2)  			ret [x' y] = byte.MaxValue;  		// salt forces to 255 (WHITE)  		else  			ret [x' y] = img [x' y];  	}  }  
Magic Number,Framework.Filters.Noise,SaltPepperNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\SaltPepperNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	if (rnd_value >= MAGIC && rnd_value < prob_norm1)  		ret [x' y] = byte.MinValue;  	// pepper forces to 0 (BLACK)  	else if (rnd_value < MAGIC && rnd_value >= prob_norm2)  		ret [x' y] = byte.MaxValue;  	// salt forces to 255 (WHITE)  	else  		ret [x' y] = img [x' y];  }  
Magic Number,Framework.Filters.Noise,SaltPepperNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\SaltPepperNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Var"' new Rangeable (0.5' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Mean"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Mean"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("Mean"' new Rangeable (10' 0' 255' 0.5));  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,ApplyFilter,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		rnd.NextBytes (rnd_buffer);  		// Force to ushort' in range [0; 32767]  		rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  		noise = sqrt_var * MAGIC * rnd_value + mean - sqrt_var * MAGIC2;  		noise += img [x' y];  		// add noise to image   		noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  		// trim  		ret [x' y] = (Byte)Math.Ceiling (noise);  		// (Byte)(noise + 0.5);  	}  }  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,ApplyFilter,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	rnd.NextBytes (rnd_buffer);  	// Force to ushort' in range [0; 32767]  	rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  	noise = sqrt_var * MAGIC * rnd_value + mean - sqrt_var * MAGIC2;  	noise += img [x' y];  	// add noise to image   	noise = Math.Max (byte.MinValue' Math.Min (byte.MaxValue' noise));  	// trim  	ret [x' y] = (Byte)Math.Ceiling (noise);  	// (Byte)(noise + 0.5);  }  
Magic Number,Framework.Filters.Noise,UniformNoise,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Noise\UniformNoise.cs,ApplyFilter,The following statement contains a magic number: rnd_value = (ushort)(BitConverter.ToUInt16 (rnd_buffer' 0) % 32768);  
Magic Number,Framework.Filters.Sharpening,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Sharpening,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Sharpening,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("n"' new Rangeable (2.0' 1.0' 10.0' 1));  
Magic Number,Framework.Filters.Sharpening,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("n"' new Rangeable (2.0' 1.0' 10.0' 1));  
Magic Number,Framework.Filters.Sharpening,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Butterworth.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	return 1 / (1.0 + Math.Pow (d0 / FrequencyFilter.D (u' v' width' height)' 2 * n));  });  
Magic Number,Framework.Filters.Sharpening,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Butterworth.cs,ApplyFilter,The following statement contains a magic number: return 1 / (1.0 + Math.Pow (d0 / FrequencyFilter.D (u' v' width' height)' 2 * n));  
Magic Number,Framework.Filters.Sharpening,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Sharpening,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Sharpening,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	return 1.0 - Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  });  
Magic Number,Framework.Filters.Sharpening,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	return 1.0 - Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  });  
Magic Number,Framework.Filters.Sharpening,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	return 1.0 - Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  });  
Magic Number,Framework.Filters.Sharpening,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return 1.0 - Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  
Magic Number,Framework.Filters.Sharpening,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return 1.0 - Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  
Magic Number,Framework.Filters.Sharpening,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return 1.0 - Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  
Magic Number,Framework.Filters.Sharpening,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Sharpening,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Sharpening\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Smoothing.Frequency,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Smoothing.Frequency,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Smoothing.Frequency,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("n"' new Rangeable (2.0' 1.0' 10.0' 1));  
Magic Number,Framework.Filters.Smoothing.Frequency,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Butterworth.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("n"' new Rangeable (2.0' 1.0' 10.0' 1));  
Magic Number,Framework.Filters.Smoothing.Frequency,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Butterworth.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	return 1 / (1.0 + Math.Pow (FrequencyFilter.D (u' v' width' height) / d0' 2 * n));  });  
Magic Number,Framework.Filters.Smoothing.Frequency,Butterworth,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Butterworth.cs,ApplyFilter,The following statement contains a magic number: return 1 / (1.0 + Math.Pow (FrequencyFilter.D (u' v' width' height) / d0' 2 * n));  
Magic Number,Framework.Filters.Smoothing.Frequency,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Smoothing.Frequency,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Gaussian.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Smoothing.Frequency,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	return Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  });  
Magic Number,Framework.Filters.Smoothing.Frequency,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	return Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  });  
Magic Number,Framework.Filters.Smoothing.Frequency,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return FrequencyFilter.ApplyFilter (complexImg' delegate (int u' int v) {  	return Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  });  
Magic Number,Framework.Filters.Smoothing.Frequency,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  
Magic Number,Framework.Filters.Smoothing.Frequency,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  
Magic Number,Framework.Filters.Smoothing.Frequency,Gaussian,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Gaussian.cs,ApplyFilter,The following statement contains a magic number: return Math.Exp (-1.0 * Math.Pow (FrequencyFilter.D (u' v' width' height)' 2) / (2.0 * Math.Pow (d0' 2)));  
Magic Number,Framework.Filters.Smoothing.Frequency,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Smoothing.Frequency,Ideal,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Frequency\Ideal.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("D0"' new Rangeable (15' 1' 3000' 1));  
Magic Number,Framework.Filters.Smoothing.Mean,ContraharmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ContraharmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,ContraharmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ContraharmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,ContraharmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ContraharmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,ContraharmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ContraharmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,ContraharmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ContraharmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("order"' new Rangeable (1' 1' 5' 1));  
Magic Number,Framework.Filters.Smoothing.Mean,ContraharmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ContraharmonicMean.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Filters.Smoothing.Mean,GeometricMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\GeometricMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,GeometricMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\GeometricMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,GeometricMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\GeometricMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,GeometricMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\GeometricMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,GeometricMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\GeometricMean.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Filters.Smoothing.Mean,HarmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\HarmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,HarmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\HarmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,HarmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\HarmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,HarmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\HarmonicMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,HarmonicMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\HarmonicMean.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Filters.Smoothing.Mean,ArithmeticMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ArithmeticMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,ArithmeticMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ArithmeticMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,ArithmeticMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ArithmeticMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,ArithmeticMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ArithmeticMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.Mean,ArithmeticMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\Mean\ArithmeticMean.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("p"' new Rangeable (1' 1' 20' 1));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,ApplyFilter,The following statement contains a magic number: if (diff > 0) {  	byte[] zeros = new byte[diff / 2];  	byte[] maxes = new byte[(int)Math.Ceiling (diff / 2.0)];  	// zeros automatically initialized with zeros  	// ...  	// init maxes to byte.MaxValue  	for (i = 0; i < maxes.Length; ++i)  		maxes [i] = byte.MaxValue;  	tmp.InsertRange (0' zeros);  	tmp.AddRange (maxes);  }  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,ApplyFilter,The following statement contains a magic number: if (diff > 0) {  	byte[] zeros = new byte[diff / 2];  	byte[] maxes = new byte[(int)Math.Ceiling (diff / 2.0)];  	// zeros automatically initialized with zeros  	// ...  	// init maxes to byte.MaxValue  	for (i = 0; i < maxes.Length; ++i)  		maxes [i] = byte.MaxValue;  	tmp.InsertRange (0' zeros);  	tmp.AddRange (maxes);  }  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,ApplyFilter,The following statement contains a magic number: if (tmp.Count > 0) {  	// Sort  	tmp.Sort ();  	ret = 0.0;  	for (i = p; i < tmp.Count - p; ++i) {  		ret += tmp [i];  	}  	ret = 1.0 / ((double)tmp.Count - 2.0 * (double)p) * ret;  	// trim  	ret = Math.Min (byte.MaxValue' Math.Max (byte.MinValue' ret));  	return (Byte)ret;  }  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,AlphaTrimmedMean,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\AlphaTrimmedMean.cs,ApplyFilter,The following statement contains a magic number: ret = 1.0 / ((double)tmp.Count - 2.0 * (double)p) * ret;  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Max,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Max.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Max,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Max.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Max,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Max.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Max,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Max.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Max,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Max.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Median,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Median.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Median,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Median.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Median,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Median.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Median,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Median.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Median,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Median.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Median,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Median.cs,ApplyFilter,The following statement contains a magic number: if (tmp.Count > 0) {  	// Sort  	tmp.Sort ();  	// Get pixel in middle  	return tmp [tmp.Count / 2];  }  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Median,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Median.cs,ApplyFilter,The following statement contains a magic number: return tmp [tmp.Count / 2];  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Midpoint,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Midpoint.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Midpoint,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Midpoint.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Midpoint,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Midpoint.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Midpoint,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Midpoint.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Midpoint,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Midpoint.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Midpoint,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Midpoint.cs,ApplyFilter,The following statement contains a magic number: return (Byte)Math.Min (byte.MaxValue' Math.Max (byte.MinValue' Math.Ceiling (0.5 * (_max + _min))));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Min,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Min.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Min,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Min.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Min,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Min.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Min,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Min.cs,GetDefaultConfigs,The following statement contains a magic number: ret.Add ("window size"' new Rangeable (3' 3' 333' 2));  
Magic Number,Framework.Filters.Smoothing.OrderStatistics,Min,C:\repos\fabriceleal_ImageProcessing\Framework\Filters\Smoothing\OrderStatistics\Min.cs,ApplyFilter,The following statement contains a magic number: if (window_size % 2 == 0)  	throw new Exception ("Window size must be odd!");  
Magic Number,Framework.Range,Rangeable,C:\repos\fabriceleal_ImageProcessing\Framework\Range\Rangeable.cs,ForNormalizedDouble,The following statement contains a magic number: return new Rangeable ((double)d' 0.0' 1.0' (1.0 / 255.0));  
Magic Number,Framework.Range,Rangeable,C:\repos\fabriceleal_ImageProcessing\Framework\Range\Rangeable.cs,ForDouble,The following statement contains a magic number: return new Rangeable (d' double.MinValue' double.MaxValue' 0.0001);  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyTransformBase,The following statement contains a magic number: if (Math.Log (width' 2) % 1 > 0)  	throw new ArgumentException ("Width of image is not base 2.");  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyTransformBase,The following statement contains a magic number: if (Math.Log (height' 2) % 1 > 0)  	throw new ArgumentException ("Height of image is not base 2.");  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyTransformBase,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	for (int y = 0; y < height; ++y) {  		// Dummy  		//transf[x' y] = dataSpatialDomain[x' y] * Math.Pow(-1' x + y);  		// Clever  		transf [x' y] = dataSpatialDomain [x' y];  		if ((x + y) % 2 != 0) {  			transf [x' y] = -1 * transf [x' y];  		}  	}  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyTransformBase,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	// Dummy  	//transf[x' y] = dataSpatialDomain[x' y] * Math.Pow(-1' x + y);  	// Clever  	transf [x' y] = dataSpatialDomain [x' y];  	if ((x + y) % 2 != 0) {  		transf [x' y] = -1 * transf [x' y];  	}  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyTransformBase,The following statement contains a magic number: if ((x + y) % 2 != 0) {  	transf [x' y] = -1 * transf [x' y];  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyReverseTransformBase,The following statement contains a magic number: for (i = 0; i < width; i++)  	for (j = 0; j < height; j++) {  		// The algorithm uses Magnitude... Gonzalez says real. Gonzalez wins.  		// Dummy  		//ret[i' j] = output[i' j].real * Math.Pow(-1' i + j);  		// Clever  		ret [i' j] = output [i' j].real;  		if ((i + j) % 2 != 0) {  			ret [i' j] = -1 * ret [i' j];  		}  	}  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyReverseTransformBase,The following statement contains a magic number: for (j = 0; j < height; j++) {  	// The algorithm uses Magnitude... Gonzalez says real. Gonzalez wins.  	// Dummy  	//ret[i' j] = output[i' j].real * Math.Pow(-1' i + j);  	// Clever  	ret [i' j] = output [i' j].real;  	if ((i + j) % 2 != 0) {  		ret [i' j] = -1 * ret [i' j];  	}  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyReverseTransformBase,The following statement contains a magic number: if ((i + j) % 2 != 0) {  	ret [i' j] = -1 * ret [i' j];  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyTransform,The following statement contains a magic number: if (Math.Log (width' 2) % 1 > 0)  	throw new ArgumentException ("Width of image is not base 2.");  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,ApplyTransform,The following statement contains a magic number: if (Math.Log (height' 2) % 1 > 0)  	throw new ArgumentException ("Height of image is not base 2.");  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT2D,The following statement contains a magic number: for (j = 0; j < c.Height; j++) {  	for (i = 0; i < c.Width; i++) {  		real [i] = c [i' j].real;  		imag [i] = c [i' j].imag;  	}  	// Calling 1D FFT Function for Rows  	m = (int)Math.Log ((double)c.Width' 2);  	//Finding power of 2 for current number of points e.g. for nx=512 m=9  	FFT1D (dir' m' ref real' ref imag);  	for (i = 0; i < c.Width; i++) {  		//  c[i'j].real = real[i];  		//  c[i'j].imag = imag[i];  		output [i' j].real = real [i];  		output [i' j].imag = imag [i];  	}  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT2D,The following statement contains a magic number: m = (int)Math.Log ((double)c.Width' 2);  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT2D,The following statement contains a magic number: for (i = 0; i < c.Width; i++) {  	for (j = 0; j < c.Height; j++) {  		//real[j] = c[i'j].real;  		//imag[j] = c[i'j].imag;  		real [j] = output [i' j].real;  		imag [j] = output [i' j].imag;  	}  	// Calling 1D FFT Function for Columns  	m = (int)Math.Log ((double)c.Height' 2);  	//Finding power of 2 for current number of points e.g. for nx=512 m=9  	FFT1D (dir' m' ref real' ref imag);  	for (j = 0; j < c.Height; j++) {  		//c[i'j].real = real[j];  		//c[i'j].imag = imag[j];  		output [i' j].real = real [j];  		output [i' j].imag = imag [j];  	}  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT2D,The following statement contains a magic number: m = (int)Math.Log ((double)c.Height' 2);  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT1D,The following statement contains a magic number: for (i = 0; i < m; i++)  	nn *= 2;  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT1D,The following statement contains a magic number: nn *= 2;  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT1D,The following statement contains a magic number: for (l = 0; l < m; l++) {  	l1 = l2;  	l2 <<= 1;  	u1 = 1.0;  	u2 = 0.0;  	for (j = 0; j < l1; j++) {  		for (i = j; i < nn; i += l2) {  			i1 = i + l1;  			t1 = u1 * x [i1] - u2 * y [i1];  			t2 = u1 * y [i1] + u2 * x [i1];  			x [i1] = x [i] - t1;  			y [i1] = y [i] - t2;  			x [i] += t1;  			y [i] += t2;  		}  		z = u1 * c1 - u2 * c2;  		u2 = u1 * c2 + u2 * c1;  		u1 = z;  	}  	c2 = Math.Sqrt ((1.0 - c1) / 2.0);  	if (dir == FFTDirection.Forward)  		c2 = -c2;  	c1 = Math.Sqrt ((1.0 + c1) / 2.0);  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT1D,The following statement contains a magic number: for (l = 0; l < m; l++) {  	l1 = l2;  	l2 <<= 1;  	u1 = 1.0;  	u2 = 0.0;  	for (j = 0; j < l1; j++) {  		for (i = j; i < nn; i += l2) {  			i1 = i + l1;  			t1 = u1 * x [i1] - u2 * y [i1];  			t2 = u1 * y [i1] + u2 * x [i1];  			x [i1] = x [i] - t1;  			y [i1] = y [i] - t2;  			x [i] += t1;  			y [i] += t2;  		}  		z = u1 * c1 - u2 * c2;  		u2 = u1 * c2 + u2 * c1;  		u1 = z;  	}  	c2 = Math.Sqrt ((1.0 - c1) / 2.0);  	if (dir == FFTDirection.Forward)  		c2 = -c2;  	c1 = Math.Sqrt ((1.0 + c1) / 2.0);  }  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT1D,The following statement contains a magic number: c2 = Math.Sqrt ((1.0 - c1) / 2.0);  
Magic Number,Framework.Transforms,FastFourierTransform,C:\repos\fabriceleal_ImageProcessing\Framework\Transforms\FastFourierTransform.cs,FFT1D,The following statement contains a magic number: c1 = Math.Sqrt ((1.0 + c1) / 2.0);  
Missing Default,Framework.Batch,BatchFilter,C:\repos\fabriceleal_ImageProcessing\Framework\Batch\BatchFilter.cs,Load,The following switch statement is missing a default case: switch (m.Field<MetricExecutionType> ("TypeMetric")) {  case MetricExecutionType.InputOutput:  	measures.Add (new MetricExec (m.Field<string> ("Key")' mm));  	break;  case MetricExecutionType.RefOutput:  	measures.Add (new MetricExecReference (m.Field<string> ("Key")' mm' new WeakImage (Facilities.ToImage (m.Field<string> ("Input")))));  	break;  }  
Missing Default,Framework.Core.Filters.Frequency,ComplexImage,C:\repos\fabriceleal_ImageProcessing\Framework\Core\Filters\Frequency\ComplexImage.cs,ToBitmap,The following switch statement is missing a default case: switch (bitmapType) {  case ComplexImageBitmapType.Magnitude:  	data [x' y] = transform [x' y].Magnitude ();  	logs [x' y] = (float)(Math.Log (0.1 + data [x' y]));  	break;  case ComplexImageBitmapType.Phase:  	data [x' y] = transform [x' y].Phase ();  	logs [x' y] = (float)Math.Log (0.1 + Math.Abs (data [x' y]));  	break;  }  
