Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MonoDevelop.Debugger.Gdb,GdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,GetExpressionCompletionData,Cyclomatic complexity of the method is 13
Complex Method,MonoDevelop.Debugger.Gdb,GdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,CreateFrame,Cyclomatic complexity of the method is 8
Long Parameter List,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetArrayChildren,The method has 5 parameters. Parameters: cacheNode' arrayPath' index' elementsToDisplay' options
Long Parameter List,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluatePrimitive,The method has 5 parameters. Parameters: rawBytes' start' t' flags' path
Long Parameter List,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateArray,The method has 5 parameters. Parameters: rawBytes' start' t' flags' path
Long Parameter List,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateArray,The method has 5 parameters. Parameters: arrayLength' firstItemPointer' t' flags' path
Long Statement,MonoDevelop.Debugger.Gdb,GdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,GetParameters,The length of the statement  "			GdbCommandResult res = session.RunCommand ("-stack-list-arguments"' "0"' frameIndex.ToString ()' frameIndex.ToString ()); " is 121.
Long Statement,MonoDevelop.Debugger.Gdb,GdbDissassemblyBuffer,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,GetLines,The length of the statement  "				ResultData data = session.RunCommand ("-data-disassemble"' "-s"' startAddr.ToString ()' "-e"' endAddr.ToString ()' "--"' "0"); " is 126.
Long Statement,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,OnRun,The length of the statement  "						console = Runtime.ProcessService.StartConsoleProcess(script' ""' "."' ExternalConsoleFactory.Instance.CreateConsole(true)' null); " is 129.
Long Statement,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,UpdateHitCountData,The length of the statement  "				string val = res.GetObject ("BreakpointTable").GetObject ("body").GetObject (0).GetObject ("bkpt").GetValueString ("ignore"); " is 125.
Long Statement,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The length of the statement  "			ulong realIntPart = realFraction >> 63;											// extract bit 64 (explicit integer part)' this is hidden in double precision " is 127.
Long Statement,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The length of the statement  "			realFraction &= ~(ulong)(realIntPart << 63); // 0x7FFFFFFFFFFFFFFF				// use only 63 bits for fraction (strip off the integer part bit) " is 135.
Long Statement,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The length of the statement  "			ushort doubleExponent = (ushort)(realExponent - realBias /* unbias real */ + doubleBias /* bias double */);		// calculate the biased exponent for double precision " is 162.
Long Statement,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The length of the statement  "			 * ^done'name="var15"'numchild="0"'value="-2.9999999999999999999130411670751266e-154"'type="long double"'thread-id="1"'has_more="0" " is 130.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetArrayChildren,The length of the statement  "				//return ObjectValue.CreateNotSupported (ValueSource' path' t.ToCode ()' "Struct/Union arrays can't be examined yet"' flags); " is 125.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetMembersWithOffsets,The length of the statement  "				 * Very important on x64: if a long' array or pointer follows e.g. an int value' it'll be aligned to an 8 byte-base again. " is 121.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetClassInstanceChildren,The length of the statement  "			// read in the object bytes -- The length of an object can be read dynamically and thus the primary range of bytes that contain object properties. " is 146.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetClassInstanceChildren,The length of the statement  "						objectMembers.Add(ObjectValue.CreateObject(ValueSource' memberPath' memberType.ToCode()' memberType.ToString()' memberFlags' null)); " is 132.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetClassInstanceChildren,The length of the statement  "					Backtrace.DSession.LogWriter (false' "Error in GetClassInstanceChildren(memberPath="+memberPath.ToString()+"): " + ex.Message+"\n"); " is 132.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetClassInstanceChildren,The length of the statement  "					addressExpression = MemoryExamination.EnforceReadRawExpression+"((void*)"+MemoryExamination.BuildAddressExpression(cacheNode.addressExpression' "&({0})")+ "+"+currentOffset+")"; " is 177.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetClassInstanceChildren,The length of the statement  "					addressExpression = MemoryExamination.EnforceReadRawExpression+"((void*)"+MemoryExamination.BuildAddressExpression(cacheNode.addressExpression) + "+" + currentOffset+")"; " is 170.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateVariable,The length of the statement  "			foreach (var t in AmbiguousType.TryDissolve(ExpressionTypeEvaluation.EvaluateType(variableExpression' resolutionCtx' false))) { " is 127.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateVariable,The length of the statement  "						return ObjectValue.CreateNullObject (ValueSource' variableName' ms.Base != null ? ms.Base.ToString () : "<Unknown base type>"' BuildObjectValueFlags (ms)); " is 155.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateVariable,The length of the statement  "					return ObjectValue.CreatePrimitive (ValueSource' new ObjectPath (variableName)' "<unknown>"' new EvaluationResult (res.GetValueString ("value"))' ObjectValueFlags.Variable); " is 173.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateArray,The length of the statement  "				Memory.Read (firstItemPointer.ToString ()' DGdbTools.SizeOf(elementTypeToken) * elementsToDisplay' out rawArrayContent); " is 120.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateAssociativeArray,The length of the statement  "			return ObjectValue.CreateNotSupported (ValueSource' path' t.ToCode ()' "Associative arrays aren't supported yet"' flags); " is 121.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateClassInstance,The length of the statement  "			if (!Memory.Read (exp[0] == MemoryExamination.EnforceReadRawExpression ? exp : (MemoryExamination.EnforceReadRawExpression + exp)' out ptr) ||  " is 142.
Long Statement,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,EvaluateClassInstance,The length of the statement  "				return ObjectValue.CreateNullObject (ValueSource' path' actualClassType == null ? "<Unkown type>" : actualClassType.ToCode ()' flags); " is 134.
Long Statement,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,ReadObjectBytes,The length of the statement  "			if (!Read (EnforceReadRawExpression+"**(int*)(" + BuildAddressExpression(exp) + ")+" + CalcOffset(2)' out objectSize)) { " is 120.
Long Statement,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,Read,The length of the statement  "			data = Misc.ArrayConversionHelpers.HexStringToByteArray (res.GetObject("memory").GetObject(0).GetValueString ("contents")); " is 123.
Long Statement,MonoDevelop.Debugger.Gdb.D,ToStringExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\ToStringExamination.cs,InjectToStringCode,The length of the statement  "			//	c) an exception signaling flag (true' in case of exception occuring during <object>.toString() execution) - *($ptr+IntPtr.Size*2) " is 132.
Long Statement,MonoDevelop.Debugger.Gdb.D,ToStringExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\ToStringExamination.cs,InjectToStringCode,The length of the statement  "			// TODD: check on the result res' if it contains a warning (in cases GDB cannot execute inferior calls - a bug in kernel)  " is 121.
Long Statement,MonoDevelop.Debugger.Gdb.D,ToStringExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\ToStringExamination.cs,InvokeToString,The length of the statement  "				res = Session.RunCommand (string.Format (InvokeCommand' MemoryExamination.enforceRawExpr(ref exp) ? exp : ("(int*)"+exp))); " is 123.
Long Statement,MonoDevelop.Debugger.Gdb.D,Deh2,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\Deh2.cs,InjectBreakpoint,The length of the statement  "			var returnOffset = funcDefinition.IndexOf(DGdbSession.Is64Bit ? _eh_finddataSearchPattern_x64 : _eh_finddataSearchPattern_x86); " is 127.
Virtual Method Call from Constructor,MonoDevelop.Debugger.Gdb,GdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,GdbBacktrace,The constructor "GdbBacktrace" calls a virtual method "CreateFrame".
Virtual Method Call from Constructor,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,OptionPanel,The constructor "OptionPanel" calls a virtual method "Build".
Empty Catch Block,MonoDevelop.Debugger.Gdb,GdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,CreateFrame,The method has an empty catch block.
Empty Catch Block,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,OnRun,The method has an empty catch block.
Empty Catch Block,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,OnInsertBreakEvent,The method has an empty catch block.
Magic Number,MonoDevelop.Debugger.Gdb,GdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,GetExpressionCompletionData,The following statement contains a magic number: if (pointer || exp.EndsWith (".")) {  				exp = exp.Substring (0' exp.Length - (pointer ? 2 : 1));  				i = 0;  				while (i < exp.Length) {  					ObjectValue val = CreateVarObject (exp' session.EvaluationOptions);  					if (!val.IsUnknown && !val.IsError) {  						CompletionData data = new CompletionData ();  						foreach (ObjectValue cv in val.GetAllChildren ())  							data.Items.Add (new CompletionItem (cv.Name' cv.Flags));  						data.ExpressionLength = 0;  						return data;  					}  					i++;  				}  				return null;  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,CreateFrame,The following statement contains a magic number: if (!string.IsNullOrEmpty (sadr))  				addr = long.Parse (sadr.Substring (2)' NumberStyles.HexNumber);  			else  				addr = 0;
Magic Number,MonoDevelop.Debugger.Gdb,GdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,Disassemble,The following statement contains a magic number: if (buffer == null) {  				ResultData data = session.RunCommand ("-stack-info-frame");  				long addr = long.Parse (data.GetObject ("frame").GetValueString ("addr").Substring (2)' NumberStyles.HexNumber);  				buffer = new GdbDissassemblyBuffer (session' addr);  				disBuffers [frameIndex] = buffer;  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbDissassemblyBuffer,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbBacktrace.cs,GetLines,The following statement contains a magic number: try {  				ResultData data = session.RunCommand ("-data-disassemble"' "-s"' startAddr.ToString ()' "-e"' endAddr.ToString ()' "--"' "0");  				ResultData ins = data.GetObject ("asm_insns");  				  				var alines = new AssemblyLine [ins.Count];  				for (int n=0; n<ins.Count; n++) {  					ResultData aline = ins.GetObject (n);  					long addr = long.Parse (aline.GetValueString ("address").Substring (2)' NumberStyles.HexNumber);  					var line = new AssemblyLine (addr' aline.GetValueString ("inst"));  					alines [n] = line;  				}  				return alines;  			} catch {  				return new AssemblyLine [0];  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbCommandResult,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbCommandResult.cs,GdbCommandResult,The following statement contains a magic number: if (line.StartsWith ("^done")) {  				Status = CommandStatus.Done;  				ReadResults (line' 6);  			} else if (line.StartsWith ("^error")) {  				Status = CommandStatus.Error;  				if (line.Length > 7) {  					ReadResults (line' 7);  					ErrorMessage = GetValueString ("msg");  				}  			} else if (line.StartsWith ("^running")) {  				Status = CommandStatus.Running;  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbCommandResult,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbCommandResult.cs,GdbCommandResult,The following statement contains a magic number: if (line.StartsWith ("^done")) {  				Status = CommandStatus.Done;  				ReadResults (line' 6);  			} else if (line.StartsWith ("^error")) {  				Status = CommandStatus.Error;  				if (line.Length > 7) {  					ReadResults (line' 7);  					ErrorMessage = GetValueString ("msg");  				}  			} else if (line.StartsWith ("^running")) {  				Status = CommandStatus.Running;  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbCommandResult,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbCommandResult.cs,GdbCommandResult,The following statement contains a magic number: if (line.StartsWith ("^done")) {  				Status = CommandStatus.Done;  				ReadResults (line' 6);  			} else if (line.StartsWith ("^error")) {  				Status = CommandStatus.Error;  				if (line.Length > 7) {  					ReadResults (line' 7);  					ErrorMessage = GetValueString ("msg");  				}  			} else if (line.StartsWith ("^running")) {  				Status = CommandStatus.Running;  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,OnRun,The following statement contains a magic number: lock (gdbLock) {  				string tty = null;    				if (Environment.OSVersion.Platform == PlatformID.Unix)  				{  					// Create a script to be run in a terminal  					string script = Path.GetTempFileName();  					string ttyfile = Path.GetTempFileName();  					string ttyfileDone = ttyfile + "_done";    					try  					{  						File.WriteAllText(script' "tty > " + ttyfile + "\ntouch " + ttyfileDone + "\nsleep 10000d");  						Mono.Unix.Native.Syscall.chmod(script' Mono.Unix.Native.FilePermissions.ALLPERMS);    						console = Runtime.ProcessService.StartConsoleProcess(script' ""' "."' ExternalConsoleFactory.Instance.CreateConsole(true)' null);  						DateTime tim = DateTime.Now;  						while (!File.Exists(ttyfileDone))  						{  							System.Threading.Thread.Sleep(100);  							if ((DateTime.Now - tim).TotalSeconds > 10)  								throw new InvalidOperationException("Console could not be created.");  						}  						tty = File.ReadAllText(ttyfile).Trim(' '' '\n');  					}  					finally  					{  						try  						{  							if (File.Exists(script))  								File.Delete(script);  							if (File.Exists(ttyfile))  								File.Delete(ttyfile);  							if (File.Exists(ttyfileDone))  								File.Delete(ttyfileDone);  						}  						catch  						{  							// Ignore  						}  					}  				}    				StartGdb ();    				// Initialize the terminal  				if (tty != null) {  					RunCommand ("-inferior-tty-set"' Escape (tty));  				}    				try {  					RunCommand ("-file-exec-and-symbols"' Escape (startInfo.Command));  				}  				catch {  					FireTargetEvent (TargetEventType.TargetExited' null);  					throw;  				}    				RunCommand ("-environment-cd"' Escape (startInfo.WorkingDirectory));  				  				// Set inferior arguments  				if (!string.IsNullOrEmpty (startInfo.Arguments))  					RunCommand ("-exec-arguments"' startInfo.Arguments);  				  				currentProcessName = startInfo.Command + " " + startInfo.Arguments;  				  				CheckIsMonoProcess ();  				OnStarted ();  				  				RunCommand ("-exec-run");  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,OnRun,The following statement contains a magic number: lock (gdbLock) {  				string tty = null;    				if (Environment.OSVersion.Platform == PlatformID.Unix)  				{  					// Create a script to be run in a terminal  					string script = Path.GetTempFileName();  					string ttyfile = Path.GetTempFileName();  					string ttyfileDone = ttyfile + "_done";    					try  					{  						File.WriteAllText(script' "tty > " + ttyfile + "\ntouch " + ttyfileDone + "\nsleep 10000d");  						Mono.Unix.Native.Syscall.chmod(script' Mono.Unix.Native.FilePermissions.ALLPERMS);    						console = Runtime.ProcessService.StartConsoleProcess(script' ""' "."' ExternalConsoleFactory.Instance.CreateConsole(true)' null);  						DateTime tim = DateTime.Now;  						while (!File.Exists(ttyfileDone))  						{  							System.Threading.Thread.Sleep(100);  							if ((DateTime.Now - tim).TotalSeconds > 10)  								throw new InvalidOperationException("Console could not be created.");  						}  						tty = File.ReadAllText(ttyfile).Trim(' '' '\n');  					}  					finally  					{  						try  						{  							if (File.Exists(script))  								File.Delete(script);  							if (File.Exists(ttyfile))  								File.Delete(ttyfile);  							if (File.Exists(ttyfileDone))  								File.Delete(ttyfileDone);  						}  						catch  						{  							// Ignore  						}  					}  				}    				StartGdb ();    				// Initialize the terminal  				if (tty != null) {  					RunCommand ("-inferior-tty-set"' Escape (tty));  				}    				try {  					RunCommand ("-file-exec-and-symbols"' Escape (startInfo.Command));  				}  				catch {  					FireTargetEvent (TargetEventType.TargetExited' null);  					throw;  				}    				RunCommand ("-environment-cd"' Escape (startInfo.WorkingDirectory));  				  				// Set inferior arguments  				if (!string.IsNullOrEmpty (startInfo.Arguments))  					RunCommand ("-exec-arguments"' startInfo.Arguments);  				  				currentProcessName = startInfo.Command + " " + startInfo.Arguments;  				  				CheckIsMonoProcess ();  				OnStarted ();  				  				RunCommand ("-exec-run");  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,OnDisassembleFile,The following statement contains a magic number: do {  				ResultData data = null;  				try {  					data = RunCommand ("-data-disassemble"' "-f"' file' "-l"' cline.ToString ()' "--"' "1");  				} catch {  					break;  				}  				ResultData asm_insns = data.GetObject ("asm_insns");  				int newLine = cline;  				for (int n=0; n<asm_insns.Count; n++) {  					ResultData src_and_asm_line = asm_insns.GetObject (n).GetObject ("src_and_asm_line");  					newLine = src_and_asm_line.GetInt ("line");  					ResultData line_asm_insn = src_and_asm_line.GetObject ("line_asm_insn");  					for (int i=0; i<line_asm_insn.Count; i++) {  						ResultData asm = line_asm_insn.GetObject (i);  						long addr = long.Parse (asm.GetValueString ("address").Substring (2)' NumberStyles.HexNumber);  						string code = asm.GetValueString ("inst");  						lines.Add (new AssemblyLine (addr' code' newLine));  					}  				}  				if (newLine <= cline)  					break;  				cline = newLine + 1;  				  			} while (true);
Magic Number,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,InternalStop,The following statement contains a magic number: lock (eventLock) {  				if (!running)  					return false;  				internalStop = true;  				KillGdb ();  				if (!Monitor.Wait (eventLock' 4000))  					throw new InvalidOperationException ("Target could not be interrupted.");  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,ProcessOutput,The following statement contains a magic number: switch (line [0]) {  				case '^':  					lock (syncLock) {  						lastResult = new GdbCommandResult (line);  						running = (lastResult.Status == CommandStatus.Running);  						Monitor.PulseAll (syncLock);  					}  					break;  					  				case '~':  				case '&':  					if (line.Length > 1 && line[1] == '"')  						line = line.Substring (2' line.Length - 5);  					Ide.DispatchService.GuiDispatch(delegate {  						OnTargetOutput (false' line + "\n");  					});  					break;  					  				case '*':  					GdbEvent ev;  					lock (eventLock) {  						running = false;  						ev = new GdbEvent (line);  						string ti = ev.GetValueString ("thread-id");  						if (ti != null && ti != "all")  							currentThread = activeThread = int.Parse (ti);  						Monitor.PulseAll (eventLock);  						if (internalStop) {  							internalStop = false;  							return;  						}  					}  					ThreadPool.QueueUserWorkItem (delegate {  						try {  							HandleEvent (ev);  						} catch (Exception ex) {  							LoggingService.LogError("Error while processing gdb output"' ex);  						}  					});  					break;  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,ProcessOutput,The following statement contains a magic number: switch (line [0]) {  				case '^':  					lock (syncLock) {  						lastResult = new GdbCommandResult (line);  						running = (lastResult.Status == CommandStatus.Running);  						Monitor.PulseAll (syncLock);  					}  					break;  					  				case '~':  				case '&':  					if (line.Length > 1 && line[1] == '"')  						line = line.Substring (2' line.Length - 5);  					Ide.DispatchService.GuiDispatch(delegate {  						OnTargetOutput (false' line + "\n");  					});  					break;  					  				case '*':  					GdbEvent ev;  					lock (eventLock) {  						running = false;  						ev = new GdbEvent (line);  						string ti = ev.GetValueString ("thread-id");  						if (ti != null && ti != "all")  							currentThread = activeThread = int.Parse (ti);  						Monitor.PulseAll (eventLock);  						if (internalStop) {  							internalStop = false;  							return;  						}  					}  					ThreadPool.QueueUserWorkItem (delegate {  						try {  							HandleEvent (ev);  						} catch (Exception ex) {  							LoggingService.LogError("Error while processing gdb output"' ex);  						}  					});  					break;  			}
Magic Number,MonoDevelop.Debugger.Gdb,GdbSessionFactory,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSessionFactory.cs,IsExecutable,The following statement contains a magic number: using (StreamReader sr = new StreamReader (file)) {  				char[] chars = new char[3];  				int n = 0' nr = 0;  				while (n < chars.Length && (nr = sr.ReadBlock (chars' n' chars.Length - n)) != 0)  					n += nr;  				if (nr != chars.Length)  					return true;  				if (chars [0] == '#' && chars [1] == '!')  					return false;  			}
Magic Number,MonoDevelop.Debugger.Gdb,ResultData,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\ResultData.cs,ReadTuple,The following statement contains a magic number: while (pos < str.Length && str [pos] != '}') {  				string name;  				object val;  				ReadResult (str' ref pos' out name' out val);  				if (data.props.ContainsKey (name)) {  					object ob = data.props [name];  					ResultData rd = ob as ResultData;  					if (rd != null && rd.isArrayProperty) {  						object[] newArr = new object [rd.array.Length + 1];  						Array.Copy (rd.array' newArr' rd.array.Length);  						newArr [rd.array.Length] = val;  						rd.array = newArr;  					} else {  						rd = new ResultData ();  						rd.isArrayProperty = true;  						rd.array = new object [2];  						rd.array [0] = ob;  						rd.array [1] = val;  						data.props [name] = rd;  					}  				} else {  					data.props [name] = val;  				}  				TryReadChar (str' ref pos' ''');  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbBacktrace.cs,CreateFrame,The following statement contains a magic number: if (!string.IsNullOrEmpty(sadr))  				addr = long.Parse(sadr.Substring(2)' System.Globalization.NumberStyles.HexNumber);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbBacktrace.cs,ParseHexValue,The following statement contains a magic number: return (ulong) D_Parser.Parser.Lexer.ParseFloatValue (sb' 16);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbBacktrace.cs,ReadInt16,The following statement contains a magic number: DSession.Memory.Read(offset.ToString()' 2' out r);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbBacktrace.cs,ReadInt32,The following statement contains a magic number: DSession.Memory.Read(offset.ToString()' 4' out r);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbBacktrace,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbBacktrace.cs,ReadInt64,The following statement contains a magic number: DSession.Memory.Read(offset.ToString()' 8' out r);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbSession.cs,OnStarted,The following statement contains a magic number: PointerSize = Is64Bit ? 8 : 4;
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbSession.cs,OnStarted,The following statement contains a magic number: PointerSize = Is64Bit ? 8 : 4;
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,SizeOf,The following statement contains a magic number: switch (typeToken) {  				case DTokens.Bool:  				case DTokens.Byte:  				case DTokens.Ubyte:  				case DTokens.Char:  					return 1;  				case DTokens.Short:  				case DTokens.Ushort:  				case DTokens.Wchar:  					return 2;  				case DTokens.Int:  				case DTokens.Uint:  				case DTokens.Dchar:  				case DTokens.Float:  					return 4;  				case DTokens.Long:  				case DTokens.Ulong:  				case DTokens.Double:  					return 8;  				case DTokens.Real:  					// size is 80 bits = 10 bytes  					if (DGdbSession.Is64Bit)  						// alignment is to 16 bytes (on 64 bit architecture)  						return 16;  					else  						// and 12 bytes (on 32 bit architecture)   						return 12;  				default:  					return 1;  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,SizeOf,The following statement contains a magic number: switch (typeToken) {  				case DTokens.Bool:  				case DTokens.Byte:  				case DTokens.Ubyte:  				case DTokens.Char:  					return 1;  				case DTokens.Short:  				case DTokens.Ushort:  				case DTokens.Wchar:  					return 2;  				case DTokens.Int:  				case DTokens.Uint:  				case DTokens.Dchar:  				case DTokens.Float:  					return 4;  				case DTokens.Long:  				case DTokens.Ulong:  				case DTokens.Double:  					return 8;  				case DTokens.Real:  					// size is 80 bits = 10 bytes  					if (DGdbSession.Is64Bit)  						// alignment is to 16 bytes (on 64 bit architecture)  						return 16;  					else  						// and 12 bytes (on 32 bit architecture)   						return 12;  				default:  					return 1;  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,SizeOf,The following statement contains a magic number: switch (typeToken) {  				case DTokens.Bool:  				case DTokens.Byte:  				case DTokens.Ubyte:  				case DTokens.Char:  					return 1;  				case DTokens.Short:  				case DTokens.Ushort:  				case DTokens.Wchar:  					return 2;  				case DTokens.Int:  				case DTokens.Uint:  				case DTokens.Dchar:  				case DTokens.Float:  					return 4;  				case DTokens.Long:  				case DTokens.Ulong:  				case DTokens.Double:  					return 8;  				case DTokens.Real:  					// size is 80 bits = 10 bytes  					if (DGdbSession.Is64Bit)  						// alignment is to 16 bytes (on 64 bit architecture)  						return 16;  					else  						// and 12 bytes (on 32 bit architecture)   						return 12;  				default:  					return 1;  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,SizeOf,The following statement contains a magic number: switch (typeToken) {  				case DTokens.Bool:  				case DTokens.Byte:  				case DTokens.Ubyte:  				case DTokens.Char:  					return 1;  				case DTokens.Short:  				case DTokens.Ushort:  				case DTokens.Wchar:  					return 2;  				case DTokens.Int:  				case DTokens.Uint:  				case DTokens.Dchar:  				case DTokens.Float:  					return 4;  				case DTokens.Long:  				case DTokens.Ulong:  				case DTokens.Double:  					return 8;  				case DTokens.Real:  					// size is 80 bits = 10 bytes  					if (DGdbSession.Is64Bit)  						// alignment is to 16 bytes (on 64 bit architecture)  						return 16;  					else  						// and 12 bytes (on 32 bit architecture)   						return 12;  				default:  					return 1;  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,SizeOf,The following statement contains a magic number: switch (typeToken) {  				case DTokens.Bool:  				case DTokens.Byte:  				case DTokens.Ubyte:  				case DTokens.Char:  					return 1;  				case DTokens.Short:  				case DTokens.Ushort:  				case DTokens.Wchar:  					return 2;  				case DTokens.Int:  				case DTokens.Uint:  				case DTokens.Dchar:  				case DTokens.Float:  					return 4;  				case DTokens.Long:  				case DTokens.Ulong:  				case DTokens.Double:  					return 8;  				case DTokens.Real:  					// size is 80 bits = 10 bytes  					if (DGdbSession.Is64Bit)  						// alignment is to 16 bytes (on 64 bit architecture)  						return 16;  					else  						// and 12 bytes (on 32 bit architecture)   						return 12;  				default:  					return 1;  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetByteValue,The following statement contains a magic number: return ToString2((sbyte)array[i]' hex' 2);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetUbyteValue,The following statement contains a magic number: return ToString2(array[i]' hex' 2);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetShortValue,The following statement contains a magic number: return ToString2(BitConverter.ToInt16 (array' i)' hex' 4);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetIntValue,The following statement contains a magic number: return ToString2(BitConverter.ToInt32 (array' i)' hex' 8);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetLongValue,The following statement contains a magic number: return ToString2(BitConverter.ToInt64 (array' i)' hex' 16);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetUshortValue,The following statement contains a magic number: return ToString2(BitConverter.ToUInt16 (array' i)' hex' 4);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetUintValue,The following statement contains a magic number: return ToString2(BitConverter.ToUInt32 (array' i)' hex' 8);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetUlongValue,The following statement contains a magic number: return ToString2(BitConverter.ToUInt64 (array' i)' hex' 16);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: ulong realIntPart = realFraction >> 63;
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: realFraction &= ~(ulong)(realIntPart << 63);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: ushort realExponent = BitConverter.ToUInt16 (array' (i + 8));
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: ushort realSign = (ushort)(realExponent >> 15);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: ulong doubleFraction = realFraction >> 11;
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: const ushort realBias = 16383;
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: const ushort doubleBias = 1023;
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: if (realIntPart == 0) {  				// we need to normalize the real fraction if the integer part was not set to 1  				ushort neededShift = 1;						// counter for needed fraction left shift in order to normalize it  				ulong fractionIter = realFraction;			// shift left iterator of real precision number fraction  				const ulong bitTest = 1 << 62;				// test for most significant bit  				while (neededShift < 63 && (fractionIter & bitTest) == 0) {  					++neededShift;  					fractionIter <<= 1;  				}  				if (fractionIter > 0) {  					// we normalize the fraction and adjust the exponent  					// TODO: this code needs to be tested  					doubleExponent += neededShift;  					doubleFraction = (realFraction << neededShift) >> (11 + neededShift);  				}  				else {  					// impossible to normalize  					return "(not normalizable) zero' infinity or NaN";  				}  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: if (realIntPart == 0) {  				// we need to normalize the real fraction if the integer part was not set to 1  				ushort neededShift = 1;						// counter for needed fraction left shift in order to normalize it  				ulong fractionIter = realFraction;			// shift left iterator of real precision number fraction  				const ulong bitTest = 1 << 62;				// test for most significant bit  				while (neededShift < 63 && (fractionIter & bitTest) == 0) {  					++neededShift;  					fractionIter <<= 1;  				}  				if (fractionIter > 0) {  					// we normalize the fraction and adjust the exponent  					// TODO: this code needs to be tested  					doubleExponent += neededShift;  					doubleFraction = (realFraction << neededShift) >> (11 + neededShift);  				}  				else {  					// impossible to normalize  					return "(not normalizable) zero' infinity or NaN";  				}  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: if (realIntPart == 0) {  				// we need to normalize the real fraction if the integer part was not set to 1  				ushort neededShift = 1;						// counter for needed fraction left shift in order to normalize it  				ulong fractionIter = realFraction;			// shift left iterator of real precision number fraction  				const ulong bitTest = 1 << 62;				// test for most significant bit  				while (neededShift < 63 && (fractionIter & bitTest) == 0) {  					++neededShift;  					fractionIter <<= 1;  				}  				if (fractionIter > 0) {  					// we normalize the fraction and adjust the exponent  					// TODO: this code needs to be tested  					doubleExponent += neededShift;  					doubleFraction = (realFraction << neededShift) >> (11 + neededShift);  				}  				else {  					// impossible to normalize  					return "(not normalizable) zero' infinity or NaN";  				}  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: doubleBytes |= ((ulong)doubleExponent << 52);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetRealValue,The following statement contains a magic number: doubleBytes |= ((ulong)realSign << 63);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,FormatCharValue,The following statement contains a magic number: return hex ? String.Format("0x{1:x" + aSize*2 + "}"' aChar) : aChar.ToString();
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetCharValue,The following statement contains a magic number: if ((uint)chars[0] == 0xFFFD) {  				// code point is wider than 1 byte  				chars = Encoding.UTF8.GetChars(array' i' i+2 > array.Length ? 1 : 2);  				if ((uint)chars[0] == 0xFFFD) {  					// code point was already in previous char  					return "(skipped code point)";  				}  				else {  					// code point is resolved correctly  					return FormatCharValue(chars[0]' hex' 1) + " (multi-code point)";  				}  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetCharValue,The following statement contains a magic number: if ((uint)chars[0] == 0xFFFD) {  				// code point is wider than 1 byte  				chars = Encoding.UTF8.GetChars(array' i' i+2 > array.Length ? 1 : 2);  				if ((uint)chars[0] == 0xFFFD) {  					// code point was already in previous char  					return "(skipped code point)";  				}  				else {  					// code point is resolved correctly  					return FormatCharValue(chars[0]' hex' 1) + " (multi-code point)";  				}  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetWcharValue,The following statement contains a magic number: char[] chars = Encoding.Unicode.GetChars(array' i' 2);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetWcharValue,The following statement contains a magic number: return FormatCharValue(chars[0]' hex' 2);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetDcharValue,The following statement contains a magic number: char[] chars = Encoding.UTF32.GetChars(array' i' 4);
Magic Number,MonoDevelop.Debugger.Gdb.D,DGdbTools,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\DGdbTools.cs,GetDcharValue,The following statement contains a magic number: return FormatCharValue(chars[0]' hex' 4);
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetArrayChildren,The following statement contains a magic number: if (elementTypeToken != DTokens.INVALID)  			{  				var valFunc = DGdbTools.GetValueFunction (elementTypeToken);  				var elementTypeString = elementType.ToCode ();  				var hex = DisplayAsHex;    				for (uint i = 0; i < elementsToDisplay; i++) {  					var valStr = valFunc (rawArrayContent' (int)(i * sizeOfElement)' hex);  					item = arrayPath.Append ((index + i).ToString ());    					children [i] = ObjectValue.CreatePrimitive (ValueSource' item' elementTypeString'  					                                            new EvaluationResult (valStr)' ObjectValueFlags.ArrayElement);  				}  			}  			else if (elementType is ArrayType) {  				var elementArrayType = elementType as ArrayType;    				for (var i = elementsToDisplay - 1; i >= 0; i--){  					item = arrayPath.Append ((index + i).ToString ());  					try{  						int subArrayLength;  						ulong subArrayFirstPointer;  						ExamArrayInfo (rawArrayContent' i * sizeOfElement' out subArrayLength' out subArrayFirstPointer);    						children [i] = EvaluateArray (subArrayLength' subArrayFirstPointer' elementArrayType'   						                              ObjectValueFlags.ArrayElement' item);  						cacheNode.Set(new SubArrayCacheNode(item.LastName' elementArrayType' subArrayFirstPointer' subArrayLength));    					}catch(Exception ex) {  						Ide.MessageService.ShowException (ex);  					}  									}  			}  			else if (elementType is PointerType ||   			         elementType is InterfaceType ||   			         elementType is ClassType) {    				for (int i = 0; i < elementsToDisplay; i++) {  					item = arrayPath.Append ((index + i).ToString ());    					long elementPointer;  					if (sizeOfElement == 4)  						elementPointer = BitConverter.ToInt32 (rawArrayContent' i * 4);  					else  						elementPointer = BitConverter.ToInt64 (rawArrayContent' i * 8);    					children [i] = EvaluateVariable (elementPointer.ToString ()' ref elementType' ObjectValueFlags.ArrayElement' item);  					cacheNode.Set(new ObjectCacheNode(item.LastName' elementType' (elementPointer+i*sizeOfElement).ToString()));  				}  			}  			else if (elementType is StructType/* || elementType is UnionType*/) {  				// Get struct size or perhaps just get the struct meta information from gdb  				//return ObjectValue.CreateNotSupported (ValueSource' path' t.ToCode ()' "Struct/Union arrays can't be examined yet"' flags);  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetArrayChildren,The following statement contains a magic number: if (elementTypeToken != DTokens.INVALID)  			{  				var valFunc = DGdbTools.GetValueFunction (elementTypeToken);  				var elementTypeString = elementType.ToCode ();  				var hex = DisplayAsHex;    				for (uint i = 0; i < elementsToDisplay; i++) {  					var valStr = valFunc (rawArrayContent' (int)(i * sizeOfElement)' hex);  					item = arrayPath.Append ((index + i).ToString ());    					children [i] = ObjectValue.CreatePrimitive (ValueSource' item' elementTypeString'  					                                            new EvaluationResult (valStr)' ObjectValueFlags.ArrayElement);  				}  			}  			else if (elementType is ArrayType) {  				var elementArrayType = elementType as ArrayType;    				for (var i = elementsToDisplay - 1; i >= 0; i--){  					item = arrayPath.Append ((index + i).ToString ());  					try{  						int subArrayLength;  						ulong subArrayFirstPointer;  						ExamArrayInfo (rawArrayContent' i * sizeOfElement' out subArrayLength' out subArrayFirstPointer);    						children [i] = EvaluateArray (subArrayLength' subArrayFirstPointer' elementArrayType'   						                              ObjectValueFlags.ArrayElement' item);  						cacheNode.Set(new SubArrayCacheNode(item.LastName' elementArrayType' subArrayFirstPointer' subArrayLength));    					}catch(Exception ex) {  						Ide.MessageService.ShowException (ex);  					}  									}  			}  			else if (elementType is PointerType ||   			         elementType is InterfaceType ||   			         elementType is ClassType) {    				for (int i = 0; i < elementsToDisplay; i++) {  					item = arrayPath.Append ((index + i).ToString ());    					long elementPointer;  					if (sizeOfElement == 4)  						elementPointer = BitConverter.ToInt32 (rawArrayContent' i * 4);  					else  						elementPointer = BitConverter.ToInt64 (rawArrayContent' i * 8);    					children [i] = EvaluateVariable (elementPointer.ToString ()' ref elementType' ObjectValueFlags.ArrayElement' item);  					cacheNode.Set(new ObjectCacheNode(item.LastName' elementType' (elementPointer+i*sizeOfElement).ToString()));  				}  			}  			else if (elementType is StructType/* || elementType is UnionType*/) {  				// Get struct size or perhaps just get the struct meta information from gdb  				//return ObjectValue.CreateNotSupported (ValueSource' path' t.ToCode ()' "Struct/Union arrays can't be examined yet"' flags);  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetArrayChildren,The following statement contains a magic number: if (elementTypeToken != DTokens.INVALID)  			{  				var valFunc = DGdbTools.GetValueFunction (elementTypeToken);  				var elementTypeString = elementType.ToCode ();  				var hex = DisplayAsHex;    				for (uint i = 0; i < elementsToDisplay; i++) {  					var valStr = valFunc (rawArrayContent' (int)(i * sizeOfElement)' hex);  					item = arrayPath.Append ((index + i).ToString ());    					children [i] = ObjectValue.CreatePrimitive (ValueSource' item' elementTypeString'  					                                            new EvaluationResult (valStr)' ObjectValueFlags.ArrayElement);  				}  			}  			else if (elementType is ArrayType) {  				var elementArrayType = elementType as ArrayType;    				for (var i = elementsToDisplay - 1; i >= 0; i--){  					item = arrayPath.Append ((index + i).ToString ());  					try{  						int subArrayLength;  						ulong subArrayFirstPointer;  						ExamArrayInfo (rawArrayContent' i * sizeOfElement' out subArrayLength' out subArrayFirstPointer);    						children [i] = EvaluateArray (subArrayLength' subArrayFirstPointer' elementArrayType'   						                              ObjectValueFlags.ArrayElement' item);  						cacheNode.Set(new SubArrayCacheNode(item.LastName' elementArrayType' subArrayFirstPointer' subArrayLength));    					}catch(Exception ex) {  						Ide.MessageService.ShowException (ex);  					}  									}  			}  			else if (elementType is PointerType ||   			         elementType is InterfaceType ||   			         elementType is ClassType) {    				for (int i = 0; i < elementsToDisplay; i++) {  					item = arrayPath.Append ((index + i).ToString ());    					long elementPointer;  					if (sizeOfElement == 4)  						elementPointer = BitConverter.ToInt32 (rawArrayContent' i * 4);  					else  						elementPointer = BitConverter.ToInt64 (rawArrayContent' i * 8);    					children [i] = EvaluateVariable (elementPointer.ToString ()' ref elementType' ObjectValueFlags.ArrayElement' item);  					cacheNode.Set(new ObjectCacheNode(item.LastName' elementType' (elementPointer+i*sizeOfElement).ToString()));  				}  			}  			else if (elementType is StructType/* || elementType is UnionType*/) {  				// Get struct size or perhaps just get the struct meta information from gdb  				//return ObjectValue.CreateNotSupported (ValueSource' path' t.ToCode ()' "Struct/Union arrays can't be examined yet"' flags);  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetMembersWithOffsets,The following statement contains a magic number: if (tit is ClassType)  				size = Memory.CalcOffset (2);  			else if (tit is StructType || tit is UnionType)  				size = 0;  			else  				throw new ArgumentException ("Can only estimate size of classes' structs and unions");
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetMembersWithOffsets,The following statement contains a magic number: foreach (var ds in MemberLookup.ListMembers(tit' resolutionCtx)) {    				// If there's a base interface' the interface's vtbl pointer is stored at this position -- and shall be skipped!  				if(ds is InterfaceType){  					// See below  					if (memberLength < sz)  						size += size % sz;    					size += sz;  					continue;  				}    				var ms = ds as MemberSymbol;    				if (ms == null)  					throw new InvalidDataException ("ds must be a MemberSymbol' not "+ds.ToCode());    				var newSize = SizeOf (ms.Base);    				/*  				 * Very important on x64: if a long' array or pointer follows e.g. an int value' it'll be aligned to an 8 byte-base again.  				 */  				if (memberLength < sz && newSize % sz == 0)  					size += size % sz;  				memberLength = newSize;    				members.Add (new Tuple<MemberSymbol' int>(ms' size));    				size += memberLength % 4 == 0 ? memberLength : ((memberLength / 4) + 1) * 4;  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetMembersWithOffsets,The following statement contains a magic number: foreach (var ds in MemberLookup.ListMembers(tit' resolutionCtx)) {    				// If there's a base interface' the interface's vtbl pointer is stored at this position -- and shall be skipped!  				if(ds is InterfaceType){  					// See below  					if (memberLength < sz)  						size += size % sz;    					size += sz;  					continue;  				}    				var ms = ds as MemberSymbol;    				if (ms == null)  					throw new InvalidDataException ("ds must be a MemberSymbol' not "+ds.ToCode());    				var newSize = SizeOf (ms.Base);    				/*  				 * Very important on x64: if a long' array or pointer follows e.g. an int value' it'll be aligned to an 8 byte-base again.  				 */  				if (memberLength < sz && newSize % sz == 0)  					size += size % sz;  				memberLength = newSize;    				members.Add (new Tuple<MemberSymbol' int>(ms' size));    				size += memberLength % 4 == 0 ? memberLength : ((memberLength / 4) + 1) * 4;  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,GetMembersWithOffsets,The following statement contains a magic number: foreach (var ds in MemberLookup.ListMembers(tit' resolutionCtx)) {    				// If there's a base interface' the interface's vtbl pointer is stored at this position -- and shall be skipped!  				if(ds is InterfaceType){  					// See below  					if (memberLength < sz)  						size += size % sz;    					size += sz;  					continue;  				}    				var ms = ds as MemberSymbol;    				if (ms == null)  					throw new InvalidDataException ("ds must be a MemberSymbol' not "+ds.ToCode());    				var newSize = SizeOf (ms.Base);    				/*  				 * Very important on x64: if a long' array or pointer follows e.g. an int value' it'll be aligned to an 8 byte-base again.  				 */  				if (memberLength < sz && newSize % sz == 0)  					size += size % sz;  				memberLength = newSize;    				members.Add (new Tuple<MemberSymbol' int>(ms' size));    				size += memberLength % 4 == 0 ? memberLength : ((memberLength / 4) + 1) * 4;  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,ExamArrayInfo,The following statement contains a magic number: if (DGdbSession.Is64Bit) {  				arrayLength = (int)BitConverter.ToUInt64 (rawBytes' start);  				firstItem = BitConverter.ToUInt64 (rawBytes' start + 8);  			} else {  				arrayLength = (int)BitConverter.ToUInt32 (rawBytes' start);  				firstItem = BitConverter.ToUInt32 (rawBytes' start + 4);  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,ExamArrayInfo,The following statement contains a magic number: if (DGdbSession.Is64Bit) {  				arrayLength = (int)BitConverter.ToUInt64 (rawBytes' start);  				firstItem = BitConverter.ToUInt64 (rawBytes' start + 8);  			} else {  				arrayLength = (int)BitConverter.ToUInt32 (rawBytes' start);  				firstItem = BitConverter.ToUInt32 (rawBytes' start + 4);  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,VariableValueExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\VariableValueExamination.cs,SizeOf,The following statement contains a magic number: if (t is ArrayType)  				return Memory.CalcOffset(2);
Magic Number,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,ReadDArrayHeader,The following statement contains a magic number: if (!Read (exp' 2' out hdr))  				return new DArrayStruct ();
Magic Number,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,ReadObjectBytes,The following statement contains a magic number: if (!Read (EnforceReadRawExpression+"**(int*)(" + BuildAddressExpression(exp) + ")+" + CalcOffset(2)' out objectSize)) {  				Session.LogWriter (false' "Object (exp=\""+exp+"\") length couldn't be read. Return.\n");  				return new byte[0];  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,Read,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				if (DGdbSession.Is64Bit)  					v [i] = new UIntPtr (BitConverter.ToUInt64 (rawBytes' i * 8));  				else  					v [i] = new UIntPtr (BitConverter.ToUInt32 (rawBytes' i * 4));  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,Read,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				if (DGdbSession.Is64Bit)  					v [i] = new UIntPtr (BitConverter.ToUInt64 (rawBytes' i * 8));  				else  					v [i] = new UIntPtr (BitConverter.ToUInt32 (rawBytes' i * 4));  			}
Magic Number,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,Read,The following statement contains a magic number: if (charWidth == 1)  				v = Encoding.UTF8.GetString (rawBytes);  			else if (charWidth == 2)  				v = Encoding.Unicode.GetString (rawBytes);  			else if (charWidth == 4)  				v = Encoding.UTF32.GetString (rawBytes);  			else  				throw new ArgumentException ("charWidth (" + charWidth + ") can only be 1'2 or 4");
Magic Number,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,Read,The following statement contains a magic number: if (charWidth == 1)  				v = Encoding.UTF8.GetString (rawBytes);  			else if (charWidth == 2)  				v = Encoding.Unicode.GetString (rawBytes);  			else if (charWidth == 4)  				v = Encoding.UTF32.GetString (rawBytes);  			else  				throw new ArgumentException ("charWidth (" + charWidth + ") can only be 1'2 or 4");
Magic Number,MonoDevelop.Debugger.Gdb.D,MemoryExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\MemoryExamination.cs,WriteMemory,The following statement contains a magic number: var sb = new StringBuilder (data.Length * 2);
Magic Number,MonoDevelop.Debugger.Gdb.D,ToStringExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\ToStringExamination.cs,ToStringExamination,The following statement contains a magic number: InjectCommands = new string[2];
Magic Number,MonoDevelop.Debugger.Gdb.D,ToStringExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\ToStringExamination.cs,ToStringExamination,The following statement contains a magic number: tempStringBuilder.Append ("set $").Append (ToStringMethodId)  				.Append ("=mmap(0'").Append (assemblerInstructions.Length / 2).Append ("'7'0x20|0x2");
Magic Number,MonoDevelop.Debugger.Gdb.D,ToStringExamination,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\ToStringExamination.cs,InvokeToString,The following statement contains a magic number: var stringResult = Encoding.UTF8.GetString (returnData' 8' (int)stringLength);
Magic Number,MonoDevelop.Debugger.Gdb.D,Deh2,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb.D\Deh2.cs,InjectBreakpoint,The following statement contains a magic number: if (returnOffset > 0) {  				res = Session.RunCommand("-break-insert"'"*("+hookMethod+"+"+(returnOffset / 2).ToString()+")");  				injected = res.Status == CommandStatus.Done;  				return true;  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: char[] c = new char[bytes.Length * 2];
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,ByteArrayToHexString,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  				b = bytes[i] >> 4;  				c[i * 2] = (char)(55 + b + (((b-10)>>31)&-7));  				b = bytes[i] & 0xF;  				c[i * 2 + 1] = (char)(55 + b + (((b-10)>>31)&-7));  			}
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,HexStringToByteArray,The following statement contains a magic number: byte[] bytes = new byte[hex.Length/2];
Magic Number,Misc,ArrayConversionHelpers,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Misc\ArrayConversionHelpers.cs,HexStringToByteArray,The following statement contains a magic number: for (int i = 0; i < bl; ++i)  			{  				bytes[i] = (byte)((hex[j] > 'F' ? hex[j] - 0x57 : hex[j] > '9' ? hex[j] - 0x37 : hex[j] - 0x30) << 4);  				++j;  				bytes[i] |= (byte)(hex[j] > 'F' ? hex[j] - 0x57 : hex[j] > '9' ? hex[j] - 0x37 : hex[j] - 0x30);  				++j;  			}
Magic Number,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,Build,The following statement contains a magic number: this.table1 = new global::Gtk.Table (((uint)(2))' ((uint)(2))' false);
Magic Number,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,Build,The following statement contains a magic number: this.table1 = new global::Gtk.Table (((uint)(2))' ((uint)(2))' false);
Magic Number,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,Build,The following statement contains a magic number: this.table1.RowSpacing = ((uint)(6));
Magic Number,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,Build,The following statement contains a magic number: this.table1.ColumnSpacing = ((uint)(6));
Magic Number,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,Build,The following statement contains a magic number: w1.RightAttach = ((uint)(2));
Magic Number,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,Build,The following statement contains a magic number: w1.YOptions = ((global::Gtk.AttachOptions)(4));
Magic Number,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,Build,The following statement contains a magic number: w2.XOptions = ((global::Gtk.AttachOptions)(4));
Magic Number,MonoDevelop.Debugger.Options,OptionPanel,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Options\OptionPanel.cs,Build,The following statement contains a magic number: w2.YOptions = ((global::Gtk.AttachOptions)(4));
Missing Default,MonoDevelop.Debugger.Gdb,GdbSession,C:\repos\llucenic_MonoDevelop.Debugger.Gdb.D\Gdb\GdbSession.cs,ProcessOutput,The following switch statement is missing a default case: switch (line [0]) {  				case '^':  					lock (syncLock) {  						lastResult = new GdbCommandResult (line);  						running = (lastResult.Status == CommandStatus.Running);  						Monitor.PulseAll (syncLock);  					}  					break;  					  				case '~':  				case '&':  					if (line.Length > 1 && line[1] == '"')  						line = line.Substring (2' line.Length - 5);  					Ide.DispatchService.GuiDispatch(delegate {  						OnTargetOutput (false' line + "\n");  					});  					break;  					  				case '*':  					GdbEvent ev;  					lock (eventLock) {  						running = false;  						ev = new GdbEvent (line);  						string ti = ev.GetValueString ("thread-id");  						if (ti != null && ti != "all")  							currentThread = activeThread = int.Parse (ti);  						Monitor.PulseAll (eventLock);  						if (internalStop) {  							internalStop = false;  							return;  						}  					}  					ThreadPool.QueueUserWorkItem (delegate {  						try {  							HandleEvent (ev);  						} catch (Exception ex) {  							LoggingService.LogError("Error while processing gdb output"' ex);  						}  					});  					break;  			}
