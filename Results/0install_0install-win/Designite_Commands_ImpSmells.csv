Implementation smell,Namespace,Class,File,Method,Description
Long Method,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Run,The method has 223 lines of code.
Complex Method,ZeroInstall.Commands.CliCommands,AddFeed,C:\repos\0install_0install-win\src\Commands\CliCommands\AddFeed.cs,ExecuteHelper,Cyclomatic complexity of the method is 8
Complex Method,ZeroInstall.Commands.CliCommands,Remove,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Remove.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,ZeroInstall.Commands.CliCommands,RemoveFeed,C:\repos\0install_0install-win\src\Commands\CliCommands\RemoveFeed.cs,ExecuteHelper,Cyclomatic complexity of the method is 8
Complex Method,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,GetRegistryFilter,Cyclomatic complexity of the method is 8
Long Parameter List,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,CreateProcessWCallback,The method has 10 parameters. Parameters: lpApplicationName' lpCommandLine' lpProcessAttributes' lpThreadAttributes' bInheritHandles' dwCreationFlags' lpEnvironment' lpCurrentDirectory' lpStartupInfo' lpProcessInformation
Long Parameter List,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,CreateProcessACallback,The method has 10 parameters. Parameters: lpApplicationName' lpCommandLine' lpProcessAttributes' lpThreadAttributes' bInheritHandles' dwCreationFlags' lpEnvironment' lpCurrentDirectory' lpStartupInfo' lpProcessInformation
Long Parameter List,ZeroInstall.Commands.Utils,UnsafeNativeMethods,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,CreateProcessW,The method has 10 parameters. Parameters: lpApplicationName' lpCommandLine' lpProcessAttributes' lpThreadAttributes' bInheritHandles' dwCreationFlags' lpEnvironment' lpCurrentDirectory' lpStartupInfo' lpProcessInformation
Long Parameter List,ZeroInstall.Commands.Utils,UnsafeNativeMethods,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,CreateProcessA,The method has 10 parameters. Parameters: lpApplicationName' lpCommandLine' lpProcessAttributes' lpThreadAttributes' bInheritHandles' dwCreationFlags' lpEnvironment' lpCurrentDirectory' lpStartupInfo' lpProcessInformation
Long Identifier,ZeroInstall.Commands.CliCommands,AddApp,C:\repos\0install_0install-win\src\Commands\CliCommands\AddApp.cs,,The length of the parameter AddedNonCatalogAppWindowMessageID is 33.
Long Statement,ZeroInstall.Commands,CommandBase,C:\repos\0install_0install-win\src\Commands\CommandBase.cs,FindByShortName,The length of the statement  "            if (result == null && Config.NetworkUse != NetworkLevel.Offline) result = CatalogManager.GetOnlineSafe().FindByShortName(shortName); " is 132.
Long Statement,ZeroInstall.Commands,CommandBase,C:\repos\0install_0install-win\src\Commands\CommandBase.cs,StartCommandBackground,The length of the statement  "                var startInfo = ProcessUtils.Assembly(ProgramUtils.GuiAssemblyName' new[] {command' "--background"}.Concat(args).ToArray()); " is 124.
Long Statement,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Run,The length of the statement  "                handler.Error(new OptionException(ex.Message + Environment.NewLine + string.Format(Resources.TryHelp' exeName)' ex.OptionName)); " is 128.
Long Statement,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Run,The length of the statement  "                RegistryUtils.GetDword(RegKeyFSPolicyUser' RegValueNameLongPaths' defaultValue: RegistryUtils.GetDword(RegKeyFSPolicyMachine' RegValueNameLongPaths)) != 1) " is 155.
Long Statement,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Run,The length of the statement  "                        RegistryUtils.SetDword(WindowsUtils.IsAdministrator ? RegKeyFSPolicyMachine : RegKeyFSPolicyUser' RegValueNameLongPaths' 1); " is 124.
Long Statement,ZeroInstall.Commands.CliCommands,AddAlias,C:\repos\0install_0install-win\src\Commands\CliCommands\AddAlias.cs,Execute,The length of the statement  "                if (AdditionalArgs.Count > 1) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs[1].EscapeArgument()' null); " is 149.
Long Statement,ZeroInstall.Commands.CliCommands,AddAlias,C:\repos\0install_0install-win\src\Commands\CliCommands\AddAlias.cs,Execute,The length of the statement  "                if (AdditionalArgs.Count < 2 || string.IsNullOrEmpty(AdditionalArgs[1])) throw new OptionException(Resources.MissingArguments' null); " is 133.
Long Statement,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,Execute,The length of the statement  "                        if (AdditionalArgs.Count > 2) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs.Skip(2).JoinEscapeArguments()' null); " is 159.
Long Statement,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The length of the statement  "                        MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1]) " is 124.
Long Statement,ZeroInstall.Commands.CliCommands,CliCommand,C:\repos\0install_0install-win\src\Commands\CliCommands\CliCommand.cs,Parse,The length of the statement  "            if (AdditionalArgsMin == 1 && string.IsNullOrEmpty(AdditionalArgs[0])) throw new OptionException(Resources.MissingArguments' null); " is 131.
Long Statement,ZeroInstall.Commands.CliCommands,CliCommand,C:\repos\0install_0install-win\src\Commands\CliCommands\CliCommand.cs,Parse,The length of the statement  "            if (AdditionalArgs.Count > AdditionalArgsMax) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs.Skip(AdditionalArgsMax).JoinEscapeArguments()' null); " is 191.
Long Statement,ZeroInstall.Commands.CliCommands,Digest,C:\repos\0install_0install-win\src\Commands\CliCommands\Digest.cs,GenerateManifest,The length of the statement  "                if (!string.IsNullOrEmpty(subdir)) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + subdir.EscapeArgument()' null); " is 143.
Long Statement,ZeroInstall.Commands.CliCommands,IntegrateApp,C:\repos\0install_0install-win\src\Commands\CliCommands\IntegrateApp.cs,ExecuteHelper,The length of the statement  "                        Resources.IntegrateAppInvalid + Environment.NewLine + ex.Message + Environment.NewLine + Environment.NewLine + Resources.IntegrateAppRetry' " is 139.
Long Statement,ZeroInstall.Commands.CliCommands,IntegrateApp,C:\repos\0install_0install-win\src\Commands\CliCommands\IntegrateApp.cs,ExecuteHelper,The length of the statement  "                        Resources.IntegrateAppInvalid + Environment.NewLine + ex.Message + Environment.NewLine + Environment.NewLine + Resources.IntegrateAppRetry' " is 139.
Long Statement,ZeroInstall.Commands.CliCommands,IntegrationCommand,C:\repos\0install_0install-win\src\Commands\CliCommands\IntegrationCommand.cs,CheckInstallBase,The length of the statement  "                // NOTE: Portable instances remain decoupled from local instances' so we do not use UnsuitableInstallBaseException here' which would redirect commands to other instances. " is 170.
Long Statement,ZeroInstall.Commands.CliCommands,IntegrationCommand,C:\repos\0install_0install-win\src\Commands\CliCommands\IntegrationCommand.cs,CheckInstallBase,The length of the statement  "            if (ProgramUtils.IsRunningFromCache) throw new UnsuitableInstallBaseException(Resources.NoIntegrationFromCache' MachineWide); " is 125.
Long Statement,ZeroInstall.Commands.CliCommands,IntegrationCommand,C:\repos\0install_0install-win\src\Commands\CliCommands\IntegrationCommand.cs,CheckInstallBase,The length of the statement  "            if (MachineWide && ProgramUtils.IsRunningFromPerUserDir) throw new UnsuitableInstallBaseException(Resources.NoMachineWideIntegrationFromPerUser' MachineWide); " is 158.
Long Statement,ZeroInstall.Commands.CliCommands,IntegrationCommand,C:\repos\0install_0install-win\src\Commands\CliCommands\IntegrationCommand.cs,DetectReplacement,The length of the statement  "                defaultAnswer: false' alternateMessage: string.Format(Resources.FeedReplaced' target.Uri' target.Feed.ReplacedBy.Target))) " is 122.
Long Statement,ZeroInstall.Commands.CliCommands,MaintenanceMan,C:\repos\0install_0install-win\src\Commands\CliCommands\MaintenanceMan.cs,WindowsSelfDelete,The length of the statement  "            new ProcessStartInfo("cmd.exe"' "/c (ping 127.0.0.1 -n 8 || ping ::1 -n 8) & rd /s /q " + Locations.InstallBase.EscapeArgument()) " is 129.
Long Statement,ZeroInstall.Commands.CliCommands,Deploy,C:\repos\0install_0install-win\src\Commands\CliCommands\MaintenanceMan.Deploy.cs,Execute,The length of the statement  "                        if (!Handler.Ask(string.Format(Resources.AskDeployNewTarget' targetDir) + Environment.NewLine + hint' defaultAnswer: true' alternateMessage: hint)) " is 147.
Long Statement,ZeroInstall.Commands.CliCommands,Deploy,C:\repos\0install_0install-win\src\Commands\CliCommands\MaintenanceMan.Deploy.cs,GetDefaultTargetDir,The length of the statement  "                    string programFiles = _machineWide ? Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)' "Programs"); " is 200.
Long Statement,ZeroInstall.Commands.CliCommands,Deploy,C:\repos\0install_0install-win\src\Commands\CliCommands\MaintenanceMan.Deploy.cs,GetCustomTargetDir,The length of the statement  "                        if (Handler.Ask(Resources.AskDeployMachineWide + Environment.NewLine + hint' defaultAnswer: false' alternateMessage: hint)) " is 123.
Long Statement,ZeroInstall.Commands.CliCommands,SelfUpdate,C:\repos\0install_0install-win\src\Commands\CliCommands\SelfUpdate.cs,Parse,The length of the statement  "            if (AdditionalArgs.Count != 0) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs.JoinEscapeArguments()' null); " is 152.
Long Statement,ZeroInstall.Commands.CliCommands,SelfUpdate,C:\repos\0install_0install-win\src\Commands\CliCommands\SelfUpdate.cs,Execute,The length of the statement  "                if (!Handler.Ask(string.Format(Resources.SelfUpdateAvailable' Selections.MainImplementation.Version)' defaultAnswer: true)) " is 123.
Long Statement,ZeroInstall.Commands.CliCommands,Optimise,C:\repos\0install_0install-win\src\Commands\CliCommands\StoreMan.Management.cs,Execute,The length of the statement  "                Handler.OutputLow(Resources.OptimiseComplete' string.Format(Resources.StorageReclaimed' savedBytes.FormatBytes(CultureInfo.CurrentCulture))); " is 141.
Long Statement,ZeroInstall.Commands.CliCommands,SyncApps,C:\repos\0install_0install-win\src\Commands\CliCommands\SyncApps.cs,Execute,The length of the statement  "                using (var syncManager = new SyncIntegrationManager(Config.ToSyncServer()' Config.SyncCryptoKey' FeedManager.GetFresh' Handler' MachineWide)) " is 141.
Long Statement,ZeroInstall.Commands.Utils,AppUtils,C:\repos\0install_0install-win\src\Commands\Utils\AppUtils.cs,RemoveAllApps,The length of the statement  "                handler.RunTask(ForEachTask.Create(Resources.RemovingApplications' integrationManager.AppList.Entries.ToList()' integrationManager.RemoveApp)); " is 143.
Long Statement,ZeroInstall.Commands.Utils,Exporter,C:\repos\0install_0install-win\src\Commands\Utils\Exporter.cs,ExportImplementations,The length of the statement  "                using (var generator = ArchiveGenerator.Create(sourcePath' Path.Combine(contentDir' digest.Best + ".tbz2")' Archive.MimeTypeTarBzip)) " is 133.
Long Statement,ZeroInstall.Commands.Utils,HelpExporterBase,C:\repos\0install_0install-win\src\Commands\Utils\HelpExporterBase.cs,GetPrototypes,The length of the statement  "            var parameters = _descriptionParameterRegex.Matches(option.Description).Cast<Match>().Select(x => x.Captures[0].Value).ToList(); " is 128.
Long Statement,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,RegistryApply,The length of the statement  "                uninsKey.SetValue("DisplayName"' MachineWide ? AppInfo.CurrentLibrary.ProductName : AppInfo.CurrentLibrary.ProductName + " (current user)"); " is 140.
Long Statement,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,RegistryApply,The length of the statement  "                uninsKey.SetValue("UninstallString"' new[] {Path.Combine(TargetDir' "0install-win.exe")' MaintenanceMan.Name' MaintenanceMan.Remove.Name}.JoinEscapeArguments()); " is 161.
Long Statement,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,RegistryApply,The length of the statement  "                uninsKey.SetValue("QuietUninstallString"' new[] {Path.Combine(TargetDir' "0install-win.exe")' MaintenanceMan.Name' MaintenanceMan.Remove.Name' "--batch"' "--background"}.JoinEscapeArguments()); " is 193.
Long Statement,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,RegistryApply,The length of the statement  "            RegistryUtils.SetSoftwareString(@"Microsoft\PackageManagement"' "ZeroInstall"' Path.Combine(TargetDir' "ZeroInstall.OneGet.dll")' MachineWide); " is 143.
Long Statement,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,ServiceStop,The length of the statement  "            string imagePath = RegistryUtils.GetString(@"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\" + ServiceName' "ImagePath").Trim('"'); " is 138.
Long Statement,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,RemoveOneGetBootstrap,The length of the statement  "                Environment.GetFolderPath(MachineWide ? Environment.SpecialFolder.ProgramFiles : Environment.SpecialFolder.MyDocuments)' " is 120.
Long Statement,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,RemoveOneGetBootstrap,The length of the statement  "                Environment.GetFolderPath(MachineWide ? Environment.SpecialFolder.ProgramFiles : Environment.SpecialFolder.LocalApplicationData)' " is 129.
Long Statement,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,GetRegistryFilter,The length of the statement  "            foreach (var defaultProgram in _target.Feed.CapabilityLists.CompatibleCapabilities().OfType<Store.Model.Capabilities.DefaultProgram>()) " is 135.
Long Statement,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,GetRegistryFilter,The length of the statement  "                    filterRuleList.AddLast(GetInstallCommandFilter(defaultProgram.InstallCommands.Reinstall' defaultProgram.InstallCommands.ReinstallArgs' "--machine --batch --add=defaults " + _target.Uri.ToStringRfc().EscapeArgument())); " is 218.
Long Statement,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,GetRegistryFilter,The length of the statement  "                    filterRuleList.AddLast(GetInstallCommandFilter(defaultProgram.InstallCommands.ShowIcons' defaultProgram.InstallCommands.ShowIconsArgs' "--machine --batch --add=icons " + _target.Uri.ToStringRfc().EscapeArgument())); " is 215.
Long Statement,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,GetRegistryFilter,The length of the statement  "                    filterRuleList.AddLast(GetInstallCommandFilter(defaultProgram.InstallCommands.HideIcons' defaultProgram.InstallCommands.HideIconsArgs' "--machine --batch --remove=icons " + _target.Uri.ToStringRfc().EscapeArgument())); " is 218.
Long Statement,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,CreateProcessWCallback,The length of the statement  "            var result = UnsafeNativeMethods.CreateProcessW(lpApplicationName' lpCommandLine' lpProcessAttributes' lpThreadAttributes' bInheritHandles' dwCreationFlags | UnsafeNativeMethods.CreateSuspended' lpEnvironment' lpCurrentDirectory' lpStartupInfo' out lpProcessInformation); " is 271.
Long Statement,ZeroInstall.Commands.Utils,RunHook,C:\repos\0install_0install-win\src\Commands\Utils\RunHook.cs,CreateProcessACallback,The length of the statement  "            var result = UnsafeNativeMethods.CreateProcessA(lpApplicationName' lpCommandLine' lpProcessAttributes' lpThreadAttributes' bInheritHandles' dwCreationFlags | UnsafeNativeMethods.CreateSuspended' lpEnvironment' lpCurrentDirectory' lpStartupInfo' out lpProcessInformation); " is 271.
Long Statement,ZeroInstall.Commands.Utils,SyncUtils,C:\repos\0install_0install-win\src\Commands\Utils\SyncUtils.cs,ToSyncServer,The length of the statement  "            return new SyncServer {Uri = config.SyncServer' Username = config.SyncServerUsername' Password = config.SyncServerPassword}; " is 124.
Complex Conditional,ZeroInstall.Commands,CommandBase,C:\repos\0install_0install-win\src\Commands\CommandBase.cs,SelfUpdateCheck,The conditional expression  "SelfUpdateUtils.NoAutoCheck ||                  ProgramUtils.IsRunningFromCache ||                  Config.NetworkUse != NetworkLevel.Full ||                  Handler.Verbosity == Verbosity.Batch ||                  !FeedManager.IsStale(Config.SelfUpdateUri)"  is complex.
Empty Catch Block,ZeroInstall.Commands,CommandBase,C:\repos\0install_0install-win\src\Commands\CommandBase.cs,StartCommandBackground,The method has an empty catch block.
Empty Catch Block,ZeroInstall.Commands.CliCommands,Selection,C:\repos\0install_0install-win\src\Commands\CliCommands\Selection.cs,TryParseSelectionsDocument,The method has an empty catch block.
Magic Number,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Init,The following statement contains a magic number: if (AppMutex.Probe(mutexName + "-update")) Environment.Exit(999);
Magic Number,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Run,The following statement contains a magic number: try              {                  var command = CommandFactory.CreateAndParse(args' handler);                  return command.Execute();              }                  #region Error handling              catch (OperationCanceledException)              {                  return ExitCode.UserCanceled;              }              catch (NeedGuiException ex)              {                  if (GuiAssemblyName != null)                  {                      Log.Info("Switching to GUI");                      handler.DisableUI();                      try                      {                          return (ExitCode)ProcessUtils.Assembly(GuiAssemblyName' args).Run();                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                  }                  else                  {                      handler.Error(ex);                      return ExitCode.NotSupported;                  }              }              catch (NotAdminException ex)              {                  if (WindowsUtils.HasUac)                  {                      Log.Info("Elevating to admin");                      handler.DisableUI();                      try                      {                          return (ExitCode)ProcessUtils.Assembly(GuiAssemblyName ?? exeName' args).AsAdmin().Run();                      }                      catch (PlatformNotSupportedException ex2)                      {                          handler.Error(ex2);                          return ExitCode.NotSupported;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                  }                  else                  {                      handler.Error(ex);                      return ExitCode.AccessDenied;                  }              }              catch (UnsuitableInstallBaseException ex)              {                  if (WindowsUtils.IsWindows)                  {                      try                      {                          var result = TryRunOtherInstance(exeName' args' handler' ex.NeedsMachineWide);                          if (result.HasValue) return result.Value;                          else if (handler.Ask(Resources.AskDeployZeroInstall + Environment.NewLine + ex.Message'                              defaultAnswer: true' alternateMessage: ex.Message))                          {                              var deployArgs = new[] {MaintenanceMan.Name' MaintenanceMan.Deploy.Name' "--batch"};                              if (ex.NeedsMachineWide) deployArgs = deployArgs.Append("--machine");                              var deployResult = Run(exeName' deployArgs' handler);                              if (deployResult == ExitCode.OK)                              {                                  result = TryRunOtherInstance(exeName' args' handler' ex.NeedsMachineWide);                                  if (result.HasValue) return result.Value;                                  else throw new IOException("Unable to find newly installed instance.");                              }                              else return deployResult;                          }                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                  }                  else handler.Error(ex);                    return ExitCode.NotSupported;              }              catch (OptionException ex)              {                  handler.Error(new OptionException(ex.Message + Environment.NewLine + string.Format(Resources.TryHelp' exeName)' ex.OptionName));                  return ExitCode.InvalidArguments;              }              catch (FormatException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidArguments;              }              catch (WebException ex)              {                  handler.Error(ex);                  return ExitCode.WebError;              }              catch (NotSupportedException ex)              {                  handler.Error(ex);                  return ExitCode.NotSupported;              }              catch (PathTooLongException ex) when (                  WindowsUtils.IsWindows10Redstone &&                  Environment.Version >= new Version(4' 6' 2) &&                  RegistryUtils.GetDword(RegKeyFSPolicyUser' RegValueNameLongPaths' defaultValue: RegistryUtils.GetDword(RegKeyFSPolicyMachine' RegValueNameLongPaths)) != 1)              {                  string message = $"{ex.Message} Enabling Windows support for Long Paths may solve this problem.";                  if (handler.Ask($"{message} Do you want to try this now?"' defaultAnswer: false' alternateMessage: message))                  {                      try                      {                          RegistryUtils.SetDword(WindowsUtils.IsAdministrator ? RegKeyFSPolicyMachine : RegKeyFSPolicyUser' RegValueNameLongPaths' 1);                          return (ExitCode)ProcessUtils.Assembly(exeName' args).Run();                      }                      catch (PlatformNotSupportedException ex2)                      {                          handler.Error(ex2);                          return ExitCode.NotSupported;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                  }                    handler.Error(ex);                  return ExitCode.IOError;              }              catch (IOException ex)              {                  handler.Error(ex);                  return ExitCode.IOError;              }              catch (UnauthorizedAccessException ex)              {                  handler.Error(ex);                  return ExitCode.AccessDenied;              }              catch (InvalidDataException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidData;              }              catch (SignatureException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidSignature;              }              catch (DigestMismatchException ex)              {                  Log.Info(ex.LongMessage);                  handler.Error(ex);                  return ExitCode.DigestMismatch;              }              catch (SolverException ex)              {                  handler.Error(ex);                  return ExitCode.SolverError;              }              catch (ExecutorException ex)              {                  handler.Error(ex);                  return ExitCode.ExecutorError;              }              catch (ConflictException ex)              {                  handler.Error(ex);                  return ExitCode.Conflict;              }                  #endregion                finally              {                  handler.CloseUI();              }
Magic Number,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Run,The following statement contains a magic number: try              {                  var command = CommandFactory.CreateAndParse(args' handler);                  return command.Execute();              }                  #region Error handling              catch (OperationCanceledException)              {                  return ExitCode.UserCanceled;              }              catch (NeedGuiException ex)              {                  if (GuiAssemblyName != null)                  {                      Log.Info("Switching to GUI");                      handler.DisableUI();                      try                      {                          return (ExitCode)ProcessUtils.Assembly(GuiAssemblyName' args).Run();                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                  }                  else                  {                      handler.Error(ex);                      return ExitCode.NotSupported;                  }              }              catch (NotAdminException ex)              {                  if (WindowsUtils.HasUac)                  {                      Log.Info("Elevating to admin");                      handler.DisableUI();                      try                      {                          return (ExitCode)ProcessUtils.Assembly(GuiAssemblyName ?? exeName' args).AsAdmin().Run();                      }                      catch (PlatformNotSupportedException ex2)                      {                          handler.Error(ex2);                          return ExitCode.NotSupported;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                  }                  else                  {                      handler.Error(ex);                      return ExitCode.AccessDenied;                  }              }              catch (UnsuitableInstallBaseException ex)              {                  if (WindowsUtils.IsWindows)                  {                      try                      {                          var result = TryRunOtherInstance(exeName' args' handler' ex.NeedsMachineWide);                          if (result.HasValue) return result.Value;                          else if (handler.Ask(Resources.AskDeployZeroInstall + Environment.NewLine + ex.Message'                              defaultAnswer: true' alternateMessage: ex.Message))                          {                              var deployArgs = new[] {MaintenanceMan.Name' MaintenanceMan.Deploy.Name' "--batch"};                              if (ex.NeedsMachineWide) deployArgs = deployArgs.Append("--machine");                              var deployResult = Run(exeName' deployArgs' handler);                              if (deployResult == ExitCode.OK)                              {                                  result = TryRunOtherInstance(exeName' args' handler' ex.NeedsMachineWide);                                  if (result.HasValue) return result.Value;                                  else throw new IOException("Unable to find newly installed instance.");                              }                              else return deployResult;                          }                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                  }                  else handler.Error(ex);                    return ExitCode.NotSupported;              }              catch (OptionException ex)              {                  handler.Error(new OptionException(ex.Message + Environment.NewLine + string.Format(Resources.TryHelp' exeName)' ex.OptionName));                  return ExitCode.InvalidArguments;              }              catch (FormatException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidArguments;              }              catch (WebException ex)              {                  handler.Error(ex);                  return ExitCode.WebError;              }              catch (NotSupportedException ex)              {                  handler.Error(ex);                  return ExitCode.NotSupported;              }              catch (PathTooLongException ex) when (                  WindowsUtils.IsWindows10Redstone &&                  Environment.Version >= new Version(4' 6' 2) &&                  RegistryUtils.GetDword(RegKeyFSPolicyUser' RegValueNameLongPaths' defaultValue: RegistryUtils.GetDword(RegKeyFSPolicyMachine' RegValueNameLongPaths)) != 1)              {                  string message = $"{ex.Message} Enabling Windows support for Long Paths may solve this problem.";                  if (handler.Ask($"{message} Do you want to try this now?"' defaultAnswer: false' alternateMessage: message))                  {                      try                      {                          RegistryUtils.SetDword(WindowsUtils.IsAdministrator ? RegKeyFSPolicyMachine : RegKeyFSPolicyUser' RegValueNameLongPaths' 1);                          return (ExitCode)ProcessUtils.Assembly(exeName' args).Run();                      }                      catch (PlatformNotSupportedException ex2)                      {                          handler.Error(ex2);                          return ExitCode.NotSupported;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                  }                    handler.Error(ex);                  return ExitCode.IOError;              }              catch (IOException ex)              {                  handler.Error(ex);                  return ExitCode.IOError;              }              catch (UnauthorizedAccessException ex)              {                  handler.Error(ex);                  return ExitCode.AccessDenied;              }              catch (InvalidDataException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidData;              }              catch (SignatureException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidSignature;              }              catch (DigestMismatchException ex)              {                  Log.Info(ex.LongMessage);                  handler.Error(ex);                  return ExitCode.DigestMismatch;              }              catch (SolverException ex)              {                  handler.Error(ex);                  return ExitCode.SolverError;              }              catch (ExecutorException ex)              {                  handler.Error(ex);                  return ExitCode.ExecutorError;              }              catch (ConflictException ex)              {                  handler.Error(ex);                  return ExitCode.Conflict;              }                  #endregion                finally              {                  handler.CloseUI();              }
Magic Number,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Run,The following statement contains a magic number: try              {                  var command = CommandFactory.CreateAndParse(args' handler);                  return command.Execute();              }                  #region Error handling              catch (OperationCanceledException)              {                  return ExitCode.UserCanceled;              }              catch (NeedGuiException ex)              {                  if (GuiAssemblyName != null)                  {                      Log.Info("Switching to GUI");                      handler.DisableUI();                      try                      {                          return (ExitCode)ProcessUtils.Assembly(GuiAssemblyName' args).Run();                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                  }                  else                  {                      handler.Error(ex);                      return ExitCode.NotSupported;                  }              }              catch (NotAdminException ex)              {                  if (WindowsUtils.HasUac)                  {                      Log.Info("Elevating to admin");                      handler.DisableUI();                      try                      {                          return (ExitCode)ProcessUtils.Assembly(GuiAssemblyName ?? exeName' args).AsAdmin().Run();                      }                      catch (PlatformNotSupportedException ex2)                      {                          handler.Error(ex2);                          return ExitCode.NotSupported;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                  }                  else                  {                      handler.Error(ex);                      return ExitCode.AccessDenied;                  }              }              catch (UnsuitableInstallBaseException ex)              {                  if (WindowsUtils.IsWindows)                  {                      try                      {                          var result = TryRunOtherInstance(exeName' args' handler' ex.NeedsMachineWide);                          if (result.HasValue) return result.Value;                          else if (handler.Ask(Resources.AskDeployZeroInstall + Environment.NewLine + ex.Message'                              defaultAnswer: true' alternateMessage: ex.Message))                          {                              var deployArgs = new[] {MaintenanceMan.Name' MaintenanceMan.Deploy.Name' "--batch"};                              if (ex.NeedsMachineWide) deployArgs = deployArgs.Append("--machine");                              var deployResult = Run(exeName' deployArgs' handler);                              if (deployResult == ExitCode.OK)                              {                                  result = TryRunOtherInstance(exeName' args' handler' ex.NeedsMachineWide);                                  if (result.HasValue) return result.Value;                                  else throw new IOException("Unable to find newly installed instance.");                              }                              else return deployResult;                          }                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                  }                  else handler.Error(ex);                    return ExitCode.NotSupported;              }              catch (OptionException ex)              {                  handler.Error(new OptionException(ex.Message + Environment.NewLine + string.Format(Resources.TryHelp' exeName)' ex.OptionName));                  return ExitCode.InvalidArguments;              }              catch (FormatException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidArguments;              }              catch (WebException ex)              {                  handler.Error(ex);                  return ExitCode.WebError;              }              catch (NotSupportedException ex)              {                  handler.Error(ex);                  return ExitCode.NotSupported;              }              catch (PathTooLongException ex) when (                  WindowsUtils.IsWindows10Redstone &&                  Environment.Version >= new Version(4' 6' 2) &&                  RegistryUtils.GetDword(RegKeyFSPolicyUser' RegValueNameLongPaths' defaultValue: RegistryUtils.GetDword(RegKeyFSPolicyMachine' RegValueNameLongPaths)) != 1)              {                  string message = $"{ex.Message} Enabling Windows support for Long Paths may solve this problem.";                  if (handler.Ask($"{message} Do you want to try this now?"' defaultAnswer: false' alternateMessage: message))                  {                      try                      {                          RegistryUtils.SetDword(WindowsUtils.IsAdministrator ? RegKeyFSPolicyMachine : RegKeyFSPolicyUser' RegValueNameLongPaths' 1);                          return (ExitCode)ProcessUtils.Assembly(exeName' args).Run();                      }                      catch (PlatformNotSupportedException ex2)                      {                          handler.Error(ex2);                          return ExitCode.NotSupported;                      }                      catch (IOException ex2)                      {                          handler.Error(ex2);                          return ExitCode.IOError;                      }                      catch (NotAdminException ex2)                      {                          handler.Error(ex2);                          return ExitCode.AccessDenied;                      }                      catch (OperationCanceledException)                      {                          return ExitCode.UserCanceled;                      }                  }                    handler.Error(ex);                  return ExitCode.IOError;              }              catch (IOException ex)              {                  handler.Error(ex);                  return ExitCode.IOError;              }              catch (UnauthorizedAccessException ex)              {                  handler.Error(ex);                  return ExitCode.AccessDenied;              }              catch (InvalidDataException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidData;              }              catch (SignatureException ex)              {                  handler.Error(ex);                  return ExitCode.InvalidSignature;              }              catch (DigestMismatchException ex)              {                  Log.Info(ex.LongMessage);                  handler.Error(ex);                  return ExitCode.DigestMismatch;              }              catch (SolverException ex)              {                  handler.Error(ex);                  return ExitCode.SolverError;              }              catch (ExecutorException ex)              {                  handler.Error(ex);                  return ExitCode.ExecutorError;              }              catch (ConflictException ex)              {                  handler.Error(ex);                  return ExitCode.Conflict;              }                  #endregion                finally              {                  handler.CloseUI();              }
Magic Number,ZeroInstall.Commands.CliCommands,AddAlias,C:\repos\0install_0install-win\src\Commands\CliCommands\AddAlias.cs,Execute,The following statement contains a magic number: if (_resolve || _remove)              {                  if (AdditionalArgs.Count > 1) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs[1].EscapeArgument()' null);                  return ResolveOrRemove(                      aliasName: AdditionalArgs[0]);              }              else              {                  if (AdditionalArgs.Count < 2 || string.IsNullOrEmpty(AdditionalArgs[1])) throw new OptionException(Resources.MissingArguments' null);                  return CreateAlias(                      aliasName: AdditionalArgs[0]'                      interfaceUri: GetCanonicalUri(AdditionalArgs[1])'                      command: (AdditionalArgs.Count >= 3) ? AdditionalArgs[2] : null);              }
Magic Number,ZeroInstall.Commands.CliCommands,AddAlias,C:\repos\0install_0install-win\src\Commands\CliCommands\AddAlias.cs,Execute,The following statement contains a magic number: if (_resolve || _remove)              {                  if (AdditionalArgs.Count > 1) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs[1].EscapeArgument()' null);                  return ResolveOrRemove(                      aliasName: AdditionalArgs[0]);              }              else              {                  if (AdditionalArgs.Count < 2 || string.IsNullOrEmpty(AdditionalArgs[1])) throw new OptionException(Resources.MissingArguments' null);                  return CreateAlias(                      aliasName: AdditionalArgs[0]'                      interfaceUri: GetCanonicalUri(AdditionalArgs[1])'                      command: (AdditionalArgs.Count >= 3) ? AdditionalArgs[2] : null);              }
Magic Number,ZeroInstall.Commands.CliCommands,AddAlias,C:\repos\0install_0install-win\src\Commands\CliCommands\AddAlias.cs,Execute,The following statement contains a magic number: if (_resolve || _remove)              {                  if (AdditionalArgs.Count > 1) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs[1].EscapeArgument()' null);                  return ResolveOrRemove(                      aliasName: AdditionalArgs[0]);              }              else              {                  if (AdditionalArgs.Count < 2 || string.IsNullOrEmpty(AdditionalArgs[1])) throw new OptionException(Resources.MissingArguments' null);                  return CreateAlias(                      aliasName: AdditionalArgs[0]'                      interfaceUri: GetCanonicalUri(AdditionalArgs[1])'                      command: (AdditionalArgs.Count >= 3) ? AdditionalArgs[2] : null);              }
Magic Number,ZeroInstall.Commands.CliCommands,AddRemoveFeedCommand,C:\repos\0install_0install-win\src\Commands\CliCommands\AddRemoveFeedCommand.cs,Execute,The following statement contains a magic number: if (AdditionalArgs.Count == 2)              { // Main interface for feed specified explicitly                  feedUri = GetCanonicalUri(AdditionalArgs[1]);                  interfaces = new[] {GetCanonicalUri(AdditionalArgs[0])};              }              else              { // Determine interfaces from feed content (<feed-for> tags)                  feedUri = GetCanonicalUri(AdditionalArgs[0]);                  interfaces = GetInterfaces(feedUri' ref suggestedStabilityPolicy);              }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,Execute,The following statement contains a magic number: try                  {                      if (File.Exists(path))                      { // One or more archives (combined/overlayed)                          Store.AddArchives(GetArchiveFileInfos()' manifestDigest' Handler);                          return ExitCode.OK;                      }                      else if (Directory.Exists(path))                      { // A single directory                          if (AdditionalArgs.Count > 2) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs.Skip(2).JoinEscapeArguments()' null);                          Store.AddDirectory(Path.GetFullPath(path)' manifestDigest' Handler);                          return ExitCode.OK;                      }                      else throw new FileNotFoundException(string.Format(Resources.FileOrDirNotFound' path)' path);                  }                  catch (ImplementationAlreadyInStoreException ex)                  {                      Log.Warn(ex);                      return ExitCode.NoChanges;                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,Execute,The following statement contains a magic number: try                  {                      if (File.Exists(path))                      { // One or more archives (combined/overlayed)                          Store.AddArchives(GetArchiveFileInfos()' manifestDigest' Handler);                          return ExitCode.OK;                      }                      else if (Directory.Exists(path))                      { // A single directory                          if (AdditionalArgs.Count > 2) throw new OptionException(Resources.TooManyArguments + Environment.NewLine + AdditionalArgs.Skip(2).JoinEscapeArguments()' null);                          Store.AddDirectory(Path.GetFullPath(path)' manifestDigest' Handler);                          return ExitCode.OK;                      }                      else throw new FileNotFoundException(string.Format(Resources.FileOrDirNotFound' path)' path);                  }                  catch (ImplementationAlreadyInStoreException ex)                  {                      Log.Warn(ex);                      return ExitCode.NoChanges;                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: var archives = new ArchiveFileInfo[(AdditionalArgs.Count + 1) / 3];
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Add,C:\repos\0install_0install-win\src\Commands\CliCommands\CatalogMan.Add.cs,GetArchiveFileInfos,The following statement contains a magic number: for (int i = 0; i < archives.Length; i++)                  {                      archives[i] = new ArchiveFileInfo                      {                          Path = Path.GetFullPath(AdditionalArgs[i * 3 + 1])'                          Extract = (AdditionalArgs.Count > i * 3 + 2) ? AdditionalArgs[i * 3 + 2] : null'                          MimeType = (AdditionalArgs.Count > i * 3 + 3) ? AdditionalArgs[i * 3 + 3] : Archive.GuessMimeType(AdditionalArgs[i * 3 + 1])                      };                  }
Magic Number,ZeroInstall.Commands.CliCommands,Configure,C:\repos\0install_0install-win\src\Commands\CliCommands\Configure.cs,Execute,The following statement contains a magic number: switch (AdditionalArgs.Count)              {                  case 0:                      Handler.ShowConfig(Config' _configTab);                      Config.Save();                      break;                    case 1:                      GetOptions(AdditionalArgs[0]);                      break;                    case 2:                      SetOption(AdditionalArgs[0]' AdditionalArgs[1]);                      Config.Save();                      break;              }
Magic Number,ZeroInstall.Commands.CliCommands,Digest,C:\repos\0install_0install-win\src\Commands\CliCommands\Digest.cs,Execute,The following statement contains a magic number: var manifest = GenerateManifest(                  AdditionalArgs[0]'                  (AdditionalArgs.Count == 2) ? AdditionalArgs[1] : null);
Magic Number,ZeroInstall.Commands.CliCommands,Export,C:\repos\0install_0install-win\src\Commands\CliCommands\Export.cs,Execute,The following statement contains a magic number: string mimeType = (AdditionalArgs.Count == 3) ? AdditionalArgs[3] : null;
Magic Number,ZeroInstall.Commands.CliCommands,Export,C:\repos\0install_0install-win\src\Commands\CliCommands\Export.cs,Execute,The following statement contains a magic number: string mimeType = (AdditionalArgs.Count == 3) ? AdditionalArgs[3] : null;
Magic Number,ZeroInstall.Commands.CliCommands,Copy,C:\repos\0install_0install-win\src\Commands\CliCommands\StoreMan.Implementations.cs,Execute,The following statement contains a magic number: var store = (AdditionalArgs.Count == 2) ? new DirectoryStore(AdditionalArgs[1]) : Store;
Magic Number,ZeroInstall.Commands.CliCommands,Verify,C:\repos\0install_0install-win\src\Commands\CliCommands\StoreMan.Implementations.cs,Execute,The following statement contains a magic number: try                  {                      switch (AdditionalArgs.Count)                      {                          case 1:                              // Verify a directory inside the store                              Store.Verify(new ManifestDigest(AdditionalArgs[0])' Handler);                              break;                            case 2:                              // Verify an arbitrary directory                              DirectoryStore.VerifyDirectory(AdditionalArgs[0]' new ManifestDigest(AdditionalArgs[1])' Handler);                              break;                      }                  }                  catch (DigestMismatchException ex)                  {                      Handler.Output(Resources.VerifyImplementation' ex.LongMessage);                      return ExitCode.DigestMismatch;                  }
Magic Number,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,ServiceStop,The following statement contains a magic number: Handler.RunTask(new SimpleTask(Resources.StopService' () =>              {                  try                  {                      service.Stop();                  }                  #region Error handling                  catch (InvalidOperationException ex)                  {                      // Wrap exception since only certain exception types are allowed                      throw new IOException("Failed to stop service."' ex);                  }                  catch (Win32Exception ex)                  {                      // Wrap exception since only certain exception types are allowed                      throw new IOException("Failed to stop service."' ex);                  }                  #endregion                    Thread.Sleep(2000);              }));
Magic Number,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,TargetMutexAquire,The following statement contains a magic number: Handler.RunTask(new SimpleTask(Resources.MutexWait' () =>              {                  // Wait for existing instances to terminate                  while (AppMutex.Probe(targetMutex))                      Thread.Sleep(1000);                    // Prevent new instances from starting                  _targetMutex = AppMutex.Create(targetMutex + "-update");                    // Detect any new instances that started in the short time between detecting existing ones and blocking new ones                  while (AppMutex.Probe(targetMutex))                      Thread.Sleep(1000);              }));
Magic Number,ZeroInstall.Commands.Utils,MaintenanceManager,C:\repos\0install_0install-win\src\Commands\Utils\MaintenanceManager.cs,TargetMutexAquire,The following statement contains a magic number: Handler.RunTask(new SimpleTask(Resources.MutexWait' () =>              {                  // Wait for existing instances to terminate                  while (AppMutex.Probe(targetMutex))                      Thread.Sleep(1000);                    // Prevent new instances from starting                  _targetMutex = AppMutex.Create(targetMutex + "-update");                    // Detect any new instances that started in the short time between detecting existing ones and blocking new ones                  while (AppMutex.Probe(targetMutex))                      Thread.Sleep(1000);              }));
Duplicate Code,ZeroInstall.Commands,ProgramUtils,C:\repos\0install_0install-win\src\Commands\ProgramUtils.cs,Run,The method contains a code clone-set at the following line numbers (starting from the method definition): ((54' 74)' (155' 175))
Missing Default,ZeroInstall.Commands.CliCommands,Configure,C:\repos\0install_0install-win\src\Commands\CliCommands\Configure.cs,Execute,The following switch statement is missing a default case: switch (AdditionalArgs.Count)              {                  case 0:                      Handler.ShowConfig(Config' _configTab);                      Config.Save();                      break;                    case 1:                      GetOptions(AdditionalArgs[0]);                      break;                    case 2:                      SetOption(AdditionalArgs[0]' AdditionalArgs[1]);                      Config.Save();                      break;              }
Missing Default,ZeroInstall.Commands.CliCommands,Export,C:\repos\0install_0install-win\src\Commands\CliCommands\Export.cs,Execute,The following switch statement is missing a default case: switch (_bootstrapType)              {                  case BootstrapMode.Run:                      exporter.DeployBootstrapRun(Handler);                      break;                  case BootstrapMode.Integrate:                      exporter.DeployBootstrapIntegrate(Handler);                      break;              }
Missing Default,ZeroInstall.Commands.CliCommands,Verify,C:\repos\0install_0install-win\src\Commands\CliCommands\StoreMan.Implementations.cs,Execute,The following switch statement is missing a default case: switch (AdditionalArgs.Count)                      {                          case 1:                              // Verify a directory inside the store                              Store.Verify(new ManifestDigest(AdditionalArgs[0])' Handler);                              break;                            case 2:                              // Verify an arbitrary directory                              DirectoryStore.VerifyDirectory(AdditionalArgs[0]' new ManifestDigest(AdditionalArgs[1])' Handler);                              break;                      }
