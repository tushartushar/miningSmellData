Implementation smell,Namespace,Class,File,Method,Description
Complex Method,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,Cyclomatic complexity of the method is 15
Complex Method,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,UnParse,Cyclomatic complexity of the method is 14
Complex Method,meshExpImp.ModelBlocks,VertexFormat,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,ElementList,Cyclomatic complexity of the method is 10
Complex Method,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,ElementList,Cyclomatic complexity of the method is 10
Complex Method,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,UnParse,Cyclomatic complexity of the method is 10
Complex Method,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,GetBoundingBox,Cyclomatic complexity of the method is 10
Complex Method,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,GetVertices,Cyclomatic complexity of the method is 10
Complex Method,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,Cyclomatic complexity of the method is 19
Complex Method,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,PositionMinMax,Cyclomatic complexity of the method is 8
Complex Method,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,SetVertices,Cyclomatic complexity of the method is 12
Complex Method,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteUVData,Cyclomatic complexity of the method is 8
Complex Method,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,Cyclomatic complexity of the method is 17
Long Parameter List,meshExpImp.ModelBlocks,Matrix43,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\Common\Matrix43.cs,Matrix43,The method has 6 parameters. Parameters: APIversion' handler' right' up' back' translate
Long Parameter List,meshExpImp.ModelBlocks,UByte4,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\Common\UByte4.cs,UByte4,The method has 6 parameters. Parameters: APIversion' handler' a' b' c' d
Long Parameter List,meshExpImp.ModelBlocks,Vector3,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\Common\Vector3.cs,Vector3,The method has 5 parameters. Parameters: APIversion' handler' x' y' z
Long Parameter List,meshExpImp.ModelBlocks,Vector4,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\Common\Vector4.cs,Vector4,The method has 6 parameters. Parameters: APIversion' handler' x' y' z' w
Long Parameter List,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,GEOM,The method has 15 parameters. Parameters: APIversion' handler' version' shader' mtnf' mergeGroup' sortOrder' vertexFormats' vertexData' facePoints' skinIndex' unknownThings' unknownThings2' boneHashes' tgiBlockList
Long Parameter List,meshExpImp.ModelBlocks,PositionElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,PositionElement,The method has 5 parameters. Parameters: APIversion' handler' x' y' z
Long Parameter List,meshExpImp.ModelBlocks,NormalElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,NormalElement,The method has 5 parameters. Parameters: APIversion' handler' x' y' z
Long Parameter List,meshExpImp.ModelBlocks,WeightsElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,WeightsElement,The method has 6 parameters. Parameters: APIversion' handler' w1' w2' w3' w4
Long Parameter List,meshExpImp.ModelBlocks,WeightBytesElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,WeightBytesElement,The method has 6 parameters. Parameters: APIversion' handler' w1' w2' w3' w4
Long Parameter List,meshExpImp.ModelBlocks,TangentNormalElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,TangentNormalElement,The method has 5 parameters. Parameters: APIversion' handler' x' y' z
Long Parameter List,meshExpImp.ModelBlocks,VertexDataElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,VertexDataElement,The method has 5 parameters. Parameters: APIversion' handler' version' s' parentVertexFormats
Long Parameter List,meshExpImp.ModelBlocks,VertexDataElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,VertexDataElement,The method has 5 parameters. Parameters: APIversion' handler' version' elementList' parentVertexFormats
Long Parameter List,meshExpImp.ModelBlocks,VertexDataList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,VertexDataList,The method has 5 parameters. Parameters: handler' version' s' origCount' parentVertexFormats
Long Parameter List,meshExpImp.ModelBlocks,Face,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Face,The method has 5 parameters. Parameters: APIversion' handler' vertexDataIndex0' vertexDataIndex1' vertexDataIndex2
Long Parameter List,meshExpImp.ModelBlocks,UnknownThing2,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,UnknownThing2,The method has 20 parameters. Parameters: APIversion' handler' unknown1' unknown2' unknown3' unknown4' unknown5' unknown6' unknown7' unknown8' unknown9' unknown10' unknown11' unknown12' unknown13' unknown14' unknown15' unknown16' unknown17' unknown18
Long Parameter List,meshExpImp.ModelBlocks,IBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\IBUF.cs,SetIndices,The method has 6 parameters. Parameters: mlod' myIBI' type' startIndex' primCount' indices
Long Parameter List,meshExpImp.ModelBlocks,IBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\IBUF.cs,SetIndices,The method has 5 parameters. Parameters: mlod' myIBI' beforeLength' afterPos' indices
Long Parameter List,meshExpImp.ModelBlocks,IBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\IBUF.cs,IBUF,The method has 6 parameters. Parameters: APIversion' handler' version' flags' displayListUsage' buffer
Long Parameter List,meshExpImp.ModelBlocks,GeometryState,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MLOD.cs,GeometryState,The method has 7 parameters. Parameters: APIversion' handler' name' startIndex' minVertexIndex' vertexCount' primitiveCount
Long Parameter List,meshExpImp.ModelBlocks,Mesh,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MLOD.cs,Mesh,The method has 24 parameters. Parameters: APIversion' handler' owner' name' materialIndex' vertexFormatIndex' vertexBufferIndex' indexBufferIndex' primitiveType' flags' streamOffset' startVertex' startIndex' minVertexIndex' vertexCount' primitiveCount' bounds' skinControllerIndex' jointReferences' geometryStates' scaleOffsetIndex' parentName' mirrorPlane' unknown1
Long Parameter List,meshExpImp.ModelBlocks,MODL,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MODL.cs,MODL,The method has 8 parameters. Parameters: APIversion' handler' version' bounds' extraBounds' fadeType' customFadeDistance' entries
Long Parameter List,meshExpImp.ModelBlocks,LODEntry,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MODL.cs,LODEntry,The method has 7 parameters. Parameters: APIversion' handler' modelLodIndex' flags' id' minZValue' maxZValue
Long Parameter List,meshExpImp.ModelBlocks,SegmentInfo,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBSI.cs,SegmentInfo,The method has 6 parameters. Parameters: APIversion' handler' vertexSize' vertexCount' byteOffset' swizzles
Long Parameter List,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,VBUF,The method has 6 parameters. Parameters: APIversion' handler' version' flags' swizzleInfo' buffer
Long Parameter List,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,SetVertices,The method has 5 parameters. Parameters: mlod' meshIndex' vrtf' vertices' uvscales
Long Parameter List,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,SetVertices,The method has 5 parameters. Parameters: mlod' mesh' vrtf' vertices' uvscales
Long Parameter List,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,SetVertices,The method has 6 parameters. Parameters: mlod' mesh' geoIndex' vrtf' vertices' uvscales
Long Parameter List,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,SetVertices,The method has 6 parameters. Parameters: mlod' mesh' geo' vrtf' vertices' uvscales
Long Parameter List,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,SetVertices,The method has 7 parameters. Parameters: mlod' myVBI' beforeLength' count' vrtf' vertices' uvscales
Long Parameter List,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,VRTF,The method has 6 parameters. Parameters: APIversion' handler' version' stride' layouts' extendedFormat
Long Parameter List,meshExpImp.ModelBlocks,ElementLayout,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,ElementLayout,The method has 6 parameters. Parameters: APIversion' handler' format' offset' usage' usageIndex
Long Statement,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,The length of the statement  "                    throw new InvalidDataException(String.Format("Invalid Tag read: '{0}'; expected: 'GEOM'; at 0x{1:X8}"' FOURCC(tag)' s.Position)); " is 129.
Long Statement,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,The length of the statement  "                    throw new InvalidDataException(String.Format("Invalid Version read: '{0}'; expected: '0x00000005' or '0x0000000C'; at 0x{1:X8}"' version' s.Position)); " is 151.
Long Statement,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,The length of the statement  "                        throw new InvalidDataException(String.Format("MTNF chunk size invalid; expected 0x{0:X8} bytes' read 0x{1:X8} bytes; at 0x{2:X8}"' " is 130.
Long Statement,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,The length of the statement  "                    throw new InvalidDataException(String.Format("Expected number of face point sizes to be 1' read {0}' at 0x{1:X8}"' numFacePointSizes' s.Position)); " is 147.
Long Statement,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,The length of the statement  "                    throw new InvalidDataException(String.Format("Expected face point size to be 2' read {0}' at 0x{1:X8}"' facePointSize' s.Position)); " is 132.
Long Statement,meshExpImp.ModelBlocks,VertexFormat,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,The length of the statement  "                        throw new InvalidDataException(string.Format("Expected data type 0x{0:X8}' read 0x{1:X8}' at 0x{2:X8}"' expectedDataType[(uint)usage]' dataType' s.Position)); " is 158.
Long Statement,meshExpImp.ModelBlocks,VertexFormat,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,The length of the statement  "                        throw new InvalidDataException(String.Format("Expected element size 0x{0:X2}' read 0x{1:X2}' at {2:X8}"' expectedElementSize[(uint)usage]' elementSize' s.Position)); " is 165.
Long Statement,meshExpImp.ModelBlocks,WeightsElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Parse,The length of the statement  "{ BinaryReader r = new BinaryReader(s); w1 = r.ReadSingle(); w2 = r.ReadSingle(); w3 = r.ReadSingle(); w4 = r.ReadSingle(); }" is 125.
Long Statement,meshExpImp.ModelBlocks,WeightsElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Equals,The length of the statement  "{ WeightsElement o = other as WeightsElement; return o != null && w1.Equals(o.w1) && w2.Equals(o.w2) && w3.Equals(o.w3) && w3.Equals(o.w4); }" is 141.
Long Statement,meshExpImp.ModelBlocks,WeightBytesElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Equals,The length of the statement  "{ WeightBytesElement o = other as WeightBytesElement; return o != null && w1.Equals(o.w1) && w2.Equals(o.w2) && w3.Equals(o.w3) && w3.Equals(o.w4); }" is 149.
Long Statement,meshExpImp.ModelBlocks,TangentNormalElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,Equals,The length of the statement  "{ TangentNormalElement o = other as TangentNormalElement; return o != null && x.Equals(o.x) && y.Equals(o.y) && z.Equals(o.z); }" is 128.
Long Statement,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,UnParse,The length of the statement  "                        case UsageType.BoneAssignment: (vtx is BoneAssignmentElement ? vtx : new BoneAssignmentElement(0' null)).UnParse(s); break; " is 123.
Long Statement,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,UnParse,The length of the statement  "                        case UsageType.TangentNormal: (vtx is TangentNormalElement ? vtx : new TangentNormalElement(0' null)).UnParse(s); break; " is 120.
Long Statement,meshExpImp.ModelBlocks,UnknownThing2,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,GetHashCode,The length of the statement  "{ return unknown1.GetHashCode() ^ unknown2.GetHashCode() ^ unknown3.GetHashCode() ^ unknown4.GetHashCode() ^ unknown5.GetHashCode(); }" is 134.
Long Statement,meshExpImp.ModelBlocks,GeometryResource,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GeomResource.cs,UnParse,The length of the statement  "                blockList = new ChunkEntryList(OnResourceChanged' new ChunkEntry[] { new ChunkEntry(0' OnResourceChanged' rk' geom)' }) { ParentTGIBlocks = Resources' }; " is 153.
Long Statement,meshExpImp.ModelBlocks,IBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\IBUF.cs,Parse,The length of the statement  "                throw new InvalidDataException(string.Format("Invalid Tag read: '{0}'; expected: '{1}'; at 0x{2:X8}"' tag' Tag' s.Position)); " is 125.
Long Statement,meshExpImp.ModelBlocks,MLOD,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MLOD.cs,Parse,The length of the statement  "                throw new InvalidDataException(string.Format("Invalid Tag read: '{0}'; expected: '{1}'; at 0x{1:X8}"' tag' Tag' s.Position)); " is 125.
Long Statement,meshExpImp.ModelBlocks,MODL,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MODL.cs,Parse,The length of the statement  "                throw new InvalidDataException(string.Format("Invalid Tag read: '{0}'; expected: '{1}'; at 0x{1:X8}"' tag' Tag' s.Position)); " is 125.
Long Statement,meshExpImp.ModelBlocks,SKIN,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\SKIN.cs,Parse,The length of the statement  "                throw new InvalidDataException(string.Format("Invalid Tag read: '{0}'; expected: '{1}'; at 0x{1:X8}"' tag' Tag' s.Position)); " is 125.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,Parse,The length of the statement  "                throw new InvalidDataException(string.Format("Invalid Tag read: '{0}'; expected: '{1}'; at 0x{2:X8}"' tag' Tag' s.Position)); " is 125.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,GetBoundingBox,The length of the statement  "                    bbox = new BoundingBox(0' null' new s4pi.Interfaces.Vertex(0' null' fs[0]' fs[1]' fs[2])' new s4pi.Interfaces.Vertex(0' null' fs[0]' fs[1]' fs[2])); " is 148.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,PositionMinMax,The length of the statement  "            var layout = vrtf.Layouts.FirstOrDefault(x => x.Format == VRTF.ElementFormat.UShort4N && x.Usage == VRTF.ElementUsage.Position); " is 128.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,SetVertices,The length of the statement  "                if (v.BlendIndices != null) Array.Copy(v.BlendIndices' 0' output' blendIndices.Offset' VRTF.ByteSizeFromFormat(blendIndices.Format)); " is 133.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WritePositionData,The length of the statement  "                        Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short)); " is 133.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WritePositionData,The length of the statement  "                    Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar - 1))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short)); " is 136.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteUVData,The length of the statement  "                        Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] / scale))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short)); " is 132.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteUVData,The length of the statement  "                        Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short)); " is 141.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteUVData,The length of the statement  "                        Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short)); " is 141.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteUVData,The length of the statement  "                    Array.Copy(BitConverter.GetBytes((short)Math.Round(input[input.Length - 1] * 511))' 0' output' layout.Offset + (input.Length - 1) * sizeof(short)' sizeof(short)); " is 162.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The length of the statement  "                        Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short)); " is 141.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The length of the statement  "                        Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short)); " is 133.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The length of the statement  "                    Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short)); " is 122.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The length of the statement  "                        Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short)); " is 133.
Long Statement,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The length of the statement  "                    Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short)); " is 142.
Long Statement,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,CreateDefaultForDropShadow,The length of the statement  "            v.Layouts.Add(new ElementLayout(0' null' ElementFormat.Short4_DropShadow' (byte)v.Layouts.Select(x => VRTF.ByteSizeFromFormat(x.Format)).Sum()' ElementUsage.UV' 0)); " is 165.
Long Statement,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,CreateDefaultForDropShadow,The length of the statement  "            //v.Layouts.Add(new ElementLayout(0' null' ElementFormat.Short2' (byte)v.Layouts.Select(x => VRTF.ByteSizeFromFormat(x.Format)).Sum()' ElementUsage.UV' 0)); " is 156.
Long Statement,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,CreateDefaultForDropShadow,The length of the statement  "            //v.Layouts.Add(new ElementLayout(0' null' ElementFormat.Short2' (byte)v.Layouts.Select(x => VRTF.ByteSizeFromFormat(x.Format)).Sum()' ElementUsage.UV' 1)); " is 156.
Long Statement,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,CreateDefaultForDropShadow,The length of the statement  "            //v.Layouts.Add(new ElementLayout(0' null' ElementFormat.ColorUByte4' (byte)v.Layouts.Select(x => VRTF.ByteSizeFromFormat(x.Format)).Sum()' ElementUsage.Normal' 0)); " is 165.
Long Statement,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,Parse,The length of the statement  "                throw new InvalidDataException(string.Format("Invalid Tag read: '{0}'; expected: '{1}'; at 0x{2:X8}"' tag' Tag' s.Position)); " is 125.
Complex Conditional,meshExpImp.ModelBlocks,GeometryResource,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GeomResource.cs,UnParse,The conditional expression  "version == 0 && publicChunks == 0 && unused == 0 && blockList == null && resources == null"  is complex.
Virtual Method Call from Constructor,meshExpImp.ModelBlocks,UByte4,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\Common\UByte4.cs,UByte4,The constructor "UByte4" calls a virtual method "Parse".
Virtual Method Call from Constructor,meshExpImp.ModelBlocks,Vector2,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\Common\Vector2.cs,Vector2,The constructor "Vector2" calls a virtual method "Parse".
Virtual Method Call from Constructor,meshExpImp.ModelBlocks,VertexElement,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,VertexElement,The constructor "VertexElement" calls a virtual method "Parse".
Magic Number,meshExpImp.ModelBlocks,GEOM,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,UnParse,The following statement contains a magic number: w.Write((byte)2);
Magic Number,meshExpImp.ModelBlocks,FaceList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,ReadCount,The following statement contains a magic number: return base.ReadCount(s) / 3;
Magic Number,meshExpImp.ModelBlocks,FaceList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,WriteCount,The following statement contains a magic number: base.WriteCount(s' (int)(count * 3));
Magic Number,meshExpImp.ModelBlocks,IBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\IBUF.cs,Parse,The following statement contains a magic number: mBuffer = new Int32[(s.Length-s.Position) / (is32Bit ? 4 : 2)];
Magic Number,meshExpImp.ModelBlocks,IBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\IBUF.cs,Parse,The following statement contains a magic number: mBuffer = new Int32[(s.Length-s.Position) / (is32Bit ? 4 : 2)];
Magic Number,meshExpImp.ModelBlocks,IBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\IBUF.cs,IndexCountFromPrimitiveType,The following statement contains a magic number: switch (t)              {                  case ModelPrimitiveType.TriangleList:                      return 3;                  default:                      throw new NotImplementedException();              }
Magic Number,meshExpImp.ModelBlocks,Mesh,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MLOD.cs,Parse,The following statement contains a magic number: mFlags = (MeshFlags)(val >> 8);
Magic Number,meshExpImp.ModelBlocks,Mesh,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MLOD.cs,UnParse,The following statement contains a magic number: bw.Write((UInt32)mPrimitiveType | ((UInt32)mFlags << 8));
Magic Number,meshExpImp.ModelBlocks,MODL,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MODL.cs,Parse,The following statement contains a magic number: mVersion >= 258 && mVersion < 0x300
Magic Number,meshExpImp.ModelBlocks,MODL,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MODL.cs,UnParse,The following statement contains a magic number: mVersion = 258;
Magic Number,meshExpImp.ModelBlocks,MODL,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MODL.cs,UnParse,The following statement contains a magic number: mVersion < 258 && mExtraBounds.Count > 0
Magic Number,meshExpImp.ModelBlocks,MODL,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\MODL.cs,UnParse,The following statement contains a magic number: mVersion >= 258 && mVersion < 0x300
Magic Number,meshExpImp.ModelBlocks,SegmentInfo,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBSI.cs,Parse,The following statement contains a magic number: mSwizzles = new SwizzleList(handler' s' (int)mVertexSize / 4);
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,GetBoundingBox,The following statement contains a magic number: fs.Length != 3
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,GetBoundingBox,The following statement contains a magic number: bbox = new BoundingBox(0' null' new s4pi.Interfaces.Vertex(0' null' fs[0]' fs[1]' fs[2])' new s4pi.Interfaces.Vertex(0' null' fs[0]' fs[1]' fs[2]));
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,GetBoundingBox,The following statement contains a magic number: bbox = new BoundingBox(0' null' new s4pi.Interfaces.Vertex(0' null' fs[0]' fs[1]' fs[2])' new s4pi.Interfaces.Vertex(0' null' fs[0]' fs[1]' fs[2]));
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,GetVertices,The following statement contains a magic number: uvscales = new float[3];
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadUVData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                      {                          output[i] += (float)BitConverter.ToInt16(element' i * sizeof(short)) * scale;                      }                      break;                  case VRTF.ElementFormat.Short4:                      for (int i = 0; i < output.Length; i++)                          output[i] += (float)BitConverter.ToInt16(element' i * sizeof(short)) / short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4_DropShadow:                      for (int i = 0; i < output.Length - 1; i++)                          output[i] += (float)BitConverter.ToInt16(element' i * sizeof(short)) / short.MaxValue;                      output[output.Length - 1] += (float)BitConverter.ToInt16(element' (output.Length - 1) * sizeof(short)) / 511;                      break;                  default:                      ReadFloatData(data' layout' ref output);                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,ReadFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToSingle(element' i * sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[i] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < output.Length; i++)                                  output[i] += element[kColorUByte4Map[i]] / (float)byte.MaxValue;                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              for (int i = 0; i < output.Length - 1; i++)                                  output[i] += element[2 - i] == 0 ? -1 : (((element[2 - i] + 1) / 128f) - 1);                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //???                              //--                              // input: 255 > 128 > 127 > 0                              // map step1: +2 > 0                              // map step2: +1 > -1                              //for (int i = 0; i < output.Length - 1; i++)                              //    output[i] += (element[2 - i] / 127.5f) - 1f;                                switch (element[3])                              {                                  case 0: output[output.Length - 1] = -1f; break; // -1 determinant                                  case 127: output[output.Length - 1] = 0f; break; // There is no determinant                                  case 255: output[output.Length - 1] = +1f; break; // +1 determinant                                  default: System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' element[3])); break;                              }                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / (float)short.MaxValue;                      break;                  case VRTF.ElementFormat.Short4:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(short));                      if (scalar == 0) scalar = short.MaxValue;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;                  case VRTF.ElementFormat.UShort4N:                      scalar = BitConverter.ToUInt16(element' 3 * sizeof(ushort));                      if (scalar == 0) scalar = 511;                      //scalar++;                      for (int i = 0; i < output.Length; i++)                          output[i] += BitConverter.ToInt16(element' i * sizeof(short)) / scalar;                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WritePositionData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.UShort4N:                      //scalar = (max >= 1) ? 511 : (ulong)short.MaxValue;                      //-- could try "max < 1.0 / 512.0"?                      //ulong scalar = (ulong)(max < 1 ? short.MaxValue : 511);                      //scalar++;                      //2011-08-30 changed to fixed 512 as LoveseatDanishModern had problems                      ulong scalar = 512;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar - 1))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  default:                      WriteFloatData(input' layout' output);                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WritePositionData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.UShort4N:                      //scalar = (max >= 1) ? 511 : (ulong)short.MaxValue;                      //-- could try "max < 1.0 / 512.0"?                      //ulong scalar = (ulong)(max < 1 ? short.MaxValue : 511);                      //scalar++;                      //2011-08-30 changed to fixed 512 as LoveseatDanishModern had problems                      ulong scalar = 512;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar - 1))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  default:                      WriteFloatData(input' layout' output);                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WritePositionData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.UShort4N:                      //scalar = (max >= 1) ? 511 : (ulong)short.MaxValue;                      //-- could try "max < 1.0 / 512.0"?                      //ulong scalar = (ulong)(max < 1 ? short.MaxValue : 511);                      //scalar++;                      //2011-08-30 changed to fixed 512 as LoveseatDanishModern had problems                      ulong scalar = 512;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar - 1))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  default:                      WriteFloatData(input' layout' output);                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteUVData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                      {                          if ((short)Math.Round(input[i] / scale) != (long)Math.Round(input[i] / scale)) okay = false;                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] / scale))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      }                      break;                    case VRTF.ElementFormat.Short4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4_DropShadow:                      for (int i = 0; i < input.Length - 1; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)Math.Round(input[input.Length - 1] * 511))' 0' output' layout.Offset + (input.Length - 1) * sizeof(short)' sizeof(short));                      break;                  default:                      WriteFloatData(input' layout' output);                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following statement contains a magic number: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Magic Number,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,FloatCountFromFormat,The following statement contains a magic number: switch (format)              {                  case ElementFormat.Float1:                      return 1;                  case ElementFormat.Float2:                  case ElementFormat.UShort2N:                  case ElementFormat.Short2:                      return 2;                  case ElementFormat.Short4:                  case ElementFormat.Short4N:                  case ElementFormat.UByte4N:                  case ElementFormat.UShort4N:                  case ElementFormat.Float3:                      return 3;                  case ElementFormat.ColorUByte4:                  case ElementFormat.Float4:                  case ElementFormat.Short4_DropShadow:                      return 4;                  default:                      throw new NotImplementedException();              }
Magic Number,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,FloatCountFromFormat,The following statement contains a magic number: switch (format)              {                  case ElementFormat.Float1:                      return 1;                  case ElementFormat.Float2:                  case ElementFormat.UShort2N:                  case ElementFormat.Short2:                      return 2;                  case ElementFormat.Short4:                  case ElementFormat.Short4N:                  case ElementFormat.UByte4N:                  case ElementFormat.UShort4N:                  case ElementFormat.Float3:                      return 3;                  case ElementFormat.ColorUByte4:                  case ElementFormat.Float4:                  case ElementFormat.Short4_DropShadow:                      return 4;                  default:                      throw new NotImplementedException();              }
Magic Number,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,FloatCountFromFormat,The following statement contains a magic number: switch (format)              {                  case ElementFormat.Float1:                      return 1;                  case ElementFormat.Float2:                  case ElementFormat.UShort2N:                  case ElementFormat.Short2:                      return 2;                  case ElementFormat.Short4:                  case ElementFormat.Short4N:                  case ElementFormat.UByte4N:                  case ElementFormat.UShort4N:                  case ElementFormat.Float3:                      return 3;                  case ElementFormat.ColorUByte4:                  case ElementFormat.Float4:                  case ElementFormat.Short4_DropShadow:                      return 4;                  default:                      throw new NotImplementedException();              }
Magic Number,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,ByteSizeFromFormat,The following statement contains a magic number: switch (f)              {                  case ElementFormat.Float1:                  case ElementFormat.UByte4:                  case ElementFormat.ColorUByte4:                  case ElementFormat.UByte4N:                  case ElementFormat.UShort2N:                  case ElementFormat.Short2:                      return 4;                  case ElementFormat.UShort4N:                  case ElementFormat.Float2:                  case ElementFormat.Short4:                  case ElementFormat.Short4N:                  case ElementFormat.Short4_DropShadow:                      return 8;                  case ElementFormat.Float3:                      return 12;                  case ElementFormat.Float4:                      return 16;                  default:                      throw new NotImplementedException();              }
Magic Number,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,ByteSizeFromFormat,The following statement contains a magic number: switch (f)              {                  case ElementFormat.Float1:                  case ElementFormat.UByte4:                  case ElementFormat.ColorUByte4:                  case ElementFormat.UByte4N:                  case ElementFormat.UShort2N:                  case ElementFormat.Short2:                      return 4;                  case ElementFormat.UShort4N:                  case ElementFormat.Float2:                  case ElementFormat.Short4:                  case ElementFormat.Short4N:                  case ElementFormat.Short4_DropShadow:                      return 8;                  case ElementFormat.Float3:                      return 12;                  case ElementFormat.Float4:                      return 16;                  default:                      throw new NotImplementedException();              }
Magic Number,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,ByteSizeFromFormat,The following statement contains a magic number: switch (f)              {                  case ElementFormat.Float1:                  case ElementFormat.UByte4:                  case ElementFormat.ColorUByte4:                  case ElementFormat.UByte4N:                  case ElementFormat.UShort2N:                  case ElementFormat.Short2:                      return 4;                  case ElementFormat.UShort4N:                  case ElementFormat.Float2:                  case ElementFormat.Short4:                  case ElementFormat.Short4N:                  case ElementFormat.Short4_DropShadow:                      return 8;                  case ElementFormat.Float3:                      return 12;                  case ElementFormat.Float4:                      return 16;                  default:                      throw new NotImplementedException();              }
Magic Number,meshExpImp.ModelBlocks,VRTF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VRTF.cs,ByteSizeFromFormat,The following statement contains a magic number: switch (f)              {                  case ElementFormat.Float1:                  case ElementFormat.UByte4:                  case ElementFormat.ColorUByte4:                  case ElementFormat.UByte4N:                  case ElementFormat.UShort2N:                  case ElementFormat.Short2:                      return 4;                  case ElementFormat.UShort4N:                  case ElementFormat.Float2:                  case ElementFormat.Short4:                  case ElementFormat.Short4N:                  case ElementFormat.Short4_DropShadow:                      return 8;                  case ElementFormat.Float3:                      return 12;                  case ElementFormat.Float4:                      return 16;                  default:                      throw new NotImplementedException();              }
Missing Default,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,ElementList,The following switch statement is missing a default case: switch (fmt.Usage)                      {                          case UsageType.Position: this.Add(new PositionElement(0' handler' s)); break;                          case UsageType.Normal: this.Add(new NormalElement(0' handler' s)); break;                          case UsageType.UV: this.Add(new UVElement(0' handler' s)); break;                          case UsageType.BoneAssignment: this.Add(new BoneAssignmentElement(0' handler' s)); break;                          case UsageType.Weights:                              switch (this.version)                              {                                  case 0x00000005: this.Add(new WeightsElement(0' handler' s)); break;                                  case 0x0000000C: this.Add(new WeightBytesElement(0' handler' s)); break;                              }                              break;                          case UsageType.TangentNormal: this.Add(new TangentNormalElement(0' handler' s)); break;                          case UsageType.Color: this.Add(new ColorElement(0' handler' s)); break;                          case UsageType.VertexID: this.Add(new VertexIDElement(0' handler' s)); break;                      }
Missing Default,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,ElementList,The following switch statement is missing a default case: switch (this.version)                              {                                  case 0x00000005: this.Add(new WeightsElement(0' handler' s)); break;                                  case 0x0000000C: this.Add(new WeightBytesElement(0' handler' s)); break;                              }
Missing Default,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,ElementList,The following switch statement is missing a default case: switch (fmt.Usage)                      {                          case UsageType.Position: this.Add(vtx is PositionElement ? vtx : new PositionElement(0' handler)); break;                            //case UsageType.Position: this.Add(ilt.FirstOrDefault(t => t is PositionElement) ?? new PositionElement(0' handler)); break;                          case UsageType.Normal: this.Add(vtx is NormalElement ? vtx : new NormalElement(0' handler)); break;                          case UsageType.UV: this.Add(vtx is UVElement ? vtx : new UVElement(0' handler)); break;                          case UsageType.BoneAssignment: this.Add(vtx is BoneAssignmentElement ? vtx : new BoneAssignmentElement(0' handler)); break;                            //case UsageType.Normal: this.Add(ilt.FirstOrDefault(t => t is NormalElement) ?? new NormalElement(0' handler)); break;                          //case UsageType.UV: this.Add(ilt.FirstOrDefault(t => t is UVElement) ?? new UVElement(0' handler)); break;                          //case UsageType.BoneAssignment: this.Add(ilt.FirstOrDefault(t => t is BoneAssignmentElement) ?? new BoneAssignmentElement(0' handler)); break;                          //case UsageType.Weights: this.Add(vtx is WeightsElement ? vtx : new WeightsElement(0' handler)); break;                            case UsageType.Weights:                              switch (this.version)                              {                                  case 0x00000005: this.Add(vtx is WeightsElement ? vtx : new WeightsElement(0' handler)); break;                                  case 0x0000000C: this.Add(vtx is WeightBytesElement ? vtx : new WeightBytesElement(0' handler)); break;                                  //case 0x0000000C: this.Add(ilt.FirstOrDefault(t => t is WeightBytesElement) ?? new WeightBytesElement(0' handler)); break;                              }                              break;                            //case UsageType.TangentNormal: this.Add(ilt.FirstOrDefault(t => t is TangentNormalElement) ?? new TangentNormalElement(0' handler)); break;                          //case UsageType.Color: this.Add(ilt.FirstOrDefault(t => t is ColorElement) ?? new ColorElement(0' handler)); break;                          //case UsageType.VertexID: this.Add(ilt.FirstOrDefault(t => t is VertexIDElement) ?? new VertexIDElement(0' handler)); break;                          case UsageType.TangentNormal: this.Add(vtx is TangentNormalElement ? vtx : new TangentNormalElement(0' handler)); break;                          case UsageType.Color: this.Add(vtx is ColorElement ? vtx : new ColorElement(0' handler)); break;                          case UsageType.VertexID: this.Add(vtx is VertexIDElement ? vtx : new VertexIDElement(0' handler)); break;                        }
Missing Default,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,ElementList,The following switch statement is missing a default case: switch (this.version)                              {                                  case 0x00000005: this.Add(vtx is WeightsElement ? vtx : new WeightsElement(0' handler)); break;                                  case 0x0000000C: this.Add(vtx is WeightBytesElement ? vtx : new WeightBytesElement(0' handler)); break;                                  //case 0x0000000C: this.Add(ilt.FirstOrDefault(t => t is WeightBytesElement) ?? new WeightBytesElement(0' handler)); break;                              }
Missing Default,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,UnParse,The following switch statement is missing a default case: switch (fmt.Usage)                      {                          case UsageType.Position: (vtx is PositionElement ? vtx : new PositionElement(0' null)).UnParse(s); break;                          case UsageType.Normal: (vtx is NormalElement ? vtx : new NormalElement(0' null)).UnParse(s); break;                          case UsageType.UV: (vtx is UVElement ? vtx : new UVElement(0' null)).UnParse(s); break;                          case UsageType.BoneAssignment: (vtx is BoneAssignmentElement ? vtx : new BoneAssignmentElement(0' null)).UnParse(s); break;                          case UsageType.Weights:                              switch (this.version)                              {                                  case 0x00000005: (vtx is WeightsElement ? vtx : new WeightsElement(0' null)).UnParse(s); break;                                  case 0x0000000C: (vtx is WeightBytesElement ? vtx : new WeightBytesElement(0' null)).UnParse(s); break;                              }                              break;                          case UsageType.TangentNormal: (vtx is TangentNormalElement ? vtx : new TangentNormalElement(0' null)).UnParse(s); break;                          case UsageType.Color: (vtx is ColorElement ? vtx : new ColorElement(0' null)).UnParse(s); break;                          case UsageType.VertexID: (vtx is VertexIDElement ? vtx : new VertexIDElement(0' null)).UnParse(s); break;                      }
Missing Default,meshExpImp.ModelBlocks,ElementList,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\GEOM.cs,UnParse,The following switch statement is missing a default case: switch (this.version)                              {                                  case 0x00000005: (vtx is WeightsElement ? vtx : new WeightsElement(0' null)).UnParse(s); break;                                  case 0x0000000C: (vtx is WeightBytesElement ? vtx : new WeightBytesElement(0' null)).UnParse(s); break;                              }
Missing Default,meshExpImp.ModelBlocks,SegmentInfo,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBSI.cs,FromMesh,The following switch statement is missing a default case: switch(layout.Format)                      {                          case VRTF.ElementFormat.Float1:                          case VRTF.ElementFormat.UByte4:                          case VRTF.ElementFormat.UByte4N:                          case VRTF.ElementFormat.ColorUByte4:                          case VRTF.ElementFormat.Dec3N:                          case VRTF.ElementFormat.UDec3N:                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              break;                          case VRTF.ElementFormat.Float2:                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              break;                          case VRTF.ElementFormat.Float3:                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              break;                          case VRTF.ElementFormat.Float4:                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle32));                              break;                          case VRTF.ElementFormat.Short2:                          case VRTF.ElementFormat.Short2N:                          case VRTF.ElementFormat.UShort2N:                          case VRTF.ElementFormat.Float16_2:                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle16x2));                              break;                          case VRTF.ElementFormat.Short4:                          case VRTF.ElementFormat.Short4N:                          case VRTF.ElementFormat.UShort4N:                          case VRTF.ElementFormat.Float16_4:                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle16x2));                              segment.Swizzles.Add(new SwizzleEntry(0' null' SwizzleCmd.Swizzle16x2));                              break;                      }
Missing Default,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following switch statement is missing a default case: switch (layout.Format)              {                  case VRTF.ElementFormat.Float1:                  case VRTF.ElementFormat.Float2:                  case VRTF.ElementFormat.Float3:                  case VRTF.ElementFormat.Float4:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes(input[i])' 0' output' layout.Offset + i * sizeof(float)' sizeof(float));                      break;                  case VRTF.ElementFormat.ColorUByte4:                      switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }                      break;                  case VRTF.ElementFormat.Short2:                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * short.MaxValue))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.Short4:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1 ? short.MaxValue : short.MaxValue / max);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;                  case VRTF.ElementFormat.UShort4N:                      max = Math.Ceiling(input.Max(x => Math.Abs(x)));                      scalar = (ulong)(max < 1.0 ? short.MaxValue : 512);                      //scalar++;                      for (int i = 0; i < input.Length; i++)                          Array.Copy(BitConverter.GetBytes((short)Math.Round(input[i] * scalar))' 0' output' layout.Offset + i * sizeof(short)' sizeof(short));                      Array.Copy(BitConverter.GetBytes((short)(scalar == 512 ? 0 : scalar /*- 1/**/))' 0' output' layout.Offset + 3 * sizeof(short)' sizeof(short));                      break;              }
Missing Default,meshExpImp.ModelBlocks,VBUF,D:\research\architectureSmells\repos\Kuree_Sims4Tools\s4pi Wrappers\MeshChunks\VBUF.cs,WriteFloatData,The following switch statement is missing a default case: switch (layout.Usage)                      {                          case VRTF.ElementUsage.Colour:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + i] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.BlendWeight:                              for (int i = 0; i < input.Length; i++)                                  output[layout.Offset + kColorUByte4Map[i]] = (byte)Math.Round(input[i] * byte.MaxValue);                              break;                          case VRTF.ElementUsage.Normal:                          case VRTF.ElementUsage.Tangent:                              // -0.98828125 == (((0.5 + 1) / 128f) - 1)                              for (int i = 0; i < input.Length - 1; i++)                                  output[layout.Offset + 2 - i] = (byte)(input[i] < -0.98828125 ? 0 : (Math.Round((input[i] + 1) * 128) - 1));                              //--                              // Wes: (signed char) bytes[0]=vert[2+vrtfp.offset[j]];                              //      (float)       norms[0]=(float)bytes[0];                              //                    norms[0]=(norms[0]<(float)0.0)?(norms[0]+(float)128.0):(norms[0]-(float)128.0);                              //??                              //--                              // input: +1 > 0 > -1                              // map step1: +2 > +1 > 0                              // map step2: 255 > 127.5 > 0                              //for (int i = 0; i < input.Length - 1; i++)                              //    output[layout.Offset + 2 - i] = (byte)Math.Round((input[i] + 1) * 127.5);                                if (input[input.Length - 1] == -1) output[layout.Offset + 3] = 0;                              else if (input[input.Length - 1] == 0) output[layout.Offset + 3] = 127;                              else if (input[input.Length - 1] == 1) output[layout.Offset + 3] = 255;                              else                                  System.Diagnostics.Debug.WriteLine(String.Format("Unexpected handedness {0}."' input[input.Length - 1]));                              break;                      }
