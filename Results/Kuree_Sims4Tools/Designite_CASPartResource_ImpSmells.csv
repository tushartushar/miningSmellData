Implementation smell,Namespace,Class,File,Method,Description
Long Method,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The method has 169 lines of code.
Complex Method,CASPartResource,CASPartResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\CASPartResource.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,CASPartResource,CASPartResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\CASPartResource.cs,UnParse,Cyclomatic complexity of the method is 16
Complex Method,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,Cyclomatic complexity of the method is 11
Long Parameter List,CASPartResource,MatrixRow,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\BoneResource.cs,MatrixRow,The method has 5 parameters. Parameters: APIversion' handler' x' y' z
Long Parameter List,CASPartResource,Matrix4x3,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\BoneResource.cs,Matrix4x3,The method has 6 parameters. Parameters: APIversion' handler' row1' row2' row3' row4
Long Statement,CASPartResource,BoneResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\BoneResource.cs,Parse,The length of the statement  "                throw new InvalidDataException(String.Format("Unequal counts for bone names and matrices.  Bone name count {0}' matrix count {1}.  Position {2:X8}."' " is 149.
Long Statement,CASPartResource,BoneResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\BoneResource.cs,Parse,The length of the statement  "            bones = new BoneList(OnResourceChanged' names.Zip(matrices' (name' matrix) => new Bone(requestedApiVersion' null' name' matrix))); " is 130.
Long Statement,CASPartResource,ReferenceBlock,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\GEOMListResource.cs,Equals,The length of the statement  "                return this.region == other.region && this.layer == other.layer && this.isReplacement == other.isReplacement && this.tgiList.Equals(other.tgiList); " is 147.
Long Statement,CASPartResource,UnknownBlock,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SimOutfitResource.cs,Equals,The length of the statement  "                return this.blockIndex == other.blockIndex && this.unknown1 == other.unknown1 && this.unknownReferenceList.Equals(other.unknownReferenceList); " is 142.
Virtual Method Call from Constructor,CASPartResource,BoneResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\BoneResource.cs,BoneResource,The constructor "BoneResource" calls a virtual method "OnResourceChanged".
Virtual Method Call from Constructor,CASPartResource,CASPartResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\CASPartResource.cs,CASPartResource,The constructor "CASPartResource" calls a virtual method "OnResourceChanged".
Virtual Method Call from Constructor,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,DeformerMapResource,The constructor "DeformerMapResource" calls a virtual method "OnResourceChanged".
Virtual Method Call from Constructor,CASPartResource,GEOMListResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\GEOMListResource.cs,GEOMListResource,The constructor "GEOMListResource" calls a virtual method "OnResourceChanged".
Virtual Method Call from Constructor,CASPartResource,SimOutfitResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SimOutfitResource.cs,SimOutfitResource,The constructor "SimOutfitResource" calls a virtual method "OnResourceChanged".
Virtual Method Call from Constructor,CASPartResource,SkinToneResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SkinToneResource.cs,SkinToneResource,The constructor "SkinToneResource" calls a virtual method "OnResourceChanged".
Virtual Method Call from Constructor,CASPartResource,StyleLookResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\StyleLookResource.cs,StyleLookResource,The constructor "StyleLookResource" calls a virtual method "OnResourceChanged".
Magic Number,CASPartResource,CASPartResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\CASPartResource.cs,Parse,The following statement contains a magic number: tgiOffset = r.ReadUInt32() + 8;
Magic Number,CASPartResource,CASPartResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\CASPartResource.cs,UnParse,The following statement contains a magic number: w.BaseStream.Position = 4;
Magic Number,CASPartResource,CASPartResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\CASPartResource.cs,UnParse,The following statement contains a magic number: w.Write(tgiPosition - 8);
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: byte[] pixelArraySkinTight = new byte[width * height * 3];
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: byte[] pixelArrayRobe = new byte[width * height * 3];
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  if (scanLines[i].RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                  {                      pixelsize = 6;                  }                  else                  {                      pixelsize = 3;                  }                    var scan = scanLines[i];                  if (!scan.IsCompressed)                  {                      for (int j = 0; j < width; j++)                      {                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 0];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 1];                          pixelArraySkinTight[destSkinTight++] = scan.UncompressedPixels[(j * pixelsize) + 2];                            switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }                      }                  }                  else                  {                        // Look up each pixel using index tables                      for (int j = 0; j < width; j++)                      {                          // To get pointer to the RLE encoded data we need first find                           // proper RLE run in the buffer. Use index for this:                            // Cache increment for indexing in pixel space?                          int step = 1 + width / (scan.NumIndexes - 1); // 1 entry was added for the remainder of the division                            // Find index into the positions and data table:                          int idx = j / step;                            // This is location of the run first covering this interval.                          int pixelPosX = scan.PixelPosIndexes[idx];                            // Position of the RLE data of the place where need to unwind to the pixel.                           int dataPos = scan.DataPosIndexes[idx] * (pixelsize + 1); // +1 for run length byte                            // This is run length for the RLE entry found at                           int runLength = scan.RLEArrayOfPixels[dataPos];                            // Loop forward unwinding RLE data from the found indexed position.                           // Continue until the pixel position in question is not covered                           // by the current run interval. By design the loop should execute                           // only few times until we find the value we are looking for.                          while (j >= pixelPosX + runLength)                          {                              pixelPosX += runLength;                              dataPos += (1 + pixelsize); // 1 for run length' +pixelSize for the run value                                runLength = scan.RLEArrayOfPixels[dataPos];                          }                            // After breaking out of the cycle' we have the current run length interval                          // covering the pixel position x we are interested in. So just return the pointer                          // to the pixel data we were after:                          int pixelStart = dataPos + 1;                            //                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 0];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 1];                          pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[pixelStart + 2];                          switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }                      }                        //// Unpack the RLE Scan line without using index tables                      //numpixelsdecoded = 0;                      //rleindex = 0;                        //while (numpixelsdecoded < width)                      //{                      //    runlen = scan.RLEArrayOfPixels[rleindex++];                      //    for (int j = 0; j < runlen; j++)                      //    {                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 0];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 1];                      //        pixelArraySkinTight[destSkinTight++] = scan.RLEArrayOfPixels[rleindex + 2];                      //        switch (scan.RobeChannel)                      //        {                      //            case RobeChannel.ROBECHANNEL_PRESENT:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //            case RobeChannel.ROBECHANNEL_DROPPED:                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                pixelArrayRobe[destIndexRobe++] = 0;                      //                break;                      //            case RobeChannel.ROBECHANNEL_ISCOPY:                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[rleindex + 0];                      //                break;                      //        }                      //        numpixelsdecoded++;                      //    }                      //    rleindex += pixelsize;                      //}                  }              }
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: w.Write(54);
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: w.Write(40);
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: w.Write((ushort)24);
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < 6; i++) w.Write(0);
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: int bytesPerLine = (int)Math.Ceiling(width * 24.0 / 8.0);
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: int bytesPerLine = (int)Math.Ceiling(width * 24.0 / 8.0);
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: int padding = 4 - bytesPerLine % 4;
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: int padding = 4 - bytesPerLine % 4;
Magic Number,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following statement contains a magic number: for (int i = 0; i < height; i++)              {                  for (int j = 0; j < width * 3; j++)                  {                      w.Write(type == OutputType.Robe? pixelArrayRobe[sourcePosition++] : pixelArraySkinTight[sourcePosition++]);                  }                    for (int j = 0; j < padding; j++)                  {                      w.Write((byte)0);                  }              }
Magic Number,CASPartResource,ScanLine,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ScanLine,The following statement contains a magic number: if (!IsCompressed)                  {                      if (RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                      {                          this.UncompressedPixels = r.ReadBytes(width * 6);                      }                      else                      {                          this.UncompressedPixels = r.ReadBytes(width * 3);                      }                  }                  else                  {                      NumIndexes = r.ReadByte();                      this.PixelPosIndexes = new UInt16[NumIndexes];                      this.DataPosIndexes = new UInt16[NumIndexes];                      for (int i = 0; i < NumIndexes; i++) this.PixelPosIndexes[i] = r.ReadUInt16();                      for (int i = 0; i < NumIndexes; i++) this.DataPosIndexes[i] = r.ReadUInt16();                      uint headerdatasize = 4U + 1U + (4U * NumIndexes);                      this.RLEArrayOfPixels = new byte[scanLineDataSize - headerdatasize];                      for (int i = 0; i < RLEArrayOfPixels.Length; i++) this.RLEArrayOfPixels[i] = r.ReadByte();                  }
Magic Number,CASPartResource,ScanLine,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ScanLine,The following statement contains a magic number: if (!IsCompressed)                  {                      if (RobeChannel == RobeChannel.ROBECHANNEL_PRESENT)                      {                          this.UncompressedPixels = r.ReadBytes(width * 6);                      }                      else                      {                          this.UncompressedPixels = r.ReadBytes(width * 3);                      }                  }                  else                  {                      NumIndexes = r.ReadByte();                      this.PixelPosIndexes = new UInt16[NumIndexes];                      this.DataPosIndexes = new UInt16[NumIndexes];                      for (int i = 0; i < NumIndexes; i++) this.PixelPosIndexes[i] = r.ReadUInt16();                      for (int i = 0; i < NumIndexes; i++) this.DataPosIndexes[i] = r.ReadUInt16();                      uint headerdatasize = 4U + 1U + (4U * NumIndexes);                      this.RLEArrayOfPixels = new byte[scanLineDataSize - headerdatasize];                      for (int i = 0; i < RLEArrayOfPixels.Length; i++) this.RLEArrayOfPixels[i] = r.ReadByte();                  }
Magic Number,CASPartResource,GEOMListResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\GEOMListResource.cs,UnParse,The following statement contains a magic number: this.objectPosition = (uint)(ms.Position + 8);
Magic Number,CASPartResource,GEOMListResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\GEOMListResource.cs,UnParse,The following statement contains a magic number: this.objectLength = referenceBlockList.Size + 4;
Magic Number,CASPartResource,SimOutfitResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SimOutfitResource.cs,Parse,The following statement contains a magic number: uint tgiOffset = r.ReadUInt32() + 8;
Magic Number,CASPartResource,SimOutfitResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SimOutfitResource.cs,Parse,The following statement contains a magic number: this.unknown10 = new DataBlobHandler(RecommendedApiVersion' OnResourceChanged' r.ReadBytes(24));
Magic Number,CASPartResource,SimOutfitResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SimOutfitResource.cs,Parse,The following statement contains a magic number: this.unknown12 = new DataBlobHandler(RecommendedApiVersion' OnResourceChanged' r.ReadBytes(16));
Magic Number,CASPartResource,SimOutfitResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SimOutfitResource.cs,Parse,The following statement contains a magic number: this.unknown13 = new DataBlobHandler(recommendedApiVersion' OnResourceChanged' r.ReadBytes(9));
Magic Number,CASPartResource,SimOutfitResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SimOutfitResource.cs,UnParse,The following statement contains a magic number: w.Write((uint)tmpPostion - 8);
Magic Number,CASPartResource,UnknownReference,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\SimOutfitResource.cs,Parse,The following statement contains a magic number: this.unknownBlock = new DataBlobHandler(recommendedApiVersion' handler' r.ReadBytes(17));
Magic Number,CASPartResource,StyleLookResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\StyleLookResource.cs,Parse,The following statement contains a magic number: this.unknown2 = new DataBlobHandler(recommendedApiVersion' OnResourceChanged' r.ReadBytes(14));
Missing Default,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following switch statement is missing a default case: switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.UncompressedPixels[(j * pixelsize) + 2];                                  break;                          }
Missing Default,CASPartResource,DeformerMapResource,C:\repos\Kuree_Sims4Tools\s4pi Wrappers\CASPartResource\DeformerMapResource.cs,ToBitMap,The following switch statement is missing a default case: switch (scan.RobeChannel)                          {                              case RobeChannel.ROBECHANNEL_PRESENT:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 3];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 4];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 5];                                  break;                              case RobeChannel.ROBECHANNEL_DROPPED:                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  pixelArrayRobe[destIndexRobe++] = 0;                                  break;                              case RobeChannel.ROBECHANNEL_ISCOPY:                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 0];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 1];                                  pixelArrayRobe[destIndexRobe++] = scan.RLEArrayOfPixels[pixelStart + 2];                                  break;                          }
