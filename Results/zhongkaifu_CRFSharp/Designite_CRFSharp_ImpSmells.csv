Implementation smell,Namespace,Class,File,Method,Description
Long Method,CRFSharp,LBFGS,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\LBFGS.cs,lbfgs_optimize,The method has 124 lines of code.
Long Method,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The method has 211 lines of code.
Long Method,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The method has 137 lines of code.
Complex Method,CRFSharp,BaseModel,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\BaseModel.cs,get_index,Cyclomatic complexity of the method is 9
Complex Method,CRFSharp,Tagger,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\Tagger.cs,viterbi,Cyclomatic complexity of the method is 8
Complex Method,CRFSharp,DecoderTagger,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\decoder\DecoderTagger.cs,parse,Cyclomatic complexity of the method is 8
Complex Method,CRFSharp,CRFEncoderThread,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\CRFEncoderThread.cs,Init,Cyclomatic complexity of the method is 9
Complex Method,CRFSharp,EncoderTagger,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\EncoderTagger.cs,gradient,Cyclomatic complexity of the method is 8
Complex Method,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,GetOrAddId,Cyclomatic complexity of the method is 11
Complex Method,CRFSharp,LBFGS,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\LBFGS.cs,lbfgs_optimize,Cyclomatic complexity of the method is 12
Complex Method,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,Cyclomatic complexity of the method is 8
Complex Method,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,Cyclomatic complexity of the method is 15
Long Parameter List,CRFSharp,LBFGS,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\LBFGS.cs,ddot_,The method has 5 parameters. Parameters: size' dx' dx_idx' dy' dy_idx
Long Parameter List,CRFSharp,LBFGS,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\LBFGS.cs,ddot_,The method has 5 parameters. Parameters: size' dx' dx_idx' dy' dy_idx
Long Parameter List,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The method has 13 parameters. Parameters: stx' fx' dx' sty' fy' dy' stp' fp' dp' brackt' stpmin' stpmax' info
Long Parameter List,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,ddot_,The method has 5 parameters. Parameters: size' dx' dx_idx' dy' dy_idx
Long Parameter List,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The method has 9 parameters. Parameters: x' f' g' s' s_idx' stp' info' nfev' wa
Long Identifier,CRFSharp,ModelWriter,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\ModelWriter.cs,BuildFeatureSetIntoIndex,The length of the parameter filename_featureset_raw_format is 30.
Long Statement,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,GetOrAddId,The length of the statement  "                        Console.WriteLine("[Feature Size:{0}' TimeSpan:{1}' Next Shrink Rate:{2}%]"' arrayFeatureFreqSize' ts' SHRINK_AVALI_MEM_LOAD); " is 126.
Long Statement,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The length of the statement  "                    Console.WriteLine("MCSRCH warning: Rounding errors prevent further progress.There may not be a step which satisfies the sufficient decrease and curvature conditions. Tolerances may be too small."); " is 197.
Long Statement,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The length of the statement  "                    Console.WriteLine("stp:{0}' lb3_1_stpmin:{1}' f:{2}' ftest1:{3}' dg:{4}' dgtest:{5}"' stp' lb3_1_stpmin' f' ftest1' dg' dgtest); " is 128.
Long Statement,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The length of the statement  "                    Console.WriteLine("MCSRCH warning: More than {0} function evaluations were required at the present iteration."' maxfev); " is 120.
Complex Conditional,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The conditional expression  "brackt == true && ((stp <= Math.Min(stx' sty) || stp >= Math.Max(stx' sty)) ||                              dx * (stp - stx) >= 0.0 || stpmax < stpmin)"  is complex.
Complex Conditional,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The conditional expression  "brackt && ((stp <= stmin || stp >= stmax) || infoc == 0)"  is complex.
Complex Conditional,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The conditional expression  "(brackt && ((stp <= stmin || stp >= stmax) ||                              nfev >= maxfev - 1 || infoc == 0)) ||                  (brackt && (stmax - stmin <= xtol * stmax))"  is complex.
Magic Number,CRFSharp,BaseModel,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\BaseModel.cs,get_index,The following statement contains a magic number: for (; i < p.Length; i++)              {                  var c = p[i];                  if (isInRow)                  {                      if (c >= '0' && c <= '9')                      {                          row = 10 * row + (c - '0');                      }                      else if (c == ''')                      {                          isInRow = false;                      }                      else                      {                          return new Index(null' i);                      }                  }                  else                  {                      if (c >= '0' && c <= '9')                      {                          col = 10 * col + (c - '0');                      }                      else if (c == ']')                      {                          break;                      }                      else                      {                          return new Index(null' i);                      }                  }              }
Magic Number,CRFSharp,BaseModel,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\BaseModel.cs,get_index,The following statement contains a magic number: for (; i < p.Length; i++)              {                  var c = p[i];                  if (isInRow)                  {                      if (c >= '0' && c <= '9')                      {                          row = 10 * row + (c - '0');                      }                      else if (c == ''')                      {                          isInRow = false;                      }                      else                      {                          return new Index(null' i);                      }                  }                  else                  {                      if (c >= '0' && c <= '9')                      {                          col = 10 * col + (c - '0');                      }                      else if (c == ']')                      {                          break;                      }                      else                      {                          return new Index(null' i);                      }                  }              }
Magic Number,CRFSharp,Utils,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\Utils.cs,heap_insert,The following statement contains a magic number: while (i != 1 && H.elem_ptr_list[i / 2].fx > qe.fx)              {                  H.elem_ptr_list[i] = H.elem_ptr_list[i / 2];  //此时i还没有进行i/2操作		                  i /= 2;              }
Magic Number,CRFSharp,Utils,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\Utils.cs,heap_insert,The following statement contains a magic number: while (i != 1 && H.elem_ptr_list[i / 2].fx > qe.fx)              {                  H.elem_ptr_list[i] = H.elem_ptr_list[i / 2];  //此时i还没有进行i/2操作		                  i /= 2;              }
Magic Number,CRFSharp,Utils,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\Utils.cs,heap_insert,The following statement contains a magic number: while (i != 1 && H.elem_ptr_list[i / 2].fx > qe.fx)              {                  H.elem_ptr_list[i] = H.elem_ptr_list[i / 2];  //此时i还没有进行i/2操作		                  i /= 2;              }
Magic Number,CRFSharp,Utils,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\Utils.cs,heap_delete_min,The following statement contains a magic number: int i = 1' ci = 2;
Magic Number,CRFSharp,Utils,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\base\Utils.cs,heap_delete_min,The following statement contains a magic number: while (ci <= H.size)              {                  if (ci < H.size && H.elem_ptr_list[ci].fx > H.elem_ptr_list[ci + 1].fx)                  {                      ci++;                  }                  if (last_elem.fx <= H.elem_ptr_list[ci].fx)                  {                      break;                  }                  H.elem_ptr_list[i] = H.elem_ptr_list[ci];                  i = ci;                  ci *= 2;              }
Magic Number,CRFSharp,DecoderTagger,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\decoder\DecoderTagger.cs,InitializeFeatureCache,The following statement contains a magic number: for (var i = 0; i < crf_max_word_num * 2; i++)              {                  var features = new long[feature_cache_every_row_size];                  for (var j = 0; j < feature_cache_every_row_size; j++)                  {                      features[j] = -1;                  }                  feature_cache_.Add(features);              }
Magic Number,CRFSharp,DecoderTagger,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\decoder\DecoderTagger.cs,termbuf_build,The following statement contains a magic number: for (var i = 0; i < this_word_num; ++i)              {                  term_buf.result_[i] = yname(result_[i]);                  switch (vlevel_)                  {                      case 0:                          term_buf.weight_[i] = 0.0;                          break;                      case 2:                          term_buf.weight_[i] = prob(i);                          break;                  }              }
Magic Number,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,HugeFeatureLexicalDict,The following statement contains a magic number: arrayFeatureFreq = new VarBigArray<FeatureFreq>(1024 * 1024);
Magic Number,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,HugeFeatureLexicalDict,The following statement contains a magic number: arrayFeatureFreq = new VarBigArray<FeatureFreq>(1024 * 1024);
Magic Number,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,GetOrAddId,The following statement contains a magic number: while (ShrinkingLock == 1) { Thread.Sleep(5000); }
Magic Number,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,GetOrAddId,The following statement contains a magic number: if (oldValue % 10000000 == 0)              {                  var msex = new MEMORYSTATUSEX();                  GlobalMemoryStatusEx(msex);                  memoryLoad = msex.dwMemoryLoad;              }
Magic Number,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,GetOrAddId,The following statement contains a magic number: if (memoryLoad >= SHRINK_AVALI_MEM_LOAD)              {                  if (Interlocked.CompareExchange(ref ShrinkingLock' 1' 0) == 0)                  {                      //Double check whether shrink should be started                      var msex = new MEMORYSTATUSEX();                      GlobalMemoryStatusEx(msex);                      if (msex.dwMemoryLoad >= SHRINK_AVALI_MEM_LOAD)                      {                          while (AddLock != 0) { Thread.Sleep(1000); }                            var startDT = DateTime.Now;                          Console.WriteLine("Begin to shrink [Feature Size: {0}]..."' arrayFeatureFreqSize);                          var newArrayFeatureFreqSize = Shrink(0' arrayFeatureFreqSize - 1' 0) + 1;                            GlobalMemoryStatusEx(msex);                          if (msex.dwMemoryLoad >= SHRINK_AVALI_MEM_LOAD - 1)                          {                              //Still have enough available memory' raise shrink threshold                              SHRINK_AVALI_MEM_LOAD = msex.dwMemoryLoad + 1;                              if (SHRINK_AVALI_MEM_LOAD >= 100)                              {                                  //if use more than 100% memory' the performance will extremely reduce                                  SHRINK_AVALI_MEM_LOAD = 100;                              }                          }                            arrayFeatureFreqSize = newArrayFeatureFreqSize;                          var ts = DateTime.Now - startDT;                          Console.WriteLine("Shrink has been done!");                          Console.WriteLine("[Feature Size:{0}' TimeSpan:{1}' Next Shrink Rate:{2}%]"' arrayFeatureFreqSize' ts' SHRINK_AVALI_MEM_LOAD);                      }                        Interlocked.Decrement(ref ShrinkingLock);                  }              }
Magic Number,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,GetOrAddId,The following statement contains a magic number: if (memoryLoad >= SHRINK_AVALI_MEM_LOAD)              {                  if (Interlocked.CompareExchange(ref ShrinkingLock' 1' 0) == 0)                  {                      //Double check whether shrink should be started                      var msex = new MEMORYSTATUSEX();                      GlobalMemoryStatusEx(msex);                      if (msex.dwMemoryLoad >= SHRINK_AVALI_MEM_LOAD)                      {                          while (AddLock != 0) { Thread.Sleep(1000); }                            var startDT = DateTime.Now;                          Console.WriteLine("Begin to shrink [Feature Size: {0}]..."' arrayFeatureFreqSize);                          var newArrayFeatureFreqSize = Shrink(0' arrayFeatureFreqSize - 1' 0) + 1;                            GlobalMemoryStatusEx(msex);                          if (msex.dwMemoryLoad >= SHRINK_AVALI_MEM_LOAD - 1)                          {                              //Still have enough available memory' raise shrink threshold                              SHRINK_AVALI_MEM_LOAD = msex.dwMemoryLoad + 1;                              if (SHRINK_AVALI_MEM_LOAD >= 100)                              {                                  //if use more than 100% memory' the performance will extremely reduce                                  SHRINK_AVALI_MEM_LOAD = 100;                              }                          }                            arrayFeatureFreqSize = newArrayFeatureFreqSize;                          var ts = DateTime.Now - startDT;                          Console.WriteLine("Shrink has been done!");                          Console.WriteLine("[Feature Size:{0}' TimeSpan:{1}' Next Shrink Rate:{2}%]"' arrayFeatureFreqSize' ts' SHRINK_AVALI_MEM_LOAD);                      }                        Interlocked.Decrement(ref ShrinkingLock);                  }              }
Magic Number,CRFSharp,HugeFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\HugeFeatureLexicalDict.cs,GetOrAddId,The following statement contains a magic number: if (memoryLoad >= SHRINK_AVALI_MEM_LOAD)              {                  if (Interlocked.CompareExchange(ref ShrinkingLock' 1' 0) == 0)                  {                      //Double check whether shrink should be started                      var msex = new MEMORYSTATUSEX();                      GlobalMemoryStatusEx(msex);                      if (msex.dwMemoryLoad >= SHRINK_AVALI_MEM_LOAD)                      {                          while (AddLock != 0) { Thread.Sleep(1000); }                            var startDT = DateTime.Now;                          Console.WriteLine("Begin to shrink [Feature Size: {0}]..."' arrayFeatureFreqSize);                          var newArrayFeatureFreqSize = Shrink(0' arrayFeatureFreqSize - 1' 0) + 1;                            GlobalMemoryStatusEx(msex);                          if (msex.dwMemoryLoad >= SHRINK_AVALI_MEM_LOAD - 1)                          {                              //Still have enough available memory' raise shrink threshold                              SHRINK_AVALI_MEM_LOAD = msex.dwMemoryLoad + 1;                              if (SHRINK_AVALI_MEM_LOAD >= 100)                              {                                  //if use more than 100% memory' the performance will extremely reduce                                  SHRINK_AVALI_MEM_LOAD = 100;                              }                          }                            arrayFeatureFreqSize = newArrayFeatureFreqSize;                          var ts = DateTime.Now - startDT;                          Console.WriteLine("Shrink has been done!");                          Console.WriteLine("[Feature Size:{0}' TimeSpan:{1}' Next Shrink Rate:{2}%]"' arrayFeatureFreqSize' ts' SHRINK_AVALI_MEM_LOAD);                      }                        Interlocked.Decrement(ref ShrinkingLock);                  }              }
Magic Number,CRFSharp,LBFGS,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\LBFGS.cs,optimize,The following statement contains a magic number: const long msize = 5;
Magic Number,CRFSharp,LBFGS,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\LBFGS.cs,optimize,The following statement contains a magic number: if (w == null || w.LongLength == 0)              {                  iflag_ = 0;                  w = new FixedBigArray<double>(size * (2 * msize + 1) + 2 * msize' 1);                  diag = new double[size + 1];                  if (orthant == true)                  {                      xi = new double[size + 1];                      v = new double[size + 1];                  }              }
Magic Number,CRFSharp,LBFGS,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\LBFGS.cs,optimize,The following statement contains a magic number: if (w == null || w.LongLength == 0)              {                  iflag_ = 0;                  w = new FixedBigArray<double>(size * (2 * msize + 1) + 2 * msize' 1);                  diag = new double[size + 1];                  if (orthant == true)                  {                      xi = new double[size + 1];                      v = new double[size + 1];                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (fp > fx)              {                  info = 1;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp < stx)                  {                      gamma = -gamma;                  }                  p = gamma - dx + theta;                  q = gamma - dx + gamma + dp;                  r = p / q;                  stpc = stx + r * (stp - stx);                  stpq = stx + dx / ((fx - fp) /                                       (stp - stx) + dx) / 2 * (stp - stx);                  d1 = stpc - stx;                  d2 = stpq - stx;                  if (Math.Abs(d1) < Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpc + (stpq - stpc) / 2;                  }                  brackt = true;              }              else if (sgnd < 0.0)              {                  info = 2;                  bound = false;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d1 = theta / s;                  gamma = s * Math.Sqrt(d1 * d1 - dx / s * (dp / s));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma - dp + gamma + dx;                  r = p / q;                  stpc = stp + r * (stx - stp);                  stpq = stp + dp / (dp - dx) * (stx - stp);                    d1 = stpc - stp;                  d2 = stpq - stp;                  if (Math.Abs(d1) > Math.Abs(d2))                  {                      stpf = stpc;                  }                  else                  {                      stpf = stpq;                  }                  brackt = true;              }              else if (Math.Abs(dp) < Math.Abs(dx))              {                  info = 3;                  bound = true;                  theta = (fx - fp) * 3 / (stp - stx) + dx + dp;                  d1 = Math.Abs(theta);                  d2 = Math.Abs(dx);                  d1 = Math.Max(d1' d2);                  d2 = Math.Abs(dp);                  s = Math.Max(d1' d2);                  d3 = theta / s;                  d1 = 0.0f;                  d2 = d3 * d3 - dx / s * (dp / s);                  gamma = s * Math.Sqrt((Math.Max(d1' d2)));                  if (stp > stx)                  {                      gamma = -gamma;                  }                  p = gamma - dp + theta;                  q = gamma + (dx - dp) + gamma;                  r = p / q;                  if (r < 0.0 && gamma != 0.0)                  {                      stpc = stp + r * (stx - stp);                  }                  else if (stp > stx)                  {                      stpc = stpmax;                  }                  else                  {                      stpc = stpmin;                  }                  stpq = stp + dp / (dp - dx) * (stx - stp);                  if (brackt == true)                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) < Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }                  else                  {                      d1 = stp - stpc;                      d2 = stp - stpq;                      if (Math.Abs(d1) > Math.Abs(d2))                      {                          stpf = stpc;                      }                      else                      {                          stpf = stpq;                      }                  }              }              else              {                  info = 4;                  bound = false;                  if (brackt == true)                  {                      theta = (fp - fy) * 3 / (sty - stp) + dy + dp;                      d1 = Math.Abs(theta);                      d2 = Math.Abs(dy);                      d1 = Math.Max(d1' d2);                      d2 = Math.Abs(dp);                      s = Math.Max(d1' d2);                      d1 = theta / s;                      gamma = s * Math.Sqrt(d1 * d1 - dy / s * (dp / s));                      if (stp > sty)                      {                          gamma = -gamma;                      }                      p = gamma - dp + theta;                      q = gamma - dp + gamma + dy;                      r = p / q;                      stpc = stp + r * (sty - stp);                      stpf = stpc;                  }                  else if (stp > stx)                  {                      stpf = stpmax;                  }                  else                  {                      stpf = stpmin;                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (brackt == true && bound)              {                  if (sty > stx)                  {                      d1 = stx + (sty - stx) * 0.66;                      stp = Math.Min(d1' stp);                  }                  else                  {                      d1 = stx + (sty - stx) * 0.66;                      stp = Math.Max(d1' stp);                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcstep,The following statement contains a magic number: if (brackt == true && bound)              {                  if (sty > stx)                  {                      d1 = stx + (sty - stx) * 0.66;                      stp = Math.Min(d1' stp);                  }                  else                  {                      d1 = stx + (sty - stx) * 0.66;                      stp = Math.Max(d1' stp);                  }              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The following statement contains a magic number: if (info == -1)              {                  info = 0;                  nfev++;                    var dg = ddot_(size' g' 1' s' s_idx + 1);                  var ftest1 = finit + stp * dgtest;                    if (brackt && ((stp <= stmin || stp >= stmax) || infoc == 0))                  {                      info = 6;                      Console.WriteLine("MCSRCH warning: Rounding errors prevent further progress.There may not be a step which satisfies the sufficient decrease and curvature conditions. Tolerances may be too small.");                      Console.WriteLine("bracket: {0}' stp:{1}' stmin:{2}' stmax:{3}' infoc:{4}"' brackt' stp' stmin' stmax' infoc);                  }                  if (stp == lb3_1_stpmax && f <= ftest1 && dg <= dgtest)                  {                      info = 5;                      Console.WriteLine("MCSRCH warning: The step is too large.");                  }                  if (stp == lb3_1_stpmin && (f > ftest1 || dg >= dgtest))                  {                      info = 4;                      Console.WriteLine("MCSRCH warning: The step is too small.");                      Console.WriteLine("stp:{0}' lb3_1_stpmin:{1}' f:{2}' ftest1:{3}' dg:{4}' dgtest:{5}"' stp' lb3_1_stpmin' f' ftest1' dg' dgtest);                  }                  if (nfev >= maxfev)                  {                      info = 3;                      Console.WriteLine("MCSRCH warning: More than {0} function evaluations were required at the present iteration."' maxfev);                  }                  if (brackt && stmax - stmin <= xtol * stmax)                  {                      info = 2;                      Console.WriteLine("MCSRCH warning: Relative width of the interval of uncertainty is at most xtol.");                  }                  if (f <= ftest1 && Math.Abs(dg) <= lb3_1_gtol * (-dginit))                  {                      info = 1;                  }                    if (info != 0)                  {                      return;                  }                    if (stage1 && f <= ftest1 && dg >= Math.Min(ftol' lb3_1_gtol) * dginit)                  {                      stage1 = false;                  }                    if (stage1 && f <= fx && f > ftest1)                  {                      var fm = f - stp * dgtest;                      var fxm = fx - stx * dgtest;                      var fym = fy - sty * dgtest;                      var dgm = dg - dgtest;                      var dgxm = dgx - dgtest;                      var dgym = dgy - dgtest;                      mcstep(ref stx' ref fxm' ref dgxm' ref sty' ref fym' ref dgym' ref stp' fm' dgm' ref brackt'                             stmin' stmax' ref infoc);                      fx = fxm + stx * dgtest;                      fy = fym + sty * dgtest;                      dgx = dgxm + dgtest;                      dgy = dgym + dgtest;                  }                  else                  {                      mcstep(ref stx' ref fx' ref dgx' ref sty' ref fy' ref dgy' ref stp' f' dg' ref brackt'                             stmin' stmax' ref infoc);                  }                    if (brackt)                  {                      var d1 = 0.0;                      d1 = sty - stx;                      if (Math.Abs(d1) >= p66 * width1)                      {                          stp = stx + p5 * (sty - stx);                      }                      width1 = width;                      d1 = sty - stx;                      width = Math.Abs(d1);                  }              }              else              {                  infoc = 1;                  if (size <= 0 || stp <= 0.0)                  {                      return;                  }                    dginit = ddot_(size' g' 1' s' s_idx + 1);                  if (dginit >= 0.0)                  {                      return;                  }                    brackt = false;                  stage1 = true;                  nfev = 0;                  finit = f;                  dgtest = ftol * dginit;                  width = lb3_1_stpmax - lb3_1_stpmin;                  width1 = width / p5;                    Parallel.For(1' size + 1' parallelOption' i =>                  {                      wa[i] = x[i];                  }                  );                    stx = 0.0;                  fx = finit;                  dgx = dginit;                  sty = 0.0;                  fy = finit;                  dgy = dginit;              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The following statement contains a magic number: if (info == -1)              {                  info = 0;                  nfev++;                    var dg = ddot_(size' g' 1' s' s_idx + 1);                  var ftest1 = finit + stp * dgtest;                    if (brackt && ((stp <= stmin || stp >= stmax) || infoc == 0))                  {                      info = 6;                      Console.WriteLine("MCSRCH warning: Rounding errors prevent further progress.There may not be a step which satisfies the sufficient decrease and curvature conditions. Tolerances may be too small.");                      Console.WriteLine("bracket: {0}' stp:{1}' stmin:{2}' stmax:{3}' infoc:{4}"' brackt' stp' stmin' stmax' infoc);                  }                  if (stp == lb3_1_stpmax && f <= ftest1 && dg <= dgtest)                  {                      info = 5;                      Console.WriteLine("MCSRCH warning: The step is too large.");                  }                  if (stp == lb3_1_stpmin && (f > ftest1 || dg >= dgtest))                  {                      info = 4;                      Console.WriteLine("MCSRCH warning: The step is too small.");                      Console.WriteLine("stp:{0}' lb3_1_stpmin:{1}' f:{2}' ftest1:{3}' dg:{4}' dgtest:{5}"' stp' lb3_1_stpmin' f' ftest1' dg' dgtest);                  }                  if (nfev >= maxfev)                  {                      info = 3;                      Console.WriteLine("MCSRCH warning: More than {0} function evaluations were required at the present iteration."' maxfev);                  }                  if (brackt && stmax - stmin <= xtol * stmax)                  {                      info = 2;                      Console.WriteLine("MCSRCH warning: Relative width of the interval of uncertainty is at most xtol.");                  }                  if (f <= ftest1 && Math.Abs(dg) <= lb3_1_gtol * (-dginit))                  {                      info = 1;                  }                    if (info != 0)                  {                      return;                  }                    if (stage1 && f <= ftest1 && dg >= Math.Min(ftol' lb3_1_gtol) * dginit)                  {                      stage1 = false;                  }                    if (stage1 && f <= fx && f > ftest1)                  {                      var fm = f - stp * dgtest;                      var fxm = fx - stx * dgtest;                      var fym = fy - sty * dgtest;                      var dgm = dg - dgtest;                      var dgxm = dgx - dgtest;                      var dgym = dgy - dgtest;                      mcstep(ref stx' ref fxm' ref dgxm' ref sty' ref fym' ref dgym' ref stp' fm' dgm' ref brackt'                             stmin' stmax' ref infoc);                      fx = fxm + stx * dgtest;                      fy = fym + sty * dgtest;                      dgx = dgxm + dgtest;                      dgy = dgym + dgtest;                  }                  else                  {                      mcstep(ref stx' ref fx' ref dgx' ref sty' ref fy' ref dgy' ref stp' f' dg' ref brackt'                             stmin' stmax' ref infoc);                  }                    if (brackt)                  {                      var d1 = 0.0;                      d1 = sty - stx;                      if (Math.Abs(d1) >= p66 * width1)                      {                          stp = stx + p5 * (sty - stx);                      }                      width1 = width;                      d1 = sty - stx;                      width = Math.Abs(d1);                  }              }              else              {                  infoc = 1;                  if (size <= 0 || stp <= 0.0)                  {                      return;                  }                    dginit = ddot_(size' g' 1' s' s_idx + 1);                  if (dginit >= 0.0)                  {                      return;                  }                    brackt = false;                  stage1 = true;                  nfev = 0;                  finit = f;                  dgtest = ftol * dginit;                  width = lb3_1_stpmax - lb3_1_stpmin;                  width1 = width / p5;                    Parallel.For(1' size + 1' parallelOption' i =>                  {                      wa[i] = x[i];                  }                  );                    stx = 0.0;                  fx = finit;                  dgx = dginit;                  sty = 0.0;                  fy = finit;                  dgy = dginit;              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The following statement contains a magic number: if (info == -1)              {                  info = 0;                  nfev++;                    var dg = ddot_(size' g' 1' s' s_idx + 1);                  var ftest1 = finit + stp * dgtest;                    if (brackt && ((stp <= stmin || stp >= stmax) || infoc == 0))                  {                      info = 6;                      Console.WriteLine("MCSRCH warning: Rounding errors prevent further progress.There may not be a step which satisfies the sufficient decrease and curvature conditions. Tolerances may be too small.");                      Console.WriteLine("bracket: {0}' stp:{1}' stmin:{2}' stmax:{3}' infoc:{4}"' brackt' stp' stmin' stmax' infoc);                  }                  if (stp == lb3_1_stpmax && f <= ftest1 && dg <= dgtest)                  {                      info = 5;                      Console.WriteLine("MCSRCH warning: The step is too large.");                  }                  if (stp == lb3_1_stpmin && (f > ftest1 || dg >= dgtest))                  {                      info = 4;                      Console.WriteLine("MCSRCH warning: The step is too small.");                      Console.WriteLine("stp:{0}' lb3_1_stpmin:{1}' f:{2}' ftest1:{3}' dg:{4}' dgtest:{5}"' stp' lb3_1_stpmin' f' ftest1' dg' dgtest);                  }                  if (nfev >= maxfev)                  {                      info = 3;                      Console.WriteLine("MCSRCH warning: More than {0} function evaluations were required at the present iteration."' maxfev);                  }                  if (brackt && stmax - stmin <= xtol * stmax)                  {                      info = 2;                      Console.WriteLine("MCSRCH warning: Relative width of the interval of uncertainty is at most xtol.");                  }                  if (f <= ftest1 && Math.Abs(dg) <= lb3_1_gtol * (-dginit))                  {                      info = 1;                  }                    if (info != 0)                  {                      return;                  }                    if (stage1 && f <= ftest1 && dg >= Math.Min(ftol' lb3_1_gtol) * dginit)                  {                      stage1 = false;                  }                    if (stage1 && f <= fx && f > ftest1)                  {                      var fm = f - stp * dgtest;                      var fxm = fx - stx * dgtest;                      var fym = fy - sty * dgtest;                      var dgm = dg - dgtest;                      var dgxm = dgx - dgtest;                      var dgym = dgy - dgtest;                      mcstep(ref stx' ref fxm' ref dgxm' ref sty' ref fym' ref dgym' ref stp' fm' dgm' ref brackt'                             stmin' stmax' ref infoc);                      fx = fxm + stx * dgtest;                      fy = fym + sty * dgtest;                      dgx = dgxm + dgtest;                      dgy = dgym + dgtest;                  }                  else                  {                      mcstep(ref stx' ref fx' ref dgx' ref sty' ref fy' ref dgy' ref stp' f' dg' ref brackt'                             stmin' stmax' ref infoc);                  }                    if (brackt)                  {                      var d1 = 0.0;                      d1 = sty - stx;                      if (Math.Abs(d1) >= p66 * width1)                      {                          stp = stx + p5 * (sty - stx);                      }                      width1 = width;                      d1 = sty - stx;                      width = Math.Abs(d1);                  }              }              else              {                  infoc = 1;                  if (size <= 0 || stp <= 0.0)                  {                      return;                  }                    dginit = ddot_(size' g' 1' s' s_idx + 1);                  if (dginit >= 0.0)                  {                      return;                  }                    brackt = false;                  stage1 = true;                  nfev = 0;                  finit = f;                  dgtest = ftol * dginit;                  width = lb3_1_stpmax - lb3_1_stpmin;                  width1 = width / p5;                    Parallel.For(1' size + 1' parallelOption' i =>                  {                      wa[i] = x[i];                  }                  );                    stx = 0.0;                  fx = finit;                  dgx = dginit;                  sty = 0.0;                  fy = finit;                  dgy = dginit;              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The following statement contains a magic number: if (info == -1)              {                  info = 0;                  nfev++;                    var dg = ddot_(size' g' 1' s' s_idx + 1);                  var ftest1 = finit + stp * dgtest;                    if (brackt && ((stp <= stmin || stp >= stmax) || infoc == 0))                  {                      info = 6;                      Console.WriteLine("MCSRCH warning: Rounding errors prevent further progress.There may not be a step which satisfies the sufficient decrease and curvature conditions. Tolerances may be too small.");                      Console.WriteLine("bracket: {0}' stp:{1}' stmin:{2}' stmax:{3}' infoc:{4}"' brackt' stp' stmin' stmax' infoc);                  }                  if (stp == lb3_1_stpmax && f <= ftest1 && dg <= dgtest)                  {                      info = 5;                      Console.WriteLine("MCSRCH warning: The step is too large.");                  }                  if (stp == lb3_1_stpmin && (f > ftest1 || dg >= dgtest))                  {                      info = 4;                      Console.WriteLine("MCSRCH warning: The step is too small.");                      Console.WriteLine("stp:{0}' lb3_1_stpmin:{1}' f:{2}' ftest1:{3}' dg:{4}' dgtest:{5}"' stp' lb3_1_stpmin' f' ftest1' dg' dgtest);                  }                  if (nfev >= maxfev)                  {                      info = 3;                      Console.WriteLine("MCSRCH warning: More than {0} function evaluations were required at the present iteration."' maxfev);                  }                  if (brackt && stmax - stmin <= xtol * stmax)                  {                      info = 2;                      Console.WriteLine("MCSRCH warning: Relative width of the interval of uncertainty is at most xtol.");                  }                  if (f <= ftest1 && Math.Abs(dg) <= lb3_1_gtol * (-dginit))                  {                      info = 1;                  }                    if (info != 0)                  {                      return;                  }                    if (stage1 && f <= ftest1 && dg >= Math.Min(ftol' lb3_1_gtol) * dginit)                  {                      stage1 = false;                  }                    if (stage1 && f <= fx && f > ftest1)                  {                      var fm = f - stp * dgtest;                      var fxm = fx - stx * dgtest;                      var fym = fy - sty * dgtest;                      var dgm = dg - dgtest;                      var dgxm = dgx - dgtest;                      var dgym = dgy - dgtest;                      mcstep(ref stx' ref fxm' ref dgxm' ref sty' ref fym' ref dgym' ref stp' fm' dgm' ref brackt'                             stmin' stmax' ref infoc);                      fx = fxm + stx * dgtest;                      fy = fym + sty * dgtest;                      dgx = dgxm + dgtest;                      dgy = dgym + dgtest;                  }                  else                  {                      mcstep(ref stx' ref fx' ref dgx' ref sty' ref fy' ref dgy' ref stp' f' dg' ref brackt'                             stmin' stmax' ref infoc);                  }                    if (brackt)                  {                      var d1 = 0.0;                      d1 = sty - stx;                      if (Math.Abs(d1) >= p66 * width1)                      {                          stp = stx + p5 * (sty - stx);                      }                      width1 = width;                      d1 = sty - stx;                      width = Math.Abs(d1);                  }              }              else              {                  infoc = 1;                  if (size <= 0 || stp <= 0.0)                  {                      return;                  }                    dginit = ddot_(size' g' 1' s' s_idx + 1);                  if (dginit >= 0.0)                  {                      return;                  }                    brackt = false;                  stage1 = true;                  nfev = 0;                  finit = f;                  dgtest = ftol * dginit;                  width = lb3_1_stpmax - lb3_1_stpmin;                  width1 = width / p5;                    Parallel.For(1' size + 1' parallelOption' i =>                  {                      wa[i] = x[i];                  }                  );                    stx = 0.0;                  fx = finit;                  dgx = dginit;                  sty = 0.0;                  fy = finit;                  dgy = dginit;              }
Magic Number,CRFSharp,Mcsrch,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\Mcsrch.cs,mcsrch,The following statement contains a magic number: if (info == -1)              {                  info = 0;                  nfev++;                    var dg = ddot_(size' g' 1' s' s_idx + 1);                  var ftest1 = finit + stp * dgtest;                    if (brackt && ((stp <= stmin || stp >= stmax) || infoc == 0))                  {                      info = 6;                      Console.WriteLine("MCSRCH warning: Rounding errors prevent further progress.There may not be a step which satisfies the sufficient decrease and curvature conditions. Tolerances may be too small.");                      Console.WriteLine("bracket: {0}' stp:{1}' stmin:{2}' stmax:{3}' infoc:{4}"' brackt' stp' stmin' stmax' infoc);                  }                  if (stp == lb3_1_stpmax && f <= ftest1 && dg <= dgtest)                  {                      info = 5;                      Console.WriteLine("MCSRCH warning: The step is too large.");                  }                  if (stp == lb3_1_stpmin && (f > ftest1 || dg >= dgtest))                  {                      info = 4;                      Console.WriteLine("MCSRCH warning: The step is too small.");                      Console.WriteLine("stp:{0}' lb3_1_stpmin:{1}' f:{2}' ftest1:{3}' dg:{4}' dgtest:{5}"' stp' lb3_1_stpmin' f' ftest1' dg' dgtest);                  }                  if (nfev >= maxfev)                  {                      info = 3;                      Console.WriteLine("MCSRCH warning: More than {0} function evaluations were required at the present iteration."' maxfev);                  }                  if (brackt && stmax - stmin <= xtol * stmax)                  {                      info = 2;                      Console.WriteLine("MCSRCH warning: Relative width of the interval of uncertainty is at most xtol.");                  }                  if (f <= ftest1 && Math.Abs(dg) <= lb3_1_gtol * (-dginit))                  {                      info = 1;                  }                    if (info != 0)                  {                      return;                  }                    if (stage1 && f <= ftest1 && dg >= Math.Min(ftol' lb3_1_gtol) * dginit)                  {                      stage1 = false;                  }                    if (stage1 && f <= fx && f > ftest1)                  {                      var fm = f - stp * dgtest;                      var fxm = fx - stx * dgtest;                      var fym = fy - sty * dgtest;                      var dgm = dg - dgtest;                      var dgxm = dgx - dgtest;                      var dgym = dgy - dgtest;                      mcstep(ref stx' ref fxm' ref dgxm' ref sty' ref fym' ref dgym' ref stp' fm' dgm' ref brackt'                             stmin' stmax' ref infoc);                      fx = fxm + stx * dgtest;                      fy = fym + sty * dgtest;                      dgx = dgxm + dgtest;                      dgy = dgym + dgtest;                  }                  else                  {                      mcstep(ref stx' ref fx' ref dgx' ref sty' ref fy' ref dgy' ref stp' f' dg' ref brackt'                             stmin' stmax' ref infoc);                  }                    if (brackt)                  {                      var d1 = 0.0;                      d1 = sty - stx;                      if (Math.Abs(d1) >= p66 * width1)                      {                          stp = stx + p5 * (sty - stx);                      }                      width1 = width;                      d1 = sty - stx;                      width = Math.Abs(d1);                  }              }              else              {                  infoc = 1;                  if (size <= 0 || stp <= 0.0)                  {                      return;                  }                    dginit = ddot_(size' g' 1' s' s_idx + 1);                  if (dginit >= 0.0)                  {                      return;                  }                    brackt = false;                  stage1 = true;                  nfev = 0;                  finit = f;                  dgtest = ftol * dginit;                  width = lb3_1_stpmax - lb3_1_stpmin;                  width1 = width / p5;                    Parallel.For(1' size + 1' parallelOption' i =>                  {                      wa[i] = x[i];                  }                  );                    stx = 0.0;                  fx = finit;                  dgx = dginit;                  sty = 0.0;                  fy = finit;                  dgy = dginit;              }
Magic Number,CRFSharp,ModelWriter,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\ModelWriter.cs,ReadAllRecords,The following statement contains a magic number: Parallel.For(0' trainCorpusList.Count' parallelOption' i =>              {                  var _x = new EncoderTagger(this);                  if (_x.GenerateFeature(trainCorpusList[i]) == false)                  {                      Logger.WriteLine("Load a training sentence failed' skip it.");                  }                  else                  {                      var oldValue = Interlocked.Increment(ref arrayEncoderTaggerSize) - 1;                      arrayEncoderTagger[oldValue] = _x;                        if (oldValue % 10000 == 0)                      {                          //Show current progress on console                          Console.Write("{0}..."' oldValue);                      }                  }              });
Magic Number,CRFSharp,ModelWriter,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\ModelWriter.cs,SaveFeatureWeight,The following statement contains a magic number: if (bVQ == true)              {                  Logger.WriteLine("Save feature weights into a VQ model: {0}"' filename_alpha);                  //Build code book                  VectorQuantization vq = new VectorQuantization();                  for (long i = 1; i <= maxid_; i++)                  {                      vq.Add(alpha_[i]);                  }                    int vqSize = 256;                  double distortion = vq.BuildCodebook(vqSize);                  Logger.WriteLine("Weight vector quantization distortion: {0}"' distortion);                    //VQ size                  bw.Write(vqSize);                    //Save VQ codebook into file                  for (int j = 0; j < vqSize; j++)                  {                      bw.Write(vq.CodeBook[j]);                  }                    //Save weights                  for (long i = 1; i <= maxid_; ++i)                  {                      bw.Write((byte)vq.ComputeVQ(alpha_[i]));                  }              }              else              {                  Logger.WriteLine("Save feature weights into a normal model: {0}"' filename_alpha);                    bw.Write(0);                  //Save weights                  for (long i = 1; i <= maxid_; ++i)                  {                      bw.Write((float)alpha_[i]);                  }              }
Magic Number,CRFSharp,DefaultFeatureLexicalDict,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\encoder\DefaultFeatureLexicalDict.cs,DefaultFeatureLexicalDict,The following statement contains a magic number: featureset_dict_ = new BTreeDictionary<string' FeatureIdPair>(StringComparer.Ordinal' 128);
Missing Default,CRFSharp,DecoderTagger,C:\repos\zhongkaifu_CRFSharp\Core\CRFSharp\decoder\DecoderTagger.cs,termbuf_build,The following switch statement is missing a default case: switch (vlevel_)                  {                      case 0:                          term_buf.weight_[i] = 0.0;                          break;                      case 2:                          term_buf.weight_[i] = prob(i);                          break;                  }
