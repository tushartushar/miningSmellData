Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The method has 193 lines of code.
Long Method,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The method has 193 lines of code.
Long Method,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The method has 124 lines of code.
Long Method,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The method has 268 lines of code.
Complex Method,System.Net.Http,ByteRangeStreamContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\ByteRangeStreamContent.cs,ByteRangeStreamContent,Cyclomatic complexity of the method is 10
Complex Method,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,ValidateHttpMessageContent,Cyclomatic complexity of the method is 10
Complex Method,System.Net.Http.Formatting,BsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BsonMediaTypeFormatter.cs,ReadFromStream,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,MediaTypeHeaderValueExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeHeaderValueExtensions.cs,IsSubsetOf,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,FormUrlEncodedJson,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,ParseInternal,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,FormUrlEncodedJson,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,CanBecomeArray,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,ComputeFormatterMatches,Cyclomatic complexity of the method is 11
Complex Method,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,SelectCharacterEncoding,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,SetDefaultContentHeaders,Cyclomatic complexity of the method is 10
Complex Method,System.Net.Http.Internal,ReadOnlyStreamWithEncodingPreamble,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Internal\ReadOnlyStreamWithEncodingPreamble.cs,ReadOnlyStreamWithEncodingPreamble,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Headers,CookieHeaderValue,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Headers\CookieHeaderValue.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,Cyclomatic complexity of the method is 11
Complex Method,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ValidateArguments,Cyclomatic complexity of the method is 11
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' mediaType
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' mediaType
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' mediaType
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' mediaType
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpContentExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentExtensions.cs,ReadAsAsync,The method has 5 parameters. Parameters: content' type' formatters' formatterLogger' cancellationToken
Long Parameter List,System.Net.Http,HttpContentExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentExtensions.cs,ReadAsAsync,The method has 5 parameters. Parameters: content' type' formatters' formatterLogger' cancellationToken
Long Parameter List,System.Net.Http,HttpContentExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentExtensions.cs,ReadAsAsyncCore,The method has 5 parameters. Parameters: content' type' formatterLogger' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpRequestMessageAsync,The method has 5 parameters. Parameters: content' uriScheme' bufferSize' maxHeaderSize' cancellationToken
Long Parameter List,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpRequestMessageAsyncCore,The method has 5 parameters. Parameters: content' uriScheme' bufferSize' maxHeaderSize' cancellationToken
Long Parameter List,System.Net.Http.Formatting,BaseJsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BaseJsonMediaTypeFormatter.cs,WriteToStreamAsync,The method has 6 parameters. Parameters: type' value' writeStream' content' transportContext' cancellationToken
Long Parameter List,System.Net.Http.Formatting,BufferedMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BufferedMediaTypeFormatter.cs,WriteToStream,The method has 5 parameters. Parameters: type' value' writeStream' content' cancellationToken
Long Parameter List,System.Net.Http.Formatting,BufferedMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BufferedMediaTypeFormatter.cs,ReadFromStream,The method has 5 parameters. Parameters: type' readStream' content' formatterLogger' cancellationToken
Long Parameter List,System.Net.Http.Formatting,BufferedMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BufferedMediaTypeFormatter.cs,WriteToStreamAsync,The method has 5 parameters. Parameters: type' value' writeStream' content' transportContext
Long Parameter List,System.Net.Http.Formatting,BufferedMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BufferedMediaTypeFormatter.cs,WriteToStreamAsync,The method has 6 parameters. Parameters: type' value' writeStream' content' transportContext' cancellationToken
Long Parameter List,System.Net.Http.Formatting,BufferedMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BufferedMediaTypeFormatter.cs,WriteToStreamSync,The method has 5 parameters. Parameters: type' value' writeStream' content' cancellationToken
Long Parameter List,System.Net.Http.Formatting,BufferedMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BufferedMediaTypeFormatter.cs,ReadFromStreamAsync,The method has 5 parameters. Parameters: type' readStream' content' formatterLogger' cancellationToken
Long Parameter List,System.Net.Http.Formatting,BufferedMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BufferedMediaTypeFormatter.cs,ReadFromStreamSync,The method has 5 parameters. Parameters: type' readStream' content' formatterLogger' cancellationToken
Long Parameter List,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,WriteToStreamAsync,The method has 6 parameters. Parameters: type' value' writeStream' content' transportContext' cancellationToken
Long Parameter List,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,ReadFromStreamAsync,The method has 5 parameters. Parameters: type' readStream' content' formatterLogger' cancellationToken
Long Parameter List,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,WriteToStreamAsync,The method has 5 parameters. Parameters: type' value' writeStream' content' transportContext
Long Parameter List,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,WriteToStreamAsync,The method has 6 parameters. Parameters: type' value' writeStream' content' transportContext' cancellationToken
Long Parameter List,System.Net.Http.Formatting,MediaTypeFormatterExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatterExtensions.cs,AddRequestHeaderMapping,The method has 6 parameters. Parameters: formatter' headerName' headerValue' valueComparison' isValueSubstring' mediaType
Long Parameter List,System.Net.Http.Formatting,MediaTypeFormatterExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatterExtensions.cs,AddRequestHeaderMapping,The method has 6 parameters. Parameters: formatter' headerName' headerValue' valueComparison' isValueSubstring' mediaType
Long Parameter List,System.Net.Http.Formatting,RequestHeaderMapping,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\RequestHeaderMapping.cs,RequestHeaderMapping,The method has 5 parameters. Parameters: headerName' headerValue' valueComparison' isValueSubstring' mediaType
Long Parameter List,System.Net.Http.Formatting,RequestHeaderMapping,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\RequestHeaderMapping.cs,RequestHeaderMapping,The method has 5 parameters. Parameters: headerName' headerValue' valueComparison' isValueSubstring' mediaType
Long Parameter List,System.Net.Http.Formatting,RequestHeaderMapping,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\RequestHeaderMapping.cs,MatchHeaderValue,The method has 5 parameters. Parameters: request' headerName' headerValue' valueComparison' isValueSubstring
Long Parameter List,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,WriteToStreamAsync,The method has 6 parameters. Parameters: type' value' writeStream' content' transportContext' cancellationToken
Long Parameter List,System.Net.Http.Internal,ByteRangeStream,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Internal\ByteRangeStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Internal,ByteRangeStream,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Internal\ByteRangeStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Internal,DelegatingStream,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Internal\DelegatingStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Internal,DelegatingStream,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Internal\DelegatingStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Handlers,ProgressStream,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Handlers,ProgressStream,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Handlers,ProgressWriteAsyncResult,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressWriteAsyncResult.cs,ProgressWriteAsyncResult,The method has 7 parameters. Parameters: innerStream' progressStream' buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Formatting.Internal,HttpValueCollection,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Internal\HttpValueCollection.cs,AppendNameValuePair,The method has 5 parameters. Parameters: builder' first' urlEncode' name' value
Long Parameter List,System.Net.Http.Formatting.Parsers,FormUrlEncodedParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\FormUrlEncodedParser.cs,ParseNameValuePairs,The method has 8 parameters. Parameters: buffer' bytesReady' bytesConsumed' nameValueState' maximumLength' totalBytesConsumed' currentNameValuePair' nameValuePairs
Long Parameter List,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The method has 8 parameters. Parameters: buffer' bytesReady' bytesConsumed' requestLineState' maximumHeaderLength' totalBytesConsumed' currentToken' httpRequest
Long Parameter List,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The method has 8 parameters. Parameters: buffer' bytesReady' bytesConsumed' statusLineState' maximumHeaderLength' totalBytesConsumed' currentToken' httpResponse
Long Parameter List,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The method has 9 parameters. Parameters: buffer' bytesReady' bytesConsumed' requestHeaderState' maximumHeaderLength' totalBytesConsumed' currentField' headers' ignoreHeaderValidation
Long Parameter List,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBuffer,The method has 6 parameters. Parameters: buffer' bytesReady' bytesConsumed' remainingBodyPart' bodyPart' isFinalBodyPart
Long Parameter List,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The method has 7 parameters. Parameters: buffer' bytesReady' bytesConsumed' bodyPartState' maximumMessageLength' totalBytesConsumed' currentBodyPart
Long Identifier,System.Net.Http,FormattingUtilities,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,,The length of the parameter DelegatingEnumerableGenericType is 31.
Long Identifier,System.Net.Http,FormattingUtilities,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,,The length of the parameter EnumerableInterfaceGenericType is 30.
Long Identifier,System.Net.Http,HttpContentExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentExtensions.cs,,The length of the parameter _defaultMediaTypeFormatterCollection is 36.
Long Identifier,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,,The length of the parameter _spaceSeparatedValueHeaderFields is 32.
Long Identifier,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The length of the parameter bestMatchOnAcceptHeaderLiteral is 30.
Long Identifier,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The length of the parameter bestMatchOnAcceptHeaderSubtypeMediaRange is 40.
Long Identifier,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The length of the parameter bestMatchOnAcceptHeaderAllMediaRange is 36.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationXmlMediaType is 31.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationJsonMediaType is 32.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationOctetStreamMediaType is 39.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationFormUrlEncodedMediaType is 42.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationBsonMediaType is 32.
Long Identifier,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,,The length of the parameter _delegatingEnumerableConstructorCache is 37.
Long Statement,System.Web.Http,Error,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\Error.cs,ArgumentUriNotHttpOrHttpsScheme,The length of the statement  "            return new ArgumentException(Error.Format(CommonWebApiResources.ArgumentInvalidHttpUriScheme' actualValue' HttpScheme' HttpsScheme)' parameterName); " is 148.
Long Statement,System.Web.Http,Error,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\Error.cs,ArgumentUriNotAbsolute,The length of the statement  "            return new ArgumentException(Error.Format(CommonWebApiResources.ArgumentInvalidAbsoluteUri' actualValue)' parameterName); " is 121.
Long Statement,System.Web.Http,Error,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\Error.cs,ArgumentUriHasQueryOrFragment,The length of the statement  "            return new ArgumentException(Error.Format(CommonWebApiResources.ArgumentUriHasQueryOrFragment' actualValue)' parameterName); " is 124.
Long Statement,System.Web.Http,Error,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\Error.cs,ArgumentMustBeGreaterThanOrEqualTo,The length of the statement  "            return new ArgumentOutOfRangeException(parameterName' actualValue' Error.Format(CommonWebApiResources.ArgumentMustBeGreaterThanOrEqualTo' minValue)); " is 149.
Long Statement,System.Web.Http,Error,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\Error.cs,ArgumentMustBeLessThanOrEqualTo,The length of the statement  "            return new ArgumentOutOfRangeException(parameterName' actualValue' Error.Format(CommonWebApiResources.ArgumentMustBeLessThanOrEqualTo' maxValue)); " is 146.
Long Statement,System.Web.Http,Error,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\Error.cs,InvalidEnumArgument,The length of the statement  "            return new ArgumentException(Error.Format(CommonWebApiResources.InvalidEnumArgument' parameterName' invalidValue' enumClass.Name)' parameterName); " is 146.
Long Statement,System.Net.Http,HttpContentFormDataExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentFormDataExtensions.cs,IsFormData,The length of the statement  "            return contentType != null && String.Equals(ApplicationFormUrlEncoded' contentType.MediaType' StringComparison.OrdinalIgnoreCase); " is 130.
Long Statement,System.Net.Http,MultipartRelatedStreamProvider,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\MultipartRelatedStreamProvider.cs,FindMultipartRelatedParameter,The length of the statement  "            return parentContentType.Parameters.FirstOrDefault(nvp => String.Equals(nvp.Name' parameterName' StringComparison.OrdinalIgnoreCase)); " is 134.
Long Statement,System.Net.Http,HttpClientFactory,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientFactory.cs,CreatePipeline,The length of the statement  "                    throw Error.Argument("handlers"' Properties.Resources.DelegatingHandlerArrayContainsNullItem' typeof(DelegatingHandler).Name); " is 126.
Long Statement,System.Net.Http,HttpClientFactory,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientFactory.cs,CreatePipeline,The length of the statement  "                    throw Error.Argument("handlers"' Properties.Resources.DelegatingHandlerArrayHasNonNullInnerHandler' typeof(DelegatingHandler).Name' "InnerHandler"' handler.GetType().Name); " is 172.
Long Statement,System.Net.Http,HttpRequestHeadersExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpRequestHeadersExtensions.cs,GetCookies,The length of the statement  "            CookieHeaderValue[] matches = cookieHeaderValues.Where(header => header.Cookies.Any(state => String.Equals(state.Name' name' StringComparison.OrdinalIgnoreCase))).ToArray(); " is 173.
Long Statement,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The length of the statement  "            return client.PostAsync(requestUri' value' formatter' mediaType: (MediaTypeHeaderValue)null' cancellationToken: cancellationToken); " is 131.
Long Statement,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The length of the statement  "            return client.PostAsync(requestUri' value' formatter' mediaType: (MediaTypeHeaderValue)null' cancellationToken: cancellationToken); " is 131.
Long Statement,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The length of the statement  "            return client.PutAsync(requestUri' value' formatter' mediaType: (MediaTypeHeaderValue)null' cancellationToken: cancellationToken); " is 130.
Long Statement,System.Net.Http,HttpClientExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The length of the statement  "            return client.PutAsync(requestUri' value' formatter' mediaType: (MediaTypeHeaderValue)null' cancellationToken: cancellationToken); " is 130.
Long Statement,System.Net.Http,FormattingUtilities,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,CreateDefaultReaderQuotas,The length of the statement  "#if NETFX_CORE // MaxDepth is a DOS mitigation. We don't support MaxDepth in portable libraries because it is strictly client side. " is 131.
Long Statement,System.Net.Http,FormattingUtilities,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,UnquoteToken,The length of the statement  "            if (token.StartsWith("\""' StringComparison.Ordinal) && token.EndsWith("\""' StringComparison.Ordinal) && token.Length > 1) " is 123.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpRequestMessageAsync,The length of the statement  "                throw Error.ArgumentMustBeGreaterThanOrEqualTo("maxHeaderSize"' maxHeaderSize' InternetMessageFormatHeaderParser.MinHeaderSize); " is 128.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpResponseMessageAsync,The length of the statement  "            return ReadAsHttpResponseMessageAsync(content' bufferSize' HttpResponseHeaderParser.DefaultMaxHeaderSize' cancellationToken); " is 125.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpResponseMessageAsync,The length of the statement  "                throw Error.ArgumentMustBeGreaterThanOrEqualTo("maxHeaderSize"' maxHeaderSize' InternetMessageFormatHeaderParser.MinHeaderSize); " is 128.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpResponseMessageAsyncCore,The length of the statement  "            HttpResponseHeaderParser parser = new HttpResponseHeaderParser(httpResponse' HttpResponseHeaderParser.DefaultMaxStatusLineSize' maxHeaderSize); " is 143.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateRequestUri,The length of the statement  "                    throw Error.InvalidOperation(Properties.Resources.HttpMessageParserInvalidHostCount' FormattingUtilities.HttpHostHeader' hostCount); " is 132.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateRequestUri,The length of the statement  "                throw Error.InvalidOperation(Properties.Resources.HttpMessageParserInvalidHostCount' FormattingUtilities.HttpHostHeader' 0); " is 124.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateRequestUri,The length of the statement  "            // We don't use UriBuilder as hostValues.ElementAt(0) contains 'host:port' and UriBuilder needs these split out into separate host and port. " is 140.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateRequestUri,The length of the statement  "            string requestUri = String.Format(CultureInfo.InvariantCulture' "{0}://{1}{2}"' uriScheme' hostValues.ElementAt(0)' httpRequest.RequestUri); " is 140.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateHeaderFields,The length of the statement  "                    throw Error.InvalidOperation(Properties.Resources.HttpMessageContentStreamMustBeSeekable' "ContentReadStream"' FormattingUtilities.HttpResponseMessageType.Name); " is 161.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateHttpRequestMessage,The length of the statement  "            httpRequestMessage.Content = CreateHeaderFields(httpRequest.HttpHeaders' httpRequestMessage.Headers' contentStream' rewind); " is 124.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateHttpResponseMessage,The length of the statement  "            httpResponseMessage.Content = CreateHeaderFields(httpResponse.HttpHeaders' httpResponseMessage.Headers' contentStream' rewind); " is 127.
Long Statement,System.Net.Http,HttpContentMultipartExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,ReadAsMultipartAsync,The length of the statement  "            return ReadAsMultipartAsync<MultipartMemoryStreamProvider>(content' new MultipartMemoryStreamProvider()' DefaultBufferSize); " is 124.
Long Statement,System.Net.Http,HttpContentMultipartExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,ReadAsMultipartAsync,The length of the statement  "            return ReadAsMultipartAsync<MultipartMemoryStreamProvider>(content' new MultipartMemoryStreamProvider()' DefaultBufferSize' cancellationToken); " is 143.
Long Statement,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,ValidateHttpMessageContent,The length of the statement  "                        throw Error.Argument("content"' Properties.Resources.HttpMessageInvalidMediaType' FormattingUtilities.HttpContentType.Name' " is 123.
Long Statement,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,ValidateHttpMessageContent,The length of the statement  "                                throw Error.Argument("content"' Properties.Resources.HttpMessageInvalidMediaType' FormattingUtilities.HttpContentType.Name' isRequest ? DefaultRequestMediaType : DefaultResponseMediaType); " is 188.
Long Statement,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,ValidateHttpMessageContent,The length of the statement  "                throw Error.Argument("content"' Properties.Resources.HttpMessageInvalidMediaType' FormattingUtilities.HttpContentType.Name' isRequest ? DefaultRequestMediaType : DefaultResponseMediaType); " is 188.
Long Statement,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,SerializeRequestLine,The length of the statement  "            message.Append(FormattingUtilities.HttpVersionToken + "/" + (httpRequest.Version != null ? httpRequest.Version.ToString(2) : "1.1") + CRLF); " is 140.
Long Statement,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,SerializeStatusLine,The length of the statement  "            message.Append(FormattingUtilities.HttpVersionToken + "/" + (httpResponse.Version != null ? httpResponse.Version.ToString(2) : "1.1") + SP); " is 140.
Long Statement,System.Net.Http,MimeBodyPart,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\MimeBodyPart.cs,GetOutputStream,The length of the statement  "                    throw Error.InvalidOperation(e' Properties.Resources.ReadAsMimeMultipartStreamProviderException' _streamProvider.GetType().Name); " is 129.
Long Statement,System.Net.Http,MimeBodyPart,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\MimeBodyPart.cs,GetOutputStream,The length of the statement  "                    throw Error.InvalidOperation(Properties.Resources.ReadAsMimeMultipartStreamProviderNull' _streamProvider.GetType().Name' _streamType.Name); " is 139.
Long Statement,System.Net.Http,MimeBodyPart,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\MimeBodyPart.cs,GetOutputStream,The length of the statement  "                    throw Error.InvalidOperation(Properties.Resources.ReadAsMimeMultipartStreamProviderReadOnly' _streamProvider.GetType().Name' _streamType.Name); " is 143.
Long Statement,System.Net.Http.Formatting,BaseJsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BaseJsonMediaTypeFormatter.cs,ReadFromStream,The length of the statement  "                    // Failure to do so can cause the exception to be rethrown at every recursive level and overflow the stack for x64 CLR processes " is 128.
Long Statement,System.Net.Http.Formatting,BaseJsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BaseJsonMediaTypeFormatter.cs,CreateJsonReaderInternal,The length of the statement  "                throw Error.InvalidOperation(Properties.Resources.MediaTypeFormatter_JsonReaderFactoryReturnedNull' "CreateJsonReader"); " is 120.
Long Statement,System.Net.Http.Formatting,BaseJsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BaseJsonMediaTypeFormatter.cs,CreateJsonWriterInternal,The length of the statement  "                throw Error.InvalidOperation(Properties.Resources.MediaTypeFormatter_JsonWriterFactoryReturnedNull' "CreateJsonWriter"); " is 120.
Long Statement,System.Net.Http.Formatting,MediaTypeHeaderValueExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeHeaderValueExtensions.cs,IsSubsetOf,The length of the statement  "            // Optimize for the common case where the parameters inherit from Collection<T> and cache the count which is faster for Collection<T>. " is 134.
Long Statement,System.Net.Http.Formatting,FormUrlEncodedJson,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToArray,The length of the statement  "            Contract.Assert(path.Length >= 2' "The path must be at least 2' one for the ending []' and one for before the '[' (which can be empty)"); " is 137.
Long Statement,System.Net.Http.Formatting,FormUrlEncodedJson,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToArray,The length of the statement  "            Contract.Assert(((IDictionary<string' JToken>)parent).ContainsKey(parentPath)' "It was added on insert to get to this point"); " is 126.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,Negotiate,The length of the statement  "                MediaTypeFormatter bestFormatter = bestFormatterMatch.Formatter.GetPerRequestFormatterInstance(type' request' bestMediaType); " is 125.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The length of the statement  "            // we want to give precedence to the media type mappings' but only if their quality is >= that of the supported media type. " is 123.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseCharacterEncoding,The length of the statement  "                IEnumerable<StringWithQualityHeaderValue> sortedAcceptCharsetValues = SortStringWithQualityHeaderValuesByQFactor(request.Headers.AcceptCharset); " is 144.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,MatchMediaTypeMapping,The length of the statement  "                    return new MediaTypeFormatterMatch(formatter' mapping.MediaType' quality' MediaTypeFormatterMatchRanking.MatchOnRequestWithMediaTypeMapping); " is 141.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,MatchRequestMediaType,The length of the statement  "                            return new MediaTypeFormatterMatch(formatter' supportedMediaType' FormattingUtilities.Match' MediaTypeFormatterMatchRanking.MatchOnRequestMediaType); " is 149.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,MatchType,The length of the statement  "            return new MediaTypeFormatterMatch(formatter' mediaType' FormattingUtilities.Match' MediaTypeFormatterMatchRanking.MatchOnCanWriteType); " is 136.
Long Statement,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,ReadFromStream,The length of the statement  "                using (XmlReader reader = JsonReaderWriterFactory.CreateJsonReader(new NonClosingDelegatingStream(readStream)' effectiveEncoding' _readerQuotas' null)) " is 151.
Long Statement,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,GetDataContractSerializer,The length of the statement  "                throw Error.InvalidOperation(Properties.Resources.SerializerCannotSerializeType' typeof(DataContractJsonSerializer).Name' type.Name); " is 133.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,WriteToStreamAsync,The length of the statement  "            // HttpContent.SerializeToStreamAsync doesn't take in a CancellationToken. So' there is no easy way to get the CancellationToken " is 128.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,WriteToStreamAsync,The length of the statement  "            // to the formatter while writing response. We are cheating here by passing fake cancellation tokens. We should fix this " is 120.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,GetOrAddDelegatingType,The length of the statement  "                    // The current method is called by methods that already checked the type for is not null' is generic and is or implements IEnumerable<T> " is 136.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,GetOrAddDelegatingType,The length of the statement  "                    ConstructorInfo delegatingConstructor = delegatingType.GetConstructor(new Type[] { FormattingUtilities.EnumerableInterfaceGenericType.MakeGenericType(elementType) }); " is 166.
Long Statement,System.Net.Http.Formatting,MediaTypeHeaderValueCollection,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,ValidateMediaType,The length of the statement  "                    throw Error.Argument("item"' Properties.Resources.CannotUseMediaRangeForSupportedMediaType' _mediaTypeHeaderValueType.Name' item.MediaType); " is 140.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatterExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatterExtensions.cs,AddRequestHeaderMapping,The length of the statement  "            RequestHeaderMapping mapping = new RequestHeaderMapping(headerName' headerValue' valueComparison' isValueSubstring' mediaType); " is 127.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatterExtensions,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatterExtensions.cs,AddRequestHeaderMapping,The length of the statement  "            RequestHeaderMapping mapping = new RequestHeaderMapping(headerName' headerValue' valueComparison' isValueSubstring' mediaType); " is 127.
Long Statement,System.Net.Http.Formatting,ParsedMediaTypeHeaderValue,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\ParsedMediaTypeHeaderValue.cs,SubTypesEqual,The length of the statement  "            return String.Compare(_mediaType' _delimiterIndex + 1' other._mediaType' other._delimiterIndex + 1' _subTypeLength' StringComparison.OrdinalIgnoreCase) == 0; " is 157.
Long Statement,System.Net.Http.Formatting,XmlHttpRequestHeaderMapping,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlHttpRequestHeaderMapping.cs,TryMatchMediaType,The length of the statement  "                || (request.Headers.Accept.Count == 1 && request.Headers.Accept.First().MediaType.Equals("*/*"' StringComparison.Ordinal))) " is 123.
Long Statement,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,CreateXmlReader,The length of the statement  "            return XmlDictionaryReader.CreateTextReader(new ReadOnlyStreamWithEncodingPreamble(readStream' effectiveEncoding)' _readerQuotas); " is 130.
Long Statement,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,CreateXmlReader,The length of the statement  "            return XmlDictionaryReader.CreateTextReader(new NonClosingDelegatingStream(readStream)' effectiveEncoding' _readerQuotas' null); " is 128.
Long Statement,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,GetSerializerForType,The length of the statement  "            Contract.Assert(serializer is XmlSerializer || serializer is XmlObjectSerializer' "Only XmlSerializer or XmlObjectSerializer are supported."); " is 142.
Long Statement,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,ThrowInvalidSerializerException,The length of the statement  "                throw Error.InvalidOperation(Properties.Resources.XmlMediaTypeFormatter_NullReturnedSerializer' getSerializerMethodName); " is 121.
Long Statement,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,ThrowInvalidSerializerException,The length of the statement  "                throw Error.InvalidOperation(Properties.Resources.XmlMediaTypeFormatter_InvalidSerializerType' serializer.GetType().Name' getSerializerMethodName); " is 147.
Long Statement,System.Net.Http.Handlers,ProgressStream,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,ReportBytesSent,The length of the statement  "                _handler.OnHttpRequestProgress(_request' new HttpProgressEventArgs(percentage' userState' _bytesSent' _totalBytesToSend)); " is 122.
Long Statement,System.Net.Http.Handlers,ProgressStream,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,ReportBytesReceived,The length of the statement  "                _handler.OnHttpResponseProgress(_request' new HttpProgressEventArgs(percentage' userState' _bytesReceived' _totalBytesToReceive)); " is 130.
Long Statement,System.Net.Http.Headers,CookieHeaderValue,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Headers\CookieHeaderValue.cs,ToString,The length of the statement  "                first = AppendSegment(header' first' MaxAgeToken' ((int)MaxAge.Value.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo)); " is 125.
Long Statement,System.Net.Http.Formatting.Internal,HttpValueCollection,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Internal\HttpValueCollection.cs,ThrowIfMaxHttpCollectionKeysExceeded,The length of the statement  "                throw Error.InvalidOperation(System.Net.Http.Properties.Resources.MaxHttpCollectionKeyLimitReached' MediaTypeFormatter.MaxHttpCollectionKeys' typeof(MediaTypeFormatter)); " is 170.
Long Statement,System.Net.Http.Formatting.Parsers,FormUrlEncodedParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\FormUrlEncodedParser.cs,ParseNameValuePairs,The length of the statement  "            Contract.Assert(maximumLength <= 0 || totalBytesConsumed <= maximumLength' "ParseNameValuePairs()|Headers already read exceeds limit."); " is 136.
Long Statement,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The length of the statement  "            Contract.Assert(maximumHeaderLength <= 0 || totalBytesConsumed <= maximumHeaderLength' "ParseRequestLine()|Headers already read exceeds limit."); " is 145.
Long Statement,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The length of the statement  "            int effectiveMax = maximumHeaderLength <= 0 ? Int32.MaxValue : (maximumHeaderLength - totalBytesConsumed + bytesConsumed); " is 122.
Long Statement,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The length of the statement  "                        throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken)); " is 128.
Long Statement,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The length of the statement  "            Contract.Assert(maximumHeaderLength <= 0 || totalBytesConsumed <= maximumHeaderLength' "ParseRequestLine()|Headers already read exceeds limit."); " is 145.
Long Statement,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The length of the statement  "            int effectiveMax = maximumHeaderLength <= 0 ? Int32.MaxValue : (maximumHeaderLength - totalBytesConsumed + bytesConsumed); " is 122.
Long Statement,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The length of the statement  "                        throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken)); " is 128.
Long Statement,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The length of the statement  "            Contract.Assert(maximumHeaderLength <= 0 || totalBytesConsumed <= maximumHeaderLength' "ParseHeaderFields()|Headers already read exceeds limit."); " is 146.
Long Statement,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The length of the statement  "            int effectiveMax = maximumHeaderLength <= 0 ? Int32.MaxValue : maximumHeaderLength - totalBytesConsumed + initialBytesParsed; " is 125.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,The length of the statement  "                _mimeStatus = _mimeParser.ParseBuffer(data' bytesRead' ref bytesConsumed' out _parsedBodyPart[0]' out _parsedBodyPart[1]' out isFinal); " is 135.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,The length of the statement  "                if (_mimeStatus != MimeMultipartParser.State.BodyPartCompleted && _mimeStatus != MimeMultipartParser.State.NeedMoreData) " is 120.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,The length of the statement  "                        _bodyPartHeaderStatus = _currentBodyPart.HeaderParser.ParseBuffer(part.Array' part.Count + part.Offset' ref headerConsumed); " is 124.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,The length of the statement  "                            _currentBodyPart.Segments.Add(new ArraySegment<byte>(part.Array' headerConsumed' part.Count + part.Offset - headerConsumed)); " is 125.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ValidateArguments,The length of the statement  "                    throw Error.Argument("content"' Properties.Resources.ReadAsMimeMultipartArgumentNoContentType' typeof(HttpContent).Name' "multipart/"); " is 135.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ValidateArguments,The length of the statement  "                    throw Error.Argument("content"' Properties.Resources.ReadAsMimeMultipartArgumentNoMultipart' typeof(HttpContent).Name' "multipart/"); " is 133.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ValidateArguments,The length of the statement  "                    throw Error.Argument("content"' Properties.Resources.ReadAsMimeMultipartArgumentNoBoundary' typeof(HttpContent).Name' "multipart"' "boundary"); " is 143.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The length of the statement  "            Contract.Assert(maximumMessageLength <= 0 || totalBytesConsumed <= maximumMessageLength' "ParseBodyPart()|Message already read exceeds limit."); " is 144.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The length of the statement  "            long effectiveMax = maximumMessageLength <= 0 ? Int64.MaxValue : (maximumMessageLength - totalBytesConsumed + bytesConsumed); " is 125.
Complex Conditional,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,IsUrlSafeChar,The conditional expression  "ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9'"  is complex.
Complex Conditional,System.Net.Http.Formatting,BsonMediaTypeFormatter,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BsonMediaTypeFormatter.cs,ReadFromStreamAsync,The conditional expression  "type == typeof(DBNull) && content != null && content.Headers != null && content.Headers.ContentLength == 0"  is complex.
Complex Conditional,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseCharacterEncoding,The conditional expression  "encoding != null && acceptCharset.Quality != FormattingUtilities.NoMatch &&                              (acceptCharset.Value.Equals(encoding.WebName' StringComparison.OrdinalIgnoreCase) ||                              acceptCharset.Value.Equals("*"' StringComparison.OrdinalIgnoreCase))"  is complex.
Virtual Method Call from Constructor,System.Net.Http,ObjectContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\ObjectContent.cs,ObjectContent,The constructor "ObjectContent" calls a virtual method "CanWriteType".
Virtual Method Call from Constructor,System.Net.Http,ObjectContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\ObjectContent.cs,ObjectContent,The constructor "ObjectContent" calls a virtual method "SetDefaultContentHeaders".
Empty Catch Block,System.Net.Http,ByteRangeStreamContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\ByteRangeStreamContent.cs,ByteRangeStreamContent,The method has an empty catch block.
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,UrlEncode,The following statement contains a magic number: byte[] expandedBytes = new byte[count + cUnsafe * 2];
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,UrlEncode,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  byte b = bytes[offset + i];                  char ch = (char)b;                    if (IsUrlSafeChar(ch))                  {                      expandedBytes[pos++] = b;                  }                  else if (ch == ' ')                  {                      expandedBytes[pos++] = (byte)'+';                  }                  else                  {                      expandedBytes[pos++] = (byte)'%';                      expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);                      expandedBytes[pos++] = (byte)IntToHex(b & 0x0f);                  }              }
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int pos = 0; pos < count; pos++)              {                  char ch = value[pos];                    if (ch == '+')                  {                      ch = ' ';                  }                  else if (ch == '%' && pos < count - 2)                  {                      int h1 = HexToInt(value[pos + 1]);                      int h2 = HexToInt(value[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {                          // valid 2 hex chars                          byte b = (byte)((h1 << 4) | h2);                          pos += 2;                            // don't add as char                          helper.AddByte(b);                          continue;                      }                  }                    if ((ch & 0xFF80) == 0)                      helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode                  else                      helper.AddChar(ch);              }
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int pos = 0; pos < count; pos++)              {                  char ch = value[pos];                    if (ch == '+')                  {                      ch = ' ';                  }                  else if (ch == '%' && pos < count - 2)                  {                      int h1 = HexToInt(value[pos + 1]);                      int h2 = HexToInt(value[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {                          // valid 2 hex chars                          byte b = (byte)((h1 << 4) | h2);                          pos += 2;                            // don't add as char                          helper.AddByte(b);                          continue;                      }                  }                    if ((ch & 0xFF80) == 0)                      helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode                  else                      helper.AddChar(ch);              }
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int pos = 0; pos < count; pos++)              {                  char ch = value[pos];                    if (ch == '+')                  {                      ch = ' ';                  }                  else if (ch == '%' && pos < count - 2)                  {                      int h1 = HexToInt(value[pos + 1]);                      int h2 = HexToInt(value[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {                          // valid 2 hex chars                          byte b = (byte)((h1 << 4) | h2);                          pos += 2;                            // don't add as char                          helper.AddByte(b);                          continue;                      }                  }                    if ((ch & 0xFF80) == 0)                      helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode                  else                      helper.AddChar(ch);              }
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int pos = 0; pos < count; pos++)              {                  char ch = value[pos];                    if (ch == '+')                  {                      ch = ' ';                  }                  else if (ch == '%' && pos < count - 2)                  {                      int h1 = HexToInt(value[pos + 1]);                      int h2 = HexToInt(value[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {                          // valid 2 hex chars                          byte b = (byte)((h1 << 4) | h2);                          pos += 2;                            // don't add as char                          helper.AddByte(b);                          continue;                      }                  }                    if ((ch & 0xFF80) == 0)                      helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode                  else                      helper.AddChar(ch);              }
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,HexToInt,The following statement contains a magic number: return (h >= '0' && h <= '9') ? h - '0' :              (h >= 'a' && h <= 'f') ? h - 'a' + 10 :              (h >= 'A' && h <= 'F') ? h - 'A' + 10 :              -1;
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,HexToInt,The following statement contains a magic number: return (h >= '0' && h <= '9') ? h - '0' :              (h >= 'a' && h <= 'f') ? h - 'a' + 10 :              (h >= 'A' && h <= 'F') ? h - 'A' + 10 :              -1;
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,IntToHex,The following statement contains a magic number: if (n <= 9)                  return (char)(n + (int)'0');              else                  return (char)(n - 10 + (int)'a');
Magic Number,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,IntToHex,The following statement contains a magic number: if (n <= 9)                  return (char)(n + (int)'0');              else                  return (char)(n - 10 + (int)'a');
Magic Number,System.Net.Http,FormattingUtilities,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,UnquoteToken,The following statement contains a magic number: if (token.StartsWith("\""' StringComparison.Ordinal) && token.EndsWith("\""' StringComparison.Ordinal) && token.Length > 1)              {                  return token.Substring(1' token.Length - 2);              }
Magic Number,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,SerializeRequestLine,The following statement contains a magic number: message.Append(FormattingUtilities.HttpVersionToken + "/" + (httpRequest.Version != null ? httpRequest.Version.ToString(2) : "1.1") + CRLF);
Magic Number,System.Net.Http,HttpMessageContent,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,SerializeStatusLine,The following statement contains a magic number: message.Append(FormattingUtilities.HttpVersionToken + "/" + (httpResponse.Version != null ? httpResponse.Version.ToString(2) : "1.1") + SP);
Magic Number,System.Net.Http,MimeBodyPart,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\MimeBodyPart.cs,MimeBodyPart,The following statement contains a magic number: Segments = new List<ArraySegment<byte>>(2);
Magic Number,System.Net.Http.Formatting,FormUrlEncodedJson,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToArray,The following statement contains a magic number: Contract.Assert(path.Length >= 2' "The path must be at least 2' one for the ending []' and one for before the '[' (which can be empty)");
Magic Number,System.Net.Http.Formatting,FormUrlEncodedJson,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToArray,The following statement contains a magic number: string parentPath = path[path.Length - 2];
Magic Number,System.Net.Http.Formatting,ParsedMediaTypeHeaderValue,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\ParsedMediaTypeHeaderValue.cs,ParsedMediaTypeHeaderValue,The following statement contains a magic number: if (_delimiterIndex == mediaTypeLength - 2)              {                  if (mediaType[mediaTypeLength - 1] == MediaRangeAsterisk)                  {                      _isSubtypeMediaRange = true;                      if (_delimiterIndex == 1 && mediaType[0] == MediaRangeAsterisk)                      {                          _isAllMediaRange = true;                      }                  }              }
Magic Number,System.Net.Http.Internal,ReadOnlyStreamWithEncodingPreamble,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Internal\ReadOnlyStreamWithEncodingPreamble.cs,ReadOnlyStreamWithEncodingPreamble,The following statement contains a magic number: int finalBufferLength = preambleLength * 2;
Magic Number,System.Net.Http.Headers,CookieHeaderValue,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Headers\CookieHeaderValue.cs,ParseCookieSegment,The following statement contains a magic number: string[] nameValue = segment.Split(nameValueSeparator' 2);
Magic Number,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following statement contains a magic number: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Magic Number,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following statement contains a magic number: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Magic Number,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following statement contains a magic number: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Magic Number,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following statement contains a magic number: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Magic Number,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,MimeMultipartParser,The following statement contains a magic number: if (boundary.Length > MaxBoundarySize - 10)              {                  throw Error.ArgumentMustBeLessThanOrEqualTo("boundary"' boundary.Length' MaxBoundarySize - 10);              }
Magic Number,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,MimeMultipartParser,The following statement contains a magic number: if (boundary.Length > MaxBoundarySize - 10)              {                  throw Error.ArgumentMustBeLessThanOrEqualTo("boundary"' boundary.Length' MaxBoundarySize - 10);              }
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,CurrentBodyPartStore,The following statement contains a magic number: _referenceBoundary[2] = MimeMultipartParser.Dash;
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,CurrentBodyPartStore,The following statement contains a magic number: _referenceBoundary[3] = MimeMultipartParser.Dash;
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,CurrentBodyPartStore,The following statement contains a magic number: _referenceBoundaryLength = 4 + Encoding.UTF8.GetBytes(referenceBoundary' 0' referenceBoundary.Length' _referenceBoundary' 4);
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,CurrentBodyPartStore,The following statement contains a magic number: _referenceBoundaryLength = 4 + Encoding.UTF8.GetBytes(referenceBoundary' 0' referenceBoundary.Length' _referenceBoundary' 4);
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,AppendBoundary,The following statement contains a magic number: if (_boundaryLength + count > _referenceBoundaryLength + 6)                  {                      return false;                  }
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,IsBoundaryValid,The following statement contains a magic number: if (_boundary[count] == MimeMultipartParser.Dash &&                      _boundary[count + 1] == MimeMultipartParser.Dash)                  {                      boundaryIsFinal = true;                      count += 2;                  }
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,IsBoundaryValid,The following statement contains a magic number: for (; count < _boundaryLength - 2; count++)                  {                      if (_boundary[count] != MimeMultipartParser.SP && _boundary[count] != MimeMultipartParser.HTAB)                      {                          return false;                      }                  }
Missing Default,System.Web.Http,UriQueryUtility,C:\repos\ASP-NET-MVC_aspnetwebstack\src\Common\UriQueryUtility.cs,IsUrlSafeChar,The following switch statement is missing a default case: switch (ch)              {                  case '-':                  case '_':                  case '.':                  case '!':                  case '*':                  case '(':                  case ')':                      return true;              }
Missing Default,System.Net.Http.Formatting,FormUrlEncodedJson,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,ValidateQueryString,The following switch statement is missing a default case: switch (key[i])                  {                      case '[':                          if (!hasUnMatchedLeftBraket)                          {                              hasUnMatchedLeftBraket = true;                          }                          else                          {                              if (throwOnError)                              {                                  throw Error.Argument(Properties.Resources.NestedBracketNotValid' ApplicationFormUrlEncoded' i);                              }                                return false;                          }                            break;                      case ']':                          if (hasUnMatchedLeftBraket)                          {                              hasUnMatchedLeftBraket = false;                          }                          else                          {                              if (throwOnError)                              {                                  throw Error.Argument(Properties.Resources.UnMatchedBracketNotValid' ApplicationFormUrlEncoded' i);                              }                                return false;                          }                            break;                  }
Missing Default,System.Net.Http.Formatting,DefaultContentNegotiator,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The following switch statement is missing a default case: switch (match.Ranking)                  {                      case MediaTypeFormatterMatchRanking.MatchOnCanWriteType:                          // First match by type trumps all other type matches                          if (bestMatchOnType == null)                          {                              bestMatchOnType = match;                          }                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestWithMediaTypeMapping:                          // Matches on accept headers using mappings must choose the highest quality match                          bestMatchOnMediaTypeMapping = UpdateBestMatch(bestMatchOnMediaTypeMapping' match);                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestAcceptHeaderLiteral:                          // Matches on accept headers must choose the highest quality match.                          // A match of 0.0 means we won't use it at all.                          bestMatchOnAcceptHeaderLiteral = UpdateBestMatch(bestMatchOnAcceptHeaderLiteral' match);                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestAcceptHeaderSubtypeMediaRange:                          // Matches on accept headers must choose the highest quality match.                          // A match of 0.0 means we won't use it at all.                          bestMatchOnAcceptHeaderSubtypeMediaRange = UpdateBestMatch(bestMatchOnAcceptHeaderSubtypeMediaRange' match);                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestAcceptHeaderAllMediaRange:                          // Matches on accept headers must choose the highest quality match.                          // A match of 0.0 means we won't use it at all.                          bestMatchOnAcceptHeaderAllMediaRange = UpdateBestMatch(bestMatchOnAcceptHeaderAllMediaRange' match);                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestMediaType:                          // First match on request content type trumps other request content matches                          if (bestMatchOnRequestMediaType == null)                          {                              bestMatchOnRequestMediaType = match;                          }                          break;                  }
Missing Default,System.Net.Http.Formatting.Parsers,FormUrlEncodedParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\FormUrlEncodedParser.cs,ParseNameValuePairs,The following switch statement is missing a default case: switch (nameValueState)              {                  case NameValueState.Name:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '=' && buffer[bytesConsumed] != '&')                      {                          if (++bytesConsumed == effectiveMax)                          {                              string name = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentNameValuePair.Name.Append(name);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string name = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentNameValuePair.Name.Append(name);                      }                        // Check if we got name=value or just name                      if (buffer[bytesConsumed] == '=')                      {                          // Move part the '='                          nameValueState = NameValueState.Value;                          if (++bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case NameValueState.Value;                      }                      else                      {                          // Copy parsed name-only to collection                          currentNameValuePair.CopyNameOnlyTo(nameValuePairs);                            // Move past the '&' but stay in same state                          if (++bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case NameValueState.Name;                      }                    case NameValueState.Value:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '&')                      {                          if (++bytesConsumed == effectiveMax)                          {                              string value = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentNameValuePair.Value.Append(value);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string value = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentNameValuePair.Value.Append(value);                      }                        // Copy parsed name value pair to collection                      currentNameValuePair.CopyTo(nameValuePairs);                        // Move past the '&'                      nameValueState = NameValueState.Name;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case NameValueState.Name;              }
Missing Default,System.Net.Http.Formatting.Parsers,HttpRequestHeaderParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestHeaderParser.cs,ParseBuffer,The following switch statement is missing a default case: switch (_requestStatus)              {                  case HttpRequestState.RequestLine:                      try                      {                          subParseStatus = _requestLineParser.ParseBuffer(buffer' bytesReady' ref bytesConsumed);                      }                      catch (Exception)                      {                          subParseStatus = ParserState.Invalid;                      }                        if (subParseStatus == ParserState.Done)                      {                          _requestStatus = HttpRequestState.RequestHeaders;                          subParseStatus = ParserState.NeedMoreData;                          goto case HttpRequestState.RequestHeaders;                      }                      else if (subParseStatus != ParserState.NeedMoreData)                      {                          // Report error - either Invalid or DataTooBig                          parseStatus = subParseStatus;                          break;                      }                        break; // read more data                    case HttpRequestState.RequestHeaders:                      if (bytesConsumed >= bytesReady)                      {                          // we already can tell we need more data                          break;                      }                        try                      {                          subParseStatus = _headerParser.ParseBuffer(buffer' bytesReady' ref bytesConsumed);                      }                      catch (Exception)                      {                          subParseStatus = ParserState.Invalid;                      }                        if (subParseStatus == ParserState.Done)                      {                          parseStatus = subParseStatus;                      }                      else if (subParseStatus != ParserState.NeedMoreData)                      {                          parseStatus = subParseStatus;                          break;                      }                        break; // need more data              }
Missing Default,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The following switch statement is missing a default case: switch (requestLineState)              {                  case HttpRequestLineState.RequestMethod:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      httpRequest.Method = new HttpMethod(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      requestLineState = HttpRequestLineState.RequestUri;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.RequestUri;                    case HttpRequestLineState.RequestUri:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] == '\r')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // URI validation happens when we create the URI later.                      if (currentToken.Length == 0)                      {                          throw new FormatException(Properties.Resources.HttpMessageParserEmptyUri);                      }                        // Copy value out                      httpRequest.RequestUri = currentToken.ToString();                      currentToken.Clear();                        // Move past the SP                      requestLineState = HttpRequestLineState.BeforeVersionNumbers;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.BeforeVersionNumbers;                    case HttpRequestLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      requestLineState = HttpRequestLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.MajorVersionNumber;                    case HttpRequestLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      requestLineState = HttpRequestLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.MinorVersionNumber;                    case HttpRequestLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpRequest.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the CR                      requestLineState = HttpRequestLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.AfterCarriageReturn;                    case HttpRequestLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Missing Default,System.Net.Http.Formatting.Parsers,HttpResponseHeaderParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpResponseHeaderParser.cs,ParseBuffer,The following switch statement is missing a default case: switch (_responseStatus)              {                  case HttpResponseState.StatusLine:                      try                      {                          subParseStatus = _statusLineParser.ParseBuffer(buffer' bytesReady' ref bytesConsumed);                      }                      catch (Exception)                      {                          subParseStatus = ParserState.Invalid;                      }                        if (subParseStatus == ParserState.Done)                      {                          _responseStatus = HttpResponseState.ResponseHeaders;                          subParseStatus = ParserState.NeedMoreData;                          goto case HttpResponseState.ResponseHeaders;                      }                      else if (subParseStatus != ParserState.NeedMoreData)                      {                          // Report error - either Invalid or DataTooBig                          parseStatus = subParseStatus;                          break;                      }                        break; // read more data                    case HttpResponseState.ResponseHeaders:                      if (bytesConsumed >= bytesReady)                      {                          // we already can tell we need more data                          break;                      }                        try                      {                          subParseStatus = _headerParser.ParseBuffer(buffer' bytesReady' ref bytesConsumed);                      }                      catch (Exception)                      {                          subParseStatus = ParserState.Invalid;                      }                        if (subParseStatus == ParserState.Done)                      {                          parseStatus = subParseStatus;                      }                      else if (subParseStatus != ParserState.NeedMoreData)                      {                          parseStatus = subParseStatus;                          break;                      }                        break; // need more data              }
Missing Default,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following switch statement is missing a default case: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Missing Default,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The following switch statement is missing a default case: switch (requestHeaderState)              {                  case HeaderFieldState.Name:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ':')                      {                          if (buffer[bytesConsumed] == '\r')                          {                              if (!currentField.IsEmpty())                              {                                  parseStatus = ParserState.Invalid;                                  goto quit;                              }                              else                              {                                  // Move past the '\r'                                  requestHeaderState = HeaderFieldState.AfterCarriageReturn;                                  if (++bytesConsumed == effectiveMax)                                  {                                      goto quit;                                  }                                    goto case HeaderFieldState.AfterCarriageReturn;                              }                          }                            if (++bytesConsumed == effectiveMax)                          {                              string headerFieldName = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentField.Name.Append(headerFieldName);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string headerFieldName = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentField.Name.Append(headerFieldName);                      }                        // Move past the ':'                      requestHeaderState = HeaderFieldState.Value;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HeaderFieldState.Value;                    case HeaderFieldState.Value:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (++bytesConsumed == effectiveMax)                          {                              string headerFieldValue = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentField.Value.Append(headerFieldValue);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string headerFieldValue = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentField.Value.Append(headerFieldValue);                      }                        // Move past the CR                      requestHeaderState = HeaderFieldState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HeaderFieldState.AfterCarriageReturn;                    case HeaderFieldState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        if (currentField.IsEmpty())                      {                          parseStatus = ParserState.Done;                          bytesConsumed++;                          goto quit;                      }                        requestHeaderState = HeaderFieldState.FoldingLine;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HeaderFieldState.FoldingLine;                    case HeaderFieldState.FoldingLine:                      if (buffer[bytesConsumed] != ' ' && buffer[bytesConsumed] != '\t')                      {                          currentField.CopyTo(headers' ignoreHeaderValidation);                          requestHeaderState = HeaderFieldState.Name;                          if (bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case HeaderFieldState.Name;                      }                        // Unfold line by inserting SP instead                      currentField.Value.Append(' ');                        // Continue parsing header field value                      requestHeaderState = HeaderFieldState.Value;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HeaderFieldState.Value;              }
Missing Default,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\repos\ASP-NET-MVC_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The following switch statement is missing a default case: switch (bodyPartState)              {                  case BodyPartState.BodyPart:                      while (buffer[bytesConsumed] != MimeMultipartParser.CR)                      {                          if (++bytesConsumed == effectiveMax)                          {                              goto quit;                          }                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.CR);                        // Move past the CR                      bodyPartState = BodyPartState.AfterFirstCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.AfterFirstCarriageReturn;                    case BodyPartState.AfterFirstCarriageReturn:                      if (buffer[bytesConsumed] != MimeMultipartParser.LF)                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.LF);                        // Move past the CR                      bodyPartState = BodyPartState.AfterFirstLineFeed;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.AfterFirstLineFeed;                    case BodyPartState.AfterFirstLineFeed:                      if (buffer[bytesConsumed] == MimeMultipartParser.CR)                      {                          // Remember potential boundary                          currentBodyPart.ResetBoundary();                          currentBodyPart.AppendBoundary(MimeMultipartParser.CR);                            // Move past the CR                          bodyPartState = BodyPartState.AfterFirstCarriageReturn;                          if (++bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case BodyPartState.AfterFirstCarriageReturn;                      }                        if (buffer[bytesConsumed] != MimeMultipartParser.Dash)                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.Dash);                        // Move past the Dash                      bodyPartState = BodyPartState.AfterFirstDash;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.AfterFirstDash;                    case BodyPartState.AfterFirstDash:                      if (buffer[bytesConsumed] != MimeMultipartParser.Dash)                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.Dash);                        // Move past the Dash                      bodyPartState = BodyPartState.Boundary;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.Boundary;                    case BodyPartState.Boundary:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != MimeMultipartParser.CR)                      {                          if (++bytesConsumed == effectiveMax)                          {                              if (currentBodyPart.AppendBoundary(buffer' segmentStart' bytesConsumed - segmentStart))                              {                                  if (currentBodyPart.IsBoundaryComplete())                                  {                                      // At this point we've seen the end of a boundary segment that is aligned at the end                                      // of the buffer - this might be because we have another segment coming or it might                                      // truly be the end of the message.                                      bodyPartState = BodyPartState.AfterBoundary;                                  }                              }                              else                              {                                  currentBodyPart.ResetBoundary();                                  bodyPartState = BodyPartState.BodyPart;                              }                              goto quit;                          }                      }                                            if (bytesConsumed > segmentStart)                      {                          if (!currentBodyPart.AppendBoundary(buffer' segmentStart' bytesConsumed - segmentStart))                          {                              currentBodyPart.ResetBoundary();                              bodyPartState = BodyPartState.BodyPart;                              goto case BodyPartState.BodyPart;                          }                      }                        goto case BodyPartState.AfterBoundary;                    case BodyPartState.AfterBoundary:                        // This state means that we just saw the end of a boundary. It might by a 'normal' boundary' in which                      // case it's followed by optional whitespace and a CRLF. Or it might be the 'final' boundary and will                       // be followed by '--'' optional whitespace and an optional CRLF.                      if (buffer[bytesConsumed] == MimeMultipartParser.Dash && !currentBodyPart.IsFinal)                      {                          currentBodyPart.AppendBoundary(MimeMultipartParser.Dash);                          if (++bytesConsumed == effectiveMax)                          {                              bodyPartState = BodyPartState.AfterSecondDash;                              goto quit;                          }                            goto case BodyPartState.AfterSecondDash;                      }                        // Capture optional whitespace                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != MimeMultipartParser.CR)                      {                          if (++bytesConsumed == effectiveMax)                          {                              if (!currentBodyPart.AppendBoundary(buffer' segmentStart' bytesConsumed - segmentStart))                              {                                  // It's an unexpected character                                  currentBodyPart.ResetBoundary();                                  bodyPartState = BodyPartState.BodyPart;                              }                                goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          if (!currentBodyPart.AppendBoundary(buffer' segmentStart' bytesConsumed - segmentStart))                          {                              currentBodyPart.ResetBoundary();                              bodyPartState = BodyPartState.BodyPart;                              goto case BodyPartState.BodyPart;                          }                      }                        if (buffer[bytesConsumed] == MimeMultipartParser.CR)                      {                          currentBodyPart.AppendBoundary(MimeMultipartParser.CR);                          if (++bytesConsumed == effectiveMax)                          {                              bodyPartState = BodyPartState.AfterSecondCarriageReturn;                              goto quit;                          }                            goto case BodyPartState.AfterSecondCarriageReturn;                      }                      else                      {                          // It's an unexpected character                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                    case BodyPartState.AfterSecondDash:                      if (buffer[bytesConsumed] == MimeMultipartParser.Dash)                      {                          currentBodyPart.AppendBoundary(MimeMultipartParser.Dash);                          bytesConsumed++;                                                    if (currentBodyPart.IsBoundaryComplete())                          {                              Debug.Assert(currentBodyPart.IsFinal);                                // If we get in here' it means we've see the trailing '--' of the last boundary - in order to consume all of the                               // remaining bytes' we don't mark the parse as complete again - wait until this method is called again with the                               // empty buffer to do that.                              bodyPartState = BodyPartState.AfterBoundary;                              parseStatus = State.NeedMoreData;                              goto quit;                          }                          else                          {                              currentBodyPart.ResetBoundary();                              if (bytesConsumed == effectiveMax)                              {                                  goto quit;                              }                                goto case BodyPartState.BodyPart;                          }                      }                      else                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                    case BodyPartState.AfterSecondCarriageReturn:                      if (buffer[bytesConsumed] != MimeMultipartParser.LF)                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                        currentBodyPart.AppendBoundary(MimeMultipartParser.LF);                      bytesConsumed++;                        bodyPartState = BodyPartState.BodyPart;                      if (currentBodyPart.IsBoundaryComplete())                      {                          parseStatus = State.BodyPartCompleted;                          goto quit;                      }                      else                      {                          currentBodyPart.ResetBoundary();                          if (bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case BodyPartState.BodyPart;                      }              }
