Implementation smell,Namespace,Class,File,Method,Description
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,VerifyCapiCompatibleParameters,The length of the statement  "                KeyFormatter.VerifyFormat(IsCapiCompatible(parameters)' "Private key parameters have lengths that are not supported by CAPI."); " is 127.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The length of the statement  "            KeyFormatter.VerifyFormat(hasPrivateKey ? (magicHeader == PrivateKeyMagicHeader) : (magicHeader == PublicKeyMagicHeader)); " is 122.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The length of the statement  "            int bytelen = parameters.Modulus[0] == 0 // if high-order byte is zero' it's for sign bit; don't count in bit-size calculation " is 126.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The length of the statement  "            writer.Write(Encoding.UTF8.GetBytes(KeyFormatter.HasPrivateKey(parameters) ? PrivateKeyMagicHeader : PublicKeyMagicHeader)); " is 124.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' new byte[1])); " is 125.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "            sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.Modulus))); " is 147.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "            sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.Exponent))); " is 148.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.D))); " is 141.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.P))); " is 141.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.Q))); " is 141.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.DP))); " is 142.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.DQ))); " is 142.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.InverseQ))); " is 148.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "            stream.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.Sequence' sequence.ToArray())); " is 133.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs8KeyFormatter.cs,ReadCore,The length of the statement  "            KeyFormatter.VerifyFormat(X509SubjectPublicKeyInfoFormatter.BufferEqual(oid.Content' Pkcs1KeyFormatter.RsaEncryptionObjectIdentifier)' "Unrecognized object identifier."); " is 170.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "            if (sequence.Class != Asn.BerClass.Universal || sequence.PC != Asn.BerPC.Constructed || sequence.Tag != Asn.BerTag.Sequence) " is 124.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "            if (elements.Count != 2 || elements[0].Class != Asn.BerClass.Universal || elements[0].PC != Asn.BerPC.Constructed || elements[0].Tag != Asn.BerTag.Sequence) " is 156.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "            if (elements[1].Class != Asn.BerClass.Universal || elements[1].PC != Asn.BerPC.Primitive || elements[1].Tag != Asn.BerTag.BitString || elements[1].Content[0] != 0) " is 163.
Long Statement,PCLCrypto,BCryptRsaKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\BCryptRsaKeyFormatter.cs,WriteCore,The length of the statement  "            Verify.Operation(parameters.D != null || !this.IncludeFullPrivateKey' "Cannot serialize missing full private key data."); " is 121.
Long Statement,PCLCrypto,KeyFormatterTests,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto.Tests.Shared\KeyFormatterTests.cs,CreateRSAParametersWithShortD,The length of the statement  "                Modulus = WinRTCrypto.CryptographicBuffer.DecodeFromHexString("a4d5f49f3298500af851b031d27754fd63b8df7f37508b2bea15794ae706abc4cc790d5c8f4bac7ac46ac770b53830a28e97fd3bd9d2afdd18b8db9266965413")' " is 194.
Long Statement,PCLCrypto,KeyFormatterTests,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto.Tests.Shared\KeyFormatterTests.cs,CreateRSAParametersWithShortD,The length of the statement  "                P = WinRTCrypto.CryptographicBuffer.DecodeFromHexString("e6505d775acbc8077462f0cdbe22a59fc6c75758a9a097211bc4e071c963e415")' " is 124.
Long Statement,PCLCrypto,KeyFormatterTests,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto.Tests.Shared\KeyFormatterTests.cs,CreateRSAParametersWithShortD,The length of the statement  "                D = WinRTCrypto.CryptographicBuffer.DecodeFromHexString("6b87270cb2f4a9427ebacb35b516235b28b271198bfbfecda6e65b39817bd8907b0e7051b74ddb728f1f29220cef00095d63c224d5a148e14e15a9cb4c6849")' " is 186.
Long Statement,PCLCrypto,KeyFormatterTests,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto.Tests.Shared\KeyFormatterTests.cs,CreateRSAParametersWithShortD,The length of the statement  "                Q = WinRTCrypto.CryptographicBuffer.DecodeFromHexString("b73823d2929601f4f95050e17de1587841cbdc4152444f2352d9f83f54d71987")' " is 124.
Long Statement,PCLCrypto,KeyFormatterTests,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto.Tests.Shared\KeyFormatterTests.cs,CreateRSAParametersWithShortD,The length of the statement  "                DP = WinRTCrypto.CryptographicBuffer.DecodeFromHexString("200f81e352855994081499d6da27f28c5a5c77814523b0c6101a88efee0bf4bd")' " is 125.
Long Statement,PCLCrypto,KeyFormatterTests,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto.Tests.Shared\KeyFormatterTests.cs,CreateRSAParametersWithShortD,The length of the statement  "                DQ = WinRTCrypto.CryptographicBuffer.DecodeFromHexString("1471d6457c07f325f3e00b766e068449bf05d1891475fce2b32f116d77b91ce7")' " is 125.
Long Statement,PCLCrypto,KeyFormatterTests,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto.Tests.Shared\KeyFormatterTests.cs,CreateRSAParametersWithShortD,The length of the statement  "                InverseQ = WinRTCrypto.CryptographicBuffer.DecodeFromHexString("c7e4c27f6596dec9f8d18eb3ccead992ca2ad7241a4abffdecaa5ad5bf965895")' " is 131.
Complex Conditional,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The conditional expression  "elements.Count != 2 || elements[0].Class != Asn.BerClass.Universal || elements[0].PC != Asn.BerPC.Constructed || elements[0].Tag != Asn.BerTag.Sequence"  is complex.
Complex Conditional,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The conditional expression  "elements[1].Class != Asn.BerClass.Universal || elements[1].PC != Asn.BerPC.Primitive || elements[1].Tag != Asn.BerTag.BitString || elements[1].Content[0] != 0"  is complex.
Magic Number,PCLCrypto.Formatters,Asn,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: length <<= 8;
Magic Number,PCLCrypto.Formatters,Asn,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: length > 8 * 1024
Magic Number,PCLCrypto.Formatters,Asn,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: length > 8 * 1024
Magic Number,PCLCrypto.Formatters,Asn,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Asn.cs,WriteAsn1Element,The following statement contains a magic number: element.Content.Length < 128
Magic Number,PCLCrypto.Formatters,Asn,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: return 4;
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,IsCapiCompatible,The following statement contains a magic number: int halfModulusLength = (parameters.Modulus.Length + 1) / 2;
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,NegotiateSizes,The following statement contains a magic number: int halfKeyLength = (keyLength + 1) / 2;
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: string magicHeader = Encoding.UTF8.GetString(reader.ReadBytes(4)' 0' 4);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: string magicHeader = Encoding.UTF8.GetString(reader.ReadBytes(4)' 0' 4);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: int bytelen = bitlen / 8;
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.Exponent = ReadReversed(reader' 4);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.P = ReadReversed(reader' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.Q = ReadReversed(reader' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.DP = ReadReversed(reader' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.DQ = ReadReversed(reader' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.InverseQ = ReadReversed(reader' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: int bitlen = 8 * bytelen;
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: byte[] exponentPadding = new byte[4 - parameters.Exponent.Length];
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed(writer' parameters.P' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed(writer' parameters.Q' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed(writer' parameters.DP' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed(writer' parameters.DQ' bytelen / 2);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed(writer' parameters.InverseQ' bytelen / 2);
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs8KeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\Pkcs8KeyFormatter.cs,ReadCore,The following statement contains a magic number: return KeyFormatter.Pkcs1.Read(sequence[2].Content);
Magic Number,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The following statement contains a magic number: elements.Count != 2 || elements[0].Class != Asn.BerClass.Universal || elements[0].PC != Asn.BerPC.Constructed || elements[0].Tag != Asn.BerTag.Sequence
Magic Number,PCLCrypto,BCryptRsaKeyFormatter,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto\Formatters\BCryptRsaKeyFormatter.cs,WriteCore,The following statement contains a magic number: header.BitLength = modulus.Length * 8;
Magic Number,PCLCrypto,KeyFormatterTests,D:\research\architectureSmells\repos\AArnott_PCLCrypto\src\PCLCrypto.Tests.Shared\KeyFormatterTests.cs,KeyFormatterTests,The following statement contains a magic number: rsaParameters = new Lazy<RSAParameters>(() =>              {                  var algorithm = WinRTCrypto.AsymmetricKeyAlgorithmProvider.OpenAlgorithm(AsymmetricAlgorithm.RsaOaepSha1);                  using (var key = algorithm.CreateKeyPair(512))                  {                      const CryptographicPrivateKeyBlobType keyBlobFormat = CryptographicPrivateKeyBlobType.BCryptFullPrivateKey;                      byte[] bcryptNative = key.Export(keyBlobFormat);                      var rsaParameters = KeyFormatter.GetFormatter(keyBlobFormat).Read(bcryptNative);                      return rsaParameters;                  }              });
