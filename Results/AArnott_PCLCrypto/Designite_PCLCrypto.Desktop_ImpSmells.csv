Implementation smell,Namespace,Class,File,Method,Description
Complex Method,PCLCrypto,CryptoStream,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptoStream.cs,Read,Cyclomatic complexity of the method is 11
Long Parameter List,PCLCrypto,KeyDerivationParametersFactory,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\KeyDerivationParametersFactory.cs,BuildForSP80056a,The method has 5 parameters. Parameters: algorithmId' partyUInfo' partyVInfo' suppPubInfo' suppPrivInfo
Long Parameter List,PCLCrypto,CryptographicHash,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptographicHash.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,PCLCrypto,CryptographicHash,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptographicHash.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,PCLCrypto,ICryptoTransform,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\ICryptoTransform.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,PCLCrypto,IKeyDerivationParametersFactory,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\IKeyDerivationParametersFactory.cs,BuildForSP80056a,The method has 5 parameters. Parameters: algorithmId' partyUInfo' partyVInfo' suppPubInfo' suppPrivInfo
Long Parameter List,PCLCrypto,NetFxCryptographicHash,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFxSymmetric\NetFxCryptographicHash.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,PCLCrypto,CryptoTransformAdaptor,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFxSymmetric\SymmetricCryptographicKey.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Identifier,PCLCrypto,WinRTCrypto,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\WinRTCrypto.cs,,The length of the parameter asymmetricKeyAlgorithmProvider is 30.
Long Identifier,PCLCrypto,WinRTCrypto,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\WinRTCrypto.cs,,The length of the parameter keyDerivationAlgorithmProvider is 30.
Long Identifier,PCLCrypto,WinRTCrypto,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\WinRTCrypto.cs,,The length of the parameter keyDerivationParametersFactory is 30.
Long Statement,PCLCrypto,CryptographicExceptionExtensions,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Desktop\CryptographicExceptionExtensions.cs,IsNotSupportedException,The length of the statement  "                    var hresultField = typeof(CryptographicException).GetField("_HResult"' System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic); " is 155.
Long Statement,PCLCrypto,CryptoStream,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptoStream.cs,Read,The length of the statement  "                        this.outputBufferSize = this.transform.TransformBlock(this.inputBuffer' 0' this.inputBuffer.Length' this.outputBuffer' 0); " is 122.
Long Statement,PCLCrypto,CryptoStream,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptoStream.cs,Write,The length of the statement  "                    int transformedBytes = this.transform.TransformBlock(this.inputBuffer' 0' this.inputBuffer.Length' this.outputBuffer' 0); " is 121.
Long Statement,PCLCrypto,SymmetricCryptographicKey,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,Encrypt,The length of the statement  "            Requires.Argument(paddingInUse || this.IsValidInputSize(data.Length)' "data"' "Length is not a multiple of block size and no padding is selected."); " is 148.
Long Statement,PCLCrypto,SymmetricCryptographicKey,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,Decrypt,The length of the statement  "            Requires.Argument(this.IsValidInputSize(data.Length)' "data"' "Length is not a multiple of block size and no padding is selected."); " is 132.
Long Statement,PCLCrypto,BCryptRsaKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\BCryptRsaKeyFormatter.cs,WriteCore,The length of the statement  "            Verify.Operation(parameters.D != null || !this.IncludeFullPrivateKey' "Cannot serialize missing full private key data."); " is 121.
Long Statement,PCLCrypto,NCryptAsymmetricKey,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKey.cs,ExportPublicKey,The length of the statement  "                byte[] nativeBlob = NCryptExportKey(this.Key' SafeKeyHandle.Null' this.Provider.NativePublicKeyFormatString' IntPtr.Zero).ToArray(); " is 132.
Long Statement,PCLCrypto,NCryptAsymmetricKey,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKey.cs,ExportPublicKey,The length of the statement  "                    : KeyFormatter.GetFormatter(blobType).Write(KeyFormatter.GetFormatter(this.Provider.NativePublicKeyFormatEnum).Read(nativeBlob)); " is 129.
Long Statement,PCLCrypto,NCryptAsymmetricKey,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKey.cs,SignOrVerify,The length of the statement  "                char[] hashAlgorithmName = HashAlgorithmProviderFactory.GetHashAlgorithmName(this.SignatureHash.Value).ToCharArrayWithNullTerminator(); " is 135.
Long Statement,PCLCrypto,NCryptAsymmetricKey,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKey.cs,EncryptOrDecrypt,The length of the statement  "                    fixed (char* hashAlgorithmNamePointer = &HashAlgorithmProviderFactory.GetHashAlgorithmName(this.SignatureHash.Value).ToCharArrayWithNullTerminator()[0]) " is 152.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,VerifyCapiCompatibleParameters,The length of the statement  "                KeyFormatter.VerifyFormat(IsCapiCompatible(parameters)' "Private key parameters have lengths that are not supported by CAPI."); " is 127.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The length of the statement  "            KeyFormatter.VerifyFormat(hasPrivateKey ? (magicHeader == PrivateKeyMagicHeader) : (magicHeader == PublicKeyMagicHeader)); " is 122.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The length of the statement  "            int bytelen = parameters.Modulus[0] == 0 // if high-order byte is zero' it's for sign bit; don't count in bit-size calculation " is 126.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The length of the statement  "            writer.Write(Encoding.UTF8.GetBytes(KeyFormatter.HasPrivateKey(parameters) ? PrivateKeyMagicHeader : PublicKeyMagicHeader)); " is 124.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' new byte[1])); " is 125.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "            sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.Modulus))); " is 147.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "            sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.Exponent))); " is 148.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.D))); " is 141.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.P))); " is 141.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.Q))); " is 141.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.DP))); " is 142.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.DQ))); " is 142.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "                sequence.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero(value.InverseQ))); " is 148.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "            stream.WriteAsn1Element(new Asn.DataElement(Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.Sequence' sequence.ToArray())); " is 133.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,ReadCore,The length of the statement  "            KeyFormatter.VerifyFormat(X509SubjectPublicKeyInfoFormatter.BufferEqual(oid.Content' Pkcs1KeyFormatter.RsaEncryptionObjectIdentifier)' "Unrecognized object identifier."); " is 170.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "            if (sequence.Class != Asn.BerClass.Universal || sequence.PC != Asn.BerPC.Constructed || sequence.Tag != Asn.BerTag.Sequence) " is 124.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "            if (elements.Count != 2 || elements[0].Class != Asn.BerClass.Universal || elements[0].PC != Asn.BerPC.Constructed || elements[0].Tag != Asn.BerTag.Sequence) " is 156.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "            if (elements[1].Class != Asn.BerClass.Universal || elements[1].PC != Asn.BerPC.Primitive || elements[1].Tag != Asn.BerTag.BitString || elements[1].Content[0] != 0) " is 163.
Complex Conditional,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The conditional expression  "elements.Count != 2 || elements[0].Class != Asn.BerClass.Universal || elements[0].PC != Asn.BerPC.Constructed || elements[0].Tag != Asn.BerTag.Sequence"  is complex.
Complex Conditional,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The conditional expression  "elements[1].Class != Asn.BerClass.Universal || elements[1].PC != Asn.BerPC.Primitive || elements[1].Tag != Asn.BerTag.BitString || elements[1].Content[0] != 0"  is complex.
Empty Catch Block,PCLCrypto,CryptographicExceptionExtensions,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Desktop\CryptographicExceptionExtensions.cs,IsNotSupportedException,The method has an empty catch block.
Magic Number,PCLCrypto,CryptographicBuffer,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: Requires.Argument(value.Length % 2 == 0' "value"' "Bad length.");
Magic Number,PCLCrypto,CryptographicBuffer,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: var buffer = new byte[value.Length / 2];
Magic Number,PCLCrypto,CryptographicBuffer,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++)              {                  buffer[i] = Convert.ToByte(value.Substring(i * 2' 2)' 16);              }
Magic Number,PCLCrypto,CryptographicBuffer,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++)              {                  buffer[i] = Convert.ToByte(value.Substring(i * 2' 2)' 16);              }
Magic Number,PCLCrypto,CryptographicBuffer,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++)              {                  buffer[i] = Convert.ToByte(value.Substring(i * 2' 2)' 16);              }
Magic Number,PCLCrypto,CryptographicBuffer,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,EncodeToHexString,The following statement contains a magic number: var builder = new StringBuilder(buffer.Length * 2);
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,CryptoUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.DsaSha1:                  case AsymmetricAlgorithm.DsaSha256:                      range = new KeySizes(512' 1024' 64);                      break;                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      range = new KeySizes(256' 256' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      range = new KeySizes(384' 384' 0);                      break;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      range = new KeySizes(521' 521' 0);                      break;                  case AsymmetricAlgorithm.RsaOaepSha1:                  case AsymmetricAlgorithm.RsaOaepSha256:                  case AsymmetricAlgorithm.RsaOaepSha384:                  case AsymmetricAlgorithm.RsaOaepSha512:                  case AsymmetricAlgorithm.RsaPkcs1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:                  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:                  case AsymmetricAlgorithm.RsaSignPssSha1:                  case AsymmetricAlgorithm.RsaSignPssSha256:                  case AsymmetricAlgorithm.RsaSignPssSha384:                  case AsymmetricAlgorithm.RsaSignPssSha512:                      range = new KeySizes(384' 16384' 8);                      break;                  default:                      throw new NotImplementedException();              }
Magic Number,PCLCrypto,SymmetricCryptographicKey,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,ThisOrDefaultIV,The following statement contains a magic number: if (iv != null)              {                  return iv;              }              else if (!this.Mode.UsesIV())              {                  // Don't create an IV when it doesn't apply.                  return null;              }              else              {                  return new byte[this.algorithm.BlockSize / 8];              }
Magic Number,PCLCrypto,SymmetricCryptographicKey,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,IsValidInputSize,The following statement contains a magic number: return (lengthInBytes * 8) % this.algorithm.BlockSize == 0;
Magic Number,PCLCrypto,BCryptRsaKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\BCryptRsaKeyFormatter.cs,WriteCore,The following statement contains a magic number: header.BitLength = modulus.Length * 8;
Magic Number,PCLCrypto,CngUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      return 256;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      return 384;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      return 521;                  default:                      throw new ArgumentException("algorithm does not specify a key size.");              }
Magic Number,PCLCrypto,CngUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      return 256;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      return 384;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      return 521;                  default:                      throw new ArgumentException("algorithm does not specify a key size.");              }
Magic Number,PCLCrypto,CngUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: switch (algorithm)              {                  case AsymmetricAlgorithm.EcdsaP256Sha256:                      return 256;                  case AsymmetricAlgorithm.EcdsaP384Sha384:                      return 384;                  case AsymmetricAlgorithm.EcdsaP521Sha512:                      return 521;                  default:                      throw new ArgumentException("algorithm does not specify a key size.");              }
Magic Number,PCLCrypto,CngUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (algorithm.GetName())              {                  case AsymmetricAlgorithmName.Dsa:                      return BCrypt.AlgorithmIdentifiers.BCRYPT_DSA_ALGORITHM;                  case AsymmetricAlgorithmName.Ecdsa:                      switch (GetAlgorithmKeySize(algorithm))                      {                          case 256:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;                          case 384:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;                          case 521:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;                          default:                              throw new ArgumentOutOfRangeException();                      }                    case AsymmetricAlgorithmName.Rsa:                  case AsymmetricAlgorithmName.RsaSign:                      return BCrypt.AlgorithmIdentifiers.BCRYPT_RSA_ALGORITHM;                  default:                      throw new NotSupportedException();              }
Magic Number,PCLCrypto,CngUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (algorithm.GetName())              {                  case AsymmetricAlgorithmName.Dsa:                      return BCrypt.AlgorithmIdentifiers.BCRYPT_DSA_ALGORITHM;                  case AsymmetricAlgorithmName.Ecdsa:                      switch (GetAlgorithmKeySize(algorithm))                      {                          case 256:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;                          case 384:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;                          case 521:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;                          default:                              throw new ArgumentOutOfRangeException();                      }                    case AsymmetricAlgorithmName.Rsa:                  case AsymmetricAlgorithmName.RsaSign:                      return BCrypt.AlgorithmIdentifiers.BCRYPT_RSA_ALGORITHM;                  default:                      throw new NotSupportedException();              }
Magic Number,PCLCrypto,CngUtilities,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (algorithm.GetName())              {                  case AsymmetricAlgorithmName.Dsa:                      return BCrypt.AlgorithmIdentifiers.BCRYPT_DSA_ALGORITHM;                  case AsymmetricAlgorithmName.Ecdsa:                      switch (GetAlgorithmKeySize(algorithm))                      {                          case 256:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;                          case 384:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;                          case 521:                              return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;                          default:                              throw new ArgumentOutOfRangeException();                      }                    case AsymmetricAlgorithmName.Rsa:                  case AsymmetricAlgorithmName.RsaSign:                      return BCrypt.AlgorithmIdentifiers.BCRYPT_RSA_ALGORITHM;                  default:                      throw new NotSupportedException();              }
Magic Number,PCLCrypto,NCryptAsymmetricKeyProviderBase,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKeyProviderBase.cs,CreateKeyPair,The following statement contains a magic number: using (var provider = NCryptOpenStorageProvider(KeyStorageProviders.MS_KEY_STORAGE_PROVIDER))              {                  var key = NCryptCreatePersistedKey(provider' CngUtilities.GetAlgorithmId(this.Algorithm));                  NCryptSetProperty(key' KeyStoragePropertyIdentifiers.NCRYPT_LENGTH_PROPERTY' keySize);                  NCryptSetProperty(key' KeyStoragePropertyIdentifiers.NCRYPT_EXPORT_POLICY_PROPERTY' 3);                  NCryptFinalizeKey(key).ThrowOnError();                  return this.CreateKey(key' isPublicOnly: false);              }
Magic Number,PCLCrypto,NCryptAsymmetricKeyProviderBase,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKeyProviderBase.cs,ImportKeyPair,The following statement contains a magic number: using (var provider = NCryptOpenStorageProvider(KeyStorageProviders.MS_KEY_STORAGE_PROVIDER))              {                  byte[] bcryptPrivateBlob;                  string nativeFormatString;                  if (this.NativePrivateKeyFormats.TryGetValue(blobType' out nativeFormatString))                  {                      bcryptPrivateBlob = keyBlob;                  }                  else                  {                      var parameters = KeyFormatter.GetFormatter(blobType).Read(keyBlob);                      bcryptPrivateBlob = KeyFormatter.GetFormatter(this.PreferredNativePrivateKeyFormat).Write(parameters);                      nativeFormatString = this.NativePrivateKeyFormats[this.PreferredNativePrivateKeyFormat];                  }                    var key = NCryptImportKey(provider' null' nativeFormatString' IntPtr.Zero' bcryptPrivateBlob);                  NCryptSetProperty(key' KeyStoragePropertyIdentifiers.NCRYPT_EXPORT_POLICY_PROPERTY' 3);                  return this.CreateKey(key' isPublicOnly: false);              }
Magic Number,PCLCrypto.Formatters,Asn,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: do              {                  int b = stream.ReadByte();                  if (b == -1)                  {                      yield break;                  }                    BerClass clazz = (BerClass)b & BerClass.Mask;                  BerPC pc = (BerPC)b & BerPC.Mask;                  BerTag tag = (BerTag)b & BerTag.Mask;                    uint length = 0;                  b = stream.ReadByte();                  if ((b & 0x80) == 0x80)                  {                      // long form                      byte lengthOfLength = (byte)(b & 0x7F);                      for (int i = 0; i < lengthOfLength; i++)                      {                          // big endian                          b = stream.ReadByte();                          length <<= 8;                          length += (uint)b;                      }                  }                  else                  {                      // short form.                      length = (uint)b;                  }                    if (length > 8 * 1024)                  {                      throw new FormatException("Invalid format or length too large.");                  }                    byte[] content = new byte[length];                  int bytesRead = stream.Read(content' 0' (int)length);                  if (bytesRead != length)                  {                      throw new ArgumentException("Unexpected end of stream.");                  }                    yield return new DataElement(clazz' pc' tag' content);              }              while (true);
Magic Number,PCLCrypto.Formatters,Asn,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: do              {                  int b = stream.ReadByte();                  if (b == -1)                  {                      yield break;                  }                    BerClass clazz = (BerClass)b & BerClass.Mask;                  BerPC pc = (BerPC)b & BerPC.Mask;                  BerTag tag = (BerTag)b & BerTag.Mask;                    uint length = 0;                  b = stream.ReadByte();                  if ((b & 0x80) == 0x80)                  {                      // long form                      byte lengthOfLength = (byte)(b & 0x7F);                      for (int i = 0; i < lengthOfLength; i++)                      {                          // big endian                          b = stream.ReadByte();                          length <<= 8;                          length += (uint)b;                      }                  }                  else                  {                      // short form.                      length = (uint)b;                  }                    if (length > 8 * 1024)                  {                      throw new FormatException("Invalid format or length too large.");                  }                    byte[] content = new byte[length];                  int bytesRead = stream.Read(content' 0' (int)length);                  if (bytesRead != length)                  {                      throw new ArgumentException("Unexpected end of stream.");                  }                    yield return new DataElement(clazz' pc' tag' content);              }              while (true);
Magic Number,PCLCrypto.Formatters,Asn,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: do              {                  int b = stream.ReadByte();                  if (b == -1)                  {                      yield break;                  }                    BerClass clazz = (BerClass)b & BerClass.Mask;                  BerPC pc = (BerPC)b & BerPC.Mask;                  BerTag tag = (BerTag)b & BerTag.Mask;                    uint length = 0;                  b = stream.ReadByte();                  if ((b & 0x80) == 0x80)                  {                      // long form                      byte lengthOfLength = (byte)(b & 0x7F);                      for (int i = 0; i < lengthOfLength; i++)                      {                          // big endian                          b = stream.ReadByte();                          length <<= 8;                          length += (uint)b;                      }                  }                  else                  {                      // short form.                      length = (uint)b;                  }                    if (length > 8 * 1024)                  {                      throw new FormatException("Invalid format or length too large.");                  }                    byte[] content = new byte[length];                  int bytesRead = stream.Read(content' 0' (int)length);                  if (bytesRead != length)                  {                      throw new ArgumentException("Unexpected end of stream.");                  }                    yield return new DataElement(clazz' pc' tag' content);              }              while (true);
Magic Number,PCLCrypto.Formatters,Asn,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,WriteAsn1Element,The following statement contains a magic number: if (element.Content.Length < 128)              {                  // use short form                  stream.WriteByte((byte)element.Content.Length);              }              else              {                  // use long form                  byte lengthOfLength = GetMinimumBytesRequiredToRepresent((uint)element.Content.Length);                  stream.WriteByte((byte)(0x80 + lengthOfLength));                    // We must write this out as big endian. We use an endian-agnostic way of reading out the integer.                  for (int significancePosition = lengthOfLength - 1; significancePosition >= 0; significancePosition--)                  {                      byte lengthOctet = (byte)(0xff & (element.Content.Length >> (8 * significancePosition)));                      stream.WriteByte(lengthOctet);                  }              }
Magic Number,PCLCrypto.Formatters,Asn,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,WriteAsn1Element,The following statement contains a magic number: if (element.Content.Length < 128)              {                  // use short form                  stream.WriteByte((byte)element.Content.Length);              }              else              {                  // use long form                  byte lengthOfLength = GetMinimumBytesRequiredToRepresent((uint)element.Content.Length);                  stream.WriteByte((byte)(0x80 + lengthOfLength));                    // We must write this out as big endian. We use an endian-agnostic way of reading out the integer.                  for (int significancePosition = lengthOfLength - 1; significancePosition >= 0; significancePosition--)                  {                      byte lengthOctet = (byte)(0xff & (element.Content.Length >> (8 * significancePosition)));                      stream.WriteByte(lengthOctet);                  }              }
Magic Number,PCLCrypto.Formatters,Asn,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xffffff)              {                  return 4;              }              else if (value > 0xffff)              {                  return 3;              }              else if (value > 0xff)              {                  return 2;              }              else              {                  return 1;              }
Magic Number,PCLCrypto.Formatters,Asn,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xffffff)              {                  return 4;              }              else if (value > 0xffff)              {                  return 3;              }              else if (value > 0xff)              {                  return 2;              }              else              {                  return 1;              }
Magic Number,PCLCrypto.Formatters,Asn,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xffffff)              {                  return 4;              }              else if (value > 0xffff)              {                  return 3;              }              else if (value > 0xff)              {                  return 2;              }              else              {                  return 1;              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,IsCapiCompatible,The following statement contains a magic number: int halfModulusLength = (parameters.Modulus.Length + 1) / 2;
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: string magicHeader = Encoding.UTF8.GetString(reader.ReadBytes(4)' 0' 4);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: string magicHeader = Encoding.UTF8.GetString(reader.ReadBytes(4)' 0' 4);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: int bytelen = bitlen / 8;
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.Exponent = ReadReversed(reader' 4);
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey)              {                  parameters.P = ReadReversed(reader' bytelen / 2);                  parameters.Q = ReadReversed(reader' bytelen / 2);                  parameters.DP = ReadReversed(reader' bytelen / 2);                  parameters.DQ = ReadReversed(reader' bytelen / 2);                  parameters.InverseQ = ReadReversed(reader' bytelen / 2);                  parameters.D = ReadReversed(reader' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey)              {                  parameters.P = ReadReversed(reader' bytelen / 2);                  parameters.Q = ReadReversed(reader' bytelen / 2);                  parameters.DP = ReadReversed(reader' bytelen / 2);                  parameters.DQ = ReadReversed(reader' bytelen / 2);                  parameters.InverseQ = ReadReversed(reader' bytelen / 2);                  parameters.D = ReadReversed(reader' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey)              {                  parameters.P = ReadReversed(reader' bytelen / 2);                  parameters.Q = ReadReversed(reader' bytelen / 2);                  parameters.DP = ReadReversed(reader' bytelen / 2);                  parameters.DQ = ReadReversed(reader' bytelen / 2);                  parameters.InverseQ = ReadReversed(reader' bytelen / 2);                  parameters.D = ReadReversed(reader' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey)              {                  parameters.P = ReadReversed(reader' bytelen / 2);                  parameters.Q = ReadReversed(reader' bytelen / 2);                  parameters.DP = ReadReversed(reader' bytelen / 2);                  parameters.DQ = ReadReversed(reader' bytelen / 2);                  parameters.InverseQ = ReadReversed(reader' bytelen / 2);                  parameters.D = ReadReversed(reader' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey)              {                  parameters.P = ReadReversed(reader' bytelen / 2);                  parameters.Q = ReadReversed(reader' bytelen / 2);                  parameters.DP = ReadReversed(reader' bytelen / 2);                  parameters.DQ = ReadReversed(reader' bytelen / 2);                  parameters.InverseQ = ReadReversed(reader' bytelen / 2);                  parameters.D = ReadReversed(reader' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: int bitlen = 8 * bytelen;
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: byte[] exponentPadding = new byte[4 - parameters.Exponent.Length];
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey(parameters))              {                  WriteReversed(writer' parameters.P' bytelen / 2);                  WriteReversed(writer' parameters.Q' bytelen / 2);                  WriteReversed(writer' parameters.DP' bytelen / 2);                  WriteReversed(writer' parameters.DQ' bytelen / 2);                  WriteReversed(writer' parameters.InverseQ' bytelen / 2);                  WriteReversed(writer' parameters.D' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey(parameters))              {                  WriteReversed(writer' parameters.P' bytelen / 2);                  WriteReversed(writer' parameters.Q' bytelen / 2);                  WriteReversed(writer' parameters.DP' bytelen / 2);                  WriteReversed(writer' parameters.DQ' bytelen / 2);                  WriteReversed(writer' parameters.InverseQ' bytelen / 2);                  WriteReversed(writer' parameters.D' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey(parameters))              {                  WriteReversed(writer' parameters.P' bytelen / 2);                  WriteReversed(writer' parameters.Q' bytelen / 2);                  WriteReversed(writer' parameters.DP' bytelen / 2);                  WriteReversed(writer' parameters.DQ' bytelen / 2);                  WriteReversed(writer' parameters.InverseQ' bytelen / 2);                  WriteReversed(writer' parameters.D' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey(parameters))              {                  WriteReversed(writer' parameters.P' bytelen / 2);                  WriteReversed(writer' parameters.Q' bytelen / 2);                  WriteReversed(writer' parameters.DP' bytelen / 2);                  WriteReversed(writer' parameters.DQ' bytelen / 2);                  WriteReversed(writer' parameters.InverseQ' bytelen / 2);                  WriteReversed(writer' parameters.D' bytelen);              }
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey(parameters))              {                  WriteReversed(writer' parameters.P' bytelen / 2);                  WriteReversed(writer' parameters.Q' bytelen / 2);                  WriteReversed(writer' parameters.DP' bytelen / 2);                  WriteReversed(writer' parameters.DQ' bytelen / 2);                  WriteReversed(writer' parameters.InverseQ' bytelen / 2);                  WriteReversed(writer' parameters.D' bytelen);              }
Magic Number,PCLCrypto.Formatters,KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\KeyFormatter.cs,NegotiateSizes,The following statement contains a magic number: if (HasPrivateKey(parameters))              {                  if (CapiKeyFormatter.IsCapiCompatible(parameters))                  {                      // Don't change a thing. Everything is perfect.                      return parameters;                  }                    parameters.Modulus = TrimLeadingZero(parameters.Modulus);                  parameters.D = TrimLeadingZero(parameters.D);                  int keyLength = Math.Max(parameters.Modulus.Length' parameters.D?.Length ?? 0);                  parameters.Modulus = TrimOrPadZeroToLength(parameters.Modulus' keyLength);                  parameters.D = TrimOrPadZeroToLength(parameters.D' keyLength);                    int halfKeyLength = (keyLength + 1) / 2;                  parameters.P = TrimOrPadZeroToLength(parameters.P' halfKeyLength);                  parameters.Q = TrimOrPadZeroToLength(parameters.Q' halfKeyLength);                  parameters.DP = TrimOrPadZeroToLength(parameters.DP' halfKeyLength);                  parameters.DQ = TrimOrPadZeroToLength(parameters.DQ' halfKeyLength);                  parameters.InverseQ = TrimOrPadZeroToLength(parameters.InverseQ' halfKeyLength);              }              else              {                  parameters.Modulus = TrimLeadingZero(parameters.Modulus);              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count)              {                  case 2:                      return new RSAParameters                      {                          Modulus = sequence[0].Content'                          Exponent = sequence[1].Content'                      };                  case 9:                      KeyFormatter.VerifyFormat(sequence[0].Content.Length == 1 && sequence[0].Content[0] == 0' "Unsupported version.");                      return new RSAParameters                      {                          Modulus = sequence[1].Content'                          Exponent = sequence[2].Content'                          D = sequence[3].Content'                          P = sequence[4].Content'                          Q = sequence[5].Content'                          DP = sequence[6].Content'                          DQ = sequence[7].Content'                          InverseQ = sequence[8].Content'                      };                  default:                      throw KeyFormatter.FailFormat();              }
Magic Number,PCLCrypto.Formatters,Pkcs8KeyFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,ReadCore,The following statement contains a magic number: return KeyFormatter.Pkcs1.Read(sequence[2].Content);
Magic Number,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,C:\repos\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The following statement contains a magic number: if (elements.Count != 2 || elements[0].Class != Asn.BerClass.Universal || elements[0].PC != Asn.BerPC.Constructed || elements[0].Tag != Asn.BerTag.Sequence)              {                  throw new ArgumentException("Unexpected format.");              }
