Implementation smell,Namespace,Class,File,Method,Description
Complex Method,PCLCrypto,AsymmetricKeyAlgorithmProviderFactory,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\AsymmetricKeyAlgorithmProviderFactory.cs,OpenAlgorithm,Cyclomatic complexity of the method is 20
Complex Method,PCLCrypto,AsymmetricKeyAlgorithmProviderFactory,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\AsymmetricKeyAlgorithmProviderFactory.cs,GetHashAlgorithmEnum,Cyclomatic complexity of the method is 19
Complex Method,PCLCrypto,MacAlgorithmProviderFactory,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\MacAlgorithmProviderFactory.cs,GetAlgorithmName,Cyclomatic complexity of the method is 8
Complex Method,PCLCrypto,AsymmetricAlgorithmExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\AsymmetricAlgorithmExtensions.cs,GetName,Cyclomatic complexity of the method is 20
Complex Method,PCLCrypto,AsymmetricAlgorithmExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\AsymmetricAlgorithmExtensions.cs,GetSignaturePadding,Cyclomatic complexity of the method is 20
Complex Method,PCLCrypto,AsymmetricAlgorithmExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\AsymmetricAlgorithmExtensions.cs,GetEncryptionPadding,Cyclomatic complexity of the method is 20
Complex Method,PCLCrypto,AsymmetricAlgorithmExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\AsymmetricAlgorithmExtensions.cs,GetHashAlgorithm,Cyclomatic complexity of the method is 20
Complex Method,PCLCrypto,CryptoStream,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptoStream.cs,Read,Cyclomatic complexity of the method is 11
Complex Method,PCLCrypto,SymmetricAlgorithmExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\SymmetricAlgorithmExtensions.cs,GetName,Cyclomatic complexity of the method is 21
Complex Method,PCLCrypto,SymmetricAlgorithmExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\SymmetricAlgorithmExtensions.cs,GetMode,Cyclomatic complexity of the method is 21
Complex Method,PCLCrypto,SymmetricAlgorithmExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\SymmetricAlgorithmExtensions.cs,GetPadding,Cyclomatic complexity of the method is 21
Complex Method,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,Cyclomatic complexity of the method is 30
Complex Method,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,Cyclomatic complexity of the method is 9
Long Parameter List,PCLCrypto,KeyDerivationParametersFactory,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\KeyDerivationParametersFactory.cs,BuildForSP80056a,The method has 5 parameters.
Long Parameter List,PCLCrypto,CryptographicHash,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptographicHash.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,PCLCrypto,CryptographicHash,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptographicHash.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,PCLCrypto,ICryptoTransform,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\ICryptoTransform.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,PCLCrypto,IKeyDerivationParametersFactory,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\IKeyDerivationParametersFactory.cs,BuildForSP80056a,The method has 5 parameters.
Long Parameter List,PCLCrypto,NetFxCryptographicHash,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFxSymmetric\NetFxCryptographicHash.cs,TransformBlock,The method has 5 parameters.
Long Statement,PCLCrypto,CryptographicExceptionExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Desktop\CryptographicExceptionExtensions.cs,IsNotSupportedException,The length of the statement  "			var hresultField = typeof(CryptographicException).GetField ("_HResult"' System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic); " is 156.
Long Statement,PCLCrypto,ECDiffieHellmanCngPublicKeyFactory,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Desktop\ECDiffieHellmanCngPublicKeyFactory.cs,FromByteArray,The length of the statement  "	return new ECDiffieHellmanPublicKey (Platform.ECDiffieHellmanCngPublicKey.FromByteArray (publicKey' Platform.CngKeyBlobFormat.EccPublicBlob)); " is 142.
Long Statement,PCLCrypto,CryptoStream,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptoStream.cs,Read,The length of the statement  "				this.outputBufferSize = this.transform.TransformBlock (this.inputBuffer' 0' this.inputBuffer.Length' this.outputBuffer' 0); " is 123.
Long Statement,PCLCrypto,CryptoStream,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\CryptoStream.cs,Write,The length of the statement  "			int transformedBytes = this.transform.TransformBlock (this.inputBuffer' 0' this.inputBuffer.Length' this.outputBuffer' 0); " is 122.
Long Statement,PCLCrypto,WinRTExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\WinRTExtensions.cs,ImportParameters,The length of the statement  "	return KeyFormatter.HasPrivateKey (parameters) ? provider.ImportKeyPair (keyBlob' CryptographicPrivateKeyBlobType.Pkcs1RsaPrivateKey) : provider.ImportPublicKey (keyBlob' CryptographicPublicKeyBlobType.Pkcs1RsaPublicKey); " is 221.
Long Statement,PCLCrypto,WinRTExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Common\WinRTExtensions.cs,ExportParameters,The length of the statement  "	byte[] keyBlob = includePrivateParameters ? key.Export (CryptographicPrivateKeyBlobType.Pkcs1RsaPrivateKey) : key.ExportPublicKey (CryptographicPublicKeyBlobType.Pkcs1RsaPublicKey); " is 181.
Long Statement,PCLCrypto,RSAParametersExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\RSAParametersExtensions.cs,Create,The length of the statement  "	var addlParameters = GetFullPrivateParameters (p: CryptoUtilities.FromPositiveBigEndian (p)' q: CryptoUtilities.FromPositiveBigEndian (q)' e: CryptoUtilities.FromPositiveBigEndian (exponent)' n: CryptoUtilities.FromPositiveBigEndian (modulus)); " is 244.
Long Statement,PCLCrypto,SymmetricCryptographicKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,Encrypt,The length of the statement  "	Requires.Argument (paddingInUse || this.IsValidInputSize (data.Length)' "data"' "Length is not a multiple of block size and no padding is selected."); " is 150.
Long Statement,PCLCrypto,SymmetricCryptographicKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,Encrypt,The length of the statement  "	return this.CipherOperation (ref this.encryptor' (me' initVector) => me.algorithm.CreateEncryptor (me.algorithm.Key' me.ThisOrDefaultIV (initVector))' data' iv); " is 161.
Long Statement,PCLCrypto,SymmetricCryptographicKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,Decrypt,The length of the statement  "	Requires.Argument (this.IsValidInputSize (data.Length)' "data"' "Length is not a multiple of block size and no padding is selected."); " is 134.
Long Statement,PCLCrypto,SymmetricCryptographicKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,Decrypt,The length of the statement  "	return this.CipherOperation (ref this.decryptor' (me' initVector) => me.algorithm.CreateDecryptor (me.algorithm.Key' me.ThisOrDefaultIV (initVector))' data' iv); " is 161.
Long Statement,PCLCrypto,BCryptRsaKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\BCryptRsaKeyFormatter.cs,WriteCore,The length of the statement  "	Verify.Operation (parameters.D != null || !this.IncludeFullPrivateKey' "Cannot serialize missing full private key data."); " is 122.
Long Statement,PCLCrypto,NCryptAsymmetricKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKey.cs,ExportPublicKey,The length of the statement  "		byte[] nativeBlob = NCryptExportKey (this.Key' SafeKeyHandle.Null' this.Provider.NativePublicKeyFormatString' IntPtr.Zero).ToArray (); " is 134.
Long Statement,PCLCrypto,NCryptAsymmetricKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKey.cs,ExportPublicKey,The length of the statement  "		byte[] formattedBlob = blobType == this.Provider.NativePublicKeyFormatEnum ? nativeBlob : KeyFormatter.GetFormatter (blobType).Write (KeyFormatter.GetFormatter (this.Provider.NativePublicKeyFormatEnum).Read (nativeBlob)); " is 221.
Long Statement,PCLCrypto,NCryptAsymmetricKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKey.cs,SignOrVerify,The length of the statement  "		char[] hashAlgorithmName = HashAlgorithmProviderFactory.GetHashAlgorithmName (this.SignatureHash.Value).ToCharArrayWithNullTerminator (); " is 137.
Long Statement,PCLCrypto,NCryptAsymmetricKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKey.cs,EncryptOrDecrypt,The length of the statement  "		fixed (char* hashAlgorithmNamePointer = &HashAlgorithmProviderFactory.GetHashAlgorithmName (this.SignatureHash.Value).ToCharArrayWithNullTerminator () [0]) { " is 157.
Long Statement,PCLCrypto,NCryptAsymmetricKeyProviderBase,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKeyProviderBase.cs,ImportPublicKey,The length of the statement  "		byte[] bcryptPublicBlob = blobType == this.NativePublicKeyFormatEnum ? keyBlob : KeyFormatter.GetFormatter (this.NativePublicKeyFormatEnum).Write (KeyFormatter.GetFormatter (blobType).Read (keyBlob)); " is 200.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,IsCapiCompatible,The length of the statement  "	return halfModulusLength == parameters.P.Length && halfModulusLength == parameters.Q.Length && halfModulusLength == parameters.DP.Length && halfModulusLength == parameters.DQ.Length && halfModulusLength == parameters.InverseQ.Length && parameters.Modulus.Length == parameters.D.Length; " is 285.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,VerifyCapiCompatibleParameters,The length of the statement  "		KeyFormatter.VerifyFormat (IsCapiCompatible (parameters)' "Private key parameters have lengths that are not supported by CAPI."); " is 129.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The length of the statement  "	KeyFormatter.VerifyFormat (hasPrivateKey ? (magicHeader == PrivateKeyMagicHeader) : (magicHeader == PublicKeyMagicHeader)); " is 123.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The length of the statement  "	int bytelen = parameters.Modulus [0] == 0 // if high-order byte is zero' it's for sign bit; don't count in bit-size calculation " is 127.
Long Statement,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The length of the statement  "	writer.Write (Encoding.UTF8.GetBytes (KeyFormatter.HasPrivateKey (parameters) ? PrivateKeyMagicHeader : PublicKeyMagicHeader)); " is 127.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The length of the statement  "	KeyFormatter.VerifyFormat (keyBlobElement.Class == Asn.BerClass.Universal && keyBlobElement.PC == Asn.BerPC.Constructed && keyBlobElement.Tag == Asn.BerTag.Sequence); " is 166.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "		sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' new byte[1])); " is 127.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "	sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero (value.Modulus))); " is 150.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "	sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero (value.Exponent))); " is 151.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "		sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero (value.D))); " is 144.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "		sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero (value.P))); " is 144.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "		sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero (value.Q))); " is 144.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "		sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero (value.DP))); " is 145.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "		sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero (value.DQ))); " is 145.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "		sequence.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Integer' PrependLeadingZero (value.InverseQ))); " is 151.
Long Statement,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,WriteCore,The length of the statement  "	stream.WriteAsn1Element (new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.Sequence' sequence.ToArray ())); " is 136.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,ReadCore,The length of the statement  "	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0x00' "Unrecognized version."); " is 122.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,ReadCore,The length of the statement  "	KeyFormatter.VerifyFormat (X509SubjectPublicKeyInfoFormatter.BufferEqual (oid.Content' Pkcs1KeyFormatter.RsaEncryptionObjectIdentifier)' "Unrecognized object identifier."); " is 172.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,WriteCore,The length of the statement  "	var rootElement = new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.Sequence' new Asn.DataElement (// Version 0 " is 140.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,WriteCore,The length of the statement  "	})' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.Sequence' new Asn.DataElement (// privateKeyAlgorithm " is 136.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,WriteCore,The length of the statement  "	Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.ObjectIdentifier' Pkcs1KeyFormatter.RsaEncryptionObjectIdentifier)' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Null' new byte[0]))' new Asn.DataElement (// rsaPrivateKey " is 259.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,WriteCore,The length of the statement  "	Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.OctetString' KeyFormatter.Pkcs1.Write (parameters' HasPrivateKey (parameters)))' new Asn.DataElement (Asn.BerClass.ContextSpecific' Asn.BerPC.Constructed' Asn.BerTag.EndOfContent' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.Sequence' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.ObjectIdentifier' new byte[] { " is 432.
Long Statement,PCLCrypto.Formatters,Pkcs8KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,WriteCore,The length of the statement  "	})' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.SetAndSetOf' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.BitString' new byte[] { " is 196.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "	if (sequence.Class != Asn.BerClass.Universal || sequence.PC != Asn.BerPC.Constructed || sequence.Tag != Asn.BerTag.Sequence) { " is 126.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "	if (elements.Count != 2 || elements [0].Class != Asn.BerClass.Universal || elements [0].PC != Asn.BerPC.Constructed || elements [0].Tag != Asn.BerTag.Sequence) { " is 161.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The length of the statement  "	if (elements [1].Class != Asn.BerClass.Universal || elements [1].PC != Asn.BerPC.Primitive || elements [1].Tag != Asn.BerTag.BitString || elements [1].Content [0] != 0) { " is 170.
Long Statement,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,WriteCore,The length of the statement  "	var rootElement = new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.Sequence' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Constructed' Asn.BerTag.Sequence' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.ObjectIdentifier' Pkcs1KeyFormatter.RsaEncryptionObjectIdentifier)' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.Null' new byte[0]))' new Asn.DataElement (Asn.BerClass.Universal' Asn.BerPC.Primitive' Asn.BerTag.BitString' PrependLeadingZero (KeyFormatter.Pkcs1.Write (parameters' includePrivateKey: false)' alwaysPrependZero: true))); " is 639.
Complex Conditional,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The conditional expression  "elements.Count != 2 || elements [0].Class != Asn.BerClass.Universal || elements [0].PC != Asn.BerPC.Constructed || elements [0].Tag != Asn.BerTag.Sequence"  is complex.
Complex Conditional,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The conditional expression  "elements [1].Class != Asn.BerClass.Universal || elements [1].PC != Asn.BerPC.Primitive || elements [1].Tag != Asn.BerTag.BitString || elements [1].Content [0] != 0"  is complex.
Empty Catch Block,PCLCrypto,CryptographicExceptionExtensions,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Desktop\CryptographicExceptionExtensions.cs,IsNotSupportedException,The method has an empty catch block.
Magic Number,PCLCrypto,CryptographicBuffer,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: Requires.Argument (value.Length % 2 == 0' "value"' "Bad length.");  
Magic Number,PCLCrypto,CryptographicBuffer,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++) {  	buffer [i] = Convert.ToByte (value.Substring (i * 2' 2)' 16);  }  
Magic Number,PCLCrypto,CryptographicBuffer,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++) {  	buffer [i] = Convert.ToByte (value.Substring (i * 2' 2)' 16);  }  
Magic Number,PCLCrypto,CryptographicBuffer,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++) {  	buffer [i] = Convert.ToByte (value.Substring (i * 2' 2)' 16);  }  
Magic Number,PCLCrypto,CryptographicBuffer,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: buffer [i] = Convert.ToByte (value.Substring (i * 2' 2)' 16);  
Magic Number,PCLCrypto,CryptographicBuffer,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: buffer [i] = Convert.ToByte (value.Substring (i * 2' 2)' 16);  
Magic Number,PCLCrypto,CryptographicBuffer,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.NetFx\CryptographicBuffer.cs,DecodeFromHexString,The following statement contains a magic number: buffer [i] = Convert.ToByte (value.Substring (i * 2' 2)' 16);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.DsaSha1:  case AsymmetricAlgorithm.DsaSha256:  	range = new KeySizes (512' 1024' 64);  	break;  case AsymmetricAlgorithm.EcdsaP256Sha256:  	range = new KeySizes (256' 256' 0);  	break;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	range = new KeySizes (384' 384' 0);  	break;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	range = new KeySizes (521' 521' 0);  	break;  case AsymmetricAlgorithm.RsaOaepSha1:  case AsymmetricAlgorithm.RsaOaepSha256:  case AsymmetricAlgorithm.RsaOaepSha384:  case AsymmetricAlgorithm.RsaOaepSha512:  case AsymmetricAlgorithm.RsaPkcs1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha1:  case AsymmetricAlgorithm.RsaSignPkcs1Sha256:  case AsymmetricAlgorithm.RsaSignPkcs1Sha384:  case AsymmetricAlgorithm.RsaSignPkcs1Sha512:  case AsymmetricAlgorithm.RsaSignPssSha1:  case AsymmetricAlgorithm.RsaSignPssSha256:  case AsymmetricAlgorithm.RsaSignPssSha384:  case AsymmetricAlgorithm.RsaSignPssSha512:  	range = new KeySizes (384' 16384' 8);  	break;  default:  	throw new NotImplementedException ();  }  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (512' 1024' 64);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (512' 1024' 64);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (512' 1024' 64);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (256' 256' 0);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (256' 256' 0);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (384' 384' 0);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (384' 384' 0);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (521' 521' 0);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (521' 521' 0);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (384' 16384' 8);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (384' 16384' 8);  
Magic Number,PCLCrypto,CryptoUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\CryptoUtilities.cs,GetTypicalLegalAsymmetricKeySizes,The following statement contains a magic number: range = new KeySizes (384' 16384' 8);  
Magic Number,PCLCrypto,SymmetricCryptographicKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,ThisOrDefaultIV,The following statement contains a magic number: if (iv != null) {  	return iv;  } else if (!this.Mode.UsesIV ()) {  	// Don't create an IV when it doesn't apply.  	return null;  } else {  	return new byte[this.algorithm.BlockSize / 8];  }  
Magic Number,PCLCrypto,SymmetricCryptographicKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,ThisOrDefaultIV,The following statement contains a magic number: if (!this.Mode.UsesIV ()) {  	// Don't create an IV when it doesn't apply.  	return null;  } else {  	return new byte[this.algorithm.BlockSize / 8];  }  
Magic Number,PCLCrypto,SymmetricCryptographicKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,ThisOrDefaultIV,The following statement contains a magic number: return new byte[this.algorithm.BlockSize / 8];  
Magic Number,PCLCrypto,SymmetricCryptographicKey,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.PlatformCommon\SymmetricCryptographicKey.Shared.cs,IsValidInputSize,The following statement contains a magic number: return (lengthInBytes * 8) % this.algorithm.BlockSize == 0;  
Magic Number,PCLCrypto,BCryptRsaKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\BCryptRsaKeyFormatter.cs,WriteCore,The following statement contains a magic number: header.BitLength = modulus.Length * 8;  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.EcdsaP256Sha256:  	return 256;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	return 384;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	return 521;  default:  	throw new ArgumentException ("algorithm does not specify a key size.");  }  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.EcdsaP256Sha256:  	return 256;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	return 384;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	return 521;  default:  	throw new ArgumentException ("algorithm does not specify a key size.");  }  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: switch (algorithm) {  case AsymmetricAlgorithm.EcdsaP256Sha256:  	return 256;  case AsymmetricAlgorithm.EcdsaP384Sha384:  	return 384;  case AsymmetricAlgorithm.EcdsaP521Sha512:  	return 521;  default:  	throw new ArgumentException ("algorithm does not specify a key size.");  }  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: return 256;  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: return 384;  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmKeySize,The following statement contains a magic number: return 521;  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (algorithm.GetName ()) {  case AsymmetricAlgorithmName.Dsa:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_DSA_ALGORITHM;  case AsymmetricAlgorithmName.Ecdsa:  	switch (GetAlgorithmKeySize (algorithm)) {  	case 256:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;  	case 384:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;  	case 521:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;  	default:  		throw new ArgumentOutOfRangeException ();  	}  case AsymmetricAlgorithmName.Rsa:  case AsymmetricAlgorithmName.RsaSign:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_RSA_ALGORITHM;  default:  	throw new NotSupportedException ();  }  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (algorithm.GetName ()) {  case AsymmetricAlgorithmName.Dsa:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_DSA_ALGORITHM;  case AsymmetricAlgorithmName.Ecdsa:  	switch (GetAlgorithmKeySize (algorithm)) {  	case 256:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;  	case 384:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;  	case 521:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;  	default:  		throw new ArgumentOutOfRangeException ();  	}  case AsymmetricAlgorithmName.Rsa:  case AsymmetricAlgorithmName.RsaSign:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_RSA_ALGORITHM;  default:  	throw new NotSupportedException ();  }  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (algorithm.GetName ()) {  case AsymmetricAlgorithmName.Dsa:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_DSA_ALGORITHM;  case AsymmetricAlgorithmName.Ecdsa:  	switch (GetAlgorithmKeySize (algorithm)) {  	case 256:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;  	case 384:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;  	case 521:  		return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;  	default:  		throw new ArgumentOutOfRangeException ();  	}  case AsymmetricAlgorithmName.Rsa:  case AsymmetricAlgorithmName.RsaSign:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_RSA_ALGORITHM;  default:  	throw new NotSupportedException ();  }  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (GetAlgorithmKeySize (algorithm)) {  case 256:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;  case 384:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;  case 521:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (GetAlgorithmKeySize (algorithm)) {  case 256:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;  case 384:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;  case 521:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,PCLCrypto,CngUtilities,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\CngUtilities.cs,GetAlgorithmId,The following statement contains a magic number: switch (GetAlgorithmKeySize (algorithm)) {  case 256:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P256_ALGORITHM;  case 384:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P384_ALGORITHM;  case 521:  	return BCrypt.AlgorithmIdentifiers.BCRYPT_ECDSA_P521_ALGORITHM;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,PCLCrypto,NCryptAsymmetricKeyProviderBase,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKeyProviderBase.cs,CreateKeyPair,The following statement contains a magic number: using (var provider = NCryptOpenStorageProvider (KeyStorageProviders.MS_KEY_STORAGE_PROVIDER)) {  	var key = NCryptCreatePersistedKey (provider' CngUtilities.GetAlgorithmId (this.Algorithm));  	NCryptSetProperty (key' KeyStoragePropertyIdentifiers.NCRYPT_LENGTH_PROPERTY' keySize);  	NCryptSetProperty (key' KeyStoragePropertyIdentifiers.NCRYPT_EXPORT_POLICY_PROPERTY' 3);  	NCryptFinalizeKey (key).ThrowOnError ();  	return this.CreateKey (key' isPublicOnly: false);  }  
Magic Number,PCLCrypto,NCryptAsymmetricKeyProviderBase,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKeyProviderBase.cs,CreateKeyPair,The following statement contains a magic number: NCryptSetProperty (key' KeyStoragePropertyIdentifiers.NCRYPT_EXPORT_POLICY_PROPERTY' 3);  
Magic Number,PCLCrypto,NCryptAsymmetricKeyProviderBase,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKeyProviderBase.cs,ImportKeyPair,The following statement contains a magic number: using (var provider = NCryptOpenStorageProvider (KeyStorageProviders.MS_KEY_STORAGE_PROVIDER)) {  	byte[] bcryptPrivateBlob;  	string nativeFormatString;  	if (this.NativePrivateKeyFormats.TryGetValue (blobType' out nativeFormatString)) {  		bcryptPrivateBlob = keyBlob;  	} else {  		var parameters = KeyFormatter.GetFormatter (blobType).Read (keyBlob);  		bcryptPrivateBlob = KeyFormatter.GetFormatter (this.PreferredNativePrivateKeyFormat).Write (parameters);  		nativeFormatString = this.NativePrivateKeyFormats [this.PreferredNativePrivateKeyFormat];  	}  	var key = NCryptImportKey (provider' null' nativeFormatString' IntPtr.Zero' bcryptPrivateBlob);  	NCryptSetProperty (key' KeyStoragePropertyIdentifiers.NCRYPT_EXPORT_POLICY_PROPERTY' 3);  	return this.CreateKey (key' isPublicOnly: false);  }  
Magic Number,PCLCrypto,NCryptAsymmetricKeyProviderBase,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Win32RSA\NCryptAsymmetricKeyProviderBase.cs,ImportKeyPair,The following statement contains a magic number: NCryptSetProperty (key' KeyStoragePropertyIdentifiers.NCRYPT_EXPORT_POLICY_PROPERTY' 3);  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: do {  	int b = stream.ReadByte ();  	if (b == -1) {  		yield break;  	}  	BerClass clazz = (BerClass)b & BerClass.Mask;  	BerPC pc = (BerPC)b & BerPC.Mask;  	BerTag tag = (BerTag)b & BerTag.Mask;  	uint length = 0;  	b = stream.ReadByte ();  	if ((b & 0x80) == 0x80) {  		// long form  		byte lengthOfLength = (byte)(b & 0x7F);  		for (int i = 0; i < lengthOfLength; i++) {  			// big endian  			b = stream.ReadByte ();  			length <<= 8;  			length += (uint)b;  		}  	} else {  		// short form.  		length = (uint)b;  	}  	if (length > 8 * 1024) {  		throw new FormatException ("Invalid format or length too large.");  	}  	byte[] content = new byte[length];  	int bytesRead = stream.Read (content' 0' (int)length);  	if (bytesRead != length) {  		throw new ArgumentException ("Unexpected end of stream.");  	}  	yield return new DataElement (clazz' pc' tag' content);  } while (true);  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: do {  	int b = stream.ReadByte ();  	if (b == -1) {  		yield break;  	}  	BerClass clazz = (BerClass)b & BerClass.Mask;  	BerPC pc = (BerPC)b & BerPC.Mask;  	BerTag tag = (BerTag)b & BerTag.Mask;  	uint length = 0;  	b = stream.ReadByte ();  	if ((b & 0x80) == 0x80) {  		// long form  		byte lengthOfLength = (byte)(b & 0x7F);  		for (int i = 0; i < lengthOfLength; i++) {  			// big endian  			b = stream.ReadByte ();  			length <<= 8;  			length += (uint)b;  		}  	} else {  		// short form.  		length = (uint)b;  	}  	if (length > 8 * 1024) {  		throw new FormatException ("Invalid format or length too large.");  	}  	byte[] content = new byte[length];  	int bytesRead = stream.Read (content' 0' (int)length);  	if (bytesRead != length) {  		throw new ArgumentException ("Unexpected end of stream.");  	}  	yield return new DataElement (clazz' pc' tag' content);  } while (true);  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: do {  	int b = stream.ReadByte ();  	if (b == -1) {  		yield break;  	}  	BerClass clazz = (BerClass)b & BerClass.Mask;  	BerPC pc = (BerPC)b & BerPC.Mask;  	BerTag tag = (BerTag)b & BerTag.Mask;  	uint length = 0;  	b = stream.ReadByte ();  	if ((b & 0x80) == 0x80) {  		// long form  		byte lengthOfLength = (byte)(b & 0x7F);  		for (int i = 0; i < lengthOfLength; i++) {  			// big endian  			b = stream.ReadByte ();  			length <<= 8;  			length += (uint)b;  		}  	} else {  		// short form.  		length = (uint)b;  	}  	if (length > 8 * 1024) {  		throw new FormatException ("Invalid format or length too large.");  	}  	byte[] content = new byte[length];  	int bytesRead = stream.Read (content' 0' (int)length);  	if (bytesRead != length) {  		throw new ArgumentException ("Unexpected end of stream.");  	}  	yield return new DataElement (clazz' pc' tag' content);  } while (true);  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: if ((b & 0x80) == 0x80) {  	// long form  	byte lengthOfLength = (byte)(b & 0x7F);  	for (int i = 0; i < lengthOfLength; i++) {  		// big endian  		b = stream.ReadByte ();  		length <<= 8;  		length += (uint)b;  	}  } else {  	// short form.  	length = (uint)b;  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: for (int i = 0; i < lengthOfLength; i++) {  	// big endian  	b = stream.ReadByte ();  	length <<= 8;  	length += (uint)b;  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: length <<= 8;  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: if (length > 8 * 1024) {  	throw new FormatException ("Invalid format or length too large.");  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,ReadAsn1Elements,The following statement contains a magic number: if (length > 8 * 1024) {  	throw new FormatException ("Invalid format or length too large.");  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,WriteAsn1Element,The following statement contains a magic number: if (element.Content.Length < 128) {  	// use short form  	stream.WriteByte ((byte)element.Content.Length);  } else {  	// use long form  	byte lengthOfLength = GetMinimumBytesRequiredToRepresent ((uint)element.Content.Length);  	stream.WriteByte ((byte)(0x80 + lengthOfLength));  	// We must write this out as big endian. We use an endian-agnostic way of reading out the integer.  	for (int significancePosition = lengthOfLength - 1; significancePosition >= 0; significancePosition--) {  		byte lengthOctet = (byte)(0xff & (element.Content.Length >> (8 * significancePosition)));  		stream.WriteByte (lengthOctet);  	}  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,WriteAsn1Element,The following statement contains a magic number: if (element.Content.Length < 128) {  	// use short form  	stream.WriteByte ((byte)element.Content.Length);  } else {  	// use long form  	byte lengthOfLength = GetMinimumBytesRequiredToRepresent ((uint)element.Content.Length);  	stream.WriteByte ((byte)(0x80 + lengthOfLength));  	// We must write this out as big endian. We use an endian-agnostic way of reading out the integer.  	for (int significancePosition = lengthOfLength - 1; significancePosition >= 0; significancePosition--) {  		byte lengthOctet = (byte)(0xff & (element.Content.Length >> (8 * significancePosition)));  		stream.WriteByte (lengthOctet);  	}  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,WriteAsn1Element,The following statement contains a magic number: for (int significancePosition = lengthOfLength - 1; significancePosition >= 0; significancePosition--) {  	byte lengthOctet = (byte)(0xff & (element.Content.Length >> (8 * significancePosition)));  	stream.WriteByte (lengthOctet);  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xffffff) {  	return 4;  } else if (value > 0xffff) {  	return 3;  } else if (value > 0xff) {  	return 2;  } else {  	return 1;  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xffffff) {  	return 4;  } else if (value > 0xffff) {  	return 3;  } else if (value > 0xff) {  	return 2;  } else {  	return 1;  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xffffff) {  	return 4;  } else if (value > 0xffff) {  	return 3;  } else if (value > 0xff) {  	return 2;  } else {  	return 1;  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: return 4;  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xffff) {  	return 3;  } else if (value > 0xff) {  	return 2;  } else {  	return 1;  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xffff) {  	return 3;  } else if (value > 0xff) {  	return 2;  } else {  	return 1;  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: return 3;  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: if (value > 0xff) {  	return 2;  } else {  	return 1;  }  
Magic Number,PCLCrypto.Formatters,Asn,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Asn.cs,GetMinimumBytesRequiredToRepresent,The following statement contains a magic number: return 2;  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.Exponent = ReadReversed (reader' 4);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey) {  	parameters.P = ReadReversed (reader' bytelen / 2);  	parameters.Q = ReadReversed (reader' bytelen / 2);  	parameters.DP = ReadReversed (reader' bytelen / 2);  	parameters.DQ = ReadReversed (reader' bytelen / 2);  	parameters.InverseQ = ReadReversed (reader' bytelen / 2);  	parameters.D = ReadReversed (reader' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey) {  	parameters.P = ReadReversed (reader' bytelen / 2);  	parameters.Q = ReadReversed (reader' bytelen / 2);  	parameters.DP = ReadReversed (reader' bytelen / 2);  	parameters.DQ = ReadReversed (reader' bytelen / 2);  	parameters.InverseQ = ReadReversed (reader' bytelen / 2);  	parameters.D = ReadReversed (reader' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey) {  	parameters.P = ReadReversed (reader' bytelen / 2);  	parameters.Q = ReadReversed (reader' bytelen / 2);  	parameters.DP = ReadReversed (reader' bytelen / 2);  	parameters.DQ = ReadReversed (reader' bytelen / 2);  	parameters.InverseQ = ReadReversed (reader' bytelen / 2);  	parameters.D = ReadReversed (reader' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey) {  	parameters.P = ReadReversed (reader' bytelen / 2);  	parameters.Q = ReadReversed (reader' bytelen / 2);  	parameters.DP = ReadReversed (reader' bytelen / 2);  	parameters.DQ = ReadReversed (reader' bytelen / 2);  	parameters.InverseQ = ReadReversed (reader' bytelen / 2);  	parameters.D = ReadReversed (reader' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: if (hasPrivateKey) {  	parameters.P = ReadReversed (reader' bytelen / 2);  	parameters.Q = ReadReversed (reader' bytelen / 2);  	parameters.DP = ReadReversed (reader' bytelen / 2);  	parameters.DQ = ReadReversed (reader' bytelen / 2);  	parameters.InverseQ = ReadReversed (reader' bytelen / 2);  	parameters.D = ReadReversed (reader' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.P = ReadReversed (reader' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.Q = ReadReversed (reader' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.DP = ReadReversed (reader' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.DQ = ReadReversed (reader' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,ReadCore,The following statement contains a magic number: parameters.InverseQ = ReadReversed (reader' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey (parameters)) {  	WriteReversed (writer' parameters.P' bytelen / 2);  	WriteReversed (writer' parameters.Q' bytelen / 2);  	WriteReversed (writer' parameters.DP' bytelen / 2);  	WriteReversed (writer' parameters.DQ' bytelen / 2);  	WriteReversed (writer' parameters.InverseQ' bytelen / 2);  	WriteReversed (writer' parameters.D' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey (parameters)) {  	WriteReversed (writer' parameters.P' bytelen / 2);  	WriteReversed (writer' parameters.Q' bytelen / 2);  	WriteReversed (writer' parameters.DP' bytelen / 2);  	WriteReversed (writer' parameters.DQ' bytelen / 2);  	WriteReversed (writer' parameters.InverseQ' bytelen / 2);  	WriteReversed (writer' parameters.D' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey (parameters)) {  	WriteReversed (writer' parameters.P' bytelen / 2);  	WriteReversed (writer' parameters.Q' bytelen / 2);  	WriteReversed (writer' parameters.DP' bytelen / 2);  	WriteReversed (writer' parameters.DQ' bytelen / 2);  	WriteReversed (writer' parameters.InverseQ' bytelen / 2);  	WriteReversed (writer' parameters.D' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey (parameters)) {  	WriteReversed (writer' parameters.P' bytelen / 2);  	WriteReversed (writer' parameters.Q' bytelen / 2);  	WriteReversed (writer' parameters.DP' bytelen / 2);  	WriteReversed (writer' parameters.DQ' bytelen / 2);  	WriteReversed (writer' parameters.InverseQ' bytelen / 2);  	WriteReversed (writer' parameters.D' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: if (KeyFormatter.HasPrivateKey (parameters)) {  	WriteReversed (writer' parameters.P' bytelen / 2);  	WriteReversed (writer' parameters.Q' bytelen / 2);  	WriteReversed (writer' parameters.DP' bytelen / 2);  	WriteReversed (writer' parameters.DQ' bytelen / 2);  	WriteReversed (writer' parameters.InverseQ' bytelen / 2);  	WriteReversed (writer' parameters.D' bytelen);  }  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed (writer' parameters.P' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed (writer' parameters.Q' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed (writer' parameters.DP' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed (writer' parameters.DQ' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,CapiKeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\CapiKeyFormatter.cs,WriteCore,The following statement contains a magic number: WriteReversed (writer' parameters.InverseQ' bytelen / 2);  
Magic Number,PCLCrypto.Formatters,KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\KeyFormatter.cs,NegotiateSizes,The following statement contains a magic number: if (HasPrivateKey (parameters)) {  	if (CapiKeyFormatter.IsCapiCompatible (parameters)) {  		// Don't change a thing. Everything is perfect.  		return parameters;  	}  	parameters.Modulus = TrimLeadingZero (parameters.Modulus);  	parameters.D = TrimLeadingZero (parameters.D);  	int keyLength = Math.Max (parameters.Modulus.Length' parameters.D.Length ?? 0);  	parameters.Modulus = TrimOrPadZeroToLength (parameters.Modulus' keyLength);  	parameters.D = TrimOrPadZeroToLength (parameters.D' keyLength);  	int halfKeyLength = (keyLength + 1) / 2;  	parameters.P = TrimOrPadZeroToLength (parameters.P' halfKeyLength);  	parameters.Q = TrimOrPadZeroToLength (parameters.Q' halfKeyLength);  	parameters.DP = TrimOrPadZeroToLength (parameters.DP' halfKeyLength);  	parameters.DQ = TrimOrPadZeroToLength (parameters.DQ' halfKeyLength);  	parameters.InverseQ = TrimOrPadZeroToLength (parameters.InverseQ' halfKeyLength);  } else {  	parameters.Modulus = TrimLeadingZero (parameters.Modulus);  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: switch (sequence.Count) {  case 2:  	return new RSAParameters {  		Modulus = sequence [0].Content'  		Exponent = sequence [1].Content'  	};  case 9:  	KeyFormatter.VerifyFormat (sequence [0].Content.Length == 1 && sequence [0].Content [0] == 0' "Unsupported version.");  	return new RSAParameters {  		Modulus = sequence [1].Content'  		Exponent = sequence [2].Content'  		D = sequence [3].Content'  		P = sequence [4].Content'  		Q = sequence [5].Content'  		DP = sequence [6].Content'  		DQ = sequence [7].Content'  		InverseQ = sequence [8].Content'  	};  default:  	throw KeyFormatter.FailFormat ();  }  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: return new RSAParameters {  	Modulus = sequence [1].Content'  	Exponent = sequence [2].Content'  	D = sequence [3].Content'  	P = sequence [4].Content'  	Q = sequence [5].Content'  	DP = sequence [6].Content'  	DQ = sequence [7].Content'  	InverseQ = sequence [8].Content'  };  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: return new RSAParameters {  	Modulus = sequence [1].Content'  	Exponent = sequence [2].Content'  	D = sequence [3].Content'  	P = sequence [4].Content'  	Q = sequence [5].Content'  	DP = sequence [6].Content'  	DQ = sequence [7].Content'  	InverseQ = sequence [8].Content'  };  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: return new RSAParameters {  	Modulus = sequence [1].Content'  	Exponent = sequence [2].Content'  	D = sequence [3].Content'  	P = sequence [4].Content'  	Q = sequence [5].Content'  	DP = sequence [6].Content'  	DQ = sequence [7].Content'  	InverseQ = sequence [8].Content'  };  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: return new RSAParameters {  	Modulus = sequence [1].Content'  	Exponent = sequence [2].Content'  	D = sequence [3].Content'  	P = sequence [4].Content'  	Q = sequence [5].Content'  	DP = sequence [6].Content'  	DQ = sequence [7].Content'  	InverseQ = sequence [8].Content'  };  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: return new RSAParameters {  	Modulus = sequence [1].Content'  	Exponent = sequence [2].Content'  	D = sequence [3].Content'  	P = sequence [4].Content'  	Q = sequence [5].Content'  	DP = sequence [6].Content'  	DQ = sequence [7].Content'  	InverseQ = sequence [8].Content'  };  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: return new RSAParameters {  	Modulus = sequence [1].Content'  	Exponent = sequence [2].Content'  	D = sequence [3].Content'  	P = sequence [4].Content'  	Q = sequence [5].Content'  	DP = sequence [6].Content'  	DQ = sequence [7].Content'  	InverseQ = sequence [8].Content'  };  
Magic Number,PCLCrypto.Formatters,Pkcs1KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs1KeyFormatter.cs,ReadCore,The following statement contains a magic number: return new RSAParameters {  	Modulus = sequence [1].Content'  	Exponent = sequence [2].Content'  	D = sequence [3].Content'  	P = sequence [4].Content'  	Q = sequence [5].Content'  	DP = sequence [6].Content'  	DQ = sequence [7].Content'  	InverseQ = sequence [8].Content'  };  
Magic Number,PCLCrypto.Formatters,Pkcs8KeyFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\Pkcs8KeyFormatter.cs,ReadCore,The following statement contains a magic number: return KeyFormatter.Pkcs1.Read (sequence [2].Content);  
Magic Number,PCLCrypto.Formatters,X509SubjectPublicKeyInfoFormatter,F:\newReposMay17\AArnott_PCLCrypto\src\PCLCrypto.Shared.Formatters\Formatters\X509SubjectPublicKeyInfoFormatter.cs,ReadCore,The following statement contains a magic number: if (elements.Count != 2 || elements [0].Class != Asn.BerClass.Universal || elements [0].PC != Asn.BerPC.Constructed || elements [0].Tag != Asn.BerTag.Sequence) {  	throw new ArgumentException ("Unexpected format.");  }  
