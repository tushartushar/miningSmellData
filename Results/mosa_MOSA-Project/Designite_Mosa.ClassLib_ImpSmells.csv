Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,Cyclomatic complexity of the method is 12
Complex Conditional,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The conditional expression  "off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]"  is complex.
Complex Conditional,Mosa.ClassLib,RedBlackTree<K;T>,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\RedBlackTree.cs,DeleteCase3,The conditional expression  "(n.parent.color == Color.Black) &&  				(s.color == Color.Black) &&  				(s.left.color == Color.Black) &&  				(s.right.color == Color.Black)"  is complex.
Complex Conditional,Mosa.ClassLib,RedBlackTree<K;T>,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\RedBlackTree.cs,DeleteCase4,The conditional expression  "(n.parent.color == Color.Red) &&  				(s.color == Color.Black) &&  				(s.left.color == Color.Black) &&  				(s.right.color == Color.Black)"  is complex.
Complex Conditional,Mosa.ClassLib,RedBlackTree<K;T>,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\RedBlackTree.cs,DeleteCase5,The conditional expression  "(n == n.parent.left) &&  				(s.color == Color.Black) &&  				(s.left.color == Color.Red) &&  				(s.right.color == Color.Black)"  is complex.
Complex Conditional,Mosa.ClassLib,RedBlackTree<K;T>,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\RedBlackTree.cs,DeleteCase5,The conditional expression  "(n == n.parent.right) &&  					   (s.color == Color.Black) &&  					   (s.right.color == Color.Red) &&  					   (s.left.color == Color.Black)"  is complex.
Magic Number,Mosa.ClassLib,CRC,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\CRC.cs,Update,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				int mask = -((int)crc & 1);  				crc = (uint)((crc >> 1) ^ (0xEDB88320 & mask));  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: uint hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Compress,The following statement contains a magic number: for (;;)  			{  				if (iidx < inputLength - 2)  				{  					hval = (hval << 8) | input[iidx + 2];  					hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  					reference = HashTable[hslot];  					HashTable[hslot] = (long)iidx;    					off = iidx - reference - 1;    					if (off < MAX_OFF  						&& iidx + 4 < inputLength  						&& reference > 0  						&& input[reference + 0] == input[iidx + 0]  						&& input[reference + 1] == input[iidx + 1]  						&& input[reference + 2] == input[iidx + 2]  						)  					{  						/* match found at *reference++ */  						uint len = 2;  						uint maxlen = (uint)inputLength - iidx - len;  						maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;    						if (oidx + lit + 1 + 3 >= outputLength)  							return 0;    						do  							len++;  						while (len < maxlen && input[reference + len] == input[iidx + len]);    						if (lit != 0)  						{  							output[oidx++] = (byte)(lit - 1);  							lit = -lit;  							do  								output[oidx++] = input[iidx + lit];  							while ((++lit) != 0);  						}    						len -= 2;  						iidx++;    						if (len < 7)  						{  							output[oidx++] = (byte)((off >> 8) + (len << 5));  						}  						else  						{  							output[oidx++] = (byte)((off >> 8) + (7 << 5));  							output[oidx++] = (byte)(len - 7);  						}    						output[oidx++] = (byte)off;    						iidx += len - 1;  						hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;    						hval = (hval << 8) | input[iidx + 2];  						HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  						iidx++;  						continue;  					}  				}  				else if (iidx == inputLength)  					break;    				/* one more literal byte we must copy */  				lit++;  				iidx++;    				if (lit == MAX_LIT)  				{  					if (oidx + 1 + MAX_LIT >= outputLength)  						return 0;    					output[oidx++] = (byte)(MAX_LIT - 1);  					lit = -lit;  					do  						output[oidx++] = input[iidx + lit];  					while ((++lit) != 0);  				}  			}
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Decompress,The following statement contains a magic number: do  			{  				uint ctrl = input[iidx++];    				if (ctrl < (1 << 5)) /* literal run */  				{  					ctrl++;    					if (oidx + ctrl > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					do  						output[oidx++] = input[iidx++];  					while ((--ctrl) != 0);  				}  				else /* back reference */  				{  					uint len = ctrl >> 5;    					int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);    					if (len == 7)  						len += input[iidx++];    					reference -= input[iidx++];    					if (oidx + len + 2 > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					if (reference < 0)  					{  						//SET_ERRNO (EINVAL);  						return 0;  					}    					output[oidx++] = output[reference++];  					output[oidx++] = output[reference++];    					do  						output[oidx++] = output[reference++];  					while ((--len) != 0);  				}  			}  			while (iidx < inputLength);
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Decompress,The following statement contains a magic number: do  			{  				uint ctrl = input[iidx++];    				if (ctrl < (1 << 5)) /* literal run */  				{  					ctrl++;    					if (oidx + ctrl > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					do  						output[oidx++] = input[iidx++];  					while ((--ctrl) != 0);  				}  				else /* back reference */  				{  					uint len = ctrl >> 5;    					int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);    					if (len == 7)  						len += input[iidx++];    					reference -= input[iidx++];    					if (oidx + len + 2 > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					if (reference < 0)  					{  						//SET_ERRNO (EINVAL);  						return 0;  					}    					output[oidx++] = output[reference++];  					output[oidx++] = output[reference++];    					do  						output[oidx++] = output[reference++];  					while ((--len) != 0);  				}  			}  			while (iidx < inputLength);
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Decompress,The following statement contains a magic number: do  			{  				uint ctrl = input[iidx++];    				if (ctrl < (1 << 5)) /* literal run */  				{  					ctrl++;    					if (oidx + ctrl > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					do  						output[oidx++] = input[iidx++];  					while ((--ctrl) != 0);  				}  				else /* back reference */  				{  					uint len = ctrl >> 5;    					int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);    					if (len == 7)  						len += input[iidx++];    					reference -= input[iidx++];    					if (oidx + len + 2 > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					if (reference < 0)  					{  						//SET_ERRNO (EINVAL);  						return 0;  					}    					output[oidx++] = output[reference++];  					output[oidx++] = output[reference++];    					do  						output[oidx++] = output[reference++];  					while ((--len) != 0);  				}  			}  			while (iidx < inputLength);
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Decompress,The following statement contains a magic number: do  			{  				uint ctrl = input[iidx++];    				if (ctrl < (1 << 5)) /* literal run */  				{  					ctrl++;    					if (oidx + ctrl > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					do  						output[oidx++] = input[iidx++];  					while ((--ctrl) != 0);  				}  				else /* back reference */  				{  					uint len = ctrl >> 5;    					int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);    					if (len == 7)  						len += input[iidx++];    					reference -= input[iidx++];    					if (oidx + len + 2 > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					if (reference < 0)  					{  						//SET_ERRNO (EINVAL);  						return 0;  					}    					output[oidx++] = output[reference++];  					output[oidx++] = output[reference++];    					do  						output[oidx++] = output[reference++];  					while ((--len) != 0);  				}  			}  			while (iidx < inputLength);
Magic Number,Mosa.ClassLib,LZF,C:\repos\mosa_MOSA-Project\Source\Mosa.ClassLib\LZF.cs,Decompress,The following statement contains a magic number: do  			{  				uint ctrl = input[iidx++];    				if (ctrl < (1 << 5)) /* literal run */  				{  					ctrl++;    					if (oidx + ctrl > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					do  						output[oidx++] = input[iidx++];  					while ((--ctrl) != 0);  				}  				else /* back reference */  				{  					uint len = ctrl >> 5;    					int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);    					if (len == 7)  						len += input[iidx++];    					reference -= input[iidx++];    					if (oidx + len + 2 > outputLength)  					{  						//SET_ERRNO (E2BIG);  						return 0;  					}    					if (reference < 0)  					{  						//SET_ERRNO (EINVAL);  						return 0;  					}    					output[oidx++] = output[reference++];  					output[oidx++] = output[reference++];    					do  						output[oidx++] = output[reference++];  					while ((--len) != 0);  				}  			}  			while (iidx < inputLength);
