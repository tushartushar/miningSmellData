Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,ToString,The method has 116 lines of code.
Long Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,TraceUsageMap,The method has 124 lines of code.
Long Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BuildLiveIntervals,The method has 110 lines of code.
Long Method,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The method has 116 lines of code.
Long Method,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,PopulateVisitationDictionary,The method has 221 lines of code.
Long Method,Mosa.Compiler.Framework.CIL,CILInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\CILInstruction.cs,Initialize,The method has 452 lines of code.
Complex Method,Mosa.Compiler.Framework.Analysis.LiveVariableAnalysis,LiveRanges,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\LiveVariableAnalysis\LiveRanges.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Analysis.LiveVariableAnalysis,LivenessAnalysis,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\LiveVariableAnalysis\LivenessAnalysis.cs,ComputeLocalLiveSets,Cyclomatic complexity of the method is 11
Complex Method,Mosa.Compiler.Framework.Analysis.LiveVariableAnalysis,LivenessAnalysis,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\LiveVariableAnalysis\LivenessAnalysis.cs,BuildLiveIntervals,Cyclomatic complexity of the method is 11
Complex Method,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,ResolveType,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,FindInterfaceMethod,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework,BaseInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseInstruction.cs,ToString,Cyclomatic complexity of the method is 17
Complex Method,Mosa.Compiler.Framework,BaseMethodCompilerStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseMethodCompilerStage.cs,IsSourceAndTargetWithinSameTryOrException,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework,BaseMethodCompilerStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseMethodCompilerStage.cs,GetInstructionSize,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,TraceDefAndUseLocations,Cyclomatic complexity of the method is 12
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,TraceUsageMap,Cyclomatic complexity of the method is 26
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ComputeLocalLiveSets,Cyclomatic complexity of the method is 23
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BuildLiveIntervals,Cyclomatic complexity of the method is 31
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,PlaceLiveIntervalOnTrackAllowEvictions,Cyclomatic complexity of the method is 12
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ProcessLiveInterval,Cyclomatic complexity of the method is 20
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ResolveDataFlow,Cyclomatic complexity of the method is 11
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,GetRegisterMoves,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,LiveRange,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\LiveRange.cs,LiveRange,Cyclomatic complexity of the method is 10
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,VirtualRegister,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\VirtualRegister.cs,AddLiveInterval,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,TrySimplePartialFreeIntervalSplit,Cyclomatic complexity of the method is 16
Complex Method,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,GetLowerOptimalSplitLocation,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.CompilerStages,MethodExceptionLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodExceptionLookupTableStage.cs,CreateMethodExceptionLookupTable,Cyclomatic complexity of the method is 15
Complex Method,Mosa.Compiler.Framework.CompilerStages,MethodLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodLookupTableStage.cs,RunPostCompile,Cyclomatic complexity of the method is 13
Complex Method,Mosa.Compiler.Framework.CompilerStages,PlugStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\PlugStage.cs,RunPreCompile,Cyclomatic complexity of the method is 15
Complex Method,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.Stages,ExceptionPrologueStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionPrologueStage.cs,InsertFlowOrJumpInstructions,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,InlineStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\InlineStage.cs,Run,Cyclomatic complexity of the method is 15
Complex Method,Mosa.Compiler.Framework.Stages,InlineStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\InlineStage.cs,Inline,Cyclomatic complexity of the method is 16
Complex Method,Mosa.Compiler.Framework.Stages,InlineEvaluationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\InlineEvaluationStage.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,Mosa.Compiler.Framework.Stages,InlineEvaluationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\InlineEvaluationStage.cs,CanInline,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Stages,InlineEvaluationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\InlineEvaluationStage.cs,CopyInstructions,Cyclomatic complexity of the method is 16
Complex Method,Mosa.Compiler.Framework.Stages,SparseConditionalConstantPropagationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\SparseConditionalConstantPropagationStage.cs,ReplaceVirtualRegisterWithConstant,Cyclomatic complexity of the method is 11
Complex Method,Mosa.Compiler.Framework.Stages,SparseConditionalConstantPropagationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\SparseConditionalConstantPropagationStage.cs,RemoveBranchesToDeadBlocks,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,EmitProtectedRegionTable,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,EmptyBlockRemovalStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\EmptyBlockRemovalStage.cs,RemoveEmptyBlocks,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,Optimize,Cyclomatic complexity of the method is 10
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,DeadCodeElimination,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimpleConstantPropagation,Cyclomatic complexity of the method is 13
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,Cyclomatic complexity of the method is 19
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ForwardPropagateMove,Cyclomatic complexity of the method is 16
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ForwardPropagateCompoundMove,Cyclomatic complexity of the method is 11
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerOperations,Cyclomatic complexity of the method is 10
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerCompare,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationMultiplication,Cyclomatic complexity of the method is 17
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationDivision,Cyclomatic complexity of the method is 17
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyExtendedMoveWithConstant,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationLogicalOperators,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationShiftOperators,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldIntegerCompareBranch,Cyclomatic complexity of the method is 13
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingAdditionAndSubstraction,Cyclomatic complexity of the method is 15
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingLogicalOr,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingLogicalAnd,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingMultiplication,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingDivision,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ReduceTruncationAndExpansion,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CombineIntegerCompareBranch,Cyclomatic complexity of the method is 11
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,FoldIntegerCompare,Cyclomatic complexity of the method is 11
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,FoldLoadStoreOffsets,Cyclomatic complexity of the method is 12
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingPhi,Cyclomatic complexity of the method is 10
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyPhi,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyPhi2,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyIntegerCompare,Cyclomatic complexity of the method is 12
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyIntegerCompare2,Cyclomatic complexity of the method is 10
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationRemUnsignedModulus,Cyclomatic complexity of the method is 13
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationRemSignedModulus,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,NormalizeConstantTo32Bit,Cyclomatic complexity of the method is 12
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,Split64Constant,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyTo64,Cyclomatic complexity of the method is 12
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifySplit64,Cyclomatic complexity of the method is 12
Complex Method,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ReduceSplit64,Cyclomatic complexity of the method is 14
Complex Method,Mosa.Compiler.Framework.Stages,VirtualRegisterRenameStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\VirtualRegisterRenameStage.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,Mosa.Compiler.Framework.Stages,CILDecodingStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILDecodingStage.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,CILDecodingStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILDecodingStage.cs,ConvertVirtualRegisterToStackLocal,Cyclomatic complexity of the method is 10
Complex Method,Mosa.Compiler.Framework.Stages,EnterSSAStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\EnterSSAStage.cs,RenameVariables,Cyclomatic complexity of the method is 13
Complex Method,Mosa.Compiler.Framework.Stages,LeaveSSAStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\LeaveSSAStage.cs,Run,Cyclomatic complexity of the method is 11
Complex Method,Mosa.Compiler.Framework.Stages,OperandAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\OperandAssignmentStage.cs,AssignOperands,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Callvirt,Cyclomatic complexity of the method is 8
Complex Method,Mosa.Compiler.Framework.Stages,CodeGenerationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CodeGenerationStage.cs,EmitInstructions,Cyclomatic complexity of the method is 10
Long Parameter List,Mosa.Compiler.Framework.Analysis,SparseConditionalConstantPropagation,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,IntegerOperation,The method has 5 parameters. Parameters: instruction' operand1' operand2' conditionCode' result
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction2,The method has 5 parameters. Parameters: instruction' result' result2' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction2,The method has 6 parameters. Parameters: instruction' result' result2' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' updateStatus' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' condition' updateStatus' result' operand1
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' condition' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 6 parameters. Parameters: instruction' condition' result' operand1' operand2' block
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 6 parameters. Parameters: instruction' condition' updateStatus' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' result' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 6 parameters. Parameters: instruction' result' operand1' operand2' operand3' operand4
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' size' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,SetInstruction,The method has 6 parameters. Parameters: instruction' size' result' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction2,The method has 5 parameters. Parameters: instruction' result' result2' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction2,The method has 6 parameters. Parameters: instruction' result' result2' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 5 parameters. Parameters: instruction' updateStatus' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 5 parameters. Parameters: instruction' result' operand1' operand2' operands
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 5 parameters. Parameters: instruction' condition' updateStatus' result' operand1
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 5 parameters. Parameters: instruction' condition' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 6 parameters. Parameters: instruction' condition' result' operand1' operand2' block
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 6 parameters. Parameters: instruction' condition' updateStatus' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 5 parameters. Parameters: instruction' result' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 6 parameters. Parameters: instruction' result' operand1' operand2' operand3' operand4
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 5 parameters. Parameters: instruction' size' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 6 parameters. Parameters: instruction' size' result' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,Context,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Context.cs,AppendInstruction,The method has 7 parameters. Parameters: instruction' size' result' operand1' operand2' operand3' operand4
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' result' operand1' operand2' operands
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction2,The method has 5 parameters. Parameters: instruction' result' result2' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction2,The method has 6 parameters. Parameters: instruction' result' result2' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' result' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 6 parameters. Parameters: instruction' result' operand1' operand2' operand3' operand4
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' updateStatus' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' condition' updateStatus' result' operand1
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' condition' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 6 parameters. Parameters: instruction' condition' result' operand1' operand2' block
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 6 parameters. Parameters: instruction' condition' updateStatus' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 5 parameters. Parameters: instruction' size' result' operand1' operand2
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 6 parameters. Parameters: instruction' size' result' operand1' operand2' operand3
Long Parameter List,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The method has 7 parameters. Parameters: instruction' size' result' operand1' operand2' operand3' operand4
Long Parameter List,Mosa.Compiler.Framework,BaseArchitecture,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseArchitecture.cs,InsertCompoundCopy,The method has 7 parameters. Parameters: compiler' context' destinationBase' destination' sourceBase' source' size
Long Parameter List,Mosa.Compiler.Framework,BaseMethodCompiler,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseMethodCompiler.cs,SetStackParameter,The method has 5 parameters. Parameters: index' type' name' isThis' offset
Long Parameter List,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,CreateStackParameter,The method has 5 parameters. Parameters: type' index' name' isThis' offset
Long Parameter List,Mosa.Compiler.Framework.RegisterAllocator,BasicRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BasicRegisterAllocator.cs,BasicRegisterAllocator,The method has 6 parameters. Parameters: basicBlocks' virtualRegisters' architecture' addStackLocal' stackFrame' traceFactory
Long Parameter List,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BaseRegisterAllocator,The method has 6 parameters. Parameters: basicBlocks' virtualRegisters' architecture' addStackLocal' stackFrame' traceFactory
Long Parameter List,Mosa.Compiler.Framework.RegisterAllocator,LiveInterval,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\LiveInterval.cs,LiveInterval,The method has 5 parameters. Parameters: virtualRegister' start' end' uses' defs
Long Parameter List,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,GreedyRegisterAllocator,The method has 6 parameters. Parameters: basicBlocks' virtualRegisters' architecture' addStackLocal' stackFrame' traceFactory
Long Parameter List,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttributeArgument,The method has 5 parameters. Parameters: symbolName' count' name' arg' isField
Long Parameter List,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,CreateProtectedRegionDefinition,The method has 6 parameters. Parameters: name' start' end' handler' handlerType' exceptionType
Long Parameter List,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Replace,The method has 5 parameters. Parameters: node' floatingPointR4Instruction' floatingPointR8Instruction' signedInstruction' unsignedInstruction
Long Identifier,Mosa.Compiler.Framework.Intrinsics,InternalAllocateString,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\InternalAllocateString.cs,,The length of the parameter StringClassTypeDefinitionSymbolName is 35.
Long Identifier,Mosa.Compiler.Framework.Stages,SparseConditionalConstantPropagationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\SparseConditionalConstantPropagationStage.cs,,The length of the parameter conditionalConstantPropagation is 30.
Long Identifier,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,CreateProtectedRegionDefinition,The length of the parameter protectedRegionDefinitionSymbol is 31.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter simplifyExtendedMoveWithConstantCount is 37.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter arithmeticSimplificationSubtractionCount is 40.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter arithmeticSimplificationMultiplicationCount is 43.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter arithmeticSimplificationDivisionCount is 37.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter arithmeticSimplificationAdditionAndSubstractionCount is 52.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter arithmeticSimplificationLogicalOperatorsCount is 45.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter arithmeticSimplificationShiftOperators is 38.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter simpleConstantPropagationCount is 30.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter reduceTruncationAndExpansionCount is 33.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter constantFoldingIntegerOperationsCount is 37.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter constantFoldingIntegerCompareCount is 34.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter constantFoldingAdditionAndSubstractionCount is 43.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter constantFoldingMultiplicationCount is 34.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter constantFoldingLogicalAndCount is 30.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter combineIntegerCompareBranchCount is 32.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter removeUselessIntegerCompareBranch is 33.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter arithmeticSimplificationModulus is 31.
Long Identifier,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,,The length of the parameter debugRestrictOptimizationByCount is 32.
Long Statement,Mosa.Compiler.Framework.Analysis.LiveVariableAnalysis,GCEnvironment,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\LiveVariableAnalysis\GCEnvironment.cs,GetInputs,The length of the statement  "			if (node.Instruction == IRInstruction.KillAll || node.Instruction == IRInstruction.KillAllExcept || node.Instruction == IRInstruction.Kill) " is 139.
Long Statement,Mosa.Compiler.Framework.Analysis.LiveVariableAnalysis,GCEnvironment,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\LiveVariableAnalysis\GCEnvironment.cs,GetOutputs,The length of the statement  "			if (node.Instruction == IRInstruction.KillAll || node.Instruction == IRInstruction.KillAllExcept || node.Instruction == IRInstruction.Kill) " is 139.
Long Statement,Mosa.Compiler.Framework.Analysis.LiveVariableAnalysis,LiveRanges,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\LiveVariableAnalysis\LiveRanges.cs,Add,The length of the statement  "							var newliveRange = new Range(Math.Min(liveRange.Start' nextLiveRange.Start)' Math.Max(liveRange.End' nextLiveRange.End)); " is 121.
Long Statement,Mosa.Compiler.Framework.Analysis,SparseConditionalConstantPropagation,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,IntegerOperation,The length of the statement  "				if (IntegerOperation(node.Instruction' operand1.ConstantUnsignedLongInteger' operand2.ConstantUnsignedLongInteger' node.ConditionCode' out ulong value)) " is 152.
Long Statement,Mosa.Compiler.Framework.Analysis,SparseConditionalConstantPropagation,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,CompareIntegerBranch,The length of the statement  "				bool? compare = Compare(operand1.ConstantUnsignedLongInteger' operand2.ConstantUnsignedLongInteger' node.ConditionCode); " is 120.
Long Statement,Mosa.Compiler.Framework.Analysis,SparseConditionalConstantPropagation,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,Phi,The length of the statement  "				//if (Trace.Active) Trace.Log("# " + index.ToString() + ": " + predecessor.ToString() + " " + (executable ? "Yes" : "No")); " is 123.
Long Statement,Mosa.Compiler.Framework,DelegatePatcher,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\DelegatePatcher.cs,GetDelegateProxyMethod,The length of the statement  "				var staticProxy = Compiler.TypeSystem.CreateLinkerMethod(delegateProxyType' delegateMethod.FullName + "@Static@Proxy"' delegateMethod.Signature.ReturnType' false' delegateMethod.Signature.Parameters); " is 200.
Long Statement,Mosa.Compiler.Framework,DelegatePatcher,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\DelegatePatcher.cs,GetDelegateProxyMethod,The length of the statement  "				var instanceProxy = Compiler.TypeSystem.CreateLinkerMethod(delegateProxyType' delegateMethod.FullName + "@Instance@Proxy"' delegateMethod.Signature.ReturnType' true' delegateMethod.Signature.Parameters); " is 203.
Long Statement,Mosa.Compiler.Framework,DelegatePatcher,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\DelegatePatcher.cs,PatchInvoke,The length of the statement  "			bool withReturn = (methodCompiler.Method.Signature.ReturnType == null) ? false : !methodCompiler.Method.Signature.ReturnType.IsVoid; " is 132.
Long Statement,Mosa.Compiler.Framework,DelegatePatcher,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\DelegatePatcher.cs,PatchInvoke,The length of the statement  "			var opReturn = withReturn ? methodCompiler.AllocateVirtualRegisterOrStackSlot(methodCompiler.Method.Signature.ReturnType) : null; " is 129.
Long Statement,Mosa.Compiler.Framework,LoadStore,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\LoadStore.cs,OrderLoadOperands,The length of the statement  "				node.Operand1 = Operand.CreateConstant(node.Operand1.ConstantUnsignedLongInteger + node.Operand2.ConstantUnsignedLongInteger' methodCompiler.TypeSystem); " is 153.
Long Statement,Mosa.Compiler.Framework,LoadStore,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\LoadStore.cs,OrderStoreOperands,The length of the statement  "				node.Operand1 = Operand.CreateConstant(node.Operand1.ConstantUnsignedLongInteger + node.Operand2.ConstantUnsignedLongInteger' methodCompiler.TypeSystem); " is 153.
Long Statement,Mosa.Compiler.Framework,MosaCompiler,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaCompiler.cs,Load,The length of the statement  "			TypeLayout = new MosaTypeLayout(typeSystem' CompilerOptions.Architecture.NativePointerSize' CompilerOptions.Architecture.NativeAlignment); " is 138.
Long Statement,Mosa.Compiler.Framework,MosaCompiler,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaCompiler.cs,Initialize,The length of the statement  "			Linker = new BaseLinker(CompilerOptions.BaseAddress' CompilerOptions.Architecture.Endianness' CompilerOptions.Architecture.MachineType' CompilerOptions.EmitSymbols' CompilerOptions.LinkerFormatType); " is 199.
Long Statement,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,GetMethodTable,The length of the statement  "			if (type.BaseType == null && !type.IsInterface && type.FullName != "System.Object")   // ghost types like generic params' function ptr' etc. " is 140.
Long Statement,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,ResolveType,The length of the statement  "			if (type.BaseType == null && !type.IsInterface && type.FullName != "System.Object")   // ghost types like generic params' function ptr' etc. " is 140.
Long Statement,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,ScanExplicitInterfaceImplementations,The length of the statement  "						if (overrideTarget.Equals(interfaceMethod) && overrideTarget.DeclaringType.Equals(interfaceType) && cleanOverrideTargetName.Equals(cleanInterfaceMethodName)) " is 157.
Long Statement,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,FindInterfaceMethod,The length of the statement  "			throw new InvalidOperationException("Failed to find implicit interface implementation for type " + type + " and interface method " + interfaceMethod); " is 150.
Long Statement,Mosa.Compiler.Framework,BaseCodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseCodeEmitter.cs,Emit,The length of the statement  "				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' pos' SectionKind.ROData' symbolOperand.Name' referenceOffset); " is 144.
Long Statement,Mosa.Compiler.Framework,BaseCodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseCodeEmitter.cs,Emit,The length of the statement  "				linker.Link(LinkType.AbsoluteAddress' PatchType.I4' SectionKind.Text' MethodName' pos' section' symbolOperand.Field.FullName' referenceOffset); " is 143.
Long Statement,Mosa.Compiler.Framework,BaseCodeEmitter,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseCodeEmitter.cs,Emit,The length of the statement  "				var symbol = (linker.FindSymbol(symbolOperand.Name' section) ?? linker.FindSymbol(symbolOperand.Name)) ?? linker.GetSymbol(symbolOperand.Name' section); " is 152.
Long Statement,Mosa.Compiler.Framework,BasicBlock,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BasicBlock.cs,AddBranchInstruction,The length of the statement  "			// Note: The list only has 1 unless it's a switch statement' so actual performance is very close to O(1) for non-switch statements " is 130.
Long Statement,Mosa.Compiler.Framework,BaseCodeTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseCodeTransformationStage.cs,Run,The length of the statement  "					if (contextVisit && contextVisitationDictionary.TryGetValue(node.Instruction' out ContextVisitationDelegate contextVisitationMethod)) " is 133.
Long Statement,Mosa.Compiler.Framework,BaseCodeTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseCodeTransformationStage.cs,Run,The length of the statement  "					else if (NodeVisit && nodeVisitationDictionary.TryGetValue(node.Instruction' out NodeVisitationDelegate nodeVisitationMethod)) " is 126.
Long Statement,Mosa.Compiler.Framework,BaseMethodCompiler,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseMethodCompiler.cs,CalculateMethodParameterSize,The length of the statement  "				var size = parameter.ParameterType.IsValueType ? TypeLayout.GetTypeSize(parameter.ParameterType) : TypeLayout.NativePointerAlignment; " is 133.
Long Statement,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,CreateLowSplitForLong,The length of the statement  "				operand = CreateStackParameter(typeSystem.BuiltIn.U4' longOperand.Index' longOperand.Name + " (Low)"' false' (int)longOperand.Offset); " is 134.
Long Statement,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,CreateHighSplitForLong,The length of the statement  "				operand = CreateStackParameter(typeSystem.BuiltIn.U4' longOperand.Index' longOperand.Name + " (High)"' false' (int)longOperand.Offset + 4); " is 139.
Long Statement,Mosa.Compiler.Framework.Intrinsics,GetAssemblyListTable,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\GetAssemblyListTable.cs,ReplaceIntrinsicCall,The length of the statement  "			context.SetInstruction(IRInstruction.MoveInteger' context.Result' Operand.CreateUnmanagedSymbolPointer(Metadata.AssembliesTable' methodCompiler.TypeSystem)); " is 157.
Long Statement,Mosa.Compiler.Framework.Intrinsics,Load16,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load16.cs,ReplaceIntrinsicCall,The length of the statement  "				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' methodCompiler.ConstantZero); " is 124.
Long Statement,Mosa.Compiler.Framework.Intrinsics,Store64,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store64.cs,ReplaceIntrinsicCall,The length of the statement  "				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2); " is 128.
Long Statement,Mosa.Compiler.Framework.Intrinsics,Store8,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store8.cs,ReplaceIntrinsicCall,The length of the statement  "				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2); " is 128.
Long Statement,Mosa.Compiler.Framework.Intrinsics,Store16,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store16.cs,ReplaceIntrinsicCall,The length of the statement  "				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2); " is 128.
Long Statement,Mosa.Compiler.Framework.Intrinsics,Store32,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store32.cs,ReplaceIntrinsicCall,The length of the statement  "				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2); " is 128.
Long Statement,Mosa.Compiler.Framework.Intrinsics,Load8,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load8.cs,ReplaceIntrinsicCall,The length of the statement  "				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' methodCompiler.ConstantZero); " is 124.
Long Statement,Mosa.Compiler.Framework.Intrinsics,Load64,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load64.cs,ReplaceIntrinsicCall,The length of the statement  "				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' methodCompiler.ConstantZero); " is 124.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,TraceBlocks,The length of the statement  "				extendedBlockTrace.Log("Block # " + block.BasicBlock.Sequence.ToString() + " (" + block.Start + " destination " + block.End + ")"); " is 131.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,TraceLiveIntervals,The length of the statement  "				registerTrace.Log("Live Intervals (" + virtualRegister.LiveIntervals.Count.ToString() + "): " + LiveIntervalsToString(virtualRegister.LiveIntervals' operand)); " is 159.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,TraceLiveIntervals,The length of the statement  "				registerTrace.Log("Def Positions (" + virtualRegister.DefPositions.Count.ToString() + "): " + SlotsToString(virtualRegister.DefPositions)); " is 139.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,TraceLiveIntervals,The length of the statement  "				registerTrace.Log("Use Positions (" + virtualRegister.UsePositions.Count.ToString() + "): " + SlotsToString(virtualRegister.UsePositions)); " is 139.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,LiveIntervalsToString,The length of the statement  "					sb.Append("[").Append(liveInterval.Start).Append("'").Append(liveInterval.End).Append("]/").Append(liveInterval.AssignedOperand).Append("'"); " is 141.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BuildLiveIntervals,The length of the statement  "						if (intervalTrace.Active) intervalTrace.Log("Add (LiveOut) " + register + " : " + block.Start + " destination " + ExtendedBlocks[b + 1].Start); " is 143.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BuildLiveIntervals,The length of the statement  "							if (intervalTrace.Active) intervalTrace.Log("Add (Call) " + register + " : " + slotIndex + " destination " + slotIndex.HalfStepForward); " is 136.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BuildLiveIntervals,The length of the statement  "							if (intervalTrace.Active) intervalTrace.Log("Add (Call) " + register + " : " + slotIndex + " destination " + slotIndex.HalfStepForward); " is 136.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BuildLiveIntervals,The length of the statement  "							if (intervalTrace.Active) intervalTrace.Log("Replace First " + register + " : " + slotIndex + " destination " + first.End); " is 123.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BuildLiveIntervals,The length of the statement  "							if (intervalTrace.Active) intervalTrace.Log("Add (Unused) " + register + " : " + slotIndex + " destination " + slotIndex); " is 122.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,BuildLiveIntervals,The length of the statement  "						if (intervalTrace.Active) intervalTrace.Log("Add (normal) " + register + " : " + block.Start + " destination " + slotIndex); " is 124.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,PlaceLiveIntervalOnTrackAllowEvictions,The length of the statement  "					if (intersection.SpillCost >= liveInterval.SpillCost || intersection.SpillCost == int.MaxValue || intersection.VirtualRegister.IsPhysicalRegister || intersection.IsPhysicalRegister) " is 181.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ProcessLiveInterval,The length of the statement  "				Trace.Log("Processing Interval: " + liveInterval + " / Length: " + liveInterval.Length.ToString() + " / Spill Cost: " + liveInterval.SpillCost.ToString() + " / Stage: " + liveInterval.Stage.ToString()); " is 202.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,CreatePhysicalRegisterOperands,The length of the statement  "					liveInterval.AssignedPhysicalOperand = Operand.CreateCPURegister(liveInterval.VirtualRegister.VirtualRegisterOperand.Type' liveInterval.AssignedPhysicalRegister); " is 162.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,InsertSpillMoves,The length of the statement  "						Architecture.InsertStoreInstruction(context' StackFrame' register.SpillSlotOperand' liveInterval.AssignedPhysicalOperand); " is 122.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,AssignRegisters,The length of the statement  "						AssignPhysicalRegistersToInstructions(use.Node' register.VirtualRegisterOperand' liveInterval.AssignedPhysicalOperand ?? liveInterval.VirtualRegister.SpillSlotOperand); " is 168.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,AssignRegisters,The length of the statement  "						AssignPhysicalRegistersToInstructions(def.Node' register.VirtualRegisterOperand' liveInterval.AssignedPhysicalOperand ?? liveInterval.VirtualRegister.SpillSlotOperand); " is 168.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ResolveDataFlow,The length of the statement  "								resolverTrace.Log("  INSERT: " + (fromAnchorFlag ? "FROM (bottom)" : "TO (Before)") + ((toLiveInterval.AssignedPhysicalOperand == null) ? "  ****SKIPPED***" : string.Empty)); " is 174.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,MoveResolver,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\MoveResolver.cs,InsertResolvingMoves,The length of the statement  "					case ResolvedMoveType.Load: architecture.InsertLoadInstruction(context' move.Destination' stackFrame' move.Source); break; " is 122.
Long Statement,Mosa.Compiler.Framework.RegisterAllocator,LiveInterval,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\LiveInterval.cs,CreateSplit,The length of the statement  "			return new LiveInterval(VirtualRegister' liveRange.Start' liveRange.End' LiveRange.UsePositions' LiveRange.DefPositions); " is 121.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MethodExceptionLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodExceptionLookupTableStage.cs,CreateMethodExceptionLookupTable,The length of the statement  "			var methodLookupTable = Linker.CreateSymbol(Metadata.MethodExceptionLookupTable' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 139.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MethodExceptionLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodExceptionLookupTableStage.cs,CreateMethodExceptionLookupTable,The length of the statement  "						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodLookupTable' (int)writer.Position' SectionKind.Text' method.FullName' 0); " is 134.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MethodExceptionLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodExceptionLookupTableStage.cs,CreateMethodExceptionLookupTable,The length of the statement  "						Linker.Link(LinkType.Size' NativePatchType' methodLookupTable' (int)writer.Position' SectionKind.Text' method.FullName' 0); " is 123.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MethodExceptionLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodExceptionLookupTableStage.cs,CreateMethodExceptionLookupTable,The length of the statement  "						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodLookupTable' (int)writer.Position' SectionKind.ROData' method.FullName + Metadata.MethodDefinition' 0); " is 164.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MethodLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodLookupTableStage.cs,RunPostCompile,The length of the statement  "			var methodLookupTable = Linker.CreateSymbol(Metadata.MethodLookupTable' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 130.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MethodLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodLookupTableStage.cs,RunPostCompile,The length of the statement  "						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodLookupTable' (int)writer.Position' SectionKind.Text' method.FullName' 0); " is 134.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MethodLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodLookupTableStage.cs,RunPostCompile,The length of the statement  "						Linker.Link(LinkType.Size' NativePatchType' methodLookupTable' (int)writer.Position' SectionKind.Text' method.FullName' 0); " is 123.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MethodLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodLookupTableStage.cs,RunPostCompile,The length of the statement  "						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodLookupTable' (int)writer.Position' SectionKind.ROData' method.FullName + Metadata.MethodDefinition' 0); " is 164.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MapFileGenerationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MapFileGenerationStage.cs,EmitSections,The length of the statement  "				writer.WriteLine("{0:x16} {1:x16} {2:x16} {3} {4}"' section.FileOffset' section.VirtualAddress' section.Size' section.Name.PadRight(32)' section.SectionKind); " is 158.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MapFileGenerationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MapFileGenerationStage.cs,EmitSymbols,The length of the statement  "					writer.WriteLine("{0:x16} {1:x16} {2:x16} {3} {4}"' symbol.VirtualAddress' symbol.SectionOffset' symbol.Size' symbol.SectionKind.ToString().PadRight(7)' symbol.Name); " is 166.
Long Statement,Mosa.Compiler.Framework.CompilerStages,PlugStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\PlugStage.cs,RunPreCompile,The length of the statement  "							targetType = TypeSystem.GetTypeByName(TypeSystem.GetModuleByAssembly(targetAssemblyName)' targetNameSpace' targetTypeName); " is 123.
Long Statement,Mosa.Compiler.Framework.CompilerStages,PlugStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\PlugStage.cs,MatchesWithStaticThis,The length of the statement  "			if (plugMethod.Signature.Parameters[0].ParameterType.IsValueType && !plugMethod.Signature.Parameters[0].ParameterType.IsManagedPointer) " is 135.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,EmitStringWithLength,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' symbol' (int)stream.Position' SectionKind.ROData' "System.String" + Metadata.TypeDefinition' 0); " is 151.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateDefinitionTables,The length of the statement  "			var assemblyListSymbol = Linker.CreateSymbol(Metadata.AssembliesTable' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 129.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateDefinitionTables,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' assemblyListSymbol' (int)writer1.Position' assemblyTableSymbol' 0); " is 122.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateAssemblyDefinition,The length of the statement  "			var assemblyTableSymbol = Linker.CreateSymbol(module.Assembly + Metadata.AssemblyDefinition' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 151.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateAssemblyDefinition,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' assemblyTableSymbol' (int)writer1.Position' assemblyNameSymbol' 0); " is 122.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateAssemblyDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' assemblyTableSymbol' (int)writer1.Position' customAttributeListSymbol' 0); " is 129.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "			var typeTableSymbol = Linker.CreateSymbol(type.FullName + Metadata.TypeDefinition' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 141.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' customAttributeListSymbol' 0); " is 125.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' SectionKind.ROData' type.BaseType.FullName + Metadata.TypeDefinition' 0); " is 168.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' SectionKind.ROData' type.DeclaringType.FullName + Metadata.TypeDefinition' 0); " is 173.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' SectionKind.ROData' type.ElementType.FullName + Metadata.TypeDefinition' 0); " is 171.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' SectionKind.ROData' method.FullName + Metadata.MethodDefinition' 0); " is 163.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' interfaceSlotTableSymbol' 0); " is 124.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' interfaceBitmapSymbol' 0); " is 121.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' SectionKind.Text' method.FullName' 0); " is 133.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The length of the statement  "					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' methodDefinitionSymbol' 0); " is 122.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateInterfaceBitmap,The length of the statement  "			var symbol = Linker.CreateSymbol(type.FullName + Metadata.InterfaceBitmap' SectionKind.ROData' TypeLayout.NativePointerAlignment' bitmap.Length); " is 145.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateInterfaceSlotTable,The length of the statement  "			var interfaceSlotTableSymbol = Linker.CreateSymbol(type.FullName + Metadata.InterfaceSlotTable' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 154.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateInterfaceSlotTable,The length of the statement  "					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' interfaceSlotTableSymbol' (int)writer1.Position' interfaceMethodTableSymbol' 0); " is 135.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateInterfaceMethodTable,The length of the statement  "			var interfaceMethodTableSymbol = Linker.CreateSymbol(type.FullName + Metadata.InterfaceMethodTable + interfaceType.FullName' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 183.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateInterfaceMethodTable,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' interfaceMethodTableSymbol' (int)writer1.Position' SectionKind.ROData' interfaceType.FullName + Metadata.TypeDefinition' 0); " is 179.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateInterfaceMethodTable,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' interfaceMethodTableSymbol' (int)writer1.Position' methodDefinitionSymbol' 0); " is 133.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateFieldDefinitions,The length of the statement  "			var fieldsTableSymbol = Linker.CreateSymbol(type.FullName + Metadata.FieldsTable' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 140.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateFieldDefinitions,The length of the statement  "				var fieldDefSymbol = Linker.CreateSymbol(field.FullName + Metadata.FieldDefinition' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 142.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateFieldDefinitions,The length of the statement  "					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' fieldDefSymbol' (int)writer2.Position' customAttributesTableSymbol' 0); " is 126.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateFieldDefinitions,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' fieldDefSymbol' (int)writer2.Position' SectionKind.ROData' field.FieldType.FullName + Metadata.TypeDefinition' 0); " is 169.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateFieldDefinitions,The length of the statement  "					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' fieldDefSymbol' (int)writer2.Position' section' field.FullName' 0); " is 122.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreatePropertyDefinitions,The length of the statement  "			var propertiesTableSymbol = Linker.CreateSymbol(type.FullName + Metadata.PropertiesTable' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 148.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreatePropertyDefinitions,The length of the statement  "				var propertyDefSymbol = Linker.CreateSymbol(property.FullName + Metadata.PropertyDefinition' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 151.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreatePropertyDefinitions,The length of the statement  "					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer1.Position' customAttributesTableSymbol' 0); " is 129.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreatePropertyDefinitions,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer2.Position' SectionKind.ROData' property.PropertyType.FullName + Metadata.TypeDefinition' 0); " is 178.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreatePropertyDefinitions,The length of the statement  "						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer2.Position' SectionKind.ROData' property.GetterMethod.FullName + Metadata.MethodDefinition' 0); " is 180.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreatePropertyDefinitions,The length of the statement  "						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer2.Position' SectionKind.ROData' property.SetterMethod.FullName + Metadata.MethodDefinition' 0); " is 180.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreatePropertyDefinitions,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertiesTableSymbol' (int)writer1.Position' propertyDefSymbol' 0); " is 123.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateMethodDefinition,The length of the statement  "			var methodTableSymbol = Linker.CreateSymbol(method.FullName + Metadata.MethodDefinition' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 147.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateMethodDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodTableSymbol' (int)writer1.Position' customAttributeListSymbol' 0); " is 127.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateMethodDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodTableSymbol' (int)writer1.Position' SectionKind.Text' method.FullName' 0); " is 135.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateMethodDefinition,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodTableSymbol' (int)writer1.Position' SectionKind.ROData' method.Signature.ReturnType.FullName + Metadata.TypeDefinition' 0); " is 184.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateMethodDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodTableSymbol' (int)writer1.Position' SectionKind.ROData' method.FullName + Metadata.ProtectedRegionTable' 0); " is 169.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateMethodDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' methodTableSymbol' (int)writer1.Position' parameterDefinitionSymbol' 0); " is 127.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateParameterDefinition,The length of the statement  "			var parameterTableSymbol = Linker.CreateSymbol(parameter.FullName + Metadata.MethodDefinition' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 153.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateParameterDefinition,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' parameterTableSymbol' (int)writer1.Position' parameterNameSymbol' 0); " is 124.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateParameterDefinition,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' parameterTableSymbol' (int)writer1.Position' customAttributeListSymbol' 0); " is 130.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateParameterDefinition,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' parameterTableSymbol' (int)writer1.Position' SectionKind.ROData' parameter.ParameterType.FullName + Metadata.TypeDefinition' 0); " is 183.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttributesTable,The length of the statement  "			var customAttributesTableSymbol = Linker.CreateSymbol(unit.FullName + Metadata.CustomAttributesTable' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 160.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttributesTable,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' customAttributesTableSymbol' (int)writer1.Position' customAttributeTableSymbol' 0); " is 138.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttribute,The length of the statement  "			var customAttributeSymbol = Linker.CreateSymbol(name + Metadata.CustomAttribute' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 139.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttribute,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' customAttributeSymbol' (int)writer1.Position' SectionKind.ROData' ca.Constructor.DeclaringType.FullName + Metadata.TypeDefinition' 0); " is 189.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttribute,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' customAttributeSymbol' (int)writer1.Position' SectionKind.ROData' ca.Constructor.FullName + Metadata.MethodDefinition' 0); " is 177.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttribute,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' customAttributeSymbol' (int)writer1.Position' customAttributeArgumentSymbol' 0); " is 135.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttribute,The length of the statement  "				var customAttributeArgumentSymbol = CreateCustomAttributeArgument(name' 0' namedArg.Name' namedArg.Argument' namedArg.IsField); " is 127.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttribute,The length of the statement  "				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' customAttributeSymbol' (int)writer1.Position' customAttributeArgumentSymbol' 0); " is 135.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttributeArgument,The length of the statement  "			var symbol = Linker.CreateSymbol(nameForSymbol + Metadata.CustomAttributeArgument' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 141.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateCustomAttributeArgument,The length of the statement  "			Linker.Link(LinkType.AbsoluteAddress' NativePatchType' symbol' (int)writer1.Position' SectionKind.ROData' arg.Type.FullName + Metadata.TypeDefinition' 0); " is 154.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,WriteArgument,The length of the statement  "					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' symbol' (int)writer.Position' SectionKind.ROData' "System.String" + Metadata.TypeDefinition' 0); " is 151.
Long Statement,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,WriteArgument,The length of the statement  "						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' symbol' (int)writer.Position' SectionKind.ROData' valueType.FullName + Metadata.TypeDefinition' 0); " is 154.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,SetReturn,The length of the statement  "				context.SetInstruction(IRInstruction.MoveFloatR4' Operand.CreateCPURegister(operand.Type' Architecture.ReturnFloatingPointRegister)' operand); " is 142.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,SetReturn,The length of the statement  "				context.SetInstruction(IRInstruction.MoveFloatR8' Operand.CreateCPURegister(operand.Type' Architecture.ReturnFloatingPointRegister)' operand); " is 142.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,SetReturn,The length of the statement  "				context.AppendInstruction(IRInstruction.MoveInteger' InstructionSize.Size32' Operand.CreateCPURegister(TypeSystem.BuiltIn.U4' Architecture.Return32BitRegister)' v1); " is 165.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,SetReturn,The length of the statement  "				context.AppendInstruction(IRInstruction.MoveInteger' InstructionSize.Size32' Operand.CreateCPURegister(TypeSystem.BuiltIn.U4' Architecture.Return64BitRegister)' v2); " is 165.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,SetReturn,The length of the statement  "				context.SetInstruction(IRInstruction.MoveInteger' InstructionSize.Size32' Operand.CreateCPURegister(operand.Type' Architecture.Return32BitRegister)' operand); " is 158.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallVirtual,The length of the statement  "			context.AppendInstruction(IRInstruction.LoadInteger' NativeInstructionSize' callTarget' typeDefinition' CreateConstant(methodPointerOffset)); " is 141.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallInterface,The length of the statement  "			context.AppendInstruction(IRInstruction.LoadInteger' NativeInstructionSize' interfaceSlotPtr' typeDefinition' CreateConstant(interfaceSlotTableOffset)); " is 152.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallInterface,The length of the statement  "			context.AppendInstruction(IRInstruction.LoadInteger' NativeInstructionSize' interfaceMethodTablePtr' interfaceSlotPtr' CreateConstant(interfaceMethodTableOffset)); " is 163.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallInterface,The length of the statement  "			context.AppendInstruction(IRInstruction.LoadInteger' NativeInstructionSize' methodDefinition' interfaceMethodTablePtr' CreateConstant(methodDefinitionOffset)); " is 159.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallInterface,The length of the statement  "			context.AppendInstruction(IRInstruction.LoadInteger' NativeInstructionSize' callTarget' methodDefinition' CreateConstant(methodPointerOffset)); " is 143.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,ReserveStackSizeForCall,The length of the statement  "			context.AppendInstruction(IRInstruction.SubSigned' StackPointer' StackPointer' CreateConstant(TypeSystem.BuiltIn.I4' stackSize)); " is 129.
Long Statement,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,FreeStackAfterCall,The length of the statement  "			context.AppendInstruction(IRInstruction.AddSigned' StackPointer' StackPointer' CreateConstant(TypeSystem.BuiltIn.I4' stackSize)); " is 129.
Long Statement,Mosa.Compiler.Framework.Stages,LowerIRStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\LowerIRStage.cs,GetVMCallMethod,The length of the statement  "			var method = InternalRuntimeType.FindMethodByName(methodName) ?? PlatformInternalRuntimeType.FindMethodByName(methodName); " is 122.
Long Statement,Mosa.Compiler.Framework.Stages,InlineStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\InlineStage.cs,Run,The length of the statement  "			if (MethodCompiler.Method.IsLinkerGenerated && MethodCompiler.Method.Name == TypeInitializerSchedulerStage.TypeInitializerName) " is 127.
Long Statement,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,EmitProtectedRegionTable,The length of the statement  "			var protectedRegionTableSymbol = MethodCompiler.Linker.CreateSymbol(MethodCompiler.Method.FullName + Metadata.ProtectedRegionTable' SectionKind.ROData' NativeAlignment' 0); " is 172.
Long Statement,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,EmitProtectedRegionTable,The length of the statement  "					trace.Log("Handler: " + region.Handler.TryStart.ToString("X4") + " to " + region.Handler.TryEnd.ToString("X4") + " Handler: " + region.Handler.HandlerStart.ToString("X4") + " Offset: [" + handler.ToString("X4") + "]"); " is 218.
Long Statement,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,EmitProtectedRegionTable,The length of the statement  "					var protectedRegionDefinition = CreateProtectedRegionDefinition(name' (uint)start' (uint)end' handler' region.Handler.ExceptionHandlerType' region.Handler.Type); " is 161.
Long Statement,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,EmitProtectedRegionTable,The length of the statement  "					MethodCompiler.Linker.Link(LinkType.AbsoluteAddress' NativePatchType' protectedRegionTableSymbol' (int)writer.Position' protectedRegionDefinition' 0); " is 150.
Long Statement,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,CreateProtectedRegionDefinition,The length of the statement  "			var protectedRegionDefinitionSymbol = MethodCompiler.Linker.CreateSymbol(name' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0); " is 137.
Long Statement,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,CreateProtectedRegionDefinition,The length of the statement  "				MethodCompiler.Linker.Link(LinkType.AbsoluteAddress' NativePatchType' protectedRegionDefinitionSymbol' (int)writer1.Position' SectionKind.ROData' exceptionType.FullName + Metadata.TypeDefinition' 0); " is 199.
Long Statement,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,FinallyEndInstruction,The length of the statement  "			ctx.SetInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.NotEqual' null' exceptionVirtualRegister' nullOperand' newBlocks[0].Block); " is 144.
Long Statement,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,The length of the statement  "			// FIXME: This will need to be preserved for filtered exceptions; will need a flag to know this - maybe an upper bit of leaveTargetRegister " is 139.
Long Statement,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,The length of the statement  "			if (exceptionContext.ExceptionHandlerType == ExceptionHandlerType.Finally && exceptionContext.IsLabelWithinTry(node.Label)) " is 123.
Long Statement,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,The length of the statement  "				ctx.AppendInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.GreaterThan' null' CreateConstant(handlerBlock.Label)' leaveTargetRegister' nextBlock.Block); " is 165.
Long Statement,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,The length of the statement  "				var otherBranch = (previousBlock.NextBlocks[0] == currentBlock) ? previousBlock.NextBlocks[1] : previousBlock.NextBlocks[0]; " is 124.
Long Statement,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,The length of the statement  "				ctx.AppendInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.Equal' null' leaveTargetRegister' CreateConstant(targets[0].Label)' targets[0]); " is 152.
Long Statement,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,The length of the statement  "					newBlocks[b - 1].AppendInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.Equal' null' leaveTargetRegister' CreateConstant(targets[b].Label)' targets[b]); " is 165.
Long Statement,Mosa.Compiler.Framework.Stages,GreedyRegisterAllocatorStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\GreedyRegisterAllocatorStage.cs,Run,The length of the statement  "			var allocator = new GreedyRegisterAllocator(BasicBlocks' MethodCompiler.VirtualRegisters' Architecture' MethodCompiler.AddStackLocal' StackFrame' this); " is 152.
Long Statement,Mosa.Compiler.Framework.Stages,BlockOrderingStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\BlockOrderingStage.cs,DumpTrace,The length of the statement  "				trace.Log("Block " + block + " #" + block.Sequence.ToString() + " -> Depth: " + depth.ToString() + " Index: " + depthindex.ToString()); " is 135.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,Run,The length of the statement  "			UpdateCounter("IROptimizations.ArithmeticSimplificationAdditionAndSubstraction"' arithmeticSimplificationAdditionAndSubstractionCount); " is 135.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,Run,The length of the statement  "			UpdateCounter("IROptimizations.ArithmeticSimplificationLogicalOperators"' arithmeticSimplificationLogicalOperatorsCount); " is 121.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The length of the statement  "			if (NativePointerSize == 4 && (destination.IsI || destination.IsU || destination.IsUnmanagedPointer) && (source.IsI4 || source.IsU4)) " is 133.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The length of the statement  "			if (NativePointerSize == 4 && (source.IsI || source.IsU || source.IsUnmanagedPointer) && (destination.IsI4 || destination.IsU4)) " is 128.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The length of the statement  "			if (NativePointerSize == 8 && (destination.IsI || destination.IsU || destination.IsUnmanagedPointer) && (source.IsI8 || source.IsU8)) " is 133.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The length of the statement  "			if (NativePointerSize == 8 && (source.IsI || source.IsU || source.IsUnmanagedPointer) && (destination.IsI8 || destination.IsU8)) " is 128.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ForwardPropagateMove,The length of the statement  "			// Also if the operand sign is different' we cannot do it as it requires a signed/unsigned extended move' not a normal move " is 123.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerOperations,The length of the statement  "			if ((node.Instruction == IRInstruction.DivSigned || node.Instruction == IRInstruction.DivUnsigned || node.Instruction == IRInstruction.RemSigned || node.Instruction == IRInstruction.RemUnsigned) && op2.IsConstantZero) " is 217.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerOperations,The length of the statement  "				constant = CreateConstant(result.Type' ((long)op1.ConstantUnsignedLongInteger) >> (int)op2.ConstantUnsignedLongInteger); " is 120.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerCompare,The length of the statement  "				case ConditionCode.NotEqual: compareResult = (op1.ConstantUnsignedLongInteger != op2.ConstantUnsignedLongInteger); break; " is 121.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerCompare,The length of the statement  "				case ConditionCode.GreaterOrEqual: compareResult = (op1.ConstantUnsignedLongInteger >= op2.ConstantUnsignedLongInteger); break; " is 127.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerCompare,The length of the statement  "				case ConditionCode.GreaterThan: compareResult = (op1.ConstantUnsignedLongInteger > op2.ConstantUnsignedLongInteger); break; " is 123.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerCompare,The length of the statement  "				case ConditionCode.LessOrEqual: compareResult = (op1.ConstantUnsignedLongInteger <= op2.ConstantUnsignedLongInteger); break; " is 124.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerCompare,The length of the statement  "				case ConditionCode.LessThan: compareResult = (op1.ConstantUnsignedLongInteger < op2.ConstantUnsignedLongInteger); break; " is 120.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationLogicalOperators,The length of the statement  "			// TODO: Add more strength reductions especially for AND w/ 0xFF' 0xFFFF' 0xFFFFFFFF' etc when source or destination are same or smaller " is 136.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldIntegerCompareBranch,The length of the statement  "				case ConditionCode.NotEqual: compareResult = (op1.ConstantUnsignedLongInteger != op2.ConstantUnsignedLongInteger); break; " is 121.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldIntegerCompareBranch,The length of the statement  "				case ConditionCode.GreaterOrEqual: compareResult = (op1.ConstantUnsignedLongInteger >= op2.ConstantUnsignedLongInteger); break; " is 127.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldIntegerCompareBranch,The length of the statement  "				case ConditionCode.GreaterThan: compareResult = (op1.ConstantUnsignedLongInteger > op2.ConstantUnsignedLongInteger); break; " is 123.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldIntegerCompareBranch,The length of the statement  "				case ConditionCode.LessOrEqual: compareResult = (op1.ConstantUnsignedLongInteger <= op2.ConstantUnsignedLongInteger); break; " is 124.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldIntegerCompareBranch,The length of the statement  "				case ConditionCode.LessThan: compareResult = (op1.ConstantUnsignedLongInteger < op2.ConstantUnsignedLongInteger); break; " is 120.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CombineIntegerCompareBranch,The length of the statement  "			node.ConditionCode = node.ConditionCode == ConditionCode.NotEqual ? node2.ConditionCode : node2.ConditionCode.GetOpposite(); " is 124.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,FoldIntegerCompare,The length of the statement  "			node.ConditionCode = node.ConditionCode == ConditionCode.NotEqual ? node2.ConditionCode : node2.ConditionCode.GetOpposite(); " is 124.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,FoldLoadStoreOffsets,The length of the statement  "				constant = Operand.CreateConstant(node.Operand2.Type' node2.Operand2.ConstantSignedLongInteger + node.Operand2.ConstantSignedLongInteger); " is 138.
Long Statement,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,FoldLoadStoreOffsets,The length of the statement  "				constant = Operand.CreateConstant(node.Operand2.Type' node.Operand2.ConstantSignedLongInteger - node2.Operand2.ConstantSignedLongInteger); " is 138.
Long Statement,Mosa.Compiler.Framework.Stages,UnboxValueTypeStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\UnboxValueTypeStage.cs,Run,The length of the statement  "			if (BasicBlocks.PrologueBlock.NextBlocks.Count == 0 || BasicBlocks.PrologueBlock.NextBlocks[0] == BasicBlocks.EpilogueBlock) " is 124.
Long Statement,Mosa.Compiler.Framework.Stages,UnboxValueTypeStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\UnboxValueTypeStage.cs,Run,The length of the statement  "			context.AppendInstruction(IRInstruction.AddSigned' NativeInstructionSize' v1' v1' CreateConstant(NativePointerSize * 2)); " is 121.
Long Statement,Mosa.Compiler.Framework.Stages,CILDecodingStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILDecodingStage.cs,DecodeInstructions,The length of the statement  "				if (flow == FlowControl.Next || flow == FlowControl.Call || flow == FlowControl.ConditionalBranch || flow == FlowControl.Switch) " is 128.
Long Statement,Mosa.Compiler.Framework.Stages,CILProtectedRegionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILProtectedRegionStage.cs,Run,The length of the statement  "			MethodCompiler.SetProtectedRegions(ProtectedRegion.CreateProtectedRegions(BasicBlocks' MethodCompiler.Method.ExceptionHandlers)); " is 129.
Long Statement,Mosa.Compiler.Framework.Stages,StaticAllocationResolutionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\StaticAllocationResolutionStage.cs,ScanForNewOperators,The length of the statement  "					if ((node.Instruction is NewobjInstruction && !MosaTypeLayout.IsStoredOnStack(node.Result.Type)) || node.Instruction is NewarrInstruction) " is 138.
Long Statement,Mosa.Compiler.Framework.Stages,StaticAllocationResolutionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\StaticAllocationResolutionStage.cs,PerformStaticAllocationOf,The length of the statement  "			var symbolName = MethodCompiler.Linker.CreateSymbol(assignmentField.FullName + "<<$cctor"' SectionKind.ROData' Architecture.NativeAlignment' typeSize); " is 151.
Long Statement,Mosa.Compiler.Framework.Stages,StaticAllocationResolutionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\StaticAllocationResolutionStage.cs,PerformStaticAllocationOf,The length of the statement  "				MethodCompiler.Linker.Link(LinkType.AbsoluteAddress' PatchType.I4' symbolName' 0' SectionKind.ROData' typeDefinitionSymbol' 0); " is 127.
Long Statement,Mosa.Compiler.Framework.Stages,StaticAllocationResolutionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\StaticAllocationResolutionStage.cs,CheckAssignmentForCompliance,The length of the statement  "			var allocationType = (allocation.InvokeMethod != null) ? allocation.InvokeMethod.DeclaringType : allocation.Result.Type.ElementType; " is 132.
Long Statement,Mosa.Compiler.Framework.Stages,StaticAllocationResolutionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\StaticAllocationResolutionStage.cs,CheckAssignmentForCompliance,The length of the statement  "			var storageType = (allocation.Instruction is CIL.NewarrInstruction) ? assignment.Operand1.Type.ElementType : assignment.MosaField.DeclaringType; " is 144.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Call,The length of the statement  "					before.SetInstruction(IRInstruction.SubSigned' context.Operand1' context.Operand1' CreateConstant(NativePointerSize * 2)); " is 122.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Call,The length of the statement  "					before.SetInstruction(IRInstruction.Box' boxedValue' GetRuntimeTypeHandle(type)' context.Operand1' CreateConstant(typeSize)); " is 125.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Callvirt,The length of the statement  "							before.SetInstruction(IRInstruction.SubSigned' context.Operand1' context.Operand1' CreateConstant(NativePointerSize * 2)); " is 122.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Callvirt,The length of the statement  "						before.SetInstruction(IRInstruction.Box' boxedValue' GetRuntimeTypeHandle(type)' context.Operand1' CreateConstant(typeSize)); " is 125.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetRuntimeTypeHandle,The length of the statement  "			return Operand.CreateSymbol(TypeSystem.GetTypeByName("System"' "RuntimeTypeHandle")' runtimeType.FullName + Metadata.TypeDefinition); " is 133.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldftn,The length of the statement  "			node.SetInstruction(IRInstruction.MoveInteger' node.Result' Operand.CreateSymbolFromMethod(node.InvokeMethod' TypeSystem)); " is 123.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldstr,The length of the statement  "			var symbol = linker.CreateSymbol(symbolName' SectionKind.ROData' NativeAlignment' (NativePointerSize * 3) + (stringdata.Length * 2)); " is 133.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldstr,The length of the statement  "			linker.Link(LinkType.AbsoluteAddress' PatchType.I4' symbol' 0' SectionKind.ROData' "System.String" + Metadata.TypeDefinition' 0); " is 129.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldstr,The length of the statement  "			Debug.Assert(stringData.Length == stringdata.Length * 2' "Byte array of string data doesn't match expected string data length"); " is 128.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Newobj,The length of the statement  "				Debug.Assert(result.Type.IsReferenceType' $"VmCall.AllocateObject only needs to be called for reference types. Type: {result.Type}"); " is 133.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Shift,The length of the statement  "				case OpCode.Shr: node.SetInstruction(IRInstruction.ArithmeticShiftRight' node.Result' node.Operand1' node.Operand2); break; " is 123.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Unbox,The length of the statement  "				context.AppendInstruction(typeSize != 8 ? (BaseIRInstruction)IRInstruction.Unbox32 : IRInstruction.Unbox64' tmp' value); " is 120.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,AddArrayBoundsCheck,The length of the statement  "			before.AppendInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.UnsignedGreaterOrEqual' null' arrayIndexOperand' lengthOperand' exceptionContext.Block); " is 163.
Long Statement,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,ProcessExternalCall,The length of the statement  "					MethodCompiler.Compiler.IntrinsicTypes.TryGetValue(node.InvokeMethod.DeclaringType.FullName + "::" + node.InvokeMethod.Name' out intrinsicType); " is 144.
Long Statement,Mosa.Compiler.Framework.CIL,ArithmeticInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\ArithmeticInstruction.cs,Resolve,The length of the statement  "				case OpCode.Add: result = addTable[(int)context.Operand1.Type.GetStackTypeCode()][(int)context.Operand2.Type.GetStackTypeCode()]; break; " is 136.
Long Statement,Mosa.Compiler.Framework.CIL,ArithmeticInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\ArithmeticInstruction.cs,Resolve,The length of the statement  "				case OpCode.Sub: result = subTable[(int)context.Operand1.Type.GetStackTypeCode()][(int)context.Operand2.Type.GetStackTypeCode()]; break; " is 136.
Long Statement,Mosa.Compiler.Framework.CIL,ArithmeticInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\ArithmeticInstruction.cs,Resolve,The length of the statement  "				default: result = operandTable[(int)context.Operand1.Type.GetStackTypeCode()][(int)context.Operand2.Type.GetStackTypeCode()]; break; " is 132.
Long Statement,Mosa.Compiler.Framework.CIL,ArithmeticOverflowInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\ArithmeticOverflowInstruction.cs,Resolve,The length of the statement  "				case OpCode.Add_ovf_un: result = addovfunTable[(int)context.Operand1.Type.GetStackTypeCode()][(int)context.Operand2.Type.GetStackTypeCode()]; break; " is 148.
Long Statement,Mosa.Compiler.Framework.CIL,ArithmeticOverflowInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\ArithmeticOverflowInstruction.cs,Resolve,The length of the statement  "				case OpCode.Sub_ovf_un: result = subovfunTable[(int)context.Operand1.Type.GetStackTypeCode()][(int)context.Operand2.Type.GetStackTypeCode()]; break; " is 148.
Long Statement,Mosa.Compiler.Framework.CIL,ArithmeticOverflowInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\ArithmeticOverflowInstruction.cs,Resolve,The length of the statement  "				default: result = operandTable[(int)context.Operand1.Type.GetStackTypeCode()][(int)context.Operand2.Type.GetStackTypeCode()]; break; " is 132.
Long Statement,Mosa.Compiler.Framework.CIL,BinaryLogicInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\BinaryLogicInstruction.cs,Resolve,The length of the statement  "				throw new InvalidOperationException("Invalid virtualLocal result of instruction: " + result.ToString() + " (" + context.Operand1 + ")"); " is 136.
Long Statement,Mosa.Compiler.Framework.CIL,LdtokenInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdtokenInstruction.cs,Decode,The length of the statement  "				node.Result = decoder.MethodCompiler.CreateVirtualRegister(decoder.TypeSystem.GetTypeByName("System"' "RuntimeTypeHandle")); " is 124.
Long Statement,Mosa.Compiler.Framework.CIL,LdtokenInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdtokenInstruction.cs,Decode,The length of the statement  "				node.Result = decoder.MethodCompiler.CreateVirtualRegister(decoder.TypeSystem.GetTypeByName("System"' "RuntimeMethodHandle")); " is 126.
Long Statement,Mosa.Compiler.Framework.CIL,LdtokenInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdtokenInstruction.cs,Decode,The length of the statement  "				node.Result = decoder.MethodCompiler.CreateVirtualRegister(decoder.TypeSystem.GetTypeByName("System"' "RuntimeFieldHandle")); " is 125.
Long Statement,Mosa.Compiler.Framework.CIL,NewobjInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\NewobjInstruction.cs,Resolve,The length of the statement  "			Debug.Assert(context.OperandCount == context.InvokeMethod.Signature.Parameters.Count - offset' "Operand count doesn't match parameter count."); " is 143.
Long Statement,Mosa.Compiler.Framework.CIL,RefanyvalInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\RefanyvalInstruction.cs,Resolve,The length of the statement  "				if (!Object.ReferenceEquals(_operands[0].Type' MetadataTypeReference.FromName(compiler.Assembly.Metadata' @"System"' @"TypedReference"))) " is 137.
Long Statement,Mosa.Compiler.Framework.CIL,ShiftInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\ShiftInstruction.cs,Resolve,The length of the statement  "			var result = operandTable[(int)context.Operand1.Type.GetStackTypeCode()][(int)context.Operand2.Type.GetStackTypeCode()]; " is 120.
Long Statement,Mosa.Compiler.Framework.CIL,ShiftInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\ShiftInstruction.cs,Resolve,The length of the statement  "				throw new InvalidOperationException("Invalid virtualLocal state for pairing (" + context.Operand1.Type.GetStackType() + "' " + context.Operand2.Type.GetStackType() + ")"); " is 171.
Complex Conditional,Mosa.Compiler.Framework.Analysis,SparseConditionalConstantPropagation,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,ProcessInstruction,The conditional expression  "instruction == IRInstruction.CallDynamic  				|| instruction == IRInstruction.CallInterface  				|| instruction == IRInstruction.CallDirect  				|| instruction == IRInstruction.CallStatic  				|| instruction == IRInstruction.CallVirtual  				|| instruction == IRInstruction.IntrinsicMethodCall"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Analysis,SparseConditionalConstantPropagation,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,ProcessInstruction,The conditional expression  "instruction == IRInstruction.LoadInteger  				|| instruction == IRInstruction.LoadSignExtended  				|| instruction == IRInstruction.LoadZeroExtended  				|| instruction == IRInstruction.LoadFloatR4  				|| instruction == IRInstruction.LoadFloatR8  				|| instruction == IRInstruction.LoadParameterInteger  				|| instruction == IRInstruction.LoadParameterSignExtended  				|| instruction == IRInstruction.LoadParameterZeroExtended  				|| instruction == IRInstruction.LoadParameterFloatR4  				|| instruction == IRInstruction.LoadParameterFloatR8"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Analysis,SparseConditionalConstantPropagation,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,ProcessInstruction,The conditional expression  "instruction == IRInstruction.AddSigned  				|| instruction == IRInstruction.AddUnsigned  				|| instruction == IRInstruction.SubSigned  				|| instruction == IRInstruction.SubUnsigned  				|| instruction == IRInstruction.MulSigned  				|| instruction == IRInstruction.MulUnsigned  				|| instruction == IRInstruction.DivSigned  				|| instruction == IRInstruction.DivUnsigned  				|| instruction == IRInstruction.RemSigned  				|| instruction == IRInstruction.RemUnsigned  				|| instruction == IRInstruction.ShiftLeft  				|| instruction == IRInstruction.ShiftRight  				|| instruction == IRInstruction.ArithmeticShiftRight"  is complex.
Complex Conditional,Mosa.Compiler.Framework,BaseMethodCompilerStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseMethodCompilerStage.cs,AddMissingBlocks,The conditional expression  "(!cleanUp) || (block.HasNextBlocks || block.HasPreviousBlocks || block.IsHandlerHeadBlock || block.IsTryHeadBlock)"  is complex.
Complex Conditional,Mosa.Compiler.Framework,BaseMethodCompiler,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseMethodCompiler.cs,InitializeType,The conditional expression  "Method.IsSpecialName && Method.IsRTSpecialName && Method.IsStatic && Method.Name == ".cctor""  is complex.
Complex Conditional,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,CreateConstant,The conditional expression  "!(operand.IsInteger || operand.IsBoolean || operand.IsChar || operand.IsPointer || operand.IsReferenceType)"  is complex.
Complex Conditional,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,ToString,The conditional expression  "IsUnsigned || IsBoolean || IsChar || IsPointer"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Intrinsics,BaseInternals,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\BaseInternals.cs,Internal,The conditional expression  "context == null || methodCompiler == null || internalMethod == null || internalClass == null"  is complex.
Complex Conditional,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,PlaceLiveIntervalOnTrackAllowEvictions,The conditional expression  "intersection.SpillCost >= liveInterval.SpillCost || intersection.SpillCost == int.MaxValue || intersection.VirtualRegister.IsPhysicalRegister || intersection.IsPhysicalRegister"  is complex.
Complex Conditional,Mosa.Compiler.Framework.RegisterAllocator,MoveResolver,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\MoveResolver.cs,InsertResolvingMoves,The conditional expression  "context.IsEmpty  					|| context.Instruction.FlowControl == FlowControl.UnconditionalBranch  					|| context.Instruction.FlowControl == FlowControl.ConditionalBranch  					|| context.Instruction.FlowControl == FlowControl.Return"  is complex.
Complex Conditional,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,CollectMoveHints,The conditional expression  "!((node.Result.IsVirtualRegister && node.Operand1.IsVirtualRegister)  						|| (node.Result.IsVirtualRegister && node.Operand1.IsCPURegister)  						|| (node.Result.IsCPURegister && node.Operand1.IsVirtualRegister))"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,CollectLeaveTargets,The conditional expression  "context.IsEmpty  					|| context.IsBlockEndInstruction  					|| context.Instruction == IRInstruction.Flow  					|| context.Instruction == IRInstruction.GotoLeaveTarget"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,DeadCodeElimination,The conditional expression  "node.Instruction == IRInstruction.CallDynamic  				|| node.Instruction == IRInstruction.CallInterface  				|| node.Instruction == IRInstruction.CallDirect  				|| node.Instruction == IRInstruction.CallStatic  				|| node.Instruction == IRInstruction.CallVirtual  				|| node.Instruction == IRInstruction.NewObject  				|| node.Instruction == IRInstruction.SetReturn  				|| node.Instruction == IRInstruction.IntrinsicMethodCall"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The conditional expression  "NativePointerSize == 4 && (destination.IsI || destination.IsU || destination.IsUnmanagedPointer) && (source.IsI4 || source.IsU4)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The conditional expression  "NativePointerSize == 4 && (source.IsI || source.IsU || source.IsUnmanagedPointer) && (destination.IsI4 || destination.IsU4)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The conditional expression  "NativePointerSize == 8 && (destination.IsI || destination.IsU || destination.IsUnmanagedPointer) && (source.IsI8 || source.IsU8)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The conditional expression  "NativePointerSize == 8 && (source.IsI || source.IsU || source.IsUnmanagedPointer) && (destination.IsI8 || destination.IsU8)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The conditional expression  "(source.IsI || source.IsU) && (destination.IsI || destination.IsU)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerOperations,The conditional expression  "!(node.Instruction == IRInstruction.AddSigned  				|| node.Instruction == IRInstruction.AddUnsigned  				|| node.Instruction == IRInstruction.SubSigned  				|| node.Instruction == IRInstruction.SubUnsigned  				|| node.Instruction == IRInstruction.LogicalAnd  				|| node.Instruction == IRInstruction.LogicalOr  				|| node.Instruction == IRInstruction.LogicalXor  				|| node.Instruction == IRInstruction.MulSigned  				|| node.Instruction == IRInstruction.MulUnsigned  				|| node.Instruction == IRInstruction.DivSigned  				|| node.Instruction == IRInstruction.DivUnsigned  				|| node.Instruction == IRInstruction.RemSigned  				|| node.Instruction == IRInstruction.RemUnsigned  				|| node.Instruction == IRInstruction.ArithmeticShiftRight  				|| node.Instruction == IRInstruction.ShiftLeft  				|| node.Instruction == IRInstruction.ShiftRight)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingIntegerOperations,The conditional expression  "(node.Instruction == IRInstruction.DivSigned || node.Instruction == IRInstruction.DivUnsigned || node.Instruction == IRInstruction.RemSigned || node.Instruction == IRInstruction.RemUnsigned) && op2.IsConstantZero"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationAdditionAndSubstraction,The conditional expression  "!(node.Instruction == IRInstruction.AddSigned  				|| node.Instruction == IRInstruction.AddUnsigned  				|| node.Instruction == IRInstruction.SubSigned  				|| node.Instruction == IRInstruction.SubUnsigned)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationLogicalOperators,The conditional expression  "((result.IsI4 || result.IsU4 || result.IsI || result.IsU) && op2.ConstantUnsignedInteger == 0xFFFFFFFF)  					|| ((result.IsI8 || result.IsU8) && op2.ConstantUnsignedLongInteger == 0xFFFFFFFFFFFFFFFF)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantMoveToRight,The conditional expression  "!(node.Instruction == IRInstruction.AddSigned  				|| node.Instruction == IRInstruction.AddUnsigned  				|| node.Instruction == IRInstruction.MulSigned  				|| node.Instruction == IRInstruction.MulUnsigned  				|| node.Instruction == IRInstruction.LogicalAnd  				|| node.Instruction == IRInstruction.LogicalOr  				|| node.Instruction == IRInstruction.LogicalXor)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingAdditionAndSubstraction,The conditional expression  "!(node.Instruction == IRInstruction.AddSigned  				|| node.Instruction == IRInstruction.AddUnsigned  				|| node.Instruction == IRInstruction.SubSigned  				|| node.Instruction == IRInstruction.SubUnsigned)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingAdditionAndSubstraction,The conditional expression  "!(node2.Instruction == IRInstruction.AddSigned || node2.Instruction == IRInstruction.AddUnsigned  				|| node2.Instruction == IRInstruction.SubSigned || node2.Instruction == IRInstruction.SubUnsigned)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingAdditionAndSubstraction,The conditional expression  "(node.Instruction == IRInstruction.AddSigned || node.Instruction == IRInstruction.AddUnsigned)  				&& (node2.Instruction == IRInstruction.SubSigned || node2.Instruction == IRInstruction.SubUnsigned)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldingAdditionAndSubstraction,The conditional expression  "(node.Instruction == IRInstruction.SubSigned || node.Instruction == IRInstruction.SubUnsigned)  				&& (node2.Instruction == IRInstruction.AddSigned || node2.Instruction == IRInstruction.AddUnsigned)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CombineIntegerCompareBranch,The conditional expression  "!((node.Operand1.IsVirtualRegister && node.Operand2.IsConstantZero)  				|| (node.Operand2.IsVirtualRegister && node.Operand1.IsConstantZero))"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,FoldIntegerCompare,The conditional expression  "!((node.Operand1.IsVirtualRegister && node.Operand2.IsConstantZero)  				|| (node.Operand2.IsVirtualRegister && node.Operand1.IsConstantZero))"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyExtendedMove,The conditional expression  "!((NativePointerSize == 4 && node.Result.IsInt && (node.Operand1.IsInt || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 4 && node.Operand1.IsInt && (node.Result.IsInt || node.Result.IsU || node.Result.IsI))  				|| (NativePointerSize == 8 && node.Result.IsLong && (node.Operand1.IsLong || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 8 && node.Operand1.IsLong && (node.Result.IsLong || node.Result.IsU || node.Result.IsI)))"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,FoldLoadStoreOffsets,The conditional expression  "!(node.Instruction == IRInstruction.LoadInteger  				|| node.Instruction == IRInstruction.StoreInteger  				|| node.Instruction == IRInstruction.StoreFloatR4  				|| node.Instruction == IRInstruction.StoreFloatR8  				|| node.Instruction == IRInstruction.LoadSignExtended  				|| node.Instruction == IRInstruction.LoadZeroExtended)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,FoldLoadStoreOffsets,The conditional expression  "!(node2.Instruction == IRInstruction.AddSigned || node2.Instruction == IRInstruction.SubSigned  				|| node2.Instruction == IRInstruction.AddUnsigned || node2.Instruction == IRInstruction.SubUnsigned)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyIntegerCompare,The conditional expression  "!((node.Operand1.IsVirtualRegister && node.Operand2.IsConstantZero)  				|| (node.Operand2.IsVirtualRegister && node.Operand1.IsConstantZero))"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,NormalizeConstantTo32Bit,The conditional expression  "node.Instruction == IRInstruction.LogicalAnd  				|| node.Instruction == IRInstruction.LogicalOr  				|| node.Instruction == IRInstruction.LogicalXor  				|| node.Instruction == IRInstruction.LogicalNot"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ReduceSplit64,The conditional expression  "!(instruction == IRInstruction.LogicalAnd  				|| instruction == IRInstruction.LogicalOr  				|| instruction == IRInstruction.LogicalXor  				|| instruction == IRInstruction.LogicalNot  				|| instruction == IRInstruction.ShiftLeft  				|| instruction == IRInstruction.AddUnsigned  				|| instruction == IRInstruction.MoveInteger  				|| instruction == IRInstruction.MulUnsigned  				|| instruction == IRInstruction.DivUnsigned  				|| instruction == IRInstruction.RemUnsigned)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,CILDecodingStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILDecodingStage.cs,DecodeInstructions,The conditional expression  "flow == FlowControl.Next || flow == FlowControl.Call || flow == FlowControl.ConditionalBranch || flow == FlowControl.Switch"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,OperandAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\OperandAssignmentStage.cs,AddMoves,The conditional expression  "context.IsEmpty  				|| context.Instruction.FlowControl == FlowControl.ConditionalBranch  				|| context.Instruction.FlowControl == FlowControl.UnconditionalBranch  				|| context.Instruction.FlowControl == FlowControl.Return  				|| context.Instruction == IRInstruction.Jmp"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,OperandAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\OperandAssignmentStage.cs,AssignOperands,The conditional expression  "ctx.IsEmpty  					|| ctx.IsBlockEndInstruction  					|| ctx.IsBlockStartInstruction  					|| ctx.Instruction == IRInstruction.Jmp"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,OperandAssignmentStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\OperandAssignmentStage.cs,AssignOperands,The conditional expression  "ctx.Instruction.FlowControl != FlowControl.ConditionalBranch  					&& ctx.Instruction.FlowControl != FlowControl.UnconditionalBranch  					&& ctx.Instruction.FlowControl != FlowControl.Return  					&& ctx.Instruction != IRInstruction.ExceptionStart  					&& ctx.Instruction != IRInstruction.FilterStart  					&& !(ctx.Instruction is BaseCILInstruction)"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Call,The conditional expression  "method.IsVirtual  				&& context.Operand1.Type.ElementType != null  				&& context.Operand1.Type.ElementType.IsValueType  				&& method.DeclaringType == context.Operand1.Type.ElementType"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Callvirt,The conditional expression  "method.IsVirtual  							&& context.Operand1.Type.ElementType != null  							&& context.Operand1.Type.ElementType.IsValueType  							&& method.DeclaringType == context.Operand1.Type.ElementType"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetMethodOrOverride,The conditional expression  "method.DeclaringType.Module == TypeSystem.CorLib  				&& (method.DeclaringType.Name.Equals("ValueType")  					|| method.DeclaringType.Name.Equals("Object")  					|| method.DeclaringType.Name.Equals("Enum"))  				&& (implMethod = type.FindMethodBySignature(method.Name' method.Signature)) != null"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldfld,The conditional expression  "!result.IsOnStack && !MosaTypeLayout.IsStoredOnStack(operand.Type) && !operand.IsReferenceType && isPointer"  is complex.
Complex Conditional,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldfld,The conditional expression  "!result.IsOnStack && !MosaTypeLayout.IsStoredOnStack(operand.Type) && !operand.IsReferenceType && !isPointer"  is complex.
Complex Conditional,Mosa.Compiler.Framework.CIL,UnaryBranchInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\UnaryBranchInstruction.cs,DecodeTargets,The conditional expression  "opcode == OpCode.Brfalse_s || opcode == OpCode.Brtrue_s  				|| opcode == OpCode.Brfalse || opcode == OpCode.Brtrue"  is complex.
Complex Conditional,Mosa.Compiler.Framework.CIL,UnaryBranchInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\UnaryBranchInstruction.cs,Decode,The conditional expression  "opcode == OpCode.Brfalse_s || opcode == OpCode.Brtrue_s  				|| opcode == OpCode.Brfalse || opcode == OpCode.Brtrue"  is complex.
Magic Number,Mosa.Compiler.Framework.Analysis.LiveVariableAnalysis,LivenessAnalysis,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\LiveVariableAnalysis\LivenessAnalysis.cs,NumberInstructions,The following statement contains a magic number: const int increment = 2;
Magic Number,Mosa.Compiler.Framework.Analysis,SparseConditionalConstantPropagation,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,Default,The following statement contains a magic number: if (node.ResultCount == 2)  			{  				var result2 = GetVariableState(node.Result);    				UpdateToOverDefined(result2);  				SetReferenceOverdefined(result2);  			}
Magic Number,Mosa.Compiler.Framework.Analysis,VariableState,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Analysis\SparseConditionalConstantPropagation.cs,AddConstant,The following statement contains a magic number: if (constants != null)  				{  					if (constants.Contains(value))  						return false;  				}  				else  				{  					constants = new List<ulong>(2);  					AppendConstant(value);  					Status = VariableStatusType.SingleConstant;  					return true;  				}
Magic Number,Mosa.Compiler.Framework,DelegatePatcher,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\DelegatePatcher.cs,PatchConstructor,The following statement contains a magic number: var methodPointerOperand = methodCompiler.Parameters[2];
Magic Number,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,MosaTypeLayout,The following statement contains a magic number: Debug.Assert(nativePointerSize == 4 || nativePointerSize == 8);
Magic Number,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,MosaTypeLayout,The following statement contains a magic number: Debug.Assert(nativePointerSize == 4 || nativePointerSize == 8);
Magic Number,Mosa.Compiler.Framework,MosaTypeLayout,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\MosaTypeLayout.cs,IsCompoundType,The following statement contains a magic number: if (primitiveSize != null && primitiveSize > 8)  				return true;
Magic Number,Mosa.Compiler.Framework,BaseInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseInstruction.cs,ToString,The following statement contains a magic number: if (node.BranchTargets != null)  			{  				sb.Append(' ');    				for (int i = 0; (i < 2) && (i < node.BranchTargetsCount); i++)  				{  					if (i != 0)  					{  						sb.Append("' ");  					}    					sb.Append(node.BranchTargets[i].ToString());  				}    				if (node.BranchTargetsCount > 2)  				{  					sb.Append("' [more]");  				}  			}
Magic Number,Mosa.Compiler.Framework,BaseInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BaseInstruction.cs,ToString,The following statement contains a magic number: if (node.BranchTargets != null)  			{  				sb.Append(' ');    				for (int i = 0; (i < 2) && (i < node.BranchTargetsCount); i++)  				{  					if (i != 0)  					{  						sb.Append("' ");  					}    					sb.Append(node.BranchTargets[i].ToString());  				}    				if (node.BranchTargetsCount > 2)  				{  					sb.Append("' [more]");  				}  			}
Magic Number,Mosa.Compiler.Framework,CompilerOptions,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerOptions.cs,CompilerOptions,The following statement contains a magic number: InlinedIRMaximum = 20;
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,ClearOperands,The following statement contains a magic number: for (int i = 3; i < OperandCount; i++)  			{  				SetOperand(i' null);  			}
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetOperand,The following statement contains a magic number: switch (index)  			{  				case 0: Operand1 = operand; return;  				case 1: Operand2 = operand; return;  				case 2: Operand3 = operand; return;  				default:  					{  						Operand current = GetAdditionalOperand(index);  						if (current == operand) return;  						if (current != null)  						{  							current.Uses.Remove(this);  						}    						if (operand != null)  						{  							if (operand.IsVirtualRegister || operand.IsOnStack)  							{  								operand.Uses.Add(this);  							}  						}    						SetAdditionalOperand(index' operand);  						return;  					}  			}
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,GetOperand,The following statement contains a magic number: switch (opIndex)  			{  				case 0: return Operand1;  				case 1: return Operand2;  				case 2: return Operand3;  				default: return GetAdditionalOperand(opIndex);  			}
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetAdditionalOperand,The following statement contains a magic number: Debug.Assert(index >= 3' "No Index");
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetAdditionalOperand,The following statement contains a magic number: SizeAdditionalOperands(index - 3);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetAdditionalOperand,The following statement contains a magic number: addition.AdditionalOperands[index - 3] = operand;
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SizeAdditionalOperands,The following statement contains a magic number: if (addition.AdditionalOperands == null)  			{  				addition.AdditionalOperands = new Operand[(index < 8) ? 8 : index];  				return;  			}
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SizeAdditionalOperands,The following statement contains a magic number: if (addition.AdditionalOperands == null)  			{  				addition.AdditionalOperands = new Operand[(index < 8) ? 8 : index];  				return;  			}
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SizeAdditionalOperands,The following statement contains a magic number: addition.AdditionalOperands = new Operand[old.Length * 2];
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,GetAdditionalOperand,The following statement contains a magic number: Debug.Assert(index >= 3' "No Index");
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,GetAdditionalOperand,The following statement contains a magic number: SizeAdditionalOperands(index - 3);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,GetAdditionalOperand,The following statement contains a magic number: return addition.AdditionalOperands[index - 3];
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction2,The following statement contains a magic number: SetInstruction(instruction' 1' 2);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction2,The following statement contains a magic number: SetInstruction(instruction' 1' 2);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction2,The following statement contains a magic number: SetInstruction(instruction' 2' 2);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction2,The following statement contains a magic number: SetInstruction(instruction' 2' 2);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction2,The following statement contains a magic number: SetInstruction(instruction' 3' 2);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction2,The following statement contains a magic number: SetInstruction(instruction' 3' 2);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The following statement contains a magic number: SetInstruction(instruction' 2' (byte)((result == null) ? 0 : 1));
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The following statement contains a magic number: SetInstruction(instruction' 3' (byte)((result == null) ? 0 : 1));
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The following statement contains a magic number: SetInstruction(instruction' 4' (byte)((result == null) ? 0 : 1));
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The following statement contains a magic number: SetOperand(3' operand4);
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The following statement contains a magic number: SetInstruction(instruction' 2' (byte)((result == null) ? 0 : 1));
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The following statement contains a magic number: SetInstruction(instruction' 2' (byte)((result == null) ? 0 : 1));
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The following statement contains a magic number: SetInstruction(instruction' 2' (byte)((result == null) ? 0 : 1));
Magic Number,Mosa.Compiler.Framework,InstructionNode,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\InstructionNode.cs,SetInstruction,The following statement contains a magic number: SetInstruction(instruction' 2' (byte)((result == null) ? 0 : 1));
Magic Number,Mosa.Compiler.Framework,BasicBlock,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\BasicBlock.cs,BasicBlock,The following statement contains a magic number: NextBlocks = new List<BasicBlock>(2);
Magic Number,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,CreateHighSplitForLong,The following statement contains a magic number: if (longOperand.IsParameter)  			{  				operand = CreateStackParameter(typeSystem.BuiltIn.U4' longOperand.Index' longOperand.Name + " (High)"' false' (int)longOperand.Offset + 4);  			}  			else if (longOperand.IsResolvedConstant)  			{  				operand = new Operand(typeSystem.BuiltIn.U4)  				{  					IsConstant = true'  					IsResolved = true'  					Index = index'  					ConstantUnsignedLongInteger = ((uint)(longOperand.ConstantUnsignedLongInteger >> 32)) & uint.MaxValue  				};  			}  			else if (longOperand.IsVirtualRegister)  			{  				operand = new Operand(typeSystem.BuiltIn.U4)  				{  					IsVirtualRegister = true'  					Index = index'  				};  			}  			else if (longOperand.IsStackLocal)  			{  				operand = new Operand(typeSystem.BuiltIn.I4)  				{  					IsConstant = true'  					IsResolved = false'  					IsStackLocal = true'  				};  			}  			else if (longOperand.IsStaticField)  			{  				//future  			}
Magic Number,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,CreateHighSplitForLong,The following statement contains a magic number: if (longOperand.IsParameter)  			{  				operand = CreateStackParameter(typeSystem.BuiltIn.U4' longOperand.Index' longOperand.Name + " (High)"' false' (int)longOperand.Offset + 4);  			}  			else if (longOperand.IsResolvedConstant)  			{  				operand = new Operand(typeSystem.BuiltIn.U4)  				{  					IsConstant = true'  					IsResolved = true'  					Index = index'  					ConstantUnsignedLongInteger = ((uint)(longOperand.ConstantUnsignedLongInteger >> 32)) & uint.MaxValue  				};  			}  			else if (longOperand.IsVirtualRegister)  			{  				operand = new Operand(typeSystem.BuiltIn.U4)  				{  					IsVirtualRegister = true'  					Index = index'  				};  			}  			else if (longOperand.IsStackLocal)  			{  				operand = new Operand(typeSystem.BuiltIn.I4)  				{  					IsConstant = true'  					IsResolved = false'  					IsStackLocal = true'  				};  			}  			else if (longOperand.IsStaticField)  			{  				//future  			}
Magic Number,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,ShortenTypeName,The following statement contains a magic number: if (value.Length < 2)  				return value;
Magic Number,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,ShortenTypeName,The following statement contains a magic number: if (value.EndsWith("[]"))  			{  				type = value.Substring(0' value.Length - 2);  				end = "[]";  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Load16,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load16.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 1)  			{  				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' methodCompiler.ConstantZero);  			}  			else if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' context.Operand2);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Store64,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store64.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2);  			}  			else if (context.OperandCount == 3)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' context.Operand2' context.Operand3);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Store64,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store64.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2);  			}  			else if (context.OperandCount == 3)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' context.Operand2' context.Operand3);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Store8,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store8.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2);  			}  			else if (context.OperandCount == 3)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' context.Operand2' context.Operand3);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Store8,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store8.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2);  			}  			else if (context.OperandCount == 3)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' context.Operand2' context.Operand3);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Store16,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store16.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2);  			}  			else if (context.OperandCount == 3)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' context.Operand2' context.Operand3);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Store16,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store16.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2);  			}  			else if (context.OperandCount == 3)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' context.Operand2' context.Operand3);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Store32,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store32.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2);  			}  			else if (context.OperandCount == 3)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' context.Operand2' context.Operand3);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Store32,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Store32.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' methodCompiler.ConstantZero' context.Operand2);  			}  			else if (context.OperandCount == 3)  			{  				context.SetInstruction(IRInstruction.StoreInteger' size' null' context.Operand1' context.Operand2' context.Operand3);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Load8,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load8.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 1)  			{  				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' methodCompiler.ConstantZero);  			}  			else if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' context.Operand2);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Load64,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load64.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (methodCompiler.Architecture.NativeIntegerSize == 64)  				instruction = IRInstruction.LoadInteger;
Magic Number,Mosa.Compiler.Framework.Intrinsics,Load64,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load64.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 1)  			{  				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' methodCompiler.ConstantZero);  			}  			else if (context.OperandCount == 2)  			{  				context.SetInstruction(IRInstruction.LoadZeroExtended' size' context.Result' context.Operand1' context.Operand2);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Intrinsics,Load32,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load32.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (methodCompiler.Architecture.NativeIntegerSize == 32)  				instruction = IRInstruction.LoadInteger;
Magic Number,Mosa.Compiler.Framework.Intrinsics,Load32,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Intrinsics\Load32.cs,ReplaceIntrinsicCall,The following statement contains a magic number: if (context.OperandCount == 1)  			{  				context.SetInstruction(instruction' size' context.Result' context.Operand1' methodCompiler.ConstantZero);  			}  			else if (context.OperandCount == 2)  			{  				context.SetInstruction(instruction' size' context.Result' context.Operand1' context.Operand2);  			}  			else  			{  				throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,GetByte,The following statement contains a magic number: if (index < 8)  			{  				int shift = 56 - (8 * index);  				return (byte)((data1 >> shift) & 0xFF);  			}  			else  			{  				index -= 8;  				int shift = 56 - (8 * index);  				return (byte)((data2 >> shift) & 0xFF);  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,WriteTo,The following statement contains a magic number: Debug.Assert(Size % 8 == 0);
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,WriteTo,The following statement contains a magic number: for (int i = 0; i < Size / 8; i++)  			{  				writer.WriteByte(GetByte(i));  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,SetBit,The following statement contains a magic number: if (offset < 64)  			{  				offset = 63 - offset;  				if (value)  					data1 = (data1 | (1ul << offset));  				else  					data1 = (data1 & ~(1ul << offset));  			}  			else  			{  				offset = 63 - (offset - 64);  				if (value)  					data2 = (data2 | (1ul << offset));  				else  					data2 = (data2 & ~(1ul << offset));  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,SetBit,The following statement contains a magic number: if (offset < 64)  			{  				offset = 63 - offset;  				if (value)  					data1 = (data1 | (1ul << offset));  				else  					data1 = (data1 & ~(1ul << offset));  			}  			else  			{  				offset = 63 - (offset - 64);  				if (value)  					data2 = (data2 | (1ul << offset));  				else  					data2 = (data2 & ~(1ul << offset));  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,SetBit,The following statement contains a magic number: if (offset < 64)  			{  				offset = 63 - offset;  				if (value)  					data1 = (data1 | (1ul << offset));  				else  					data1 = (data1 & ~(1ul << offset));  			}  			else  			{  				offset = 63 - (offset - 64);  				if (value)  					data2 = (data2 | (1ul << offset));  				else  					data2 = (data2 & ~(1ul << offset));  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,SetBit,The following statement contains a magic number: if (offset < 64)  			{  				offset = 63 - offset;  				if (value)  					data1 = (data1 | (1ul << offset));  				else  					data1 = (data1 & ~(1ul << offset));  			}  			else  			{  				offset = 63 - (offset - 64);  				if (value)  					data2 = (data2 | (1ul << offset));  				else  					data2 = (data2 & ~(1ul << offset));  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendNibble,The following statement contains a magic number: AppendBit((value >> 3) & 0x1);
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendNibble,The following statement contains a magic number: AppendBit((value >> 2) & 0x1);
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,Append3Bits,The following statement contains a magic number: AppendBit((value >> 2) & 0x1);
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendByte,The following statement contains a magic number: return AppendBits(value' 8);
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,Append8Bits,The following statement contains a magic number: return AppendBits(value' 8);
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,Append16Bits,The following statement contains a magic number: return AppendBits(value' 16);
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,Append32Bits,The following statement contains a magic number: return AppendBits(value' 32);
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendByteValue,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  			{  				AppendBit((value >> i) & 1);  			}
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendIntegerValue,The following statement contains a magic number: AppendByteValue((byte)((value >> 8) & 0xFF));
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendIntegerValue,The following statement contains a magic number: AppendByteValue((byte)((value >> 16) & 0xFF));
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendIntegerValue,The following statement contains a magic number: AppendByteValue((byte)((value >> 24) & 0xFF));
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendShortValue,The following statement contains a magic number: AppendByteValue((byte)((value >> 8) & 0xFF));
Magic Number,Mosa.Compiler.Framework.Platform,OpcodeEncoder,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Platform\XOpcodeEncoder.cs,AppendConditionalPatchPlaceholder,The following statement contains a magic number: if (include)  			{  				position = (Size / 8);  				return AppendIntegerValue(0x0);  			}  			else  			{  				position = -1;  				return this;  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BasicRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BasicRegisterAllocator.cs,GetSpillCost,The following statement contains a magic number: return factor * GetLoopDepth(use) * 100;
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BasicRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BasicRegisterAllocator.cs,CalculateSpillCost,The following statement contains a magic number: foreach (var use in liveInterval.UsePositions)  			{  				spillvalue += GetSpillCost(use' 100);  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BasicRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BasicRegisterAllocator.cs,CalculateSpillCost,The following statement contains a magic number: foreach (var use in liveInterval.DefPositions)  			{  				spillvalue += GetSpillCost(use' 115);  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BasicRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BasicRegisterAllocator.cs,CalculatePriorityValue,The following statement contains a magic number: return liveInterval.Length | ((int)((int)LiveInterval.AllocationStage.Max - liveInterval.Stage) << 28);
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,TraceUsageMap,The following statement contains a magic number: foreach (var block in BasicBlocks)  			{  				for (var node = block.First; ; node = node.Next)  				{  					if (node.IsEmpty)  						continue;    					var slotIndex = new SlotIndex(node);    					if (node.IsBlockStartInstruction)  						blockStarts.Add(slotIndex.SlotNumber);  					else if (node.IsBlockEndInstruction)  						blockEnds.Add(slotIndex.SlotNumber);    					for (int step = 0; step < 2; step++)  					{  						var slot = slotIndex;    						if (step == 0)  							slot = slot.HalfStepBack;    						//else if (step == 2)  						//	slot = slot.HalfStepForward;    						var row = new string[RegisterCount];  						map.Add(slot.SlotNumber' row);    						header.Append(slot.SlotNumber.ToString());  						header.Append("\t");    						slots.Add(slot.SlotNumber);    						if (!slot.IsOnHalfStep)  						{  							var visitor = new OperandVisitor(node);    							foreach (var op in visitor.Output)  							{  								if (op.IsCPURegister && op.Register.IsSpecial)  									continue;    								var s = row[GetIndex(op)] ?? string.Empty;    								row[GetIndex(op)] = s + "+D";  							}    							foreach (var op in visitor.Input)  							{  								if (op.IsCPURegister && op.Register.IsSpecial)  									continue;    								var s = row[GetIndex(op)] ?? string.Empty;    								row[GetIndex(op)] = s + "+U";  							}  						}    						for (int index = 0; index < RegisterCount; index++)  						{  							var vr = VirtualRegisters[index];    							foreach (var r in vr.LiveIntervals)  							{  								if (r.Contains(slot))  								{  									string s = row[index] ?? string.Empty;    									if (vr.IsPhysicalRegister)  									{  										s = "X";  									}  									else if (r.AssignedPhysicalRegister == null)  									{  										if (vr.SpillSlotOperand == null)  											s = "x";  										else  											s = "T_" + vr.SpillSlotOperand.Index.ToString(); //vr.SpillSlotOperand.ToString(false);  									}  									else  									{  										s = r.AssignedPhysicalRegister + s;  									}    									if (r.Start == slot)  										s = "(" + s;    									row[index] = s;    									if (!vr.IsPhysicalRegister)  									{  										if (r.AssignedPhysicalRegister != null)  										{  											int index2 = r.AssignedPhysicalRegister.Index;    											string s2 = row[index2] ?? string.Empty;    											s2 += vr.ToString();    											row[index2] = s2;  										}  									}  								}  								else if (r.End == slot)  								{  									string s = row[index] ?? string.Empty;  									s += ")";  									row[index] = s;  								}  							}  						}  					}    					if (node.IsBlockEndInstruction)  						break;  				}  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ProcessLiveInterval,The following statement contains a magic number: if (liveInterval.Stage == LiveInterval.AllocationStage.SplitLevel2)  			{  				if (Trace.Active) Trace.Log("  Attempting destination split interval - level 2");    				if (TrySplitInterval(liveInterval' 2))  				{  					return;  				}    				if (Trace.Active) Trace.Log("  Re-queued for split interval - level 3");    				liveInterval.Stage = LiveInterval.AllocationStage.SplitLevel3;  				AddPriorityQueue(liveInterval);  				return;  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ProcessLiveInterval,The following statement contains a magic number: if (liveInterval.Stage == LiveInterval.AllocationStage.SplitLevel3)  			{  				if (Trace.Active) Trace.Log("  Attempting destination split interval - level 3");    				if (TrySplitInterval(liveInterval' 3))  				{  					return;  				}    				// Move to final split option stage  				if (Trace.Active) Trace.Log("  Re-queued for spillable stage");    				liveInterval.Stage = LiveInterval.AllocationStage.SplitFinal;  				AddPriorityQueue(liveInterval);  				return;  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ResolveDataFlow,The following statement contains a magic number: var moveResolvers = new MoveResolver[2' BasicBlocks.Count];
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ResolveDataFlow,The following statement contains a magic number: foreach (var from in ExtendedBlocks)  			{  				foreach (var nextBlock in from.BasicBlock.NextBlocks)  				{  					var to = ExtendedBlocks[nextBlock.Sequence];    					// determine where to insert resolving moves  					bool fromAnchorFlag = (from.BasicBlock.NextBlocks.Count == 1);    					ExtendedBlock anchor = fromAnchorFlag ? from : to;    					MoveResolver moveResolver = moveResolvers[fromAnchorFlag ? 0 : 1' anchor.Sequence];    					if (moveResolver == null)  					{  						moveResolver = new MoveResolver(anchor.BasicBlock' from.BasicBlock' to.BasicBlock);  						moveResolvers[fromAnchorFlag ? 0 : 1' anchor.Sequence] = moveResolver;  					}    					foreach (var virtualRegister in GetVirtualRegisters(to.LiveIn))  					{  						//if (virtualRegister.IsPhysicalRegister)  						//continue;    						var fromLiveInterval = virtualRegister.GetIntervalAtOrEndsAt(from.End);  						var toLiveInterval = virtualRegister.GetIntervalAt(to.Start);    						Debug.Assert(fromLiveInterval != null);  						Debug.Assert(toLiveInterval != null);    						if (fromLiveInterval.AssignedPhysicalRegister != toLiveInterval.AssignedPhysicalRegister)  						{  							if (resolverTrace.Active)  							{  								resolverTrace.Log("REGISTER: " + fromLiveInterval.VirtualRegister);  								resolverTrace.Log("    FROM: " + from.ToString().PadRight(7) + " " + fromLiveInterval.AssignedOperand);  								resolverTrace.Log("      TO: " + to.ToString().PadRight(7) + " " + toLiveInterval.AssignedOperand);    								resolverTrace.Log("  INSERT: " + (fromAnchorFlag ? "FROM (bottom)" : "TO (Before)") + ((toLiveInterval.AssignedPhysicalOperand == null) ? "  ****SKIPPED***" : string.Empty));  								resolverTrace.Log("");  							}    							// interval was spilled (spill moves are inserted elsewhere)  							if (toLiveInterval.AssignedPhysicalOperand == null)  								continue;    							Debug.Assert(from.BasicBlock.NextBlocks.Count == 1 || to.BasicBlock.PreviousBlocks.Count == 1);    							moveResolver.AddMove(fromLiveInterval.AssignedOperand' toLiveInterval.AssignedOperand);  						}  					}  				}  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ResolveDataFlow,The following statement contains a magic number: foreach (var from in ExtendedBlocks)  			{  				foreach (var nextBlock in from.BasicBlock.NextBlocks)  				{  					var to = ExtendedBlocks[nextBlock.Sequence];    					// determine where to insert resolving moves  					bool fromAnchorFlag = (from.BasicBlock.NextBlocks.Count == 1);    					ExtendedBlock anchor = fromAnchorFlag ? from : to;    					MoveResolver moveResolver = moveResolvers[fromAnchorFlag ? 0 : 1' anchor.Sequence];    					if (moveResolver == null)  					{  						moveResolver = new MoveResolver(anchor.BasicBlock' from.BasicBlock' to.BasicBlock);  						moveResolvers[fromAnchorFlag ? 0 : 1' anchor.Sequence] = moveResolver;  					}    					foreach (var virtualRegister in GetVirtualRegisters(to.LiveIn))  					{  						//if (virtualRegister.IsPhysicalRegister)  						//continue;    						var fromLiveInterval = virtualRegister.GetIntervalAtOrEndsAt(from.End);  						var toLiveInterval = virtualRegister.GetIntervalAt(to.Start);    						Debug.Assert(fromLiveInterval != null);  						Debug.Assert(toLiveInterval != null);    						if (fromLiveInterval.AssignedPhysicalRegister != toLiveInterval.AssignedPhysicalRegister)  						{  							if (resolverTrace.Active)  							{  								resolverTrace.Log("REGISTER: " + fromLiveInterval.VirtualRegister);  								resolverTrace.Log("    FROM: " + from.ToString().PadRight(7) + " " + fromLiveInterval.AssignedOperand);  								resolverTrace.Log("      TO: " + to.ToString().PadRight(7) + " " + toLiveInterval.AssignedOperand);    								resolverTrace.Log("  INSERT: " + (fromAnchorFlag ? "FROM (bottom)" : "TO (Before)") + ((toLiveInterval.AssignedPhysicalOperand == null) ? "  ****SKIPPED***" : string.Empty));  								resolverTrace.Log("");  							}    							// interval was spilled (spill moves are inserted elsewhere)  							if (toLiveInterval.AssignedPhysicalOperand == null)  								continue;    							Debug.Assert(from.BasicBlock.NextBlocks.Count == 1 || to.BasicBlock.PreviousBlocks.Count == 1);    							moveResolver.AddMove(fromLiveInterval.AssignedOperand' toLiveInterval.AssignedOperand);  						}  					}  				}  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,BaseRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\BaseRegisterAllocator.cs,ResolveDataFlow,The following statement contains a magic number: for (int b = 0; b < BasicBlocks.Count; b++)  			{  				for (int fromTag = 0; fromTag < 2; fromTag++)  				{  					var moveResolver = moveResolvers[fromTag' b];    					if (moveResolver == null)  						continue;    					moveResolver.InsertResolvingMoves(Architecture' StackFrame);  				}  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,LiveRange,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\LiveRange.cs,SplitAt,The following statement contains a magic number: var ranges = new List<LiveRange>(2)  			{  				new LiveRange(Start' at' UsePositions' DefPositions)'  				new LiveRange(at' End' UsePositions' DefPositions)  			};
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,LiveRange,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\LiveRange.cs,SplitAt,The following statement contains a magic number: var ranges = new List<LiveRange>(3)  			{  				new LiveRange(Start' low' UsePositions' DefPositions)'  				new LiveRange(low' high' UsePositions' DefPositions)'  				new LiveRange(high' End' UsePositions' DefPositions)  			};
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,LiveIntervalTrack,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\LiveIntervalTrack.cs,ToString2,The following statement contains a magic number: sb.Length -= 2;
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,GetSpillCost,The following statement contains a magic number: return factor * GetLoopDepth(use) * 100;
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,CalculateSpillCost,The following statement contains a magic number: foreach (var use in liveInterval.UsePositions)  			{  				spillvalue += GetSpillCost(use' 100);  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,CalculateSpillCost,The following statement contains a magic number: foreach (var use in liveInterval.DefPositions)  			{  				spillvalue += GetSpillCost(use' 115);  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,CalculatePriorityValue,The following statement contains a magic number: return liveInterval.Length | ((int)((int)LiveInterval.AllocationStage.Max - liveInterval.Stage) << 28);
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,UpdateMoveHints,The following statement contains a magic number: if (moveHints.Length >= 1)  				moveHints[0].Update(liveInterval);  			else  				if (moveHints.Length >= 2)  				moveHints[1].Update(liveInterval);
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,CollectMoveHints,The following statement contains a magic number: foreach (var block in BasicBlocks)  			{  				for (var node = block.First; !node.IsBlockEndInstruction; node = node.Next)  				{  					if (node.IsEmpty || node.IsBlockStartInstruction || node.IsBlockEndInstruction)  						continue;    					if (!Architecture.IsInstructionMove(node.Instruction))  						continue;    					if (!((node.Result.IsVirtualRegister && node.Operand1.IsVirtualRegister)  						|| (node.Result.IsVirtualRegister && node.Operand1.IsCPURegister)  						|| (node.Result.IsCPURegister && node.Operand1.IsVirtualRegister)))  					{  						continue;  					}    					var from = VirtualRegisters[GetIndex(node.Operand1)];  					var to = VirtualRegisters[GetIndex(node.Result)];    					var slot = new SlotIndex(node);    					int factor = (from.IsPhysicalRegister || to.IsPhysicalRegister) ? 150 : 125;    					int bonus = GetLoopDepth(slot);    					moveHints.Add(slot' new MoveHint(slot' from' to' bonus));  				}  			}
Magic Number,Mosa.Compiler.Framework.RegisterAllocator,GreedyRegisterAllocator,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\GreedyRegisterAllocator.cs,CollectMoveHints,The following statement contains a magic number: foreach (var block in BasicBlocks)  			{  				for (var node = block.First; !node.IsBlockEndInstruction; node = node.Next)  				{  					if (node.IsEmpty || node.IsBlockStartInstruction || node.IsBlockEndInstruction)  						continue;    					if (!Architecture.IsInstructionMove(node.Instruction))  						continue;    					if (!((node.Result.IsVirtualRegister && node.Operand1.IsVirtualRegister)  						|| (node.Result.IsVirtualRegister && node.Operand1.IsCPURegister)  						|| (node.Result.IsCPURegister && node.Operand1.IsVirtualRegister)))  					{  						continue;  					}    					var from = VirtualRegisters[GetIndex(node.Operand1)];  					var to = VirtualRegisters[GetIndex(node.Result)];    					var slot = new SlotIndex(node);    					int factor = (from.IsPhysicalRegister || to.IsPhysicalRegister) ? 150 : 125;    					int bonus = GetLoopDepth(slot);    					moveHints.Add(slot' new MoveHint(slot' from' to' bonus));  				}  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MethodExceptionLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodExceptionLookupTableStage.cs,Setup,The following statement contains a magic number: if (TypeLayout.NativePointerSize == 4)  				NativePatchType = PatchType.I4;  			else  				NativePatchType = PatchType.I8;
Magic Number,Mosa.Compiler.Framework.CompilerStages,MethodLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodLookupTableStage.cs,Setup,The following statement contains a magic number: if (TypeLayout.NativePointerSize == 4)  				NativePatchType = PatchType.I4;  			else  				NativePatchType = PatchType.I8;
Magic Number,Mosa.Compiler.Framework.CompilerStages,MapFileGenerationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MapFileGenerationStage.cs,EmitSections,The following statement contains a magic number: foreach (var section in Linker.LinkerSections)  			{  				writer.WriteLine("{0:x16} {1:x16} {2:x16} {3} {4}"' section.FileOffset' section.VirtualAddress' section.Size' section.Name.PadRight(32)' section.SectionKind);  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MapFileGenerationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MapFileGenerationStage.cs,EmitSymbols,The following statement contains a magic number: foreach (var section in Linker.LinkerSections)  			{  				foreach (var symbol in section.Symbols)  				{  					writer.WriteLine("{0:x16} {1:x16} {2:x16} {3} {4}"' symbol.VirtualAddress' symbol.SectionOffset' symbol.Size' symbol.SectionKind.ToString().PadRight(7)' symbol.Name);  				}  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,Setup,The following statement contains a magic number: if (TypeLayout.NativePointerSize == 4)  				NativePatchType = PatchType.I4;  			else  				NativePatchType = PatchType.I8;
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,EmitStringWithLength,The following statement contains a magic number: stream.WriteZeroBytes(TypeLayout.NativePointerSize * 2);
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The following statement contains a magic number: writer1.Write(((uint)type.TypeCode << 24) + (uint)type.TypeAttributes' TypeLayout.NativePointerSize);
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The following statement contains a magic number: if (!type.IsInterface)  			{  				// 11. Fields (if any)  				if (type.Fields.Count > 0)  				{  					var fieldsSymbol = CreateFieldDefinitions(type);  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' fieldsSymbol' 0);  				}  				writer1.WriteZeroBytes(TypeLayout.NativePointerSize);    				var interfaces = GetInterfaces(type);    				// If the type doesn't use interfaces then skip 9 and 10  				if (interfaces.Count > 0)  				{  					// 12. Pointer to Interface Slots  					var interfaceSlotTableSymbol = CreateInterfaceSlotTable(type' interfaces);  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' interfaceSlotTableSymbol' 0);  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize);    					// 13. Pointer to Interface Bitmap  					var interfaceBitmapSymbol = CreateInterfaceBitmap(type' interfaces);  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' interfaceBitmapSymbol' 0);  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize);  				}  				else  				{  					// Fill 12 and 13 with zeros  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize * 2);  				}    				// For the next part we'll need to get the list of methods from the MosaTypeLayout  				var methodList = TypeLayout.GetMethodTable(type) ?? new List<MosaMethod>();    				// 14. Number of Methods  				writer1.Write(methodList.Count' TypeLayout.NativePointerSize);    				// 15. Pointer to Methods  				foreach (var method in methodList)  				{  					if (!method.IsAbstract)  					{  						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' SectionKind.Text' method.FullName' 0);  					}  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize);  				}    				// 16. Pointer to Method Definitions  				foreach (var method in methodList)  				{  					// Create definition and get the symbol  					var methodDefinitionSymbol = CreateMethodDefinition(method);    					// Link  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' methodDefinitionSymbol' 0);  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize);  				}  			}  			else  			{  				// Fill 11' 12' 13' 14 with zeros' 15 & 16 can be left out.  				writer1.WriteZeroBytes(TypeLayout.NativePointerSize * 4);  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateTypeDefinition,The following statement contains a magic number: if (!type.IsInterface)  			{  				// 11. Fields (if any)  				if (type.Fields.Count > 0)  				{  					var fieldsSymbol = CreateFieldDefinitions(type);  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' fieldsSymbol' 0);  				}  				writer1.WriteZeroBytes(TypeLayout.NativePointerSize);    				var interfaces = GetInterfaces(type);    				// If the type doesn't use interfaces then skip 9 and 10  				if (interfaces.Count > 0)  				{  					// 12. Pointer to Interface Slots  					var interfaceSlotTableSymbol = CreateInterfaceSlotTable(type' interfaces);  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' interfaceSlotTableSymbol' 0);  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize);    					// 13. Pointer to Interface Bitmap  					var interfaceBitmapSymbol = CreateInterfaceBitmap(type' interfaces);  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' interfaceBitmapSymbol' 0);  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize);  				}  				else  				{  					// Fill 12 and 13 with zeros  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize * 2);  				}    				// For the next part we'll need to get the list of methods from the MosaTypeLayout  				var methodList = TypeLayout.GetMethodTable(type) ?? new List<MosaMethod>();    				// 14. Number of Methods  				writer1.Write(methodList.Count' TypeLayout.NativePointerSize);    				// 15. Pointer to Methods  				foreach (var method in methodList)  				{  					if (!method.IsAbstract)  					{  						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' SectionKind.Text' method.FullName' 0);  					}  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize);  				}    				// 16. Pointer to Method Definitions  				foreach (var method in methodList)  				{  					// Create definition and get the symbol  					var methodDefinitionSymbol = CreateMethodDefinition(method);    					// Link  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' typeTableSymbol' (int)writer1.Position' methodDefinitionSymbol' 0);  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize);  				}  			}  			else  			{  				// Fill 11' 12' 13' 14 with zeros' 15 & 16 can be left out.  				writer1.WriteZeroBytes(TypeLayout.NativePointerSize * 4);  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateInterfaceBitmap,The following statement contains a magic number: var bitmap = new byte[(((TypeLayout.Interfaces.Count - 1) / 8) + 1)];
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateInterfaceBitmap,The following statement contains a magic number: foreach (var interfaceType in TypeLayout.Interfaces)  			{  				if (interfaces.Contains(interfaceType))  				{  					bitmap[at] = (byte)(bitmap[at] | (byte)(1 << bit));  				}    				bit++;  				if (bit == 8)  				{  					bit = 0;  					at++;  				}  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreatePropertyDefinitions,The following statement contains a magic number: foreach (MosaProperty property in type.Properties)  			{  				// Emit field name  				var fieldNameSymbol = EmitStringWithLength(property.FullName + Metadata.NameString' property.Name);    				// Emit property definition  				var propertyDefSymbol = Linker.CreateSymbol(property.FullName + Metadata.PropertyDefinition' SectionKind.ROData' TypeLayout.NativePointerAlignment' 0);  				var writer2 = new EndianAwareBinaryWriter(propertyDefSymbol.Stream' Architecture.Endianness);    				// 1. Name  				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer2.Position' fieldNameSymbol' 0);  				writer2.WriteZeroBytes(TypeLayout.NativePointerSize);    				// 2. Pointer to Custom Attributes  				if (property.CustomAttributes.Count > 0)  				{  					var customAttributesTableSymbol = CreateCustomAttributesTable(property);  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer1.Position' customAttributesTableSymbol' 0);  				}  				writer1.WriteZeroBytes(TypeLayout.NativePointerSize);    				// 3. Attributes  				writer1.Write((uint)property.PropertyAttributes' TypeLayout.NativePointerSize);    				// 4. Pointer to Property Type  				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer2.Position' SectionKind.ROData' property.PropertyType.FullName + Metadata.TypeDefinition' 0);  				writer2.WriteZeroBytes(TypeLayout.NativePointerSize);    				// If the type is a property then skip linking the methods  				if (!type.IsInterface)  				{  					// 5. Pointer to Getter Method Definition  					if (property.GetterMethod != null)  						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer2.Position' SectionKind.ROData' property.GetterMethod.FullName + Metadata.MethodDefinition' 0);  					writer2.WriteZeroBytes(TypeLayout.NativePointerSize);    					// 6. Pointer to Setter Method Definition  					if (property.SetterMethod != null)  						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertyDefSymbol' (int)writer2.Position' SectionKind.ROData' property.SetterMethod.FullName + Metadata.MethodDefinition' 0);  					writer2.WriteZeroBytes(TypeLayout.NativePointerSize);  				}  				else  				{  					// Fill 5 and 6 with zeros.  					writer1.WriteZeroBytes(TypeLayout.NativePointerSize * 2);  				}    				// Add pointer to properties table  				Linker.Link(LinkType.AbsoluteAddress' NativePatchType' propertiesTableSymbol' (int)writer1.Position' propertyDefSymbol' 0);  				writer1.WriteZeroBytes(TypeLayout.NativePointerSize);  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,CreateMethodDefinition,The following statement contains a magic number: int value = methodData.LocalMethodStackSize | (methodData.ParameterStackSize << 16);
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,ComputeArgumentSize,The following statement contains a magic number: switch (type.TypeCode)  			{  				// 1 byte  				case MosaTypeCode.Boolean:  				case MosaTypeCode.U1:  				case MosaTypeCode.I1:  					return 1;    				// 2 bytes  				case MosaTypeCode.Char:  				case MosaTypeCode.U2:  				case MosaTypeCode.I2:  					return 2;    				// 4 bytes  				case MosaTypeCode.U4:  				case MosaTypeCode.I4:  				case MosaTypeCode.R4:  					return 4;    				// 8 bytes  				case MosaTypeCode.U8:  				case MosaTypeCode.I8:  				case MosaTypeCode.R8:  					return 8;    				// SZArray  				case MosaTypeCode.SZArray:  					Debug.Assert(value is MosaCustomAttribute.Argument[]);  					var arr = (MosaCustomAttribute.Argument[])value;  					int size = 0;  					foreach (var elem in arr)  						size += ComputeArgumentSize(elem.Type' elem.Value);  					return size;    				// String  				case MosaTypeCode.String:  					return TypeLayout.NativePointerSize;    				default:  					if (type.FullName == "System.Type")  					{  						return TypeLayout.NativePointerSize;  					}  					else  					{  						throw new NotSupportedException();  					}  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,ComputeArgumentSize,The following statement contains a magic number: switch (type.TypeCode)  			{  				// 1 byte  				case MosaTypeCode.Boolean:  				case MosaTypeCode.U1:  				case MosaTypeCode.I1:  					return 1;    				// 2 bytes  				case MosaTypeCode.Char:  				case MosaTypeCode.U2:  				case MosaTypeCode.I2:  					return 2;    				// 4 bytes  				case MosaTypeCode.U4:  				case MosaTypeCode.I4:  				case MosaTypeCode.R4:  					return 4;    				// 8 bytes  				case MosaTypeCode.U8:  				case MosaTypeCode.I8:  				case MosaTypeCode.R8:  					return 8;    				// SZArray  				case MosaTypeCode.SZArray:  					Debug.Assert(value is MosaCustomAttribute.Argument[]);  					var arr = (MosaCustomAttribute.Argument[])value;  					int size = 0;  					foreach (var elem in arr)  						size += ComputeArgumentSize(elem.Type' elem.Value);  					return size;    				// String  				case MosaTypeCode.String:  					return TypeLayout.NativePointerSize;    				default:  					if (type.FullName == "System.Type")  					{  						return TypeLayout.NativePointerSize;  					}  					else  					{  						throw new NotSupportedException();  					}  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,ComputeArgumentSize,The following statement contains a magic number: switch (type.TypeCode)  			{  				// 1 byte  				case MosaTypeCode.Boolean:  				case MosaTypeCode.U1:  				case MosaTypeCode.I1:  					return 1;    				// 2 bytes  				case MosaTypeCode.Char:  				case MosaTypeCode.U2:  				case MosaTypeCode.I2:  					return 2;    				// 4 bytes  				case MosaTypeCode.U4:  				case MosaTypeCode.I4:  				case MosaTypeCode.R4:  					return 4;    				// 8 bytes  				case MosaTypeCode.U8:  				case MosaTypeCode.I8:  				case MosaTypeCode.R8:  					return 8;    				// SZArray  				case MosaTypeCode.SZArray:  					Debug.Assert(value is MosaCustomAttribute.Argument[]);  					var arr = (MosaCustomAttribute.Argument[])value;  					int size = 0;  					foreach (var elem in arr)  						size += ComputeArgumentSize(elem.Type' elem.Value);  					return size;    				// String  				case MosaTypeCode.String:  					return TypeLayout.NativePointerSize;    				default:  					if (type.FullName == "System.Type")  					{  						return TypeLayout.NativePointerSize;  					}  					else  					{  						throw new NotSupportedException();  					}  			}
Magic Number,Mosa.Compiler.Framework.CompilerStages,MetadataStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MetadataStage.cs,WriteArgument,The following statement contains a magic number: switch (type.TypeCode)  			{  				// 1 byte  				case MosaTypeCode.Boolean:  					writer.Write((bool)value);  					break;    				case MosaTypeCode.U1:  					writer.Write((byte)value);  					break;    				case MosaTypeCode.I1:  					writer.Write((sbyte)value);  					break;    				// 2 bytes  				case MosaTypeCode.Char:  					writer.Write((char)value);  					break;    				case MosaTypeCode.U2:  					writer.Write((ushort)value);  					break;    				case MosaTypeCode.I2:  					writer.Write((short)value);  					break;    				// 4 bytes  				case MosaTypeCode.U4:  					writer.Write((uint)value);  					break;    				case MosaTypeCode.I4:  					writer.Write((int)value);  					break;    				case MosaTypeCode.R4:  					writer.Write((float)value);  					break;    				// 8 bytes  				case MosaTypeCode.U8:  					writer.Write((ulong)value);  					break;    				case MosaTypeCode.I8:  					writer.Write((long)value);  					break;    				case MosaTypeCode.R8:  					writer.Write((double)value);  					break;    				// SZArray  				case MosaTypeCode.SZArray:  					Debug.Assert(value is MosaCustomAttribute.Argument[]);  					var arr = (MosaCustomAttribute.Argument[])value;  					writer.Write(arr.Length' TypeLayout.NativePointerSize);  					foreach (var elem in arr)  						WriteArgument(writer' symbol' elem.Type' elem.Value);  					break;    				// String  				case MosaTypeCode.String:    					// Since strings are immutable' make it an object that we can just use  					var str = (string)value;  					Linker.Link(LinkType.AbsoluteAddress' NativePatchType' symbol' (int)writer.Position' SectionKind.ROData' "System.String" + Metadata.TypeDefinition' 0);  					writer.WriteZeroBytes(TypeLayout.NativePointerSize * 2);  					writer.Write(str.Length' TypeLayout.NativePointerSize);  					writer.Write(System.Text.Encoding.Unicode.GetBytes(str));  					break;    				default:  					if (type.FullName == "System.Type")  					{  						var valueType = (MosaType)value;  						Linker.Link(LinkType.AbsoluteAddress' NativePatchType' symbol' (int)writer.Position' SectionKind.ROData' valueType.FullName + Metadata.TypeDefinition' 0);  						writer.WriteZeroBytes(TypeLayout.NativePointerSize);  					}  					else  					{  						throw new NotSupportedException();  					}    					break;  			}
Magic Number,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallVirtual,The following statement contains a magic number: int methodPointerOffset = CalculateMethodTableOffset(method) + (NativePointerSize * 14);
Magic Number,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallInterface,The following statement contains a magic number: int interfaceSlotTableOffset = (NativePointerSize * 11);
Magic Number,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallInterface,The following statement contains a magic number: int methodDefinitionOffset = (NativePointerSize * 2) + CalculateMethodTableOffset(method);
Magic Number,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,CallInterface,The following statement contains a magic number: int methodPointerOffset = (NativePointerSize * 4);
Magic Number,Mosa.Compiler.Framework.Stages,CallStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CallStage.cs,GetReturnValue,The following statement contains a magic number: if (result.Is64BitInteger && Architecture.NativeIntegerSize == 32)  			{  				var returnLow = Operand.CreateCPURegister(result.Type' Architecture.Return32BitRegister);  				var returnHigh = Operand.CreateCPURegister(TypeSystem.BuiltIn.U4' Architecture.Return64BitRegister);    				context.AppendInstruction(IRInstruction.Gen' returnLow);  				context.AppendInstruction(IRInstruction.Gen' returnHigh);  				context.AppendInstruction(IRInstruction.To64' result' returnLow' returnHigh);  			}  			else if (result.IsInteger)  			{  				var returnLow = Operand.CreateCPURegister(result.Type' Architecture.Return32BitRegister);  				context.AppendInstruction(IRInstruction.Gen' returnLow);  				context.AppendInstruction(IRInstruction.MoveInteger' result' returnLow);  			}  			else if (result.IsR4)  			{  				var returnFP = Operand.CreateCPURegister(result.Type' Architecture.ReturnFloatingPointRegister);  				context.AppendInstruction(IRInstruction.Gen' returnFP);  				context.AppendInstruction(IRInstruction.MoveFloatR4' result' returnFP);  			}  			else if (result.IsR8)  			{  				var returnFP = Operand.CreateCPURegister(result.Type' Architecture.ReturnFloatingPointRegister);  				context.AppendInstruction(IRInstruction.Gen' returnFP);  				context.AppendInstruction(IRInstruction.MoveFloatR8' result' returnFP);  			}  			else if (MosaTypeLayout.IsStoredOnStack(result.Type))  			{  				Debug.Assert(result.IsStackLocal);  				context.AppendInstruction(IRInstruction.LoadCompound' result' StackPointer' ConstantZero);  			}  			else  			{  				// note: same for integer logic (above)  				var returnLow = Operand.CreateCPURegister(result.Type' Architecture.Return32BitRegister);  				context.AppendInstruction(IRInstruction.Gen' returnLow);  				context.AppendInstruction(IRInstruction.MoveInteger' result' returnLow);  			}
Magic Number,Mosa.Compiler.Framework.Stages,SparseConditionalConstantPropagationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\SparseConditionalConstantPropagationStage.cs,RemoveBranchesToDeadBlocks,The following statement contains a magic number: foreach (var previous in deadBlock.PreviousBlocks.ToArray())  			{  				// unable to handle more than two branch blocks  				// and if only one branch' then this block is dead as well  				if (previous.NextBlocks.Count != 2)  					return;    				var otherBlock = previous.NextBlocks[0] == deadBlock ? previous.NextBlocks[1] : previous.NextBlocks[0];    				for (var node = previous.Last.Previous; !node.IsBlockStartInstruction; node = node.Previous)  				{  					if (node.IsEmpty)  						continue;    					if (node.BranchTargetsCount == 0)  						continue;    					if (node.Instruction == IRInstruction.CompareIntegerBranch)  					{  						if (trace.Active) trace.Log("*** RemoveBranchesToDeadBlocks");  						if (trace.Active) trace.Log("REMOVED:\t" + node);  						node.SetInstruction(IRInstruction.Nop);  						instructionsRemovedCount++;  					}  					else if (node.Instruction == IRInstruction.Jmp)  					{  						if (trace.Active) trace.Log("*** RemoveBranchesToDeadBlocks");  						if (trace.Active) trace.Log("BEFORE:\t" + node);  						node.UpdateBranchTarget(0' otherBlock);  						if (trace.Active) trace.Log("AFTER: \t" + node);  					}  				}  			}
Magic Number,Mosa.Compiler.Framework.Stages,ProtectedRegionLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ProtectedRegionLayoutStage.cs,Run,The following statement contains a magic number: if (TypeLayout.NativePointerSize == 4)  				NativePatchType = PatchType.I4;  			else  				NativePatchType = PatchType.I8;
Magic Number,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,The following statement contains a magic number: if (targets.Count == 1)  			{  				ctx.AppendInstruction(IRInstruction.Jmp' targets[0]);  				return;  			}  			else  			{  				var newBlocks = CreateNewBlockContexts(targets.Count - 1);    				ctx.AppendInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.Equal' null' leaveTargetRegister' CreateConstant(targets[0].Label)' targets[0]);  				ctx.AppendInstruction(IRInstruction.Jmp' newBlocks[0].Block);    				for (int b = 1; b < targets.Count - 2; b++)  				{  					newBlocks[b - 1].AppendInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.Equal' null' leaveTargetRegister' CreateConstant(targets[b].Label)' targets[b]);  					newBlocks[b - 1].AppendInstruction(IRInstruction.Jmp' newBlocks[b + 1].Block);  				}    				newBlocks[targets.Count - 2].AppendInstruction(IRInstruction.Jmp' targets[targets.Count - 1]);  			}
Magic Number,Mosa.Compiler.Framework.Stages,ExceptionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\ExceptionStage.cs,GotoLeaveTargetInstruction,The following statement contains a magic number: if (targets.Count == 1)  			{  				ctx.AppendInstruction(IRInstruction.Jmp' targets[0]);  				return;  			}  			else  			{  				var newBlocks = CreateNewBlockContexts(targets.Count - 1);    				ctx.AppendInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.Equal' null' leaveTargetRegister' CreateConstant(targets[0].Label)' targets[0]);  				ctx.AppendInstruction(IRInstruction.Jmp' newBlocks[0].Block);    				for (int b = 1; b < targets.Count - 2; b++)  				{  					newBlocks[b - 1].AppendInstruction(IRInstruction.CompareIntegerBranch' ConditionCode.Equal' null' leaveTargetRegister' CreateConstant(targets[b].Label)' targets[b]);  					newBlocks[b - 1].AppendInstruction(IRInstruction.Jmp' newBlocks[b + 1].Block);  				}    				newBlocks[targets.Count - 2].AppendInstruction(IRInstruction.Jmp' targets[targets.Count - 1]);  			}
Magic Number,Mosa.Compiler.Framework.Stages,JumpOptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\JumpOptimizationStage.cs,Run,The following statement contains a magic number: for (int f = 0; f < BasicBlocks.Count - 1; f++)  			{  				var from = BasicBlocks[f];  				var next = BasicBlocks[f + 1];    				if (!from.NextBlocks.Contains(next))  					continue;    				var node = from.BeforeLast.GoBackwardsToNonEmpty();    				Debug.Assert(node.Instruction.FlowControl == FlowControl.UnconditionalBranch);  				Debug.Assert(node.BranchTargetsCount != 0);    				var target = node.BranchTargets[0];    				if (next == target)  				{  					// insert pseudo flow instruction --- this is important when protected regions exists  					node.SetInstruction(IRInstruction.Flow' target);  					continue;  				}  				else  				{  					if (from.NextBlocks.Count != 2)  						continue;    					// reverse the condition and swap branch and jump target' and remove jump instruction  					var jumpNode = node;  					var branchNode = node.Previous.GoBackwardsToNonEmpty();    					Debug.Assert(node.BranchTargetsCount == 1);    					var jumpTarget = jumpNode.BranchTargets[0];    					// reverse condition  					branchNode.ConditionCode = branchNode.ConditionCode.GetOpposite();    					// insert pseudo flow instruction --- this is important when protected regions exists  					jumpNode.SetInstruction(IRInstruction.Flow' branchNode.BranchTargets[0]);    					// update branch target  					branchNode.UpdateBranchTarget(0' jumpTarget);    					continue;  				}  			}
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,DeadCodeElimination,The following statement contains a magic number: if (node.ResultCount == 0 || node.ResultCount > 2)  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,DeadCodeElimination,The following statement contains a magic number: if (node.ResultCount == 2 && node.Result2.IsVirtualRegister)  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,DeadCodeElimination,The following statement contains a magic number: if (node.ResultCount == 2 && node.Result2.Definitions.Count != 1)  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,DeadCodeElimination,The following statement contains a magic number: if (node.ResultCount == 2 && node.Result2.Uses.Count != 0)  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The following statement contains a magic number: if (NativePointerSize == 4 && (destination.IsI || destination.IsU || destination.IsUnmanagedPointer) && (source.IsI4 || source.IsU4))  				return true;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The following statement contains a magic number: if (NativePointerSize == 4 && (source.IsI || source.IsU || source.IsUnmanagedPointer) && (destination.IsI4 || destination.IsU4))  				return true;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The following statement contains a magic number: if (NativePointerSize == 8 && (destination.IsI || destination.IsU || destination.IsUnmanagedPointer) && (source.IsI8 || source.IsU8))  				return true;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,CanCopyPropagation,The following statement contains a magic number: if (NativePointerSize == 8 && (source.IsI || source.IsU || source.IsUnmanagedPointer) && (destination.IsI8 || destination.IsU8))  				return true;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationMultiplication,The following statement contains a magic number: if (IsPowerOfTwo(op2.ConstantUnsignedLongInteger))  			{  				int shift = GetPowerOfTwo(op2.ConstantUnsignedLongInteger);    				if (shift < 32)  				{  					AddOperandUsageToWorkList(node);  					if (trace.Active) trace.Log("*** ArithmeticSimplificationMultiplication");  					if (trace.Active) trace.Log("BEFORE:\t" + node);  					node.SetInstruction(IRInstruction.ShiftLeft' result' op1' CreateConstant((int)shift));  					arithmeticSimplificationMultiplicationCount++;  					if (trace.Active) trace.Log("AFTER: \t" + node);  					return;  				}  			}
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ArithmeticSimplificationDivision,The following statement contains a magic number: if (node.Instruction == IRInstruction.DivUnsigned && IsPowerOfTwo(op2.ConstantUnsignedLongInteger))  			{  				int shift = GetPowerOfTwo(op2.ConstantUnsignedLongInteger);    				if (shift < 32)  				{  					AddOperandUsageToWorkList(node);  					if (trace.Active) trace.Log("*** ArithmeticSimplificationDivision");  					if (trace.Active) trace.Log("BEFORE:\t" + node);  					node.SetInstruction(IRInstruction.ShiftRight' result' op1' CreateConstant((int)shift));  					arithmeticSimplificationDivisionCount++;  					if (trace.Active) trace.Log("AFTER: \t" + node);  					return;  				}  			}
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ConstantFoldIntegerCompareBranch,The following statement contains a magic number: Debug.Assert(node.OperandCount == 2);
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyExtendedMove,The following statement contains a magic number: if (!((NativePointerSize == 4 && node.Result.IsInt && (node.Operand1.IsInt || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 4 && node.Operand1.IsInt && (node.Result.IsInt || node.Result.IsU || node.Result.IsI))  				|| (NativePointerSize == 8 && node.Result.IsLong && (node.Operand1.IsLong || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 8 && node.Operand1.IsLong && (node.Result.IsLong || node.Result.IsU || node.Result.IsI))))  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyExtendedMove,The following statement contains a magic number: if (!((NativePointerSize == 4 && node.Result.IsInt && (node.Operand1.IsInt || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 4 && node.Operand1.IsInt && (node.Result.IsInt || node.Result.IsU || node.Result.IsI))  				|| (NativePointerSize == 8 && node.Result.IsLong && (node.Operand1.IsLong || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 8 && node.Operand1.IsLong && (node.Result.IsLong || node.Result.IsU || node.Result.IsI))))  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyExtendedMove,The following statement contains a magic number: if (!((NativePointerSize == 4 && node.Result.IsInt && (node.Operand1.IsInt || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 4 && node.Operand1.IsInt && (node.Result.IsInt || node.Result.IsU || node.Result.IsI))  				|| (NativePointerSize == 8 && node.Result.IsLong && (node.Operand1.IsLong || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 8 && node.Operand1.IsLong && (node.Result.IsLong || node.Result.IsU || node.Result.IsI))))  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,SimplifyExtendedMove,The following statement contains a magic number: if (!((NativePointerSize == 4 && node.Result.IsInt && (node.Operand1.IsInt || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 4 && node.Operand1.IsInt && (node.Result.IsInt || node.Result.IsU || node.Result.IsI))  				|| (NativePointerSize == 8 && node.Result.IsLong && (node.Operand1.IsLong || node.Operand1.IsU || node.Operand1.IsI))  				|| (NativePointerSize == 8 && node.Operand1.IsLong && (node.Result.IsLong || node.Result.IsU || node.Result.IsI))))  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,NormalizeConstantTo32Bit,The following statement contains a magic number: if (node.Instruction == IRInstruction.LogicalAnd  				|| node.Instruction == IRInstruction.LogicalOr  				|| node.Instruction == IRInstruction.LogicalXor  				|| node.Instruction == IRInstruction.LogicalNot)  			{  				if (node.Operand1.IsResolvedConstant && node.Operand1.IsLong)  				{  					if (trace.Active) trace.Log("*** NormalizeConstantTo32Bit");    					if (trace.Active) trace.Log("BEFORE:\t" + node);  					node.Operand1 = CreateConstant((int)(node.Operand1.ConstantUnsignedLongInteger & uint.MaxValue));  					if (trace.Active) trace.Log("AFTER: \t" + node);  					AddOperandUsageToWorkList(node);  				}  				if (node.OperandCount >= 2 && node.Operand2.IsResolvedConstant && node.Operand2.IsLong)  				{  					if (trace.Active) trace.Log("*** NormalizeConstantTo32Bit");    					if (trace.Active) trace.Log("BEFORE:\t" + node);  					node.Operand2 = CreateConstant((int)(node.Operand2.ConstantUnsignedLongInteger & uint.MaxValue));  					if (trace.Active) trace.Log("AFTER: \t" + node);  					AddOperandUsageToWorkList(node);  				}  			}
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,Split64Constant,The following statement contains a magic number: var high = CreateConstant((uint)(node.Operand1.ConstantUnsignedLongInteger >> 32) & 0xFFFFFFFF);
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ReduceSplit64,The following statement contains a magic number: if (defNode.OperandCount == 2 && defNode.Operand2.Definitions.Count != 1)  				return;
Magic Number,Mosa.Compiler.Framework.Stages,IROptimizationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\IROptimizationStage.cs,ReduceSplit64,The following statement contains a magic number: var operand2 = defNode.OperandCount == 2 ? defNode.Operand2 : null;
Magic Number,Mosa.Compiler.Framework.Stages,UnboxValueTypeStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\UnboxValueTypeStage.cs,Run,The following statement contains a magic number: context.AppendInstruction(IRInstruction.AddSigned' NativeInstructionSize' v1' v1' CreateConstant(NativePointerSize * 2));
Magic Number,Mosa.Compiler.Framework.Stages,EnterSSAStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\EnterSSAStage.cs,PlacePhiFunctionsMinimal,The following statement contains a magic number: foreach (var t in assignments)  			{  				var blocks = t.Value;    				if (blocks.Count < 2)  					continue;    				blocks.AddIfNew(headBlock);    				foreach (var n in analysis.IteratedDominanceFrontier(blocks))  				{  					InsertPhiInstruction(n' t.Key);  				}  			}
Magic Number,Mosa.Compiler.Framework.Stages,StaticAllocationResolutionStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\StaticAllocationResolutionStage.cs,PerformStaticAllocationOf,The following statement contains a magic number: if (allocation.Instruction is NewarrInstruction)  			{  				int elements = GetConstant(allocation.Operand1);  				typeSize = (TypeLayout.GetTypeSize(allocatedType.ElementType) * elements) + (TypeLayout.NativePointerSize * 3);  			}
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Box,The following statement contains a magic number: if (typeSize <= 8 || type.IsR)  			{  				BaseIRInstruction instruction;    				if (type.IsR4)  					instruction = IRInstruction.BoxR4;  				else if (type.IsR8)  					instruction = IRInstruction.BoxR8;  				else if (typeSize <= 4)  					instruction = IRInstruction.Box32;  				else if (typeSize == 8)  					instruction = IRInstruction.Box64;  				else  					throw new InvalidOperationException();    				context.SetInstruction(instruction' result' runtimeType' value);  			}  			else  			{  				var adr = AllocateVirtualRegister(type.ToManagedPointer());    				context.SetInstruction(IRInstruction.AddressOf' adr' value);  				context.AppendInstruction(IRInstruction.Box' result' runtimeType' adr' CreateConstant(typeSize));  			}
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Box,The following statement contains a magic number: if (typeSize <= 8 || type.IsR)  			{  				BaseIRInstruction instruction;    				if (type.IsR4)  					instruction = IRInstruction.BoxR4;  				else if (type.IsR8)  					instruction = IRInstruction.BoxR8;  				else if (typeSize <= 4)  					instruction = IRInstruction.Box32;  				else if (typeSize == 8)  					instruction = IRInstruction.Box64;  				else  					throw new InvalidOperationException();    				context.SetInstruction(instruction' result' runtimeType' value);  			}  			else  			{  				var adr = AllocateVirtualRegister(type.ToManagedPointer());    				context.SetInstruction(IRInstruction.AddressOf' adr' value);  				context.AppendInstruction(IRInstruction.Box' result' runtimeType' adr' CreateConstant(typeSize));  			}
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Box,The following statement contains a magic number: if (typeSize <= 8 || type.IsR)  			{  				BaseIRInstruction instruction;    				if (type.IsR4)  					instruction = IRInstruction.BoxR4;  				else if (type.IsR8)  					instruction = IRInstruction.BoxR8;  				else if (typeSize <= 4)  					instruction = IRInstruction.Box32;  				else if (typeSize == 8)  					instruction = IRInstruction.Box64;  				else  					throw new InvalidOperationException();    				context.SetInstruction(instruction' result' runtimeType' value);  			}  			else  			{  				var adr = AllocateVirtualRegister(type.ToManagedPointer());    				context.SetInstruction(IRInstruction.AddressOf' adr' value);  				context.AppendInstruction(IRInstruction.Box' result' runtimeType' adr' CreateConstant(typeSize));  			}
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Call,The following statement contains a magic number: if (method.IsVirtual  				&& context.Operand1.Type.ElementType != null  				&& context.Operand1.Type.ElementType.IsValueType  				&& method.DeclaringType == context.Operand1.Type.ElementType)  			{  				var before = context.InsertBefore();    				if (OverridesMethod(method))  				{  					before.SetInstruction(IRInstruction.SubSigned' context.Operand1' context.Operand1' CreateConstant(NativePointerSize * 2));  				}  				else  				{  					// Get the value type' size and native alignment  					var type = context.Operand1.Type.ElementType;  					var typeSize = Alignment.AlignUp(TypeLayout.GetTypeSize(type)' TypeLayout.NativePointerAlignment);    					// Create a virtual register to hold our boxed value  					var boxedValue = AllocateVirtualRegister(TypeSystem.BuiltIn.Object);    					before.SetInstruction(IRInstruction.Box' boxedValue' GetRuntimeTypeHandle(type)' context.Operand1' CreateConstant(typeSize));    					// Now replace the value type pointer with the boxed value virtual register  					context.Operand1 = boxedValue;  				}  			}
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Callvirt,The following statement contains a magic number: if (context.Previous.Instruction is ConstrainedPrefixInstruction)  			{  				var type = context.Previous.MosaType;    				// remove constrained prefix  				context.Previous.Empty();    				if (type.IsValueType)  				{  					method = GetMethodOrOverride(type' method);    					if (type.Methods.Contains(method))  					{  						// If the method being called is a virtual method then we need to box the value type  						if (method.IsVirtual  							&& context.Operand1.Type.ElementType != null  							&& context.Operand1.Type.ElementType.IsValueType  							&& method.DeclaringType == context.Operand1.Type.ElementType)  						{  							var before = context.InsertBefore();  							before.SetInstruction(IRInstruction.SubSigned' context.Operand1' context.Operand1' CreateConstant(NativePointerSize * 2));  						}  					}  					else  					{  						var elementType = context.Operand1.Type.ElementType;  						var typeSize = Alignment.AlignUp(TypeLayout.GetTypeSize(elementType)' TypeLayout.NativePointerAlignment);    						// Create a virtual register to hold our boxed value  						var boxedValue = AllocateVirtualRegister(TypeSystem.BuiltIn.Object);    						var before = context.InsertBefore();  						before.SetInstruction(IRInstruction.Box' boxedValue' GetRuntimeTypeHandle(type)' context.Operand1' CreateConstant(typeSize));    						// Now replace the value type pointer with the boxed value virtual register  						context.Operand1 = boxedValue;  					}    					var symbol2 = Operand.CreateSymbolFromMethod(method' TypeSystem);  					context.SetInstruction(IRInstruction.CallStatic' result' symbol2' operands);  					return;  				}  			}
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldlen,The following statement contains a magic number: var offset = CreateConstant(NativePointerSize * 2);
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldstr,The following statement contains a magic number: var symbol = linker.CreateSymbol(symbolName' SectionKind.ROData' NativeAlignment' (NativePointerSize * 3) + (stringdata.Length * 2));
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldstr,The following statement contains a magic number: var symbol = linker.CreateSymbol(symbolName' SectionKind.ROData' NativeAlignment' (NativePointerSize * 3) + (stringdata.Length * 2));
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldstr,The following statement contains a magic number: stream.WriteZeroBytes(NativePointerSize * 2);
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Ldstr,The following statement contains a magic number: Debug.Assert(stringData.Length == stringdata.Length * 2' "Byte array of string data doesn't match expected string data length");
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Unbox,The following statement contains a magic number: if (typeSize <= 8)  			{  				context.AppendInstruction(typeSize != 8 ? (BaseIRInstruction)IRInstruction.Unbox32 : IRInstruction.Unbox64' tmp' value);  			}  			else  			{  				var adr = AllocateVirtualRegister(type.ToManagedPointer());    				context.SetInstruction(IRInstruction.AddressOf' adr' MethodCompiler.AddStackLocal(type));  				context.AppendInstruction(IRInstruction.Unbox' tmp' value' adr' CreateConstant(typeSize));  			}
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,Unbox,The following statement contains a magic number: if (typeSize <= 8)  			{  				context.AppendInstruction(typeSize != 8 ? (BaseIRInstruction)IRInstruction.Unbox32 : IRInstruction.Unbox64' tmp' value);  			}  			else  			{  				var adr = AllocateVirtualRegister(type.ToManagedPointer());    				context.SetInstruction(IRInstruction.AddressOf' adr' MethodCompiler.AddStackLocal(type));  				context.AppendInstruction(IRInstruction.Unbox' tmp' value' adr' CreateConstant(typeSize));  			}
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,AddArrayBoundsCheck,The following statement contains a magic number: var fixedOffset = CreateConstant(NativePointerSize * 2);
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,CalculateTotalArrayOffset,The following statement contains a magic number: var fixedOffset = CreateConstant(NativePointerSize * 3);
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,CILTransformationStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\CILTransformationStage.cs,GetIndex,The following statement contains a magic number: if (type.IsChar) return 5;  			else if (type.IsI1) return 0;  			else if (type.IsI2) return 1;  			else if (type.IsI4) return 2;  			else if (type.IsI8) return 3;  			else if (type.IsU1) return 4;  			else if (type.IsU2) return 5;  			else if (type.IsU4) return 6;  			else if (type.IsU8) return 7;  			else if (type.IsR4) return 8;  			else if (type.IsR8) return 9;  			else if (type.IsI) return Platform32Bit ? 2 : 10;  			else if (type.IsU) return Platform32Bit ? 6 : 11;  			else if (type.IsPointer) return 12;  			else if (!type.IsValueType) return 12;
Magic Number,Mosa.Compiler.Framework.Stages,StackLayoutStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Stages\StackLayoutStage.cs,LayoutVariables,The following statement contains a magic number: foreach (var operand in locals)  			{  				var size = GetTypeSize(operand.Type' true);    				offset -= size;    				operand.Offset = offset;  				operand.IsResolved = true;    				if (operand.Low != null)  				{  					operand.Low.Offset = offset;  					operand.Low.IsResolved = true;  				}  				if (operand.High != null)  				{  					operand.High.Offset = offset + 4;  					operand.High.IsResolved = true;  				}  			}
Magic Number,Mosa.Compiler.Framework.CIL,DupInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\DupInstruction.cs,Resolve,The following statement contains a magic number: context.ResultCount = 2;
Magic Number,Mosa.Compiler.Framework.CIL,LdargInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdargInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldarg:  				case OpCode.Ldarg_s: index = (int)decoder.Instruction.Operand; break;  				case OpCode.Ldarg_0: index = 0; break;  				case OpCode.Ldarg_1: index = 1; break;  				case OpCode.Ldarg_2: index = 2; break;  				case OpCode.Ldarg_3: index = 3; break;  				default: throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdargInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdargInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldarg:  				case OpCode.Ldarg_s: index = (int)decoder.Instruction.Operand; break;  				case OpCode.Ldarg_0: index = 0; break;  				case OpCode.Ldarg_1: index = 1; break;  				case OpCode.Ldarg_2: index = 2; break;  				case OpCode.Ldarg_3: index = 3; break;  				default: throw new InvalidCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdcInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdcInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldc_i4:  					{  						int i = (int)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(i' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i4_s:  					{  						sbyte sb = (sbyte)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(sb' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i8:  					{  						long l = (long)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(l' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r4:  					{  						float f = (float)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(f' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r8:  					{  						double d = (double)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(d' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldnull: constantValueOperand = Operand.GetNullObject(decoder.TypeSystem); break;  				case OpCode.Ldc_i4_0: constantValueOperand = Operand.CreateConstant(0' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_1: constantValueOperand = Operand.CreateConstant(1' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_2: constantValueOperand = Operand.CreateConstant(2' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_3: constantValueOperand = Operand.CreateConstant(3' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_4: constantValueOperand = Operand.CreateConstant(4' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_5: constantValueOperand = Operand.CreateConstant(5' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_6: constantValueOperand = Operand.CreateConstant(6' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_7: constantValueOperand = Operand.CreateConstant(7' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_8: constantValueOperand = Operand.CreateConstant(8' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_m1: constantValueOperand = Operand.CreateConstant(-1' decoder.TypeSystem); break;  				default: throw new NotImplementCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdcInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdcInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldc_i4:  					{  						int i = (int)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(i' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i4_s:  					{  						sbyte sb = (sbyte)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(sb' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i8:  					{  						long l = (long)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(l' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r4:  					{  						float f = (float)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(f' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r8:  					{  						double d = (double)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(d' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldnull: constantValueOperand = Operand.GetNullObject(decoder.TypeSystem); break;  				case OpCode.Ldc_i4_0: constantValueOperand = Operand.CreateConstant(0' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_1: constantValueOperand = Operand.CreateConstant(1' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_2: constantValueOperand = Operand.CreateConstant(2' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_3: constantValueOperand = Operand.CreateConstant(3' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_4: constantValueOperand = Operand.CreateConstant(4' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_5: constantValueOperand = Operand.CreateConstant(5' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_6: constantValueOperand = Operand.CreateConstant(6' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_7: constantValueOperand = Operand.CreateConstant(7' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_8: constantValueOperand = Operand.CreateConstant(8' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_m1: constantValueOperand = Operand.CreateConstant(-1' decoder.TypeSystem); break;  				default: throw new NotImplementCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdcInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdcInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldc_i4:  					{  						int i = (int)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(i' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i4_s:  					{  						sbyte sb = (sbyte)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(sb' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i8:  					{  						long l = (long)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(l' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r4:  					{  						float f = (float)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(f' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r8:  					{  						double d = (double)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(d' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldnull: constantValueOperand = Operand.GetNullObject(decoder.TypeSystem); break;  				case OpCode.Ldc_i4_0: constantValueOperand = Operand.CreateConstant(0' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_1: constantValueOperand = Operand.CreateConstant(1' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_2: constantValueOperand = Operand.CreateConstant(2' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_3: constantValueOperand = Operand.CreateConstant(3' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_4: constantValueOperand = Operand.CreateConstant(4' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_5: constantValueOperand = Operand.CreateConstant(5' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_6: constantValueOperand = Operand.CreateConstant(6' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_7: constantValueOperand = Operand.CreateConstant(7' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_8: constantValueOperand = Operand.CreateConstant(8' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_m1: constantValueOperand = Operand.CreateConstant(-1' decoder.TypeSystem); break;  				default: throw new NotImplementCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdcInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdcInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldc_i4:  					{  						int i = (int)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(i' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i4_s:  					{  						sbyte sb = (sbyte)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(sb' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i8:  					{  						long l = (long)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(l' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r4:  					{  						float f = (float)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(f' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r8:  					{  						double d = (double)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(d' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldnull: constantValueOperand = Operand.GetNullObject(decoder.TypeSystem); break;  				case OpCode.Ldc_i4_0: constantValueOperand = Operand.CreateConstant(0' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_1: constantValueOperand = Operand.CreateConstant(1' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_2: constantValueOperand = Operand.CreateConstant(2' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_3: constantValueOperand = Operand.CreateConstant(3' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_4: constantValueOperand = Operand.CreateConstant(4' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_5: constantValueOperand = Operand.CreateConstant(5' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_6: constantValueOperand = Operand.CreateConstant(6' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_7: constantValueOperand = Operand.CreateConstant(7' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_8: constantValueOperand = Operand.CreateConstant(8' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_m1: constantValueOperand = Operand.CreateConstant(-1' decoder.TypeSystem); break;  				default: throw new NotImplementCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdcInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdcInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldc_i4:  					{  						int i = (int)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(i' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i4_s:  					{  						sbyte sb = (sbyte)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(sb' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i8:  					{  						long l = (long)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(l' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r4:  					{  						float f = (float)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(f' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r8:  					{  						double d = (double)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(d' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldnull: constantValueOperand = Operand.GetNullObject(decoder.TypeSystem); break;  				case OpCode.Ldc_i4_0: constantValueOperand = Operand.CreateConstant(0' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_1: constantValueOperand = Operand.CreateConstant(1' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_2: constantValueOperand = Operand.CreateConstant(2' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_3: constantValueOperand = Operand.CreateConstant(3' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_4: constantValueOperand = Operand.CreateConstant(4' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_5: constantValueOperand = Operand.CreateConstant(5' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_6: constantValueOperand = Operand.CreateConstant(6' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_7: constantValueOperand = Operand.CreateConstant(7' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_8: constantValueOperand = Operand.CreateConstant(8' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_m1: constantValueOperand = Operand.CreateConstant(-1' decoder.TypeSystem); break;  				default: throw new NotImplementCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdcInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdcInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldc_i4:  					{  						int i = (int)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(i' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i4_s:  					{  						sbyte sb = (sbyte)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(sb' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i8:  					{  						long l = (long)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(l' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r4:  					{  						float f = (float)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(f' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r8:  					{  						double d = (double)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(d' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldnull: constantValueOperand = Operand.GetNullObject(decoder.TypeSystem); break;  				case OpCode.Ldc_i4_0: constantValueOperand = Operand.CreateConstant(0' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_1: constantValueOperand = Operand.CreateConstant(1' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_2: constantValueOperand = Operand.CreateConstant(2' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_3: constantValueOperand = Operand.CreateConstant(3' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_4: constantValueOperand = Operand.CreateConstant(4' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_5: constantValueOperand = Operand.CreateConstant(5' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_6: constantValueOperand = Operand.CreateConstant(6' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_7: constantValueOperand = Operand.CreateConstant(7' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_8: constantValueOperand = Operand.CreateConstant(8' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_m1: constantValueOperand = Operand.CreateConstant(-1' decoder.TypeSystem); break;  				default: throw new NotImplementCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdcInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdcInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldc_i4:  					{  						int i = (int)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(i' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i4_s:  					{  						sbyte sb = (sbyte)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(sb' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_i8:  					{  						long l = (long)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(l' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r4:  					{  						float f = (float)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(f' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldc_r8:  					{  						double d = (double)decoder.Instruction.Operand;  						constantValueOperand = Operand.CreateConstant(d' decoder.TypeSystem);  					}  					break;    				case OpCode.Ldnull: constantValueOperand = Operand.GetNullObject(decoder.TypeSystem); break;  				case OpCode.Ldc_i4_0: constantValueOperand = Operand.CreateConstant(0' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_1: constantValueOperand = Operand.CreateConstant(1' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_2: constantValueOperand = Operand.CreateConstant(2' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_3: constantValueOperand = Operand.CreateConstant(3' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_4: constantValueOperand = Operand.CreateConstant(4' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_5: constantValueOperand = Operand.CreateConstant(5' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_6: constantValueOperand = Operand.CreateConstant(6' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_7: constantValueOperand = Operand.CreateConstant(7' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_8: constantValueOperand = Operand.CreateConstant(8' decoder.TypeSystem); break;  				case OpCode.Ldc_i4_m1: constantValueOperand = Operand.CreateConstant(-1' decoder.TypeSystem); break;  				default: throw new NotImplementCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdlocInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdlocInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldloc:  				case OpCode.Ldloc_s: index = (int)decoder.Instruction.Operand; break;  				case OpCode.Ldloc_0: index = 0; break;  				case OpCode.Ldloc_1: index = 1; break;  				case OpCode.Ldloc_2: index = 2; break;  				case OpCode.Ldloc_3: index = 3; break;  				default: throw new InvalidMetadataException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,LdlocInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\LdlocInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Ldloc:  				case OpCode.Ldloc_s: index = (int)decoder.Instruction.Operand; break;  				case OpCode.Ldloc_0: index = 0; break;  				case OpCode.Ldloc_1: index = 1; break;  				case OpCode.Ldloc_2: index = 2; break;  				case OpCode.Ldloc_3: index = 3; break;  				default: throw new InvalidMetadataException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,StlocInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\StlocInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Stloc:  				case OpCode.Stloc_s: index = (int)decoder.Instruction.Operand; break;  				case OpCode.Stloc_0: index = 0; break;  				case OpCode.Stloc_1: index = 1; break;  				case OpCode.Stloc_2: index = 2; break;  				case OpCode.Stloc_3: index = 3; break;  				default: throw new NotImplementCompilerException();  			}
Magic Number,Mosa.Compiler.Framework.CIL,StlocInstruction,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CIL\StlocInstruction.cs,Decode,The following statement contains a magic number: switch (opcode)  			{  				case OpCode.Stloc:  				case OpCode.Stloc_s: index = (int)decoder.Instruction.Operand; break;  				case OpCode.Stloc_0: index = 0; break;  				case OpCode.Stloc_1: index = 1; break;  				case OpCode.Stloc_2: index = 2; break;  				case OpCode.Stloc_3: index = 3; break;  				default: throw new NotImplementCompilerException();  			}
Duplicate Code,Mosa.Compiler.Framework.CompilerStages,MethodExceptionLookupTableStage,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\CompilerStages\MethodExceptionLookupTableStage.cs,CreateMethodExceptionLookupTable,The method contains a code clone-set at the following line numbers (starting from the method definition): ((8' 28)' (34' 54))
Missing Default,Mosa.Compiler.Framework,Operand,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\Operand.cs,ShortenTypeName2,The following switch statement is missing a default case: switch (value)  			{  				case "System.Object": return "O";  				case "System.Char": return "C";  				case "System.Void": return "V";  				case "System.String": return "String";  				case "System.Byte": return "U1";  				case "System.SByte": return "I1";  				case "System.Boolean": return "B";  				case "System.Int8": return "I1";  				case "System.UInt8": return "U1";  				case "System.Int16": return "I2";  				case "System.UInt16": return "U2";  				case "System.Int32": return "I4";  				case "System.UInt32": return "U4";  				case "System.Int64": return "I8";  				case "System.UInt64": return "U8";  				case "System.Single": return "R4";  				case "System.Double": return "R8";  			}
Missing Default,Mosa.Compiler.Framework.RegisterAllocator,MoveResolver,C:\repos\mosa_MOSA-Project\Source\Mosa.Compiler.Framework\RegisterAllocator\MoveResolver.cs,InsertResolvingMoves,The following switch statement is missing a default case: switch (move.Value)  				{  					case ResolvedMoveType.Move: architecture.InsertMoveInstruction(context' move.Destination' move.Source); break;  					case ResolvedMoveType.Exchange: architecture.InsertExchangeInstruction(context' move.Destination' move.Source); break;  					case ResolvedMoveType.Load: architecture.InsertLoadInstruction(context' move.Destination' stackFrame' move.Source); break;  				}
