Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The method has 124 lines of code.
Complex Method,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,Cyclomatic complexity of the method is 18
Complex Method,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,Cyclomatic complexity of the method is 9
Complex Method,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,Cyclomatic complexity of the method is 8
Long Statement,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The length of the statement  "				string newname = (Path.GetFileNameWithoutExtension(includeFile.Filename).PadRight(8).Substring(0' 8) + Path.GetExtension(includeFile.Filename).PadRight(4).Substring(1' 3)).ToUpper(); " is 182.
Long Statement,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The length of the statement  "			string name = (Path.GetFileNameWithoutExtension(filename) + Path.GetExtension(filename).PadRight(4).Substring(0' 4)).ToUpper(); " is 127.
Long Statement,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The length of the statement  "			fatBootSector.SetUInt(sect1Ptr1' 0);   // since only 32-bit offsets are support' the high portion of 64-bit value is zero " is 121.
Long Statement,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The length of the statement  "			string name = (Path.GetFileNameWithoutExtension(filename) + Path.GetExtension(filename).PadRight(4).Substring(0' 4)).ToUpper(); " is 127.
Long Statement,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The length of the statement  "				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ; " is 126.
Long Statement,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The length of the statement  "						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24); " is 130.
Magic Number,Mosa.Utility.BootImage,BlockFileStream,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\BlockFileStream.cs,ReadBlock,The following statement contains a magic number: byte[] data = new byte[count * 512];
Magic Number,Mosa.Utility.BootImage,BlockFileStream,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\BlockFileStream.cs,ReadBlock,The following statement contains a magic number: diskFile.Seek((block + BlockOffset) * 512' SeekOrigin.Begin);
Magic Number,Mosa.Utility.BootImage,BlockFileStream,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\BlockFileStream.cs,ReadBlock,The following statement contains a magic number: diskFile.Read(data' 0' (int)(count * 512));
Magic Number,Mosa.Utility.BootImage,BlockFileStream,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\BlockFileStream.cs,WriteBlock,The following statement contains a magic number: diskFile.Seek((block + BlockOffset) * 512' SeekOrigin.Begin);
Magic Number,Mosa.Utility.BootImage,BlockFileStream,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\BlockFileStream.cs,WriteBlock,The following statement contains a magic number: diskFile.Write(data' 0' (int)(count * 512));
Magic Number,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The following statement contains a magic number: if (blockCount == 0)  			{  				blockCount = 8400 + 1;  				foreach (var file in options.IncludeFiles)  				{  					blockCount += ((uint)file.Content.Length / SectorSize) + 1;  				}  			}
Magic Number,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The following statement contains a magic number: if (options.ImageFormat == ImageFormat.VDI)  			{  				// Create header  				var header = VDI.CreateHeader(  					blockCount'  					options.MediaGuid.ToByteArray()'  					options.MediaLastSnapGuid.ToByteArray()'  					diskGeometry  				);    				diskDevice.WriteBlock(0' 1' header);    				var map = VDI.CreateImageMap(blockCount);    				diskDevice.WriteBlock(1' (uint)(map.Length / SectorSize)' map);    				diskDevice.BlockOffset = 1 + (uint)(map.Length / 512);  			}
Magic Number,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The following statement contains a magic number: fatSettings.SerialID = new byte[4] { 0x01' 0x02' 0x03' 0x04 };
Magic Number,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The following statement contains a magic number: foreach (var includeFile in options.IncludeFiles)  			{  				var fileAttributes = new FatFileAttributes();  				if (includeFile.Archive) fileAttributes |= FatFileAttributes.Archive;  				if (includeFile.ReadOnly) fileAttributes |= FatFileAttributes.ReadOnly;  				if (includeFile.Hidden) fileAttributes |= FatFileAttributes.Hidden;  				if (includeFile.System) fileAttributes |= FatFileAttributes.System;    				string newname = (Path.GetFileNameWithoutExtension(includeFile.Filename).PadRight(8).Substring(0' 8) + Path.GetExtension(includeFile.Filename).PadRight(4).Substring(1' 3)).ToUpper();  				var location = fat.CreateFile(newname' fileAttributes);    				if (!location.IsValid)  					throw new Exception("Unable to write file");    				var fatFileStream = new FatFileStream(fat' location);  				fatFileStream.Write(includeFile.Content' 0' includeFile.Content.Length);  				fatFileStream.Flush();  			}
Magic Number,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The following statement contains a magic number: foreach (var includeFile in options.IncludeFiles)  			{  				var fileAttributes = new FatFileAttributes();  				if (includeFile.Archive) fileAttributes |= FatFileAttributes.Archive;  				if (includeFile.ReadOnly) fileAttributes |= FatFileAttributes.ReadOnly;  				if (includeFile.Hidden) fileAttributes |= FatFileAttributes.Hidden;  				if (includeFile.System) fileAttributes |= FatFileAttributes.System;    				string newname = (Path.GetFileNameWithoutExtension(includeFile.Filename).PadRight(8).Substring(0' 8) + Path.GetExtension(includeFile.Filename).PadRight(4).Substring(1' 3)).ToUpper();  				var location = fat.CreateFile(newname' fileAttributes);    				if (!location.IsValid)  					throw new Exception("Unable to write file");    				var fatFileStream = new FatFileStream(fat' location);  				fatFileStream.Write(includeFile.Content' 0' includeFile.Content.Length);  				fatFileStream.Flush();  			}
Magic Number,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The following statement contains a magic number: foreach (var includeFile in options.IncludeFiles)  			{  				var fileAttributes = new FatFileAttributes();  				if (includeFile.Archive) fileAttributes |= FatFileAttributes.Archive;  				if (includeFile.ReadOnly) fileAttributes |= FatFileAttributes.ReadOnly;  				if (includeFile.Hidden) fileAttributes |= FatFileAttributes.Hidden;  				if (includeFile.System) fileAttributes |= FatFileAttributes.System;    				string newname = (Path.GetFileNameWithoutExtension(includeFile.Filename).PadRight(8).Substring(0' 8) + Path.GetExtension(includeFile.Filename).PadRight(4).Substring(1' 3)).ToUpper();  				var location = fat.CreateFile(newname' fileAttributes);    				if (!location.IsValid)  					throw new Exception("Unable to write file");    				var fatFileStream = new FatFileStream(fat' location);  				fatFileStream.Write(includeFile.Content' 0' includeFile.Content.Length);  				fatFileStream.Flush();  			}
Magic Number,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The following statement contains a magic number: foreach (var includeFile in options.IncludeFiles)  			{  				var fileAttributes = new FatFileAttributes();  				if (includeFile.Archive) fileAttributes |= FatFileAttributes.Archive;  				if (includeFile.ReadOnly) fileAttributes |= FatFileAttributes.ReadOnly;  				if (includeFile.Hidden) fileAttributes |= FatFileAttributes.Hidden;  				if (includeFile.System) fileAttributes |= FatFileAttributes.System;    				string newname = (Path.GetFileNameWithoutExtension(includeFile.Filename).PadRight(8).Substring(0' 8) + Path.GetExtension(includeFile.Filename).PadRight(4).Substring(1' 3)).ToUpper();  				var location = fat.CreateFile(newname' fileAttributes);    				if (!location.IsValid)  					throw new Exception("Unable to write file");    				var fatFileStream = new FatFileStream(fat' location);  				fatFileStream.Write(includeFile.Content' 0' includeFile.Content.Length);  				fatFileStream.Flush();  			}
Magic Number,Mosa.Utility.BootImage,Generator,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Generator.cs,Create,The following statement contains a magic number: if (options.ImageFormat == ImageFormat.VHD)  			{  				// Create footer  				var footer = VHD.CreateFooter(  					blockCount'  					(uint)(DateTime.Now - (new DateTime(2000' 1' 1' 0' 0' 0))).Seconds'  					options.MediaGuid.ToByteArray()'  					diskGeometry  				);    				diskDevice.WriteBlock(blockCount' 1' footer);  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The following statement contains a magic number: string name = (Path.GetFileNameWithoutExtension(filename) + Path.GetExtension(filename).PadRight(4).Substring(0' 4)).ToUpper();
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The following statement contains a magic number: string name = (Path.GetFileNameWithoutExtension(filename) + Path.GetExtension(filename).PadRight(4).Substring(0' 4)).ToUpper();
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The following statement contains a magic number: uint patchArea = (uint)ldlinux.Position - 4;
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The following statement contains a magic number: ldlinuxWriter.Write((ushort)2);
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The following statement contains a magic number: ldlinuxWriter.Write(fileSize >> 2);
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The following statement contains a magic number: ldlinuxWriter.Write((ulong)sectors[sectors.Count - 2]);
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_6_03,The following statement contains a magic number: for (uint index = 0; index < (ldlinux.Length >> 2); index++)  			{  				csum = csum + ldlinuxReader.ReadUInt32();  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: string name = (Path.GetFileNameWithoutExtension(filename) + Path.GetExtension(filename).PadRight(4).Substring(0' 4)).ToUpper();
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: string name = (Path.GetFileNameWithoutExtension(filename) + Path.GetExtension(filename).PadRight(4).Substring(0' 4)).ToUpper();
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,PatchSyslinux_3_72,The following statement contains a magic number: if (location.IsValid)  			{  				// Read boot sector  				var bootSector = new DataBlock(partitionDevice.ReadBlock(0' 1));    				// Set the first sector location of the file  				bootSector.SetUInt(0x1F8' fat.GetSectorByCluster(location.FirstCluster));    				// Change jump address  				bootSector.SetUInt(0x01' 0x58);    				// Write back patched boot sector  				partitionDevice.WriteBlock(0' 1' bootSector.Data);    				// Get the file size & number of sectors used  				uint fileSize = fat.GetFileSize(location.DirectorySector' location.DirectorySectorIndex);  				uint sectorCount = (fileSize + 511) >> 9;    				uint[] sectors = new uint[65];  				uint nsec = 0;    				// Create list of the first 65 sectors of the file  				for (uint cluster = location.FirstCluster; ((cluster != 0) & (nsec <= 64)); cluster = fat.GetNextCluster(cluster))  				{  					uint sec = fat.GetSectorByCluster(cluster);  					for (uint s = 0; s < fat.SectorsPerCluster; s++)  						sectors[nsec++] = sec + s;  				}    				// Read the first cluster of the file  				var firstCluster = new DataBlock(fat.ReadCluster(location.FirstCluster));    				uint patchArea = 0;    				// Search for 0x3EB202FE (magic)  				for (patchArea = 0; (firstCluster.GetUInt(patchArea) != 0x3EB202FE) && (patchArea < fat.ClusterSizeInBytes); patchArea += 4) ;    				patchArea = patchArea + 8;    				if (patchArea < fat.ClusterSizeInBytes)  				{  					// Set up the totals  					firstCluster.SetUShort(patchArea' (ushort)(fileSize >> 2));  					firstCluster.SetUShort(patchArea + 2' (ushort)(sectorCount - 1));    					// Clear sector entries  					firstCluster.Fill(patchArea + 8' 0' 64 * 4);    					// Set sector entries  					for (nsec = 0; nsec < 64; nsec++)  						firstCluster.SetUInt(patchArea + 8 + (nsec * 4)' sectors[nsec + 1]);    					// Clear out checksum  					firstCluster.SetUInt(patchArea + 4' 0);    					// Write back the updated cluster  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);    					// Re-Calculate checksum by opening the file  					var file = new FatFileStream(fat' location);    					uint csum = 0x3EB202FE;  					for (uint index = 0; index < (file.Length >> 2); index++)  					{  						uint value = (uint)file.ReadByte() | ((uint)file.ReadByte() << 8) | ((uint)file.ReadByte() << 16) | ((uint)file.ReadByte() << 24);  						csum -= value;  					}    					// Set the checksum  					firstCluster.SetUInt(patchArea + 4' csum);    					// Write patched cluster back to disk  					fat.WriteCluster(location.FirstCluster' firstCluster.Data);  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,GenerateExtents,The following statement contains a magic number: for (int i = 1; i < sectors.Count - 2; i++)  			{  				var sector = sectors[i];    				address = address + SectorSize;    				bool extend =    					// Only if there is an active extent  					(extent != null) &&    					// Sectors in extent must be continuous  					(extent.Start + extent.Length == sector) &&    					// Extents must be strictly less than 64K in size.  					(extent.Length < (65536 / SectorSize)) &&    					// Extents can not cross 64K boundaries - first two hard coded boundaries  					(address != 64 * 1024) && (address != 128 * 1024);    				if (extend)  				{  					// expand extent by one sector  					extent.Length++;  					continue;  				}  				else  				{  					extent = new Extent(sector' 1);  					extends.Add(extent);  					baseAddress = address;  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,GenerateExtents,The following statement contains a magic number: for (int i = 1; i < sectors.Count - 2; i++)  			{  				var sector = sectors[i];    				address = address + SectorSize;    				bool extend =    					// Only if there is an active extent  					(extent != null) &&    					// Sectors in extent must be continuous  					(extent.Start + extent.Length == sector) &&    					// Extents must be strictly less than 64K in size.  					(extent.Length < (65536 / SectorSize)) &&    					// Extents can not cross 64K boundaries - first two hard coded boundaries  					(address != 64 * 1024) && (address != 128 * 1024);    				if (extend)  				{  					// expand extent by one sector  					extent.Length++;  					continue;  				}  				else  				{  					extent = new Extent(sector' 1);  					extends.Add(extent);  					baseAddress = address;  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,GenerateExtents,The following statement contains a magic number: for (int i = 1; i < sectors.Count - 2; i++)  			{  				var sector = sectors[i];    				address = address + SectorSize;    				bool extend =    					// Only if there is an active extent  					(extent != null) &&    					// Sectors in extent must be continuous  					(extent.Start + extent.Length == sector) &&    					// Extents must be strictly less than 64K in size.  					(extent.Length < (65536 / SectorSize)) &&    					// Extents can not cross 64K boundaries - first two hard coded boundaries  					(address != 64 * 1024) && (address != 128 * 1024);    				if (extend)  				{  					// expand extent by one sector  					extent.Length++;  					continue;  				}  				else  				{  					extent = new Extent(sector' 1);  					extends.Add(extent);  					baseAddress = address;  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,GenerateExtents,The following statement contains a magic number: for (int i = 1; i < sectors.Count - 2; i++)  			{  				var sector = sectors[i];    				address = address + SectorSize;    				bool extend =    					// Only if there is an active extent  					(extent != null) &&    					// Sectors in extent must be continuous  					(extent.Start + extent.Length == sector) &&    					// Extents must be strictly less than 64K in size.  					(extent.Length < (65536 / SectorSize)) &&    					// Extents can not cross 64K boundaries - first two hard coded boundaries  					(address != 64 * 1024) && (address != 128 * 1024);    				if (extend)  				{  					// expand extent by one sector  					extent.Length++;  					continue;  				}  				else  				{  					extent = new Extent(sector' 1);  					extends.Add(extent);  					baseAddress = address;  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,GenerateExtents,The following statement contains a magic number: for (int i = 1; i < sectors.Count - 2; i++)  			{  				var sector = sectors[i];    				address = address + SectorSize;    				bool extend =    					// Only if there is an active extent  					(extent != null) &&    					// Sectors in extent must be continuous  					(extent.Start + extent.Length == sector) &&    					// Extents must be strictly less than 64K in size.  					(extent.Length < (65536 / SectorSize)) &&    					// Extents can not cross 64K boundaries - first two hard coded boundaries  					(address != 64 * 1024) && (address != 128 * 1024);    				if (extend)  				{  					// expand extent by one sector  					extent.Length++;  					continue;  				}  				else  				{  					extent = new Extent(sector' 1);  					extends.Add(extent);  					baseAddress = address;  				}  			}
Magic Number,Mosa.Utility.BootImage,Syslinux,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\Syslinux.cs,GenerateExtents,The following statement contains a magic number: for (int i = 1; i < sectors.Count - 2; i++)  			{  				var sector = sectors[i];    				address = address + SectorSize;    				bool extend =    					// Only if there is an active extent  					(extent != null) &&    					// Sectors in extent must be continuous  					(extent.Start + extent.Length == sector) &&    					// Extents must be strictly less than 64K in size.  					(extent.Length < (65536 / SectorSize)) &&    					// Extents can not cross 64K boundaries - first two hard coded boundaries  					(address != 64 * 1024) && (address != 128 * 1024);    				if (extend)  				{  					// expand extent by one sector  					extent.Length++;  					continue;  				}  				else  				{  					extent = new Extent(sector' 1);  					extends.Add(extent);  					baseAddress = address;  				}  			}
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateHeader,The following statement contains a magic number: var binaryHeader = new DataBlock(512);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateHeader,The following statement contains a magic number: binaryHeader.SetUInt(VHIHeaderOffset.SectorSize' 512);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateHeader,The following statement contains a magic number: binaryHeader.SetULong(VHIHeaderOffset.DiskSize' blocks * 512);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateHeader,The following statement contains a magic number: binaryHeader.SetUInt(VHIHeaderOffset.BlocksInHDD' (blocks * 512) / 0x100000);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateHeader,The following statement contains a magic number: binaryHeader.SetUInt(VHIHeaderOffset.BlocksAllocated' (blocks * 512) / 0x100000);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateHeader,The following statement contains a magic number: binaryHeader.SetBytes(VHIHeaderOffset.UUID' guid' 0' 16);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateHeader,The following statement contains a magic number: binaryHeader.SetBytes(VHIHeaderOffset.UUIDLastSnap' lastSnapGuid' 0' 16);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateImageMap,The following statement contains a magic number: uint size = ((blocks * 512) / 0x100000) * 4;
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateImageMap,The following statement contains a magic number: uint size = ((blocks * 512) / 0x100000) * 4;
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateImageMap,The following statement contains a magic number: uint imageBlocks = (uint)(GetAlignedSize(size) / 512);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateImageMap,The following statement contains a magic number: var binaryMap = new DataBlock(imageBlocks * 512);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateImageMap,The following statement contains a magic number: for (uint i = 0; i < ((blocks * 512) / 0x100000); i++)  				binaryMap.SetUInt(i * 4' i);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,CreateImageMap,The following statement contains a magic number: for (uint i = 0; i < ((blocks * 512) / 0x100000); i++)  				binaryMap.SetUInt(i * 4' i);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,GetAlignedSize,The following statement contains a magic number: return (size + 511) & ~((ulong)511);
Magic Number,Mosa.Utility.BootImage,VDI,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VDI.cs,GetAlignedSize,The following statement contains a magic number: return (size + 511) & ~((ulong)511);
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,CreateFooter,The following statement contains a magic number: var binaryFooter = new DataBlock(512);
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,CreateFooter,The following statement contains a magic number: binaryFooter.SetString(VHDFooterOffset.Cookie' "conectix"' 8);
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,CreateFooter,The following statement contains a magic number: binaryFooter.SetString(VHDFooterOffset.CreatorApplication' "MOSA"' 4);
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,CreateFooter,The following statement contains a magic number: binaryFooter.SetULongReversed(VHDFooterOffset.OriginalSize' blocks * 512);
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,CreateFooter,The following statement contains a magic number: binaryFooter.SetULongReversed(VHDFooterOffset.CurrentSize' blocks * 512);
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,CreateFooter,The following statement contains a magic number: binaryFooter.SetBytes(VHDFooterOffset.UniqueId' guid' 0' 16);
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,CreateFooter,The following statement contains a magic number: for (uint index = 0; index < 512; index++)  				checksum += binaryFooter.Data[index];
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,GetAlignedSize,The following statement contains a magic number: return (size + 511) & ~((ulong)511);
Magic Number,Mosa.Utility.BootImage,VHD,C:\repos\mosa_MOSA-Project\Source\Mosa.Utility.BootImage\VHD.cs,GetAlignedSize,The following statement contains a magic number: return (size + 511) & ~((ulong)511);
